<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾辈之人，自当自强不息！</title>
  
  <subtitle>博客</subtitle>
  <link href="https://merlynr.github.io/atom.xml" rel="self"/>
  
  <link href="https://merlynr.github.io/"/>
  <updated>2023-02-01T02:01:00.000Z</updated>
  <id>https://merlynr.github.io/</id>
  
  <author>
    <name>Merlynr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux多进程之间的通信(二)</title>
    <link href="https://merlynr.github.io/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/"/>
    <id>https://merlynr.github.io/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/</id>
    <published>2023-02-01T02:01:00.000Z</published>
    <updated>2023-02-01T02:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPC-基本结构"><a href="#IPC-基本结构" class="headerlink" title="IPC 基本结构"></a>IPC 基本结构</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>IPC通信包括：共享内存，消息队列，信号灯</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675260317404.png" alt="IPC结构"></p><p><img src="https://files.shanqianche.cn/20232/1675261800916.png" alt="三种通信方式的函数"></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p><img src="https://files.shanqianche.cn/20232/1675262145597.png" alt="shmget创建共享内存"><br><strong>打开或创建一个共享内存对象，共享内核在内核是什么样子的？</strong><br>一块缓存，变类似于用户空间的数组或malloc函数分配的空间一样。</p><blockquote><p>查看IPC对象：ipcs -m【查看共享内存】| -q【队列】| -s【信号灯】<br>删除IPC对象：ipcrm -m | -q | -s id【IPC的ID】</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262428512.png" alt="共享内存的读"></p><blockquote><p>共享内存可以通过memcpy写入，也可以通过键盘输入stdin</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262526768.png" alt="删除映射到用户的内存"></p><h3 id="利用键盘输入读取共享内存"><a href="#利用键盘输入读取共享内存" class="headerlink" title="利用键盘输入读取共享内存"></a>利用键盘输入读取共享内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="comment">//create user memoey mapping </span></span><br><span class="line">p = (<span class="keyword">char</span> *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write to memory by keymap</span></span><br><span class="line">fgets(p,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675263694621.gif" alt="ret"></p><p>**<font color="#FF8C00">共享内存特点</font>**：</p><ol><li>共享内存创建之后，一直存在于内核中，直到被删除或系统关闭：</li><li>共享内存和管道不一样，读取后，内容仍在其共享内存中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上一段代码的修改</span></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second read :%s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">shmdt(p);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(p,<span class="string">&quot;abcd&quot;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675264544802.gif" alt="shmdt后，共享内存依旧存在但用户无法写入，说明映射到用户的内存被删除了"></p><p><img src="https://files.shanqianche.cn/20232/1675264693642.png" alt="查看，设置，删除共享内存，shmctl"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除共享内存</span></span><br><span class="line">shmdt(p);</span><br><span class="line"><span class="comment">//system(&quot;ipcs -m&quot;);</span></span><br><span class="line"><span class="comment">//memcpy(p,&quot;abcd&quot;,4);</span></span><br><span class="line"><span class="comment">//printf(&quot;third read :%s\n&quot;,p);</span></span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;have delete share memory\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675265486449.gif" alt="ret"></p><h3 id="不同进程之间的通信"><a href="#不同进程之间的通信" class="headerlink" title="不同进程之间的通信"></a>不同进程之间的通信</h3><blockquote><p>宏IPC_PRIVATE:只可以打开亲属之间的共享内存，不同进程之间的需要ftok来获取shmid。</p></blockquote><p><strong>服务端代码，进程通过kill发送SIGUSR1给客户端进程告知已写入share memory。同时接收SIGUSR2信号。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR2,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;pid = getpid();<span class="comment">//write server pid to share memory</span></span><br><span class="line">pause(); <span class="comment">// wait client read server pid;</span></span><br><span class="line">pid = p-&gt;pid;<span class="comment">//read client pid;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process start write share memory!\n&quot;</span>);</span><br><span class="line">fgets(p-&gt;buf,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line">kill(pid,SIGUSR1);<span class="comment">// client process read data</span></span><br><span class="line">pause();<span class="comment">//wait client process read</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码，进程通过kill发送SIGUSR2给服务端进程告知已读取share memory。同时接收SIGUSR1信号，进行读取。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR1,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get serve pid</span></span><br><span class="line"><span class="comment">// read share memory</span></span><br><span class="line">pid = p-&gt;pid;</span><br><span class="line"><span class="comment">//write client pid to share memory</span></span><br><span class="line">p-&gt;pid = getpid();</span><br><span class="line">kill(pid,SIGUSR2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pause();<span class="comment">//waits server  process read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client has read: %s\n&quot;</span>,p-&gt;buf);</span><br><span class="line">kill(pid,SIGUSR2);<span class="comment">// server can write share memory</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675269810736.gif" alt="ret"></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://files.shanqianche.cn/20232/1675269875809.png" alt="kernel中的消息队列"></p><p><img src="https://files.shanqianche.cn/20232/1675269995630.png" alt="msgget创建消息队列"></p><p><img src="https://files.shanqianche.cn/20232/1675270095098.png" alt="msgctl消息队列读取，设置，删除"></p><p><img src="https://files.shanqianche.cn/20232/1675270271071.png" alt="msgsnd发送数据"><br><strong>其中消息类型要与队列中消息类型进行匹配</strong></p><p><img src="https://files.shanqianche.cn/20232/1675270412264.png" alt="msgrcv读取消息队列"></p><h3 id="无亲缘关系的读写"><a href="#无亲缘关系的读写" class="headerlink" title="无亲缘关系的读写"></a>无亲缘关系的读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_write.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(sendbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear send buffer</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PLZ inout msg: &quot;</span>);</span><br><span class="line">fgets(sendbuf.msg,<span class="number">124</span>,<span class="built_in">stdin</span>);</span><br><span class="line">msgsnd(msgid,(<span class="keyword">void</span> *)&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.msg),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_read.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(readbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear read buffer</span></span><br><span class="line">msgrcv(msgid,(<span class="keyword">void</span> *)&amp;readbuf,<span class="number">124</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv msg : %s\n&quot;</span>,readbuf.msg);</span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675272294978.gif" alt="非亲缘关系的通信"></p><h2 id="信号灯"><a href="#信号灯" class="headerlink" title="信号灯"></a>信号灯</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>信号灯</strong>：信号灯集合（可以包含多个信号灯）PC对象是一个信号灯集（多个信号量）</p><p><img src="https://files.shanqianche.cn/20232/1675272452939.png" alt="由两组值构成的某个信号灯集的内核数据结构"></p><p><img src="https://files.shanqianche.cn/20232/1675272509363.png" alt="semget创建"></p><p><img src="https://files.shanqianche.cn/20232/1675272576680.png" alt="semctl：获取、设置、删除信号灯"></p><p><img src="https://files.shanqianche.cn/20232/1675335695421.png" alt="PV操作"></p><h3 id="利用信号灯进行通信"><a href="#利用信号灯进行通信" class="headerlink" title="利用信号灯进行通信"></a>利用信号灯进行通信</h3><blockquote><p>利用ftok创建key，然后构建信号灯。首先运行客户端，信号量初始化在客户端上，并进行V操作，所以信号量资源被释放，无法利用。下一步执行服务端，服务端先执行任务，然后发送P操作信息，由此分配资源给客户端。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_server.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess! key=%d\n&quot;</span>,key);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess! semid = %d\n&quot;</span>,semid);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line"><span class="comment">//mysemun.val = 0;</span></span><br><span class="line"><span class="comment">//semctl(semid,0,SETVAL,mysemun);</span></span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端才可以进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">mysembuf.sem_op =<span class="number">1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_client.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess\n&quot;</span>);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line">mysemun.val = <span class="number">0</span>;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,mysemun);</span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//p wait</span></span><br><span class="line">mysembuf.sem_op=<span class="number">-1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//mysembuf.sem_op =1;</span></span><br><span class="line"><span class="comment">//semop(semid,&amp;mysembuf,1);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675351711955.gif" alt="ret"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多进程之间的通信(一)</title>
    <link href="https://merlynr.github.io/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/"/>
    <id>https://merlynr.github.io/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/</id>
    <published>2023-01-30T17:02:00.000Z</published>
    <updated>2023-01-30T17:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>进程通信：在用户空间实现进程通信是不可能的，通过<strong>Linux内核通信</strong><br>线程间通信：可以<strong>在用户空间</strong>就可以实现，可以通过<strong>全局变量</strong>通信。</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p><font color="#FF8C00">管道通信</font>：无名管道、有名管道（文件系统中有名,文件系统）<br><font color="#FF8C00">信号通信</font>：信号（通知）通信包括：信号的发送、信号的接收和信号的处理。<br><font color="#FF8C00">IPC(Inter-Process Communication)通信</font>：共享内存、消息队列和信号灯。<br>以上是<strong>单机模式</strong>下的进程通信(只有一个L加ux内核)<br><em>Socket通信：存在于一个网络中两个进程之间的通信(两个Linux内核)。</em></p><h2 id="通信实现的思想"><a href="#通信实现的思想" class="headerlink" title="通信实现的思想"></a>通信实现的思想</h2><blockquote><p><strong>基于文件IO理念</strong></p></blockquote><p>open:功能：创建或打开进程通信对象。函数形式不一样，有的是有多个函数完成。<br>write:功能：向进程通信对象中写入内容。函数形式可能不一样。<br>read:功能：从进程通信对象中读取内容。函数形式可能不一样。<br>close:功能：关闭或删除进程通信对象。形式可能不一样。</p><h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://files.shanqianche.cn/20231/1675161823138.png" alt="管道原理"></p><blockquote><p>管道文件是一个特殊的文件，是由队列来实现的。</p></blockquote><h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><strong>水从高处流</strong><br> The array pipefd is used to return two file descriptors referring to the ends of the pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by  the kernel until it is read from the read end of the pipe.</p><blockquote><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就删除了；队列</li><li>如果管道中没有东西可读，则会阻塞</li></ol></blockquote><h3 id="无名管道的创建"><a href="#无名管道的创建" class="headerlink" title="无名管道的创建"></a>无名管道的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c </span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><strong>Linux内核在创建进程的时候会默认创建三个文件描述符，即0，1，2。所以无名管道返回的文件描述符为3，1、4</strong></p><p><img src="https://files.shanqianche.cn/20231/1675163282239.png" alt="res"></p><h3 id="无名管道的读写"><a href="#无名管道的读写" class="headerlink" title="无名管道的读写"></a>无名管道的读写</h3><p><strong>关键</strong></p><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就别除了：队列</li><li>如果管道中没有东西可读，则会阻塞。</li><li>验证写阻塞：可以计算出内核开辟的管道有多大,队列超过这么大会发生写<strong>堵塞</strong>。5456 5457.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> writebuff[]=<span class="string">&quot;hello Linux&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> readbuff[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// write</span></span><br><span class="line">write(fd[<span class="number">1</span>],writebuff,<span class="keyword">sizeof</span>(writebuff));</span><br><span class="line"></span><br><span class="line"><span class="comment">//first read</span></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//second read </span></span><br><span class="line"></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675164287464.png" alt="只能读一次，发生读堵塞"></p><p><img src="https://files.shanqianche.cn/20231/1675164430147.png" alt="阻塞状态ps -axj"></p><p>无名管道的<font color="#FF00FF">缺点</font>：不能实现不是父子进程（亲缘关系）之间的通信。</p><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><blockquote><p>由于无名管道的缺点，对无名管道进行改进：有名管道<br>所谓的有名，即文件系统中存在这个一样文件节点，每一个文件节点都有一个node号<br>而且这是一个特殊的文件类型：<strong>p管道类型</strong>。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1675165035697.png" alt="mkfifo函数"></p><blockquote><p>Create named pipes (FIFOs) with the given NAMEs</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时38分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = mkfifo(<span class="string">&quot;./myfifo&quot;</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip failure by file. ret = %d/n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create sucess\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675165870881.png" alt="基于文件系统的有名管道的创建"></p><ol><li>创建这个文件节点，不可以通过open函数，open函数只能创建普通文件，不能创建特殊文件（管道-mkdifo,套接字-socket,字符设备文件-mknod,块设备文件-mknod, 符号链接文件-ln-s,目录文件mkdir）</li><li>管道文件<font color="#FF8C00">只有node号，不占磁盘块空间</font>，<strong>和套接字、字符设备文件、块设备文件一<br>样。普通文件和符号链接文件及目录文件，不仅有node号，还占磁盘块空间。</strong></li><li><font color="#FF8C00">mkfifo用来创建管道文件的<strong>节点</strong>，<strong>没有在内核中创建管道</strong>。只有通过open函数打开这个文件时才会在内核空间创建管道。</font></li></ol><h3 id="利用有名管道进行进程通信"><a href="#利用有名管道进行进程通信" class="headerlink" title="利用有名管道进行进程通信"></a>利用有名管道进行进程通信</h3><blockquote><p>基于上一步创建的管道节点进行通信，进程一等待五秒后向通道发送信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is first process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">process_state = <span class="number">1</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">write(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line">read(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(process_state==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is second process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675167881162.png" alt="ret"></p><h1 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h1><h2 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h2><p><img src="https://files.shanqianche.cn/20231/1675167965840.png" alt="Linux中的64种信号"></p><p><img src="https://files.shanqianche.cn/20231/1675173652422.png" alt="kill命令"></p><p><img src="https://files.shanqianche.cn/20231/1675174619900.png" alt="raise函数"></p><p><img src="https://files.shanqianche.cn/20231/1675179787808.png" alt="alarm函数"><br><strong>信号通信的框架</strong></p><ol><li>信号的发送（发送信号进程）：kill raise alarm</li><li>信号的接收（接收信号进程）：pause() sleep while(1)</li><li>信号的处理（接收信号进程）：signal</li></ol><p><strong>kill函数的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: kill_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时04分08秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input param\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sig = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">pid = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sig=%d, pid = %d\n&quot;</span>,sig,pid);</span><br><span class="line"></span><br><span class="line">kill(pid,sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675174377994.png" alt="ret"></p><h2 id="简单使用kill，waitpid"><a href="#简单使用kill，waitpid" class="headerlink" title="简单使用kill，waitpid"></a>简单使用kill，waitpid</h2><blockquote><p>案例: 开始时主进程处于睡眠状态S,子进程处于暂停T. 八秒后主进程杀死子进程并利用while进入S. 但是子进程被杀死后没有回收资源所以进入僵尸状态Z.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,WNOHANG) ==<span class="number">0</span>) <span class="comment">//等待进程状态，返回值为0时表示并未退出。pid为进程id，NULL为不获取进程返回值，WNOHANG为非阻塞</span></span><br><span class="line">&#123;</span><br><span class="line">kill(pid,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait(NULL);//回收进程资源</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function before\n&quot;</span>);</span><br><span class="line">raise(SIGTSTP);<span class="comment">//SIGSTP 暂停交互，== Ctrl+Z</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function after\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675176776671.gif" alt="process"></p><p><img src="https://files.shanqianche.cn/20231/1675179547533.gif" alt="使用wait函数回收资源"></p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p><img src="https://files.shanqianche.cn/20231/1675180318371.png" alt="signal函数"></p><blockquote><p>signal函数:返回一个函数指针. 含有两个参数,第一个为信号值, 第二个为一个函数指针,其中返回值为void.<br><strong><font color="#FF8C00">默认处理信号方式为终止信号.</font></strong></p></blockquote><h3 id="alarm处理信号"><a href="#alarm处理信号" class="headerlink" title="alarm处理信号"></a>alarm处理信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: signal_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 23时56分47秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process sleep %d s!\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">signal(<span class="number">14</span>,myfun); <span class="comment">// 14为SIGALRM</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;alarm start\n&quot;</span>);</span><br><span class="line">alarm(<span class="number">9</span>);<span class="comment">//九秒后触发myfun</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;next step\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main do %d s\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675184647775.png" alt="ret"></p><h3 id="signal信号处理"><a href="#signal信号处理" class="headerlink" title="signal信号处理"></a>signal信号处理</h3><blockquote><p>父子进程进行通信</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;receive signum = %d, i = %d\n&quot;</span>,signum,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> myfun1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PID is %d\n&quot;</span>,pid);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">signal(<span class="number">10</span>,myfun);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A say %d\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">kill(getppid(),<span class="number">10</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//kill SIGCHILD</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675188572460.png" alt="ret"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程</title>
    <link href="https://merlynr.github.io/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://merlynr.github.io/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-01-29T03:56:00.000Z</published>
    <updated>2023-01-29T03:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>进程：一个正在执行的程序，它是<strong>资源分配的最小单位</strong><br>进程中的事情需要按照一定的顺序透个进行，那么如何让一个进程中的一些事情同时执行？<br><strong>线程</strong></p></blockquote><blockquote><p>线程：有时又称轻里级进程，<strong>程序执行的最小单位</strong>，系统独立调度和分派cu的基本单位，它是进程中的一个实<br>体。一个进程中可以有多中线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。<br>进程出现了很多弊端，一是由于进程是资源拥有者，创建、微消与切换存在较大的时空开销，因此需要引入轻型进<br>程：二是由于对称多处理机(SMP)出现，可以满足多个运行单位，而多个进程并行开销过大。</p></blockquote><blockquote><p>并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执<br>行的效果。看起来同时发生，实际上单核内轮询执行。</p></blockquote><blockquote><p>并行是指在同一时刻，有多条指令在多个处理器上同时执行。真正的同时发生</p></blockquote><blockquote><p>同步：彼比有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情</p></blockquote><blockquote><p>异步的解念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生</p></blockquote><h1 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h1><ol><li>当c程序运行时，首先运行main函数。在统程代码中，这个特殊的执行流被称作<strong>初始线程或者主线程</strong>。你可以在初始线程中做任何普通线程可以做的串情。<br>2、主线程的特殊性在于，它在main函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用pthread_exit函数，这样进程就会等待所有线程结束时才终止。</li><li>主线程接受参数的方式是通过<strong>argc和argv</strong>,而<strong>普通的线程只有</strong>一个参数”void *”</li><li>在绝大乡数情况下，主统程在默认堆栈上运行，这个堆栈可以增长到<strong>足够的长度</strong>。而普通线程的堆栈是<strong>受限制</strong>的，一旦溢出就会产生错误<h2 id="主线程的创建"><a href="#主线程的创建" class="headerlink" title="主线程的创建"></a>主线程的创建</h2>1、主线程是随着进程的创建而创建<br>2、其他线程可以通过调用函数来创建，主要调用pthread_create</li></ol><p><em>请注意，新线程可能在当前线程从函数pthread create返回之前就已经运行了，甚至新线程可能在当前线程从函数pthread create返回之前就已经运行完毕了</em></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之文件系统</title>
    <link href="https://merlynr.github.io/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://merlynr.github.io/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-01-27T18:35:00.000Z</published>
    <updated>2023-01-27T18:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h1><ul><li>能定义文件的组织方式，文件结构</li><li>提供建立和存取文件的环境：目录和文件</li><li>能对文件存储器空间进行组织和分配</li><li>负责文件存储并对存入的文件进行保护和检索</li><li>负责建立文件，存入、读出、修改、转储文件，控制文件的存取，撤销文件等</li></ul><h1 id="文件系统分类"><a href="#文件系统分类" class="headerlink" title="文件系统分类"></a>文件系统分类</h1><ul><li>磁盘文件系：NTFS，EXT3</li><li>闪存文件系统，JFFS2,YAFFS</li><li>数据库文件系统，BFFS,WINFS</li><li>网络文件系统：NFS</li><li>虚拟文件系统，VFS(Proc)</li></ul><h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h2 id="EXT3"><a href="#EXT3" class="headerlink" title="EXT3"></a>EXT3</h2><ul><li>EXT3是<strong>基于日志方式</strong>的文件系统</li><li>系统中每个文件都是有<strong>索引</strong>，</li><li>用户对对文件的每一个操作都会<strong>记录日志</strong>，</li><li>形成一个任务<strong>队列</strong>排着执行</li><li><strong>性能</strong>是比较好</li></ul><h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><p>swap是<strong>交换分区</strong>的文件系统，类似windows的虚拟内存<br>虚拟内存的实现：两种方式</p><ol><li>第一种是进行内存的排列像内存池一样，进行一个优化</li><li>第二种是把硬盘上的空间模拟成内存<br>swap是Linux的虚拟内存，在安装时要设好大小，是<strong>物理内存的2倍</strong></li></ol><h1 id="Linux与Window目录结构的区别"><a href="#Linux与Window目录结构的区别" class="headerlink" title="Linux与Window目录结构的区别"></a>Linux与Window目录结构的区别</h1><ol><li>根目录<br>Linux:/<br>Windows:\</li><li>命名写区分<br>Linux:命名区分大小写；<br>Windows:命名不区分大小写</li><li>结构管理<br>Linux:磁盘逻辑结构管理物理结构，格式化将磁盘分为很多的文件块区<br>Windows:物理结构管理逻结构，先分区再格式化建立结构</li></ol><h1 id="Linux文件系统目录"><a href="#Linux文件系统目录" class="headerlink" title="Linux文件系统目录"></a>Linux文件系统目录</h1><p><img src="https://files.shanqianche.cn/20231/1674895536500.png" alt="结构"><br><strong>/lib</strong> 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><h1 id="shell-特殊字符"><a href="#shell-特殊字符" class="headerlink" title="shell 特殊字符"></a>shell 特殊字符</h1><ol><li>通配符* ？ []</li></ol><p><img src="https://files.shanqianche.cn/20231/1674895793138.png" alt="通配符"><br>2. 单次执行多条命令。可以通过‘；’隔开<br>3. 输入输出重定向：&gt;,&lt;,&gt;&gt;</p><p><img src="https://files.shanqianche.cn/20231/1674895877046.png" alt="重定向"><br>4. 管道符：|</p><p>将一个进程的输出作为另一个进程的输入<br>5. 其它%，$,~</p><p><img src="https://files.shanqianche.cn/20231/1674895997064.png" alt="其它符合"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>C语言之编译</title>
    <link href="https://merlynr.github.io/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/"/>
    <id>https://merlynr.github.io/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/</id>
    <published>2023-01-26T21:08:00.000Z</published>
    <updated>2023-01-26T21:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p><img src="https://files.shanqianche.cn/20231/1674819567025.png" alt="C语言编译过程，层次递增，后边命令包含上边命令所有功能"></p><blockquote><p><font color="#FF00FF">define include 不是关键字，他们在预编译的时候就被替代了。</font></p></blockquote><h1 id="常见编译错误"><a href="#常见编译错误" class="headerlink" title="常见编译错误"></a>常见编译错误</h1><ol><li>预处理错误</li></ol><p>#include”file.h“      默认先从<font color="#FF00FF">当前路径</font>中寻找，找不到再从系统环境中查找。<br>#include&lt;file.h&gt;     直接从系统环境中寻找</p><p><strong><font color="#DC143C">NOT FIND</font></strong> 注意自己创建用双引号。<br>解决方法：可以通过相对路径；通过写入头文件路径的方式。</p><p><img src="https://files.shanqianche.cn/20231/1674838061382.png" alt="相对路径"></p><p><img src="https://files.shanqianche.cn/20231/1674838095708.png" alt="-I+路径"><br>2. 链接错误<br>    <strong>原材料不够或者溢出。</strong></p><ul><li>缺少原材料</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838261605.png" alt="函数缺少实现"></p><p><img src="https://files.shanqianche.cn/20231/1674838294886.png" alt="链接器报错"></p><ul><li>原材料溢出</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838515227.png" alt="链接器错误"></p><p><strong>原因是链接重复的函数。</strong></p><h1 id="预处理的使用"><a href="#预处理的使用" class="headerlink" title="预处理的使用"></a>预处理的使用</h1><ol><li>#include 包含头文件</li><li>#define 宏，替换   <strong><font color="#FF8C00">预处理时不进行检查直接进行替换，在编译时才进行检查</font></strong></li><li>#define 宏名 宏体 <strong>为了避免错误，加括号</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 3+5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//3+5*5=28</span></span><br><span class="line"><span class="comment">//正确例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 (3+5)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//(3+5)*5=40</span></span><br></pre></td></tr></table></figure><ol start="4"><li>系统预定义宏</li></ol><p><img src="https://files.shanqianche.cn/20231/1674839269964.png" alt="前后双下划线"></p><p><img src="https://files.shanqianche.cn/20231/1674839409010.png" alt="方便用于调试"><br>5. 条件宏变量</p><blockquote><p>多用于控制不同版本的变量。（开发版与测试版）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674839665789.png" alt="如果定义了ABC则会输出，不定义则没有输出结果"><br><strong>同时可以通过命令来进行控制宏变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -D:</span><br><span class="line">gcc -DABC == <span class="meta">#<span class="meta-keyword">define</span> ABC</span></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1674839837663.png" alt="gcc -D"><br>6. 宏展开下的 #、##</p><p><img src="https://files.shanqianche.cn/20231/1674839991226.png" alt="#、##"></p><p><img src="https://files.shanqianche.cn/20231/1674840072964.png" alt="#"></p><p><img src="https://files.shanqianche.cn/20231/1674840240184.png" alt="##"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="注意数据类型所占位数，防止溢出"><a href="#注意数据类型所占位数，防止溢出" class="headerlink" title="注意数据类型所占位数，防止溢出"></a>注意数据类型所占位数，防止溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8b</span>it = <span class="number">1B</span></span><br><span class="line"><span class="keyword">char</span> = <span class="number">1B</span></span><br><span class="line">所以<span class="keyword">char</span>最大不超过 <span class="number">2</span>^<span class="number">8</span>=<span class="number">256.</span></span><br><span class="line"><span class="keyword">char</span> a =<span class="number">300.</span> a++会报错。</span><br></pre></td></tr></table></figure><h2 id="int大小的定义"><a href="#int大小的定义" class="headerlink" title="int大小的定义"></a>int大小的定义</h2><blockquote><p>编译器最优的处理大小（由编译器决定）：<br>        系统一个周期，所能接受的最大处理单位，int<br>        32位系统，单词执行32bit，所以int大小32bit=4byte<br>        单片机中存在16位系统，则int = 2B</p></blockquote><h1 id="signed与unsigned的注意"><a href="#signed与unsigned的注意" class="headerlink" title="signed与unsigned的注意"></a>signed与unsigned的注意</h1><p>signed包含符号位，而unsigned不包含，所以进行位操作的时候会出现不同情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>=<span class="number">0xff</span></span><br><span class="line"><span class="keyword">signed</span>右移后不会变化。而<span class="keyword">unsigned</span>会变化，最后变为<span class="number">0.</span></span><br></pre></td></tr></table></figure><h1 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674842433715.png" alt="类型修饰符"></p><p><img src="https://files.shanqianche.cn/20231/1674842419473.png" alt="auto"></p><p><img src="https://files.shanqianche.cn/20231/1674842567442.png" alt="register"></p><blockquote><p><font color="#FF00FF">由于寄存器没有地址，所以对存入寄存器的值进行取址是无效的。</font></p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674842689701.png" alt="取址失败"></p><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h1><p><img src="https://files.shanqianche.cn/20231/1674842913259.png" alt="volatile"></p><h1 id="硬件中乘除法需要注意"><a href="#硬件中乘除法需要注意" class="headerlink" title="硬件中乘除法需要注意"></a>硬件中乘除法需要注意</h1><p><img src="https://files.shanqianche.cn/20231/1674843024138.png" alt="乘除法"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>C语言之函数的使用</title>
    <link href="https://merlynr.github.io/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://merlynr.github.io/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-01-25T03:13:00.000Z</published>
    <updated>2023-01-25T03:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符空间与非字符空间的区别"><a href="#字符空间与非字符空间的区别" class="headerlink" title="字符空间与非字符空间的区别"></a>字符空间与非字符空间的区别</h2><p><img src="https://files.shanqianche.cn/20231/1674544158303.png" alt="结束标符的不同"></p><h2 id="函数地址传址"><a href="#函数地址传址" class="headerlink" title="函数地址传址"></a>函数地址传址</h2><p>嵌入式中对于单个值进行修改的可以使用int *，char *,long *。如果传递的是空间则默认为void *。</p><h2 id="指针指向的合法性"><a href="#指针指向的合法性" class="headerlink" title="指针指向的合法性"></a>指针指向的合法性</h2><blockquote><p>即函数中的局部变量在函数指向完会被清除，如果直接return局部变量会造成指针异常。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674807930550.png" alt="不合法例子"></p><blockquote><p>合法空间：<font color="#FF8C00">非局部变量</font>，即非栈空间变量。static，常量，堆区（malloc，free）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674808110649.png" alt="通过static设置为静态变量"></p><p><img src="https://files.shanqianche.cn/20231/1674810427874.png" alt="返回常量，不可修改"></p><p><img src="https://files.shanqianche.cn/20231/1674810459713.png" alt="堆区"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>C语言之内存的操作</title>
    <link href="https://merlynr.github.io/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://merlynr.github.io/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2023-01-24T03:42:00.000Z</published>
    <updated>2023-01-24T03:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言格式符合"><a href="#c语言格式符合" class="headerlink" title="c语言格式符合"></a>c语言格式符合</h1><p><img src="https://files.shanqianche.cn/20231/1674625839183.png" alt="c语言格式符合"></p><h1 id="const-修饰符"><a href="#const-修饰符" class="headerlink" title="const 修饰符"></a>const 修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674626595923.png" alt="const"></p><h1 id="volatile-修饰"><a href="#volatile-修饰" class="headerlink" title="volatile 修饰"></a>volatile 修饰</h1><p>防止内存优化，每次从地址读值</p><h1 id="typedef-别名"><a href="#typedef-别名" class="headerlink" title="typedef 别名"></a>typedef 别名</h1><p><img src="https://files.shanqianche.cn/20231/1674626987035.png" alt="typedef"></p><h1 id="指针运算操作"><a href="#指针运算操作" class="headerlink" title="指针运算操作"></a>指针运算操作</h1><p><img src="https://files.shanqianche.cn/20231/1674627210213.png" alt="指针加减运算"></p><p><img src="https://files.shanqianche.cn/20231/1674627280255.png" alt="指针非线性访问数据"></p><blockquote><p>指针运算：p+n取得的是地址，p[n]取出的是内容，值</p></blockquote><h1 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h1><blockquote><p>c语言存在内存越界，c++并不存在</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674628812520.png" alt="内存越界"></p><h1 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h1><p><img src="https://files.shanqianche.cn/20231/1674628996361.png" alt="NULL与0x0类似，但是0x0有的编译器不支持，所以推荐使用NULL"></p><h1 id="多级指针的例子"><a href="#多级指针的例子" class="headerlink" title="多级指针的例子"></a>多级指针的例子</h1><p><img src="https://files.shanqianche.cn/20231/1674629440012.png" alt="**grav表示数组中的字符串的地址"></p><p><img src="https://files.shanqianche.cn/20231/1674629683298.png" alt="与上一个函数一样"></p><p><img src="https://files.shanqianche.cn/20231/1674629432130.png" alt="res"></p><h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><p><img src="https://files.shanqianche.cn/20231/1674630239737.png" alt="差异"></p><blockquote><p>字符串末尾默认加‘\0’</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630294413.png" alt="\0"></p><p><font color="#FF00FF">编译器只有第一次赋值可以一次性解决，以后对于数组操作，只能逐一操作，即一位一位进行修改。</font></p><h1 id="字符拷贝的问题"><a href="#字符拷贝的问题" class="headerlink" title="字符拷贝的问题"></a>字符拷贝的问题</h1><blockquote><p>字符拷贝函数的原贝则：<br>内存空间和内存空间的逐一赋值的功能的一个封装体一旦空间中出现了0这个特殊值，函数就即将结束。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630865267.png" alt="strcpy"><br>strcpy()函数存在问题，如果destination值后面没有’\0’，则会一直拷贝。工程中尽量不用。</p><p><img src="https://files.shanqianche.cn/20231/1674630876329.png" alt="strncpy"><br>strncpy可以设置拷贝字符长度，避免内存泄漏。</p><h1 id="字符空间"><a href="#字符空间" class="headerlink" title="字符空间"></a>字符空间</h1><p><img src="https://files.shanqianche.cn/20231/1674631169177.png" alt="字符与非字符空间"></p><h1 id="内存拷贝"><a href="#内存拷贝" class="headerlink" title="内存拷贝"></a>内存拷贝</h1><p><img src="https://files.shanqianche.cn/20231/1674631384044.png" alt="memcpy"></p><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p><img src="https://files.shanqianche.cn/20231/1674632522625.png" alt="二维数组表达方式"></p><p><img src="https://files.shanqianche.cn/20231/1674632589989.png" alt="三维"></p><h1 id="结构体中字节对齐"><a href="#结构体中字节对齐" class="headerlink" title="结构体中字节对齐"></a>结构体中字节对齐</h1><blockquote><p>即空间换效率，采取最大字节单位进行对其，所以空间大小都为4的倍数</p></blockquote><h1 id="代码编码后的地址位置"><a href="#代码编码后的地址位置" class="headerlink" title="代码编码后的地址位置"></a>代码编码后的地址位置</h1><blockquote><p>一般系统（ARM，x86等）的代码地址位于低地址</p></blockquote><p><font color="#FF00FF">x86：一般为于0x8084.</font>.</p><p><img src="https://files.shanqianche.cn/20231/1674634481092.png" alt="代码地址"></p><h1 id="内存空间结构"><a href="#内存空间结构" class="headerlink" title="内存空间结构"></a>内存空间结构</h1><p><img src="https://files.shanqianche.cn/20231/1674659004309.png" alt="结构"></p><p><img src="https://files.shanqianche.cn/20231/1674658712364.png" alt="内存查看"></p><blockquote><p>只读空间：静态空间，整个程序结束时释放内存，生存周期最长<br>栈空军：运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内<br>堆空间：运行时，可以自我管理分配和释放的空间，程序员决定的。</p></blockquote><p><strong>堆空间分配：</strong> malloc(),一旦成功，返回分配好的地址给我们，只需要接受，对于这个新地址的读法，由程序员灵活把握输入参数指定分配的大小，单位就是B。</p><p><img src="https://files.shanqianche.cn/20231/1674659425331.png" alt="malloc函数"></p><p><strong>释放空间：</strong> free(p)</p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之事件组(五)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/</id>
    <published>2022-12-16T03:39:00.000Z</published>
    <updated>2022-12-16T03:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件组等待"><a href="#事件组等待" class="headerlink" title="事件组等待"></a>事件组等待</h2><p><img src="https://files.shanqianche.cn/202212/1671172487143.png" alt="创建事件组，返回一个event group句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671173162132.png" alt="查看当前事件组的位是否被设置，如果设置了则跳过，否则发生阻塞"></p><p><img src="https://files.shanqianche.cn/202212/1671173611753.png" alt="设置事件组的值"></p><blockquote><p>设置事件组大小，如果宏定义USE_16_BIT_TICKS设置为1则，事件组大小为8；如果为0则为24位。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671172754108.png" alt="Esp32的配置"></p><p><img src="https://files.shanqianche.cn/202212/1671174406593.png" alt="创建事件组"></p><p><img src="https://files.shanqianche.cn/202212/1671174563092.png" alt="事件组的判断，零位 | 四位 为1."></p><p><img src="https://files.shanqianche.cn/202212/1671174626150.png" alt="Task2中对事件组0位和四位依次设置为1"></p><p><img src="https://files.shanqianche.cn/202212/1671174723965.png" alt="条件为或时的结果"></p><p><img src="https://files.shanqianche.cn/202212/1671174771887.png" alt="条件为与的结果"></p><h2 id="事件组同"><a href="#事件组同" class="headerlink" title="事件组同"></a>事件组同</h2><blockquote><p>事件组等待的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175636282.png" alt="Step1：task1阻塞，task2，task3依次设置位"></p><p><img src="https://files.shanqianche.cn/202212/1671175673767.png" alt="Step2：task1等待task2，3完成后开始设置自己的位"></p><blockquote><p>事件组同步的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175874589.png" alt="事件组同步"></p><p><img src="https://files.shanqianche.cn/202212/1671175906159.png" alt="Step1：三个事件依次设置，并等待"></p><p><img src="https://files.shanqianche.cn/202212/1671175935762.png" alt="Step2：同时开始"></p><p><strong>code</strong></p><p><img src="https://files.shanqianche.cn/202212/1671176947195.png" alt="BITS"></p><p><img src="https://files.shanqianche.cn/202212/1671177513328.png" alt="创建事件组"></p><p><img src="https://files.shanqianche.cn/202212/1671177624437.png" alt="Task0"></p><p><img src="https://files.shanqianche.cn/202212/1671177635589.png" alt="Task1"></p><p><img src="https://files.shanqianche.cn/202212/1671177641240.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671177663458.png" alt="结果"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之定时器(四)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/</id>
    <published>2022-12-16T03:37:00.000Z</published>
    <updated>2022-12-16T03:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Software-Timer-软件定时器"><a href="#Software-Timer-软件定时器" class="headerlink" title="Software Timer 软件定时器"></a>Software Timer 软件定时器</h2><blockquote><p>基于Daemon Task，定时器任务通过定时器命令队列进行发送给执行指令，然后任务调用相应的程序，执行软件定时器的回调函数。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670983470929.png" alt="Software Timer"></p><p><strong>软件定时器的特点</strong></p><ol><li>不受硬件影响，不受MCU的影响</li><li>软件定时器的数量与堆栈，TIMER_TASK_STACK_DEPTH的影响。不受影响影响</li></ol><p><img src="https://files.shanqianche.cn/202212/1670983728618.png" alt="xTimerCreate"></p><p><img src="https://files.shanqianche.cn/202212/1670984266679.png" alt="启动定时器"></p><p><img src="https://files.shanqianche.cn/202212/1670984718155.png" alt="xTimerStop"></p><p><img src="https://files.shanqianche.cn/202212/1670984850319.png" alt="取得Timer的名字"></p><p><img src="https://files.shanqianche.cn/202212/1670985084226.png" alt="获取Timer ID，返回一个指针"></p><p><img src="https://files.shanqianche.cn/202212/1670985575931.png" alt="只要执行reset函数，定时器将不执行回调函数，类似于喂狗"></p><p><img src="https://files.shanqianche.cn/202212/1670985661744.png" alt="改变定时器周期"></p><p><strong>创建并启动定时器</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984663776.png" alt="创建并启动定时器"><br><strong>延时并停止</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984772340.png" alt="延时等待6s并停止"></p><p><img src="https://files.shanqianche.cn/202212/1670984803629.png" alt="result"></p><p><strong>获取Timer名字</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984974432.png" alt="公用一个回调函数"></p><p><img src="https://files.shanqianche.cn/202212/1670985000934.png" alt="由于两秒执行一次Timer2，一秒一次Timer1；所以结果如此"></p><p><strong>获取一个Timer ID</strong></p><p><img src="https://files.shanqianche.cn/202212/1670985351262.png" alt="方法一，Get Timer ID"></p><p><img src="https://files.shanqianche.cn/202212/1670985502589.png" alt="方法二，返回指针获取ID"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之信号量(六)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/</id>
    <published>2022-12-16T03:35:00.000Z</published>
    <updated>2022-12-16T03:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Semaphore-二进制信号"><a href="#Binary-Semaphore-二进制信号" class="headerlink" title="Binary Semaphore 二进制信号"></a>Binary Semaphore 二进制信号</h2><p><img src="https://files.shanqianche.cn/202212/1670986242028.png" alt="创建信号量，向下兼容，不推荐使用"></p><p><img src="https://files.shanqianche.cn/202212/1670986404539.png" alt="推荐使用这个创建信号"></p><p><img src="https://files.shanqianche.cn/202212/1671088363753.png" alt="释放信号量"></p><ol><li>使用信号量执行任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671088852864.png" alt="enter description here"></p><blockquote><p>创建信号量之后为了使用它必须要释放它。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671089225283.png" alt="文档中提到了创建之后要释放它"></p><ol><li>创建信号量并调用任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089333679.png" alt="创建信号量并释放，task才可以调用"></p><ol start="2"><li>任务一进行调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089371462.png" alt="任务一"></p><ol start="3"><li>任务二调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089387925.png" alt="Task2"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089481464.png" alt="全局变量"></p><p><img src="https://files.shanqianche.cn/202212/1671089428031.png" alt="说明Task1和Task2锁住了全局变量"></p><ol start="5"><li>未使用信号量呢</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089497958.png" alt="Task"></p><ol start="6"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089571227.png" alt="没有使用信号量则会交替进行加一"></p><h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p><img src="https://files.shanqianche.cn/202212/1671091200737.png" alt="获取信号量数目"></p><p><img src="https://files.shanqianche.cn/202212/1671091310069.png" alt="取得可用信号成功则锁住"></p><p><img src="https://files.shanqianche.cn/202212/1671091477101.png" alt="创建计数信号量"></p><ol><li>创建任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091690613.png" alt="创建任务"></p><ol start="2"><li>使用计数信号量，最大信号量减减</li></ol><p> <img src="https://files.shanqianche.cn/202212/1671091848978.png" alt="使用信号量"></p><ol start="3"><li>释放信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091878388.png" alt="每到第六秒释放一个信号量"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091971061.png" alt="第五秒后没有信号量，第六秒进行释放后进行使用"></p><p><img src="https://files.shanqianche.cn/202212/1671092027319.png" alt="每隔六秒可以获得一个信号量"></p><h2 id="互斥量-mutex"><a href="#互斥量-mutex" class="headerlink" title="互斥量 mutex"></a>互斥量 mutex</h2><p><img src="https://files.shanqianche.cn/202212/1671099188414.png" alt="创建互斥量"></p><p><strong>这块需要反复理解</strong></p><ol><li>创建信号量，挂起任务调度器，创建执行任务，开启任务调度器</li></ol><p><img src="https://files.shanqianche.cn/202212/1671107894154.png" alt="创建互斥信号量、挂起任务调度器、创建执行任务、开启任务调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671108236775.png" alt="Task1"></p><p><img src="https://files.shanqianche.cn/202212/1671108106925.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671108024642.png" alt="Task3"></p><blockquote><p>主要是优先级的继承，task1继承了task3所以可以执行任务</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671110095196.png" alt="互斥信号量"></p><p><img src="https://files.shanqianche.cn/202212/1671110147625.png" alt="互斥信号量"></p><blockquote><p>task3优先级最高首先运行，发生阻塞后task2开始执行，task2发生阻塞，task1开始执行，获取信号量并锁定。<br><strong>由于task3的优先级高，所以task3开始执行，然而信号量依旧在task1那</strong>，并未被释放task1超出时间片，看门狗被触发，idle任务因为要用于内存的清理回收，idle任务无法执行，就会触发看门狗。<br>所以task3尝试取信号量，尝试失败后进入task2while循环，循环超时触发看门狗，然后task继续3尝试获取信号量。以此反复。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671111112169.png" alt="使用二进制信号量"></p><p><img src="https://files.shanqianche.cn/202212/1671108979371.png" alt="二进制信号量的结果"></p><h2 id="Recursive-Mutex-递归互斥锁"><a href="#Recursive-Mutex-递归互斥锁" class="headerlink" title="Recursive Mutex 递归互斥锁"></a>Recursive Mutex 递归互斥锁</h2><p><img src="https://files.shanqianche.cn/202212/1671160318532.png" alt="task1获取A信号量并锁住，A需要B，所以继续获取B并锁住"></p><p><img src="https://files.shanqianche.cn/202212/1671160501852.png" alt="创建递归互斥锁"></p><p><img src="https://files.shanqianche.cn/202212/1671165183178.png" alt="创建并执行任务调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671172338333.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671172326291.png" alt="Task1"></p><p><strong>结果：</strong></p><p><img src="https://files.shanqianche.cn/202212/1671172370707.png" alt="结果"></p><p><img src="https://files.shanqianche.cn/202212/1671172394998.png" alt="结果"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之队列(三)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/</id>
    <published>2022-12-16T03:09:00.000Z</published>
    <updated>2022-12-16T03:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="queue队列"><a href="#queue队列" class="headerlink" title="queue队列"></a>queue队列</h2><blockquote><p>常用于传递<font color="#FF00FF">整形、结构体及指针</font></p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670937269638.png" alt="queue"></p><p><img src="https://files.shanqianche.cn/202212/1670937418178.png" alt="xQueueCreate"></p><h3 id="传递整形"><a href="#传递整形" class="headerlink" title="传递整形"></a>传递整形</h3><ol><li>创建队列</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938179291.png" alt="创建队列"></p><ol start="2"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938268578.png" alt="接收函数"></p><ol start="3"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938366706.png" alt="接收函数"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938348411.png" alt="运行结果"></p><ol start="5"><li>对接收函数进行优化</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938507920.png" alt="监控接收队列是否为空，不为才进行接收并打印"></p><h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><ol><li>结构体</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938695866.png" alt="结构体"></p><ol start="2"><li>发送函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938716857.png" alt="发送函数"><br>3. 接收函数</p><p><img src="https://files.shanqianche.cn/202212/1670938766379.png" alt="接收函数"><br>4. 队列</p><p><img src="https://files.shanqianche.cn/202212/1670938806106.png" alt="修改队列宽度，即数据所占位数"></p><h3 id="传递指针"><a href="#传递指针" class="headerlink" title="传递指针"></a>传递指针</h3><p> <strong>小心内存的分配和清除，其它差不多</strong></p><h3 id="队列的多近单出"><a href="#队列的多近单出" class="headerlink" title="队列的多近单出"></a>队列的多近单出</h3><ol><li>发送任务一</li></ol><blockquote><p>发送数字111</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940015975.png" alt="task1"></p><ol start="2"><li>发送任务2</li></ol><blockquote><p>发送数字222</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940046663.png" alt="task2"><br>3. 接收任务</p><p><img src="https://files.shanqianche.cn/202212/1670940095025.png" alt="接收并打印，并设置接收延时最大，阻塞一直等待接收"><br>4. 队列管理</p><p><img src="https://files.shanqianche.cn/202212/1670940125054.png" alt="发送任务优先级一样，接收任务级别为2"></p><h3 id="Queue-Set"><a href="#Queue-Set" class="headerlink" title="Queue Set"></a>Queue Set</h3><p><img src="https://files.shanqianche.cn/202212/1670942546618.png" alt="队列集合，当集合中中的队列哪个有数据则获取哪个队列的数据"></p><ol><li>创建发送Task1</li></ol><p><img src="https://files.shanqianche.cn/202212/1670943244590.png" alt="Task1"><br>2. 发送Task2</p><p><img src="https://files.shanqianche.cn/202212/1670943270669.png" alt="Task2"><br>3. 接收Task</p><p><img src="https://files.shanqianche.cn/202212/1670944978777.png" alt="接收Task"><br>4. Queue 将队列加入Set</p><p><img src="https://files.shanqianche.cn/202212/1670945004119.png" alt="Queue"></p><h3 id="队列邮箱"><a href="#队列邮箱" class="headerlink" title="队列邮箱"></a>队列邮箱</h3><blockquote><p>里面存放一个数据<strong>即队列长度为1</strong>，有一个写入邮箱的task，有一个或多个读出邮箱的task</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670945120071.png" alt="Queue Mail"></p><ol><li>queue mail</li></ol><p><img src="https://files.shanqianche.cn/202212/1670946095803.png" alt="三个read一个write"><br>2. readTask</p><p><img src="https://files.shanqianche.cn/202212/1670946068507.png" alt="readTask"><br>3. writeTask</p><p><img src="https://files.shanqianche.cn/202212/1670946161788.png" alt="readTask"><br>4. 结果</p><p><img src="https://files.shanqianche.cn/202212/1670946264134.png" alt="写入延迟为6秒"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之Task(二)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8BTask(%E4%BA%8C)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8BTask(%E4%BA%8C)/</id>
    <published>2022-12-16T03:08:00.000Z</published>
    <updated>2022-12-16T03:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h4 id="vTaskSuspend-挂起-amp-vTaskResume-恢复"><a href="#vTaskSuspend-挂起-amp-vTaskResume-恢复" class="headerlink" title="vTaskSuspend 挂起 &amp; vTaskResume 恢复"></a>vTaskSuspend 挂起 &amp; vTaskResume 恢复</h4><p><img src="https://files.shanqianche.cn/202212/1670336283287.png" alt="task被挂起并恢复"></p><h4 id="vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有"><a href="#vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有" class="headerlink" title="vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有"></a>vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有</h4><p> 挂起所有task，同时执行完后不能调用FreeRTOS API函数。必须通过vTaskResumeAll（）进行恢复后才能继续直接FreeRTOS API。<strong>保证程序的独立运行</strong></p><p> <img src="https://files.shanqianche.cn/202212/1670336505558.png" alt="指的是系统被挂起后无法被调用"></p><h3 id="vTaskList-任务状态信息"><a href="#vTaskList-任务状态信息" class="headerlink" title="vTaskList() 任务状态信息"></a>vTaskList() 任务状态信息</h3><p> <img src="https://files.shanqianche.cn/202212/1670480943006.png" alt="vTaskList展示task信息"> </p><blockquote><p>运行状态<br>     X: 运行状态<br>    B:阻塞状态<br>    R:准备状态<br>    S:挂起状态<br>    D:删除状态</p></blockquote><h3 id="xTask堆栈"><a href="#xTask堆栈" class="headerlink" title="xTask堆栈"></a>xTask堆栈</h3><p><img src="https://files.shanqianche.cn/202212/1670506507182.png" alt="xTask堆栈的设置"><br><strong>usStackDepth的理解</strong>： 为堆栈的深度。即如果堆栈的宽度为4bytes，深度为100，则堆栈空间为100* 4bytes。</p><p><img src="https://files.shanqianche.cn/202212/1670507145359.png" alt="usStackDepth"></p><h4 id="uxTaskGetStackHighWaterMark-查询剩余堆栈内存"><a href="#uxTaskGetStackHighWaterMark-查询剩余堆栈内存" class="headerlink" title="uxTaskGetStackHighWaterMark() 查询剩余堆栈内存"></a>uxTaskGetStackHighWaterMark() 查询剩余堆栈内存</h4><p>调用vTaskList消耗内存较大，可以通过uxTaskGetStackHighWaterMark来获取内存信息。</p><p><strong>可以用于调试代码</strong></p><h3 id="task-Watchdogs"><a href="#task-Watchdogs" class="headerlink" title="task Watchdogs"></a>task Watchdogs</h3><blockquote><ol><li>中断看门狗300ms、2.task看门狗5s</li></ol></blockquote><h4 id="中断看门狗"><a href="#中断看门狗" class="headerlink" title="中断看门狗"></a>中断看门狗</h4><p><img src="https://files.shanqianche.cn/202212/1670832506559.png" alt="中断看门狗调用的是定时器组一"></p><p><img src="https://files.shanqianche.cn/202212/1670832612635.png" alt="中断看梦的配置"></p><h4 id="task看门狗"><a href="#task看门狗" class="headerlink" title="task看门狗"></a>task看门狗</h4><p><img src="https://files.shanqianche.cn/202212/1670915250123.png" alt="创建时引用"></p><p><img src="https://files.shanqianche.cn/202212/1670937111595.png" alt="将任务加入任务看门狗，并喂狗，如果不喂狗则会报idle错误"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之基本运行原理(一)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86(%E4%B8%80)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86(%E4%B8%80)/</id>
    <published>2022-12-16T03:06:00.000Z</published>
    <updated>2022-12-16T03:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><p><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </p><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input checked="" disabled="" type="checkbox"> 掌握task</li><li><input checked="" disabled="" type="checkbox"> 掌握list </li><li><input checked="" disabled="" type="checkbox"> 掌握queue</li></ul><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ol><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之数据流(八)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B5%81(%E5%85%AB)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B5%81(%E5%85%AB)/</id>
    <published>2022-12-16T02:45:00.000Z</published>
    <updated>2022-12-16T02:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Message-buffer"><a href="#Message-buffer" class="headerlink" title="Message buffer"></a>Message buffer</h2><blockquote><p>与stream buffer 的不同：<br>（1）：一次只能接收完整一条buffer；<br>（2）：如果数据长度超过接收buffer的大小，stream会继续接收(接收buffer大小的数据量)，而message不接收</p></blockquote><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p><img src="https://files.shanqianche.cn/202212/1671202136155.png" alt="创建"></p><p><img src="https://files.shanqianche.cn/202212/1671202226329.png" alt="接收function"></p><p><img src="https://files.shanqianche.cn/202212/1671202240298.png" alt="发送function"></p><h3 id="实验一：验证区别一"><a href="#实验一：验证区别一" class="headerlink" title="实验一：验证区别一"></a>实验一：验证区别一</h3><p><img src="https://files.shanqianche.cn/202212/1671202461368.png" alt="全局变量 message buffer句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671202272589.png" alt="调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671202413471.png" alt="创建三天message buffer并发送到buffer中"><br><img src="https://files.shanqianche.cn/202212/1671202330991.png"></p><p><img src="https://files.shanqianche.cn/202212/1671202495555.png" alt="结果：每次只接收一条数据"></p><p><img src="https://files.shanqianche.cn/202212/1671202554503.png" alt="修改为stream buffer继续实验"></p><p><img src="https://files.shanqianche.cn/202212/1671202604076.png" alt="结果：一次接收所有数据"></p><h3 id="实验二：验证区别二"><a href="#实验二：验证区别二" class="headerlink" title="实验二：验证区别二"></a>实验二：验证区别二</h3><h4 id="stream-buffer"><a href="#stream-buffer" class="headerlink" title="stream buffer"></a>stream buffer</h4><p><img src="https://files.shanqianche.cn/202212/1671202816481.png" alt="发送function"></p><p><img src="https://files.shanqianche.cn/202212/1671202862644.png" alt="接收function，buffer小"></p><p><img src="https://files.shanqianche.cn/202212/1671202933240.png" alt="结果：接收"></p><h4 id="message-buffer"><a href="#message-buffer" class="headerlink" title="message buffer"></a>message buffer</h4><p><img src="https://files.shanqianche.cn/202212/1671202988047.png" alt="结果：不在接收"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之数据流(七)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%B8%83)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%B8%83)/</id>
    <published>2022-12-16T01:44:00.000Z</published>
    <updated>2022-12-16T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream-Buffer"><a href="#Stream-Buffer" class="headerlink" title="Stream Buffer"></a>Stream Buffer</h2><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><blockquote><p>大部分音频以这种形式传输数据。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671199467534.png" alt="创建流"></p><p><img src="https://files.shanqianche.cn/202212/1671199642131.png" alt="发送stream buffer"></p><p><img src="https://files.shanqianche.cn/202212/1671199751798.png" alt="接收stream buffer"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="https://files.shanqianche.cn/202212/1671199532838.png" alt="全局变量stream buffer句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671199578431.png" alt="创建stream buffer"></p><p><img src="https://files.shanqianche.cn/202212/1671199702196.png" alt="发送handle"></p><p><img src="https://files.shanqianche.cn/202212/1671199794137.png" alt="接收handle"></p><h3 id="实验结果与改进"><a href="#实验结果与改进" class="headerlink" title="实验结果与改进"></a>实验结果与改进</h3><p><img src="https://files.shanqianche.cn/202212/1671199830149.png" alt="结果"></p><p><img src="https://files.shanqianche.cn/202212/1671200002220.png" alt="修改触发量"></p><p><img src="https://files.shanqianche.cn/202212/1671200519994.png" alt="接收"></p><p><img src="https://files.shanqianche.cn/202212/1671200339750.png" alt="基于上修改，将阻塞提前"></p><p><img src="https://files.shanqianche.cn/202212/1671200373451.png" alt="结果，先发送五次后再接收"></p><h2 id="监控stream-buffer-剩余空间"><a href="#监控stream-buffer-剩余空间" class="headerlink" title="监控stream buffer 剩余空间"></a>监控stream buffer 剩余空间</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://files.shanqianche.cn/202212/1671200744509.png" alt="task3监控stream buffer剩余空间"></p><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p><img src="https://files.shanqianche.cn/202212/1671201588256.png" alt="查看剩余空间"></p><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p><img src="https://files.shanqianche.cn/202212/1671201719717.png" alt="监控剩余空间"></p><p><img src="https://files.shanqianche.cn/202212/1671201759665.png" alt="结果"></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student, RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>STM32F108的学习</title>
    <link href="https://merlynr.github.io/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://merlynr.github.io/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-11T02:12:00.000Z</published>
    <updated>2022-11-11T02:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="f270768e-6a79-4d1d-8fd8-694008c8a311">天天PLAN</a></p><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><h3 id="LED的注意事项"><a href="#LED的注意事项" class="headerlink" title="LED的注意事项"></a>LED的注意事项</h3><ol><li>需要连接电阻，不然可能击穿LED。</li><li><strong>一般LED所需电流为0~10+的毫安【不要超过20mA】，芯片所提供电压为3.3 or 5v，所以接一个1kΩ电阻【限流电阻】即可。</strong></li><li><a href="https://blog.csdn.net/a419116194/article/details/103238872">高电平、低电平</a>。低电平时电路的阻抗低，噪声造成的电平变化小，也就是说，抗干扰能力更强</li></ol><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><h3 id="GPIO的注意事项"><a href="#GPIO的注意事项" class="headerlink" title="GPIO的注意事项"></a>GPIO的注意事项</h3><ol><li>除了GPIO的为通用<del>， 其余皆为复用</del></li></ol><p><img src="./images/1668134920148.png" alt="端口配置"><br>2. <strong>GPIO大部分使用推挽输出，ⅡC使用的开漏输出。</strong><br>3. 地址=基址+偏移地址<br>4. 端口配置寄存器【输入输出配置（模拟、浮空、上拉下拉、保留）（通用推挽、通用开漏、复用推挽、复用开漏），输入输出模式以及频率】–&gt;端口输出数据寄存器（配置端口地址为1的是输出端口）</p><h2 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h2><ol><li>AHB 高速总线、APB普通外设总结、</li><li><strong>通过APB为GPIO提供RCC时钟源，才可以使外设与CPU连接。</strong></li></ol><p><img src="./images/1668182227309.png" alt="使能GPIO"></p><ol start="3"><li>volatile 避免从缓冲区取值，只能从寄存器中取值。</li></ol><h2 id="第七节"><a href="#第七节" class="headerlink" title="第七节"></a>第七节</h2><ol><li>使用结构体可以定义连续的的相关配置，因为结构体中遍历在内存中是连续的。</li><li>使用STM32官方库需要引入相关文件。</li></ol><p><img src="./images/1668181982839.png" alt="依赖文件"></p><p><img src="./images/1668182057720.png" alt="依赖文件"></p><p><img src="./images/1668182110452.png" alt="库文件"></p><h2 id="第八节-按键控制"><a href="#第八节-按键控制" class="headerlink" title="第八节 按键控制"></a>第八节 按键控制</h2><p><img src="./images/1668242764890.png" alt="低电平输入"></p><ol><li>利用按键进行控制led时，可以利用内部的上拉电位，以此输入高电平，按键后输入低电平，以此控制LED</li></ol><h2 id="第九节呼吸灯"><a href="#第九节呼吸灯" class="headerlink" title="第九节呼吸灯"></a>第九节呼吸灯</h2><ol><li>有两种方式，一种是通过修改平均电平，第二种是通过修改PWM</li></ol><p><img src="./images/1668321362358.png" alt="修改电平，变亮就是增加高电平所占时间"></p><h2 id="第十一节NVIC"><a href="#第十一节NVIC" class="headerlink" title="第十一节NVIC"></a>第十一节NVIC</h2><p><img src="https://files.shanqianche.cn/202211/1668324442560.png" alt="抢占优先级和响应优先级"></p><ol><li>从优先级（响应优先级）,在抢占优先级相同时谁的高谁优先。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668325634113.png" alt="外部中断模式"><br>2. 事件请求：当前事件完成后跳转到中断向量表。中断请求：立刻跳转到中断向量表。</p><p><img src="https://files.shanqianche.cn/202211/1668326173434.png" alt="功能复用"><br>3. 需要考虑到pin复用。时钟和中断。</p><p><img src="https://files.shanqianche.cn/202211/1668326286702.png" alt="外部中断初始化"><br>4. 外部中断EXTI0的配置包括：向量化中断控制器的配置、PA0配置为外部中断、中断工作模式（下降沿检测）</p><h2 id="第十三节SysTick-最后一个异常"><a href="#第十三节SysTick-最后一个异常" class="headerlink" title="第十三节SysTick 最后一个异常"></a>第十三节SysTick 最后一个异常</h2><ol><li>SysTick是系统内部计时器，CorTex-M3内包含。其是一个24位的计时器，基本模式是从一个reload 值递减，为0时触发异常，然后重新计数。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668328540665.png" alt="SysTick CTRL"></p><ol start="2"><li>多久减一可以通过CLKSOURCE来设置，AHB为告诉外部时钟，为72MHZ。频率=1/时钟，所以时钟越大，精度越高。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668329188316.png" alt="时钟为72MHZ，reload value为72，最后1微妙产生一次异常中断"><br>3. 产生一次异常时间的设置。</p><h2 id="第十四节"><a href="#第十四节" class="headerlink" title="第十四节"></a>第十四节</h2><p><img src="https://files.shanqianche.cn/202211/1668346317638.png" alt="时钟配置"></p><p><img src="https://files.shanqianche.cn/202211/1668346298839.png" alt="开启时钟，设置全局变量，使其在异常函数中进行递减"><br><img src="https://files.shanqianche.cn/202211/1668346363077.png" alt="SysTick异常函数"></p><ol><li>延时函数</li></ol><h2 id="第十五节"><a href="#第十五节" class="headerlink" title="第十五节"></a>第十五节</h2><ol><li>stm32 有两个看门狗，一个独立看门狗，一个窗口看门狗</li></ol><p><img src="https://files.shanqianche.cn/202211/1668348073923.png" alt="IWDG"><br><img src="https://files.shanqianche.cn/202211/1668348218257.png" alt="IWDG主要功能"><br>2. 独立看门狗（IWDG）依赖LSI（低速内部时钟），即使晶振，外部时钟不工作，IWDG依旧正常工作</p><p><img src="https://files.shanqianche.cn/202211/1668348022275.png" alt="依赖APB1的外设"><br><img src="https://files.shanqianche.cn/202211/1668348100750.png" alt="WWDG"></p><p><img src="https://files.shanqianche.cn/202211/1668348325069.png" alt="IWDG框图"></p><p><img src="https://files.shanqianche.cn/202211/1668348444032.png" alt="键寄存器"><br><img src="https://files.shanqianche.cn/202211/1668390061020.png" alt="reload value为625，pr预分频因子为4时，IWDG就会每隔一秒钟复位一次"><br>3. WWDG依赖APB1，所以APB1出问题，无法工作。</p><p><img src="https://files.shanqianche.cn/202211/1668390482984.png" alt="设置IWDG，第一步取消写保护，设置PR"></p><p><img src="https://files.shanqianche.cn/202211/1668390706177.png" alt="第一步"><br><img src="https://files.shanqianche.cn/202211/1668390795034.png" alt="第二步PR的设置"></p><p><img src="https://files.shanqianche.cn/202211/1668390820968.png" alt="第三步reload value"><br><img src="https://files.shanqianche.cn/202211/1668390977778.png" alt="第四步装入reload value"></p><p><img src="https://files.shanqianche.cn/202211/1668391016821.png" alt="第五步使能"></p><p><img src="https://files.shanqianche.cn/202211/1668391395544.png" alt="IWDG_initt code"><br>5. 4. IWDG的设置</p><h2 id="第16节课WWDG"><a href="#第16节课WWDG" class="headerlink" title="第16节课WWDG"></a>第16节课WWDG</h2><ol><li><strong>偶尔的两次异常，即正常状态到异常状态、接着异常状态又到正常状态，这属于异常，如果这两步操作在异常恢复时间内，即喂狗时间内，IWDG是无法检测到的。而WWDG可以解决。</strong></li></ol><p><img src="https://files.shanqianche.cn/202211/1668392219848.png" alt="特殊异常"><br>2. WWDG喂狗机制，当WWDG的递减计数器1T[6:0]大于上限窗口W[6:0]时1，如果尝试去喂狗，将立刻产生CPU复位。</p><p><img src="https://files.shanqianche.cn/202211/1668392718745.png" alt="只有在0x60-0x3F内喂狗才有效"><br><img src="https://files.shanqianche.cn/202211/1668393252329.png" alt="WWDG原理"></p><p><img src="https://files.shanqianche.cn/202211/1668393442189.png" alt="enter description here"></p><p><img src="https://files.shanqianche.cn/202211/1668393484988.png" alt="喂狗"></p><ol start="3"><li>WWDG配置code<pre><code>- 因为WWDG是与APB1连接的，所以需要从APB1相关函数使能WWDG- 初始化WWDG，配置计数，计数是有上限的，通过与最大值进行想与来限制。- 设置预分频值（PR）- 设置上窗口值- 使能并且喂狗</code></pre></li></ol><p><img src="https://files.shanqianche.cn/202211/1668495595263.png" alt="WWDG初始化配置"></p><p><img src="https://files.shanqianche.cn/202211/1668495613227.png" alt="中断向量表初始化"></p><p>必须进行喂狗，不然CPU会不断进行重启。<br><img src="https://files.shanqianche.cn/202211/1668495643575.png" alt="喂狗"></p><h2 id="第十七节USART"><a href="#第十七节USART" class="headerlink" title="第十七节USART"></a>第十七节USART</h2><ol><li>主要用于芯片与芯片之间的传输</li><li>芯片与PC之间的通信</li><li>芯片与外围模块之间的通信 </li></ol><p>UART 异步功能<br>USART 同步功能<br>USART_CK具有时钟功能<br>USART_CTS具有流控功能，因为不同设备之间频率不一样，接发速率也不一样，CTS可以控制是否接受或者发送数据【硬件流控】，可以用于判断是否进行发送数据<br>USART_RTS发送请求</p><h3 id="代码-amp-逻辑"><a href="#代码-amp-逻辑" class="headerlink" title="代码&amp;逻辑"></a>代码&amp;逻辑</h3><ol><li>开启对应总线的时钟，同时需要开启GPIO管脚的时钟</li></ol>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,STM32" scheme="https://merlynr.github.io/tags/study-graduate-student-STM32/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版</title>
    <link href="https://merlynr.github.io/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    <id>https://merlynr.github.io/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/</id>
    <published>2022-05-15T16:00:00.000Z</published>
    <updated>2022-07-17T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="戴师帮忙选的important-point"><a href="#戴师帮忙选的important-point" class="headerlink" title="戴师帮忙选的important point"></a>戴师帮忙选的important point</h1><p><img src="http://files.shanqianche.cn/20225/1652971169338.png" alt="important point page-1"></p><p><img src="http://files.shanqianche.cn/20225/1652971169333.png" alt="important point page-2"></p><p><img src="http://files.shanqianche.cn/20225/1652971169335.png" alt="important point page-3"></p><p><img src="http://files.shanqianche.cn/20225/1652971169334.png" alt="important point page-4"></p><p><img src="http://files.shanqianche.cn/20225/1652971169337.png" alt="important point page-5"></p><p><img src="http://files.shanqianche.cn/20225/1652971169336.png" alt="important point page-6"></p><p><img src="http://files.shanqianche.cn/20225/1652971169339.png" alt="important point page-7"></p><p><img src="http://files.shanqianche.cn/20225/1652971169340.png" alt="important point page-8"></p><p><img src="http://files.shanqianche.cn/20225/1652971169411.png" alt="important point page-9"></p><p><img src="http://files.shanqianche.cn/20225/1652971169408.png" alt="important point page-X"></p><h1 id="第二章-HTML-中的-JavaScript"><a href="#第二章-HTML-中的-JavaScript" class="headerlink" title="第二章 HTML 中的 JavaScript"></a>第二章 HTML 中的 JavaScript</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>第2.1中提到type中设置为module，代码当成了<font color="#8B0000">ES6模块</font>，需要实践来验证。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169412.png" alt="script标签中type属性"></p><ol start="2"><li>第2.1中提到浏览器不会对文件扩展名进行检测，为服务器<font color="#8B0000">动态生成js</font>提供可能性，不是很理解。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169413.png" alt="不对文件后缀检测的作用"></p><ol start="3"><li>第2.1不是很懂其中提到的<font color="#8B0000">MIME</font>的作用及判断原理</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169416.png" alt="返回正确MIME类型"></p><ol start="4"><li>第2.1中提到src中url的请求策略，不理解<font color="#bf242a">同源策略</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169414.png" alt="src的请求策略，以及返回的JavaScript的受限规则"></p><ol start="5"><li>第2.1.2中推迟脚本执行中提到DOMContentLoad事件，没见过，下次学习一下HTML</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169421.png" alt="delay属性设置后依旧会在DOMContentLoad事件之前执行"></p><ol start="6"><li>第2.1.3async可以保证脚本在<font color="#E9967A">页面load事件之前执行</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169415.png" alt="async在页面中的执行顺序"></p><h2 id="理解与解决"><a href="#理解与解决" class="headerlink" title="理解与解决"></a>理解与解决</h2><h1 id="第三章语言基础"><a href="#第三章语言基础" class="headerlink" title="第三章语言基础"></a>第三章语言基础</h1><h2 id="学习与反思"><a href="#学习与反思" class="headerlink" title="学习与反思"></a>学习与反思</h2><ol><li>声明的提升</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169420.png" alt="var声明提升"></p><ol start="2"><li><p>补充：<font color="#8B0000"><a href="https://www.javascripttutorial.net/javascript-event-loop/">Event Loop</a></font></p></li><li><p>var，let与const在for中的使用</p></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169419.png" alt="for循环"></p><p>setTimeOut会在for循环结束后进行输出，var在这里读取的是一个全局变了 $i$ ,所有只会输出五，但是JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，所以有五个 $i$ 进行输出。</p><p><img src="http://files.shanqianche.cn/20225/1652971169494.png" alt="for中的let"></p><p><img src="http://files.shanqianche.cn/20225/1652971169495.png" alt="for中的const"></p><h2 id="问题与解释"><a href="#问题与解释" class="headerlink" title="问题与解释"></a>问题与解释</h2><ol><li>第3.4.5中提到八进制和十六进制在数学操作中都被视为十进制，什么意思？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169496.png" alt="八进制和十六进制的运算方式"><br>答：都转化为十进制再进行计算。</p><ol start="2"><li>第3.4.7中为什么要避免Symbol()包装对象？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169497.png" alt="Symbol()无法包装对象"><br>解：对象是引用类型，返回的是指针，针对同一类型的对象是同一个指针，这就与Symbol（）矛盾了。<br>3. 第3.4.7.4的使用Symbol实现异步迭代以及后续的内容不是很懂。</p><p><img src="http://files.shanqianche.cn/20225/1652971169498.png" alt="相关异步的问题"><br>解：重构了迭代函数<br>4. 第3.4.7.16中with环境啥意思</p><p>解：</p><p><img src="http://files.shanqianche.cn/20225/1652971169499.png" alt="with的使用"></p><ol start="5"><li>第3.6.7中标签语句进行学习</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169500.png" alt="标签语句"><br>解：</p><h1 id="第四章变量、作用域与内存"><a href="#第四章变量、作用域与内存" class="headerlink" title="第四章变量、作用域与内存"></a>第四章变量、作用域与内存</h1><h2 id="问题与解"><a href="#问题与解" class="headerlink" title="问题与解"></a>问题与解</h2><ol><li>第4.2.2中let与var的提升的区别，let提升出现暂时性死区啥意思？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655395936285.png" alt="let与var的hoisting"><br>2. 第4.3.4.3中提到内存泄漏的原因，那么如何检测内存泄漏呢？</p><h1 id="第五章基本引用类型"><a href="#第五章基本引用类型" class="headerlink" title="第五章基本引用类型"></a>第五章基本引用类型</h1><ol><li>引用值与传统面向对象编程语言中的类相似，但实现不同？<b>理解</b></li></ol><h1 id="第六章集合引用类型"><a href="#第六章集合引用类型" class="headerlink" title="第六章集合引用类型"></a>第六章集合引用类型</h1><ol><li>第6.2.4中提到会出现无法判断一个对象是否为数组的现象？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655908202281.png" alt="无法判断是否为数组"></p><ol start="2"><li>第6.2.13中迭代器的作用域对象的使用。</li></ol><p><a href="https://blog.csdn.net/qq_35087256/article/details/79658253">相关文档</a></p><p><img src="http://files.shanqianche.cn/20226/1656118450989.png" alt="作用域对象"></p><ol start="3"><li>第6.3.4中提到的上溢和下溢不是很懂。</li></ol><p><img src="http://files.shanqianche.cn/20226/1656257982512.png" alt="解决上溢下溢问题"><br>4. 第6.9中，“每种包装类型都映射到同名的原始类型”什么意思？<br>5. 第6.9中，“在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。”？<br>6. 第6.9中，“涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。”？</p><h1 id="第七章迭代器与生成器"><a href="#第七章迭代器与生成器" class="headerlink" title="第七章迭代器与生成器"></a>第七章迭代器与生成器</h1><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><ol><li>第7.3.2.4中描述到yied*实现递归，没看懂代码</li></ol><p><img src="http://files.shanqianche.cn/20226/1656581774389.png" alt="enter description here"></p><h1 id="第八章对象、类与面向对象变成"><a href="#第八章对象、类与面向对象变成" class="headerlink" title="第八章对象、类与面向对象变成"></a>第八章对象、类与面向对象变成</h1><ol><li>第8.1.7中对象结构中提到解构在内部使用函数这块不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1656743508866.png" alt="解构在内部使用函数"></p><p><strong><font color="#FF1493">结构这的语法糖还是比较怪的，建议都看</font></strong></p><ol start="2"><li>第8.3.2.2中提到盗用构造函数的缺点不是很理解 <img src="https://files.shanqianche.cn/20227/1657633886960.png" alt="缺点"> <img src="https://files.shanqianche.cn/20227/1657633898659.png" alt="缺点"></li><li>第8.3.4中原型式的继承不是很懂作用</li></ol><p><img src="https://files.shanqianche.cn/20227/1657635961798.png" alt="原型式继承"><br>3. 第8.3.6中寄生组合继承，重新梳理一下继承中的逻辑</p><p><img src="https://files.shanqianche.cn/20227/1657637338484.png" alt="理论"></p><p><img src="https://files.shanqianche.cn/20227/1657637456555.png" alt="为什么说只调用一次"><br>4. 第8.4.4.5中类混入提到利用辅助函数进行展开嵌套，不是很懂原理和作用。</p><p><img src="https://files.shanqianche.cn/20227/1657711373381.png" alt="展开嵌套"></p><h1 id="第九章代理与反射"><a href="#第九章代理与反射" class="headerlink" title="第九章代理与反射"></a>第九章代理与反射</h1><ol><li>第9.1.6.2中提到使用反射不在抛错而是返回false，与实际代码不一样。</li></ol><p><img src="https://files.shanqianche.cn/20227/1657938559413.png" alt="文档"></p><p><img src="https://files.shanqianche.cn/20227/1657938590087.png" alt="实际演示"></p><h1 id="第十章函数"><a href="#第十章函数" class="headerlink" title="第十章函数"></a>第十章函数</h1><ol><li>第10.14闭包的作用和定义依旧不是很懂</li><li>第10.14.1中this对象的作用域不清楚</li></ol><p><img src="http://files.shanqianche.cn/20227/1658048008355.png" alt="this对象的作用域"></p><ol start="3"><li>第10.14.2中</li></ol><p><img src="http://files.shanqianche.cn/20227/1658049551215.png" alt="闭包问题"></p><ol start="4"><li>第10.15，10.16都不是很懂了</li></ol><h1 id="期约和异步函数"><a href="#期约和异步函数" class="headerlink" title="期约和异步函数"></a>期约和异步函数</h1><ol><li>第11.2.4.4中对于reduce的使用不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1658200969767.png" alt="promise+reduce"></p><p><img src="http://files.shanqianche.cn/20227/1658201198623.png" alt="promise reduce"></p><ol start="2"><li>第11.2.5.1中期约的取消，实现这块函数不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/code.png" alt="期约取消功能的实现"></p><h1 id="第十四"><a href="#第十四" class="headerlink" title="第十四"></a>第十四</h1><ol><li>第14.3.3 微任务队列及为啥处理两次</li></ol><p><img src="https://files.shanqianche.cn/20227/1658421089137.png" alt="记录队列"></p><h1 id="第二十章"><a href="#第二十章" class="headerlink" title="第二十章"></a>第二十章</h1><ol><li>第20.9.2，3，4看不懂可读流，可写流和转换流</li></ol><h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><ol><li>第24.6中fetch API的数据绑定不是很懂，尤其stream那块</li></ol>]]></content>
    
    
    <summary type="html">每天学习JS</summary>
    
    
    
    <category term="FE" scheme="https://merlynr.github.io/categories/FE/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="JavaScript" scheme="https://merlynr.github.io/tags/JavaScript/"/>
    
    <category term="book" scheme="https://merlynr.github.io/tags/book/"/>
    
    <category term="front-end" scheme="https://merlynr.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>业务流程的LSTM精准模型</title>
    <link href="https://merlynr.github.io/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/"/>
    <id>https://merlynr.github.io/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-08-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>使用LSTM模型对事件下一步，时间戳和调用的资源进行预测。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要是对于前人提出在LSTM中利用近似前缀预测—<a href="https://blog.zuishuailcq.xyz/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/">基于LSTM神经网络的业务过程预测监控 | 吾辈之人，自当自强不息！</a>的缺陷的改进，缺陷：</p><ol><li>无法处理数字变量</li><li>不能生成带有时间戳的时间序列</li><li>后续有文章提出通过one-hot编码来对事件进行分类，而不是使用嵌入维度来实现的，这样<strong>随着事件类型的增加，精度就会极度下降</strong>。</li></ol><blockquote><p>知识补充<br>后处理：在模型训练后，人为的修改模型结果使之预测结果更加符合真实情况。<br><a href="https://blog.csdn.net/xieyan0811/article/details/80549001">数据挖掘之_后处理_谢彦的技术博客-CSDN博客_数据后处理</a></p></blockquote><dl><dt><strong><font color="#006400">解决：</font></strong><br>本文通过提出用于建立新的预处理和后处理方法和架构以及使用LSTM神经网络的事件日志的生成模型来解决上述方法的局限性。</dt><dd>具体地说，本文提出了一种方法去学习模型，该方法可以生成由三组(事件类型、角色、时间戳)组成的轨迹(或从给定前缀开始的轨迹的后缀)。提出的方法结合了Tax等人[13]和Evermann等人[2]的优点，<font color="#483D8B">通过使用嵌入维度，同时支持事件日志中的分类属性和数字属性</font>。本文考虑了神经网络中共享层和特有层的不同组合所对应的三种体系结构。</dd></dl><p><strong><font color="#FF8C00">评估：</font></strong></p><ol><li>第一种方法比较了与不同体系结构、预处理和后处理选择相对应的所提出方法的备选实例。该评估的目的是<font color="#00008B">根据获取到的日志的特征</font>，得出关于哪些设计选择更可取的指南。</li><li>比较提出方法在上面三条约束的表现。</li></ol><h1 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h1><h2 id="LSTM-当前的进展"><a href="#LSTM-当前的进展" class="headerlink" title="LSTM 当前的进展"></a>LSTM 当前的进展</h2><ol><li>使用LSTM对于事件类型较少的序列进行迭代循环预测，使用的是one-hot编码将事件类型，事件戳映射到向量特征向量，并使用事件发生的时间特征对其进行补充。<strong>缺点</strong>是当事件类型较多的时候，该方法效果会变差。</li></ol><ul><li>该模型由共享LSTM层构成，其中包括一个专门用于预测事件的LSTM和一个预测事件的LSTM</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627633758272.png" alt="2017-使用LSTM神经网络进行预测性业务流程监控"></p><ol start="2"><li>使用嵌入维度的LSTMs，可以减少输入长度和增加新的特征。<strong>缺点</strong>是依旧无法处理数值变量，所以也不能预测时间戳。<strong>优点</strong>是可以处理大量事件类型。</li></ol><ul><li>使用两层LSTMs隐藏层。</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627636620079.png" alt="2017-利用深度学习预测过程行为"></p><ol start="3"><li>提出基于RNN的模型MM-Pred来预测下一步事件和流程后续。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>这种方法同时使用控制流信息（事件类型）和案例数据（事件属性）。</li><li>该结构由编码器、调制器和解码器组成。</li><li>编码器和解码器使用LSTM网络将每个事件的属性转换为隐藏表示或从隐藏表示转换为隐藏表示。</li><li>调制器组件求出可变长度序列比对权重向量，其中每个权重表示用于预测未来事件和属性的属性的相关性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627873762436.png" alt="多属性事件序列的深度预测模型"></p><ol start="4"><li>使用多阶段深度学习的方法来预测下一个事件。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>首先是将每个事件映射到特征向量</li><li>下一步使用transformations降低输入维度，通常有，通过提取n-gram、使用hash、将输入通过两个自动编码层等方法</li><li>将转化后的输入传给负责预测的前馈神经网络</li></ul><p><img src="http://files.shanqianche.cn/202182/1627887742568.png" alt="业务流程事件预测的多阶段深度学习方法"></p><ol start="5"><li>作者提出一种基于GRU的神经网络架构BINet，用于业务流程执行中的实时异常检测。该架构用于预测下一个事件及属性。</li></ol><ul><li>该方法旨在为跟踪中的每个事件分配一个似然分数，然后用于检测异常。这种方法表明，过程行为的生成模型也可用于异常检测。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907436804.png" alt="基于深度学习的多元业务流程异常检测"></p><ol start="6"><li>作者比较几种真实数据集在MMs，all-k MMs以及基于自动机的模型中预测下一步的准确性和性能。</li></ol><ul><li>结果表明，AKOM模型具有最高的精度（在某些情况下优于RNN体系结构），而基于自动机的模型具有较高的可解释性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907971849.png" alt="下一个元素预测序列建模方法的跨学科比较"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="http://files.shanqianche.cn/2021811/1628666548975.png" alt="构建模型的步骤"></p><h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><h3 id="Data-transformation"><a href="#Data-transformation" class="headerlink" title="Data transformation"></a>Data transformation</h3><p><strong>根据属性性质（分类或连续）进行特定预处理。</strong></p><p><strong><font color="#294B71">分类：</font></strong></p><p>处理数据：将事件和资源作为类别属性，使用嵌入维度。</p><blockquote><p>向训练网络提供属性之间关联的正面和负面示例，使网络能够识别和定位具有相似特征的近似属性。根据NLP社区4中使用的一项通用建议，嵌入维度的数量被确定为类别数量的第四根，以避免它们之间可能发生冲突。生成的值作为不可训练的参数导出并在所有实验中重用，这样就不会增加模型的复杂性</p></blockquote><p><img src="http://files.shanqianche.cn/2021811/1628683817654.png" alt="用于训练嵌入层的网络结构和生成的4d空间被缩减为3d的空间"></p><p> <strong><font color="#E9967A">连续：</font></strong></p><p><font color="#1E90FF"> 对数据进行归一化，以供预测模型解释</font>。这里处理的事件之间的相对时间，问题在于不同日志，相对时间可能具有很大的可变性。 这种高可变性可以隐藏有关过程行为的有用信息，例如时间瓶颈或异常行为，如果不小心执行属性缩放，则可以隐藏这些信息。</p><p> 寻求一种合适的缩放方法。</p><p> <img src="http://files.shanqianche.cn/2021811/1628685428211.png" alt="最大值和对数归一化两种方法的对比"></p><h3 id="Sequences-creation"><a href="#Sequences-creation" class="headerlink" title="Sequences creation"></a>Sequences creation</h3><p> <strong>提取每个事件日志跟踪的固定大小的n-gram，以创建输入序列和预期事件来训练预测网络。</strong></p><p> <img src="http://files.shanqianche.cn/2021811/1628686156534.png" alt="从BPI 2012事件日志的案例id 174770中提取的五个n-gram"></p><p> <em>role表示的是事件与资源的关联</em></p><h2 id="Model-Structure-Definition-Phase"><a href="#Model-Structure-Definition-Phase" class="headerlink" title="Model Structure Definition Phase"></a>Model Structure Definition Phase</h2><p><img src="http://files.shanqianche.cn/2021811/1628686308297.png" alt="Baseline architecture"></p><p><img src="http://files.shanqianche.cn/2021811/1628687598994.png" alt="Tested architectures"></p><h2 id="Post-processing-Phase"><a href="#Post-processing-Phase" class="headerlink" title="Post-processing Phase"></a>Post-processing Phase</h2><p>从零前缀开始生成业务流程的完整跟踪中，传统使用的是arg max，直接根据下一个事件的最大概率来跟踪，但是这就会所有追踪的事件都倾向于概率最大值，对于低概率发生的事件无法追踪。这里作者使用的是arg max和随机选择的参数作为下一个事件的选择。</p><blockquote><p>我觉得应该使用softmax</p></blockquote><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><blockquote><p>本节描述了两个实验评估。第一个实验比较了三种架构在前处理和后处理选择方面的不同实例。第二个实验将提出的方法与技术背景中其它论文中的下一个事件、后缀和剩余时间预测任务的三条基线进行比较</p></blockquote><h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data Set"></a>Data Set</h2><pre><code>在本实验中，使用了九个来自不同领域、具有不同特征的真实事件日志</code></pre><ul><li>Helpdesk5事件日志包含来自意大利软件公司helpdesk票务管理过程的记录</li><li>BPI 20126 中的两个事件日志与来自德国金融机构的贷款申请流程相关。 这个过程由三个子过程组成，我们从中使用了 W 子过程，以便与”下一个元素预测序列建模方法的跨学科比较”进行比较 。</li><li>BPI 20137中的事件日志与沃尔沃的IT事件和问题管理有关。我们使用完整的案例学习生成模型</li><li>BPI 20158中的五个事件日志包含五个荷兰城市在四年期间提供的建筑许可证申请数据。原始事件日志分为五个部分（每个市政局一个）。所有事件日志都在子流程级别指定，包括345多个活动。因此，按照”Diagnostics of building per-mit application process in dutch municipalities”中所述的步骤对其进行预处理，以便在阶段级别进行管理</li></ul><p><img src="http://files.shanqianche.cn/2021811/1628688257014.png" alt="Event logs description"></p><ol><li><em><font color="#A9A9A9">SF指根据其在记录道数量、事件、活动和序列长度方面的组成分为简单、中等和复杂。</font></em></li><li><em><font color="#A9A9A9">TV指据每个事件日志的平均持续时间和最大持续时间之间的关系，将时间变异性（TV）分为稳定或可变</font></em></li></ol><h2 id="Experimental-setup"><a href="#Experimental-setup" class="headerlink" title="Experimental setup"></a>Experimental setup</h2><p><strong><font color="#8A2BE2">目的：</font></strong><br>    使用 LSTM 模型从大小为0的前缀开始跟踪生成完整的事件日志，然后将生成的跟踪与原始日志中的流程进行比较。</p><p><font color="#1E90FF">方法：使用两个指标来评估生成的事件日志的相似性。</font></p><ol><li>Demerau-Levinstain（DL）算法根据一个字符串与另一个字符串相等所需的版本数测量序列之间的距离。该算法在每次执行插入、删除、替换和转置等操作时都进行惩罚。因此，我们使用其倒数来衡量生成的活动或角色序列与实际事件日志中观察到的序列之间的相似性。然后，较高的值意味着序列之间的相似性较高。</li><li>平均绝对误差（MAE）度量用于测量预测时间戳的误差。通过取观测值和预测值之间距离的绝对值，然后计算这些震级的平均值来计算该测量值。我们使用该度量来评估每对（生成轨迹、地面真值轨迹）的生成相对时间和观测时间之间的距离。</li></ol><blockquote><p>使用交叉验证，将事件日志分为两部分：70%用于培训，30%用于验证。第一个折叠被用作训练2000个模型的输入（每个事件日志大约220个模型）。<br>这平均220个模型配置了不同的预处理技术和体系结构。配置值是从972个组合的完整搜索空间中随机选择的。然后，使用每个经过培训的模型生成完整事件的新事件日志（参见第3节中描述的选择下一个活动的技术）。生成了每个配置的15个日志，并对其结果进行了平均。评估了32000多个生成的事件日志。</p></blockquote><h2 id="Results-and-Interpretation"><a href="#Results-and-Interpretation" class="headerlink" title="Results and Interpretation."></a>Results and Interpretation.</h2><p><img src="http://files.shanqianche.cn/2021811/1628689342024.png" alt="不同配置的事件日志中的相似性结果"></p><ul><li><font color="#A9A9A9">MAE列对应于预测记录道周期时间的平均绝对误差</font> </li></ul><p>结果表明，使用这种方法可以训练学习并可靠地再现原始日志的观察行为模式的模型。此外，研究结果表明，对于LSTM模型来说， <strong><font color="#A52A2A">学习词汇量较大</font></strong> 的序列比学习较长的序列更困难。要了解这些模式，需要更多的示例，如BPI2012和BPI2015的结果所示。这两个日志都有30多个活动，但在跟踪数量上有很大差异（见表2）。BPI2012的高度相似性还表明，使用嵌入维度处理大量事件类型可以改善结果，只要示例数量足以学习底层模式。</p><p>针对本实验中评估的模型结构构件，我们按照预处理、模型结构和超参数选择以及预测等阶段对其进行分析，以构建生成模型。</p><p><img src="http://files.shanqianche.cn/2021811/1628689921162.png" alt="Preprocessing phase components comparison"></p><p><strong><font color="#FF8C00">这里主要比较的是对于相对时间缩放方式，和进行缩放的作用。</font></strong></p><ol><li>a 说明了如何使用最大值作为缩放技术，具有很小时间变化的日志呈现更好的结果。相比之下，具有不规则结构的日志使用对数归一化具有较低的<font color="#0000FF"> MAE</font>【横坐标】。</li><li>b 展示了使用不同大小的 n-gram 时的 DL 相似性结果，与事件日志的结构有关。 我们可以观察到，使用更长的n-grams对于trace更长的日志有更好的结果，呈现出稳定的增长趋势。 相比之下，中、简单结构的事件日志趋势不明显。 因此，应将长 n-gram 的使用保留给具有很长跟踪的日志。**<font color="#006400">这里体现的是n-gram size对于预测结果的作用，只有复杂的日志呈现良好的正相关。</font>**</li></ol><p><img src="http://files.shanqianche.cn/2021811/1628690528922.png" alt="共享层的总体相似性"></p><p>关于模型结构定义阶段，图说明连接结构的总体相似度最低。相比之下，仅在分类属性之间共享信息的模型体系结构具有中等最佳性能。然而，它与专门的体系结构并不遥远，尽管它的分布范围更广。这意味着在不同性质的属性之间共享信息会在网络正在处理的模式中产生噪声，从而阻碍学习过程。</p><p><img src="http://files.shanqianche.cn/2021811/1628690699173.png" alt="下一个事件选择方法的比较"></p><p>关于预测阶段，图显示了随机选择在所有事件日志中如何优于arg max。这种行为在具有较长和复杂跟踪的事件日志中更为明显。结果表明，无论事件日志结构如何，随机选择都是评估学习过程的可取方法。</p><h2 id="Comparison-Against-Baselines"><a href="#Comparison-Against-Baselines" class="headerlink" title="Comparison Against Baselines"></a>Comparison Against Baselines</h2><h3 id="Experimental-setup-1"><a href="#Experimental-setup-1" class="headerlink" title="Experimental setup"></a>Experimental setup</h3><p><strong><font color="#FF00FF">目的：</font></strong><br>    评估我们的方法在预测下一个事件、剩余事件序列（即后缀）和剩余时间（对于不同长度的跟踪前缀）方面的相对性能。</p><ol><li>next event prediction — 为每个模型提供长度增加的跟踪前缀，从 1 到每个跟踪的长度。 对于每个前缀，我们预测下一个事件并测量准确性（正确预测的百分比）。</li><li> suffix and remaining time prediction — 为模型提供了长度增加的前缀，直到案件结束。</li></ol><p><strong><font color="#8A2BE2">baselines:</font></strong></p><ul><li>next event and suffix prediction</li></ul><ol><li> Predictive business process monitoring with LSTM neural networks</li><li> Predicting process behaviour using deep learning</li><li> A deep predictive model for multi-attribute event sequence</li></ol><ul><li>remaining time prediction</li></ul><ol><li>Predictive business process monitoring with LSTM neural networks【Helpdesk, BPI2012W and BPI2012 event logs】</li></ol><h3 id="Results-and-Interpretation-1"><a href="#Results-and-Interpretation-1" class="headerlink" title="Results and Interpretation"></a>Results and Interpretation</h3><p><img src="http://files.shanqianche.cn/2021811/1628691394455.png" alt="下一个事件和后缀预测结果"></p><p><strong>这些结果表明，分类属性的维度控制所采用的措施，使我们的方法即使在长序列中也能获得始终如一的良好性能。</strong></p><p><img src="http://files.shanqianche.cn/2021811/1628691420458.png" alt="剩余循环时间MAE的结果（以天为单位）"></p><p>图10显示了剩余循环时间预测的MAE。尽管我们的技术目标不是预测剩余时间，但与Tax等人相比，它在这项任务中实现了类似的性能——在一个日志中略逊于它，在另一个日志中略逊于它的长前缀。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><strong><font color="#FF8C00">优</font></strong></p><ol><li>评估表明，使用更长的n-gram可获得更高的精度</li><li>对数归一化是适用于高可变性测井的缩放方法，与总是选择最有可能的下一个事件相比，使用LSTM产生的概率随机选择下一个事件可导致更广泛的记录道和更高的精度。论文还表明，该方法在预测剩余事件序列及其从给定跟踪前缀开始的时间戳方面优于现有的基于LSTM的方法</li></ol><blockquote><p>作者预计，所提出的方法可以作为业务流程模拟的工具。实际上，从本质上讲，流程模拟器是一种通用模型，它生成由事件类型、资源和时间戳组成的跟踪集，并从中计算性能度量，如等待时间、循环时间和资源利用率。虽然流程模拟器依赖于可解释的流程模型（例如BPMN模型），但原则上可以使用能够生成事件跟踪的任何模型来模拟流程，其中每个事件都由事件类型（活动标签）、时间戳和资源组成。使用LSTM网络进行流程模拟的一个关键挑战是如何捕获“假设”场景（例如，删除任务或删除资源的效果）。</p></blockquote><p><strong><font color="#2F4F4F">future</font></strong><br>计划应用技术，使用”An eye into the future: Leveraging a-priori knowledge in predictive business process monitoring.”中的约束，从LSTM模型生成事件序列</p>]]></content>
    
    
    <summary type="html">Learning Accurate LSTM Models of Business Processes</summary>
    
    
    
    <category term="paper" scheme="https://merlynr.github.io/categories/paper/"/>
    
    
    <category term="paper" scheme="https://merlynr.github.io/tags/paper/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="process mining" scheme="https://merlynr.github.io/tags/process-mining/"/>
    
    <category term="deep learning" scheme="https://merlynr.github.io/tags/deep-learning/"/>
    
    <category term="LSTM" scheme="https://merlynr.github.io/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>Long Short Term Memory Networks</title>
    <link href="https://merlynr.github.io/2021/07/19/Long%20Short%20Term%20Memory%20Networks/"/>
    <id>https://merlynr.github.io/2021/07/19/Long%20Short%20Term%20Memory%20Networks/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-07-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe><p><a href="https://zhuanlan.zhihu.com/p/32085405">人人都能看懂的LSTM - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/37644325">RNN、LSTM、GRU基础原理篇 - 知乎</a><br><a href="https://blog.csdn.net/matrix_space/article/details/53374040">机器学习：深入理解 LSTM 网络 (一)_Matrix-11-CSDN博客_lstm 机器学习</a></p><blockquote><p>中文分词、词性标注、命名实体识别、机器翻译、语音识别都属于序列挖掘的范畴。<font color="#DC143C">序列挖掘</font>的特点就是某一步的输出不仅依赖于这一步的输入，还依赖于其他步的输入或输出。在序列挖掘领域传统的机器学习方法有HMM（Hidden Markov Model，隐马尔可夫模型）和CRF（Conditional Random Field，条件随机场），近年来流行深度学习算法RNN（Recurrent Neural Networks，循环神经网络）。</p></blockquote><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p><img src="http://files.shanqianche.cn/2021719/1626698381786.png" alt="RNN网络架构图"></p><p>比如一个句子中有5个词，要给这5个词标注词性，那相应的RNN就是个5层的神经网络，每一层的输入是一个词，每一层的输出是这个词的词性。<br><img src="http://files.shanqianche.cn/2021719/1626698589144.png" alt="讲解"></p><h1 id="RNN的变体"><a href="#RNN的变体" class="headerlink" title="RNN的变体"></a>RNN的变体</h1><h2 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h2><p>双向RNN认为otot不仅依赖于序列之前的元素，也跟tt之后的元素有关，这在序列挖掘中也是很常见的事实。</p><p><img src="http://files.shanqianche.cn/2021719/1626698749683.png" alt=" Bidirectional RNNs网络结构"></p><h2 id="深层双向RNN"><a href="#深层双向RNN" class="headerlink" title="深层双向RNN"></a>深层双向RNN</h2><p>在双向RNN的基础上，每一步由原来的一个隐藏层变成了多个隐藏层。</p><p><img src="http://files.shanqianche.cn/2021719/1626698820535.png" alt="Deep Bidirectional RNNs网络结构"></p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>前文提到，由于<font color="#9932CC"><strong>梯度消失/梯度爆炸</strong></font>的问题传统RNN在实际中很难处理长期依赖，而LSTM（Long Short Term Memory）则绕开了这些问题依然可以从语料中学习到长期依赖关系。</p><p><img src="http://files.shanqianche.cn/2021719/1626699453120.png" alt="传统RNN每一步的隐藏单元只是执行一个简单的tanh或ReLU操作"></p><p><img src="http://files.shanqianche.cn/2021719/1626699501199.png" alt=" LSTM每个循环的模块内又有4层结构:3个sigmoid层，1个tanh层"></p><p><strong><font color="#D2691E">解释LSTM模块：</font></strong></p><p><img src="http://files.shanqianche.cn/2021719/1626699615537.png" alt="图标说明"></p><ul><li>粉色的圆圈表示一个二目运算。</li><li>两个箭头汇合成一个箭头表示2个向量首尾相连拼接在一起。</li><li>一个箭头分叉成2个箭头表示一个数据被复制成2份，分发到不同的地方去。</li></ul><p> LSTM的关键是细胞状态C，一条水平线贯穿于图形的上方，这条线上只有些少量的线性操作，信息在上面流传很容易保持。</p><p><img src="http://files.shanqianche.cn/2021719/1626699717681.png" alt="忘记层"></p><ol><li>忘记层，决定细胞状态中<strong>丢弃什么信息</strong>。把ht−1和xt拼接起来，传给一个sigmoid函数，该函数输出0到1之间的值，这个值乘到细胞状态Ct−1上去。<font color="#FF8C00">sigmoid函数的输出值直接决定了状态信息保留多少</font>。比如当我们要预测下一个词是什么时，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。</li></ol><p><img src="http://files.shanqianche.cn/2021719/1626700419154.png" alt="更新细胞状态"><br>2. 上一步的细胞状态Ct−1已经被忘记了一部分，接下来本步应该把哪些信息新加到细胞状态中呢？这里又包含2层：一个tanh层用来产生更新值的候选项C~t，tanh的输出在[-1,1]上，<strong>说明细胞状态在某些维度上需要加强，在某些维度上需要减弱</strong>；还有一个sigmoid层（输入门层），它的输出值要乘到tanh层的输出上，起到一个<strong>缩放</strong>的作用，<em>极端情况下sigmoid输出0说明相应维度上的细胞状态不需要更新</em>。在那个预测下一个词的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。</p><p><img src="http://files.shanqianche.cn/2021719/1626700649763.png" alt="生成新的细胞状态"><br>3. 现在可以让旧的细胞状态Ct−1与ft（f是forget忘记门的意思）相乘来丢弃一部分信息，然后再加个需要更新的部分it∗C~t（i是input输入门的意思），这就生成了<strong>新的细胞状态Ct</strong></p><p><img src="http://files.shanqianche.cn/2021719/1626700735024.png" alt="循环模块的输出"><br>4. 最后该决定输出什么了。输出值跟细胞状态有关，把Ct输给一个tanh函数得到输出值的候选项。<strong>候选项中的哪些部分最终会被输出由一个sigmoid层来决定</strong>。在那个预测下一个词的例子中，如果细胞状态告诉我们当前代词是第三人称，那我们就可以预测下一词可能是一个第三人称的动词。</p><h1 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h1><p>GRU（Gated Recurrent Unit）是LSTM最流行的一个变体，比LSTM模型要简单。没有了存储单元</p><p><img src="http://files.shanqianche.cn/2021719/1626700963311.png" alt="GRU"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RNN 结构的一个吸引人之处在于其可以利用之前的输入信息。但是一个关键的需要解决的问题是当前的信息与之前的信息的关联度有长有短。<br>LSTM的内部结构。通过门控状态来控制传输状态，<strong>记住需要长时间记忆的，忘记不重要的信息</strong>；而不像普通的RNN那样只能够“呆萌”地仅有一种记忆叠加方式。对很多需要“长期记忆”的任务来说，尤其好用。、<br>但也因为引入了很多内容，导致参数变多，也使得训练难度加大了很多。因此很多时候我们往往会使用效果和LSTM相当但参数更少的GRU来构建大训练量的模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1842</summary>
      
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="process mining" scheme="https://merlynr.github.io/tags/process-mining/"/>
    
  </entry>
  
  <entry>
    <title>基于LSTM神经网络的业务过程预测监控</title>
    <link href="https://merlynr.github.io/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/"/>
    <id>https://merlynr.github.io/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-07-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=VAPwMDAm550&list=RDVAPwMDAm550&start_radio=1" title="我還年輕 我還年輕"><img src="https://res.cloudinary.com/marcomontalbano/image/upload/v1626681958/video_to_markdown/images/youtube--VAPwMDAm550-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="我還年輕 我還年輕"></a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文研究了长-短期记忆（LSTM）神经网络作为一种预测模型。并证明LSTMs在预测运行案例的下一个事件及其时间戳方面优于现有的技术。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作者提到他的目的是提出一个可以适用的框架。本文的研究点：</p><ol><li>LSTMs能否被用于广泛的流程预测，以及如何应用？</li><li>如何保障LSTM在不同数据中的准确度始终如一？</li></ol><p>在不同预测内容中，作者适用了4个日志数据集进行验证比较。</p><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><p>主要讲的是目前对于三种预测的技术，包括了，时间相关预测、事件结果的预测、正在执行事件的预测</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li>数据集A</li><li>数据集A中所有序列 $A^{*}$</li><li>一个长度为n的序列 σ =&lt;  $a_{1}$ ,  $a_{2}$ ,  $a_{3}$ , …… ,  $a_{n}$  &gt;,空序列为&lt;&gt;</li><li>$σ_ { 1 } \cdot σ _ { 2 }$ 表示序列 $σ_{1}$ 与 $σ_{2}$ 的串联</li><li> $h d ^ { k } ( o ) = ( a _ { 1 } , a _ { 2 } , \cdots , a _ { k } )$ 为<strong>前缀长度</strong>为k（0&lt;k&lt;n） 的序列 σ的<strong>前缀</strong>。 $t l ^ { k } ( o ) = ( a _ { k + 1 } \cdots , a _ { n } )$ 是它的后缀。</li></ul><p>对于前缀后缀的一个<strong>栗子</strong>：<br>序列： $σ _ { 1 } = ( a , b , c , d , e )$<br>前缀长度为二的前缀： $h d ^ { 2 } ( σ _ { 1 } ) = ( a , b )$<br>后缀为： $t l ^ { 2 } ( σ _ { 1 } ) = ( c , d , e )$</p><ul><li> $\varepsilon$ 【伊普西隆】为所有事件集合，T为时域。</li><li> $\pi _{ \tau }\in \varepsilon  \rightarrow T$ 为事件分配事件戳</li><li> $\pi _{ A }\in \varepsilon  \rightarrow A$ 从事件集A种为一个流程分配活动<h2 id="RNN和LSTM"><a href="#RNN和LSTM" class="headerlink" title="RNN和LSTM"></a>RNN和LSTM</h2></li></ul><p><a href="https://blog.zuishuailcq.xyz/2021/07/19/Long%20Short%20Term%20Memory%20Networks/">Long Short Term Memory Networks | 吾辈之人，自当自强不息！</a></p><h1 id="下一个活动和时间戳预测"><a href="#下一个活动和时间戳预测" class="headerlink" title="下一个活动和时间戳预测"></a>下一个活动和时间戳预测</h1><p>介绍评估多种体系结构预测下一个事件和时间戳。</p><p><img src="http://files.shanqianche.cn/2021728/1627442124718.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627442195597.png" alt="事件预测算法"></p><p>输入一个事件的前缀，然后预测下一个事件。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p><strong><font color="#D2691E">知识补充</font></strong><br>one hot编码是将类别变量转换为机器学习算法易于利用的一种形式的过程。<br>假设“花”的特征可能的取值为daffodil（水仙）、lily（百合）、rose（玫瑰）。one hot编码将其转换为三个特征：is_daffodil、is_lily、is_rose，这些特征都是二进制的。<br><a href="https://zhuanlan.zhihu.com/p/37471802">什么是one hot编码？为什么要使用one hot编码？ - 知乎</a></p></blockquote><ol><li>首先为LSTM构建特征向量矩阵，作为输入。</li></ol><p>事件e=σ（i）的时间特征指的是在trace中的上一个时间和当前时间之间的时间。转换函数：<br><img src="http://files.shanqianche.cn/2021720/1626745464036.png" alt="enter description here"></p><p>三种时间特征：fvt1表示事件的当前时间特征【与上一个时间的时间间隔】，同时也添加了包函一天时间的特征fvt2和包含一周的时间特征fvt3.这样当事件在工作日或者工作周结束的时候预测下一个活动的事件中时间间隔则会更长。</p><ul><li>LSTM可以通过fvt1学到不同节点的事件宇时间差的依赖关系。</li><li>fvt2，fvt3的加入，是为处理有些有些事件超出了工作日的特殊情况，因为传统的日志处理中只记录工作日中的。</li></ul><ol start="2"><li>对时间步长k【第k个事件的时间】的输出 $o _ { a } ^ { k }$ 进行one-hot编码。</li></ol><p><font color="#6495ED">异常情况</font></p><ul><li>当在时间k为事件的结尾，既没有新的事件可以预测。 </li></ul><p><font color="#B22222"> <strong>解决</strong></font></p><ul><li>当在时间k结束时,给输出的one-hot编码向量增加额外标记值1 </li></ul><ol start="3"><li><p>设置第二个输出值 $o_{t}^{k}$ 为下一个时间间隔的 $fv_{t1}$ 值。当知道当前时间戳，就可以计算到下一个事件的时间戳。</p></li><li><p>使用Adam算法【梯度下降算法】进行神经网络权重优化</p></li></ol><p><strong><font color="#FF1493">如何优化：</font></strong></p><ul><li>最小化基础事件one-hot编码和被预测的下一个事件的one-hot编码的<font color="#0000FF">交叉熵</font>。</li><li>最小化事件和预测事件之间时间的<font color="#FF1493">平均误差</font>（MAE）</li></ul><h2 id="模型的构建"><a href="#模型的构建" class="headerlink" title="模型的构建"></a>模型的构建</h2><p><img src="http://files.shanqianche.cn/2021727/1627371341818.png" alt="单任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371437071.png" alt="共享多任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371484245.png" alt="n层共享，m层单任务混合神经网络结构"></p><ol><li>使用相同的数据特征，分别单独训练两个模型，一个是预测下一步事件，另一个是预测下一个时间戳，如图a</li><li>多任务学习可以在同一个神经网络结构学习到多个模型，例如图b，同一个LSTM神经网络结构学习输出两个模型。</li><li>混合模型</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用的循环神经网络依赖库Keras构建项目</li><li>硬件是NVidia Tesla k80 GPU，每次epoch时间为15-90s。其中预测时间时间戳是以毫秒为单位的。</li></ul><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><h3 id="评定标准"><a href="#评定标准" class="headerlink" title="评定标准"></a>评定标准</h3><p>本文使用的<font color="#FF8C00">MAE</font>（平均绝对误差）来作为实验结果比较的参考。在实验效果评价这块，作者通过修改 van der Aalst提出的论文中用于预测剩余时间的模型来作为baseline。</p><h3 id="实验准备-1"><a href="#实验准备-1" class="headerlink" title="实验准备"></a>实验准备</h3><p>使用两个数据集进行预测下一个活动和时间戳。其中2/3的数据用于训练模型，1/3的用于预测。</p><p><i class="fas fa-tags" ></i>这里数据中长度为2的序列进行 $2 \leq k \lt | o |$ 预测，长度小于2则不对其预测。</p><p><strong><font color="#00008B">数据集</font></strong></p><ol><li>帮助中心数据集</li></ol><p>来自于意大利软件公司的票务管理系统，主要包括9中事件，一种事务流程。其中流程总共有3804条，事件有13710个。<br>2. BPI12子数据集W</p><p>此事件日志源自Business Process Intelligence Challenge（BPI’12）2，包含来自大型金融机构金融产品应用程序的数据。此流程由三个子流程组成：一个子流程跟踪应用程序的状态，一个子流程跟踪与应用程序关联的工作项的状态，第三个子流程跟踪报价的状态。在预测未来事件及其时间戳的上下文中，我们对自动执行的事件不感兴趣。因此，我们将评估范围缩小到工作项子流程，<font color="#FF8C00">其中包含手动执行的事件</font>。此外，我们过滤日志以<strong>仅保留complete类型的事件</strong>。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p><img src="http://files.shanqianche.cn/2021727/1627377231055.png" alt="result，前缀为all表示所有前缀的平均值"><br>N表示神经元。MAE为当前配置不同前缀长度的性能。</p><p>表1显示了help desk和BPI’12w子流程日志上各种LSTM体系结构在MAE预测时间和预测下一事件准确性方面的性能。由于BPI12中的流程长度较长，所以前缀较长。</p><p>TODO 前缀不是很懂<br><font color="#7FFF00">分析：</font></p><ol><li>ALL LSTM体系结构在所有前缀上都优于baseline，同时分别比较LSTM模型和baseline模型，可以发现 <strong><font color="#FF00FF">短前缀的增益要比长前缀要好。</font></strong></li><li>数据集helpdesk的预测准确度最好为71%；BPI’12 W数据集预测的最佳精度为76%，高于Breuker等人报告的71.9%的精度和Evermann等人报告的62.3%的精度。</li><li>预测精度最高的模型都为混合模型，尝试将每层的神经元数量减少到75个，对于只有一个共享层的架构，将其增加到150个，但发现这会导致两个任务的性能下降。可能有75个神经元导致模型欠拟合，而150个神经元导致模型过拟合。我们还在单层架构上对传统RNN进行了实验，发现它们在时间和活动预测方面都比LSTM差得多。</li></ol><h1 id="后缀预测"><a href="#后缀预测" class="headerlink" title="后缀预测"></a>后缀预测</h1><blockquote><p><strong><font color="#ff7500">本章理解</font></strong><br>区别于上一节，上一章是单个时间步长预测下一步，而本章是预测一个运行案例的整个延续。</p></blockquote><p><img src="http://files.shanqianche.cn/2021728/1627454393652.png" alt="事件预测"></p><p><img src="http://files.shanqianche.cn/2021728/1627454420942.png" alt="时间预测"></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过迭代地预测下一个事件和时间戳，然后再次进行预测直至这个案例结束。这里用 $\perp$ 表示案例结尾。</p><p><strong><font color="#006400">迭代预测：</font></strong></p><p><img src="http://files.shanqianche.cn/2021728/1627455885003.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627456583245.png" alt="时间预测算法"></p><p><font color="#FF1493">当当前事件为END，则不进行预测；否则将预测的结果输入到预测模块迭代预测。</font></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>对于预测准确度的评价这里采用的是通过计算预测结果与实际结果的编辑距离来衡量。</p><blockquote><p>知识补充：<font color="#2e4e7e">Levenshtein distance</font><br><a href="https://www.cnblogs.com/ivanyb/archive/2011/11/25/2263356.html">字符串相似度算法（编辑距离算法 Levenshtein Distance） - ZYB - 博客园</a></p></blockquote><p><strong>问题：</strong><br>  当处理并发任务的时候，Levenshtein distance并不适用于计算。例如&lt;a,b&gt;为预测的下一个事件，但实际上为&lt;b,a&gt;，这种情况只是因为ab并发顺序导致的，<font color="#DC143C">实际上并无相关</font>。但是Levenshtein distance结果为2,因为将预测序列转换为实际序列需要一次删除和一次插入操作。</p><p><strong>解决</strong><br>Damerau-Levenstein距离是一种更好地反映预测质量的评估度量，它为Levenshtein距离使用的操作集添加了交换操作。Damerau-Levenshtein距离将分配1的转换成本⟨a、 b⟩ 进入⟨b、 a⟩. 为了获得可变长度记录道的可比较结果，我们通过实际案例后缀长度和预测后缀长度的最大值对Damerau-Levenshtein距离进行归一化，归一化的Damerau-Levenshtein距离减1以获得Damerau-Levenshtein相似性（DLS）。</p><p><strong>模型</strong><br>采用的是双层架构，每层100个神经元的LSTM。</p><p><strong>数据集</strong><br>这是荷兰某市政当局环境许可程序的日志每宗个案涉及一份许可证申请。<br>该日志包含937个案例和381种事件类型的38944个事件。几乎每一种情况都遵循一个独特的路径，这使得后缀预测更具挑战性。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://files.shanqianche.cn/2021728/1627479266512.png" alt="基于Damerau-Levenshtein相似性的后缀预测结果"><br>Polato为baseline，no duplicates表示去掉案例中的重复事件，但是保留一个【案例结尾即使为重复事件也不去掉】。</p><p>观察可以发现所有数据集中的LSTM预测结果都要好于baseline。在BPI12数据集种很多案例中的事件会重复的出现，这就会导致预测的后缀长于真实案例，因此删除了BPI12中重复的事件并重新进行评估。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>利用LSTM神经网络预测运行案例的下一个活动及其时间戳的技术。表明，这种技术在现实数据集上优于现有的基线。此外，我们发现通过单一模型（多任务学习）预测下一个活动及其时间戳比使用单独的模型进行预测具有更高的准确性。</li><li>提出了一个运行种的案例整个延续的预测和预测剩余的周期时间的解决方案。</li><li>发现了LSTM模型的局限性，**<font color="#9932CC">即在一个案例种某些事件多次重复出现时，导致后缀过长，性能就会很低</font>**。</li></ol>]]></content>
    
    
    <summary type="html">Predictive Business Process Monitoring with LSTM Neural Networks</summary>
    
    
    
    <category term="paper" scheme="https://merlynr.github.io/categories/paper/"/>
    
    
    <category term="paper" scheme="https://merlynr.github.io/tags/paper/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="deep learning" scheme="https://merlynr.github.io/tags/deep-learning/"/>
    
  </entry>
  
</feed>
