<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾辈之人，自当自强不息！</title>
  
  <subtitle>博客</subtitle>
  <link href="https://merlynr.github.io/atom.xml" rel="self"/>
  
  <link href="https://merlynr.github.io/"/>
  <updated>2022-12-11T14:52:42.620Z</updated>
  <id>https://merlynr.github.io/</id>
  
  <author>
    <name>Merlynr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简历梳理</title>
    <link href="https://merlynr.github.io/2022/12/11/%E7%AE%80%E5%8E%86%E6%A2%B3%E7%90%86/"/>
    <id>https://merlynr.github.io/2022/12/11/%E7%AE%80%E5%8E%86%E6%A2%B3%E7%90%86/</id>
    <published>2022-12-11T14:52:42.620Z</published>
    <updated>2022-12-11T14:52:42.620Z</updated>
    
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="work,graduate student" scheme="https://merlynr.github.io/tags/work-graduate-student/"/>
    
  </entry>
  
  <entry>
    <title>周报</title>
    <link href="https://merlynr.github.io/2022/11/28/%E5%91%A8%E6%8A%A5/"/>
    <id>https://merlynr.github.io/2022/11/28/%E5%91%A8%E6%8A%A5/</id>
    <published>2022-11-28T01:01:00.000Z</published>
    <updated>2022-11-28T01:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>freeRTOS系统学习<br><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </li></ol><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input disabled="" type="checkbox"> 掌握task</li><li><input disabled="" type="checkbox"> 掌握list </li><li><input disabled="" type="checkbox"> 掌握queue</li></ul><ol start="2"><li>论文阅读<h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3></li><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h2 id="论文知识点理解"><a href="#论文知识点理解" class="headerlink" title="论文知识点理解"></a>论文知识点理解</h2><p><img src="http://files.shanqianche.cn/2021531/1622426214147.png" alt="数据蛋糕"></p><p>假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。</p><p>之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。</p><blockquote><p><font color="#8B008B">满足的条件</font></p><ul><li>数据本身不可再分割</li><li>二叉树达到限定的最大深度</li></ul></blockquote><p>直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间里了。</p><p><font color="#6495ED">异常检测原理的理解：</font>由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>孤立森林算法主要针对的是<strong>连续型结构化</strong>数据中的异常点。</p><p><font color="#FF1493">理论前提</font></p><ul><li>异常数据占总样本量的比例很小</li><li>异常点的特征值与正常点的差异很大</li></ul><p><img src="http://files.shanqianche.cn/2021531/1622426925434.png" alt="数据"></p><p>上图中，中心的白色空心点为正常点，即处于高密度群体中。四周的黑色实心点为异常点，散落在高密度区域以外的空间。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>孤立森林算法是基于 <strong>Ensemble</strong> 的异常检测方法，因此具有<font color="#7FFF00">线性的时间复杂度</font>。且精准度较高，在处理大数据时速度快，所以目前在工业界的应用范围比较广。常见的场景包括：网络安全中的攻击检测、金融交易欺诈检测、疾病侦测、噪声数据过滤（数据清洗）等。</p><blockquote><p><font color="#006400">知识补充</font>集成学习算法 (Ensemble Learning)<br>统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器<font color="#8FBC8F">组合</font>，从而实现一个预测效果更好的<font color="#8A2BE2">集成分类器</font>。</p></blockquote><blockquote><p><font color="#FF00FF">知识补充：</font><br><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">算法的性能指标 | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="孤立森林的创新点"><a href="#孤立森林的创新点" class="headerlink" title="孤立森林的创新点"></a>孤立森林的创新点</h2><ol><li><font color="#D2691E">Partial models</font>：在训练过程中，每棵孤立树都是随机选取部分样本</li><li><font color="#D2691E">No distance or density measures</font>：不同于 KMeans、DBSCAN 等算法，孤立森林不需要计算有关距离、密度的指标，可大幅度提升速度，减小系统开销</li><li><font color="#D2691E"> Linear time complexity</font>：因为基于 ensemble，所以有线性时间复杂度。通常树的数量越多，算法越稳定</li><li><font color="#D2691E">Handle extremely large data size</font>：由于每棵树都是独立生成的，因此可部署在大规模分布式系统上来加速运算</li></ol>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student" scheme="https://merlynr.github.io/tags/study-graduate-student/"/>
    
  </entry>
  
  <entry>
    <title>Linux移植入门</title>
    <link href="https://merlynr.github.io/2022/11/17/Linux%E7%A7%BB%E6%A4%8D%E5%85%A5%E9%97%A8/"/>
    <id>https://merlynr.github.io/2022/11/17/Linux%E7%A7%BB%E6%A4%8D%E5%85%A5%E9%97%A8/</id>
    <published>2022-11-17T00:58:00.000Z</published>
    <updated>2022-11-17T00:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="典型分区结构"><a href="#典型分区结构" class="headerlink" title="典型分区结构"></a>典型分区结构</h1><blockquote><p>bootloader、kernel、rootfs、data fs</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1668690135821.png" alt="典型分区结构"></p><h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul><li>初始化硬件：</li><li>将操作系统内核从Flash:拷贝到SDRAM中；</li><li>改写系统的内存映射，原先Flash起始地址映射为O地址，这时需要将RAM的起始地址映射为0;</li><li>设置堆栈指针并将bss段清零，执行C语言程序和调用子函数时要用到：</li><li>提供Linux内核的启动参数；</li><li>启动Linux内核；</li><li>改变pc值，使得CPU开始执行真正的操作系统内核。</li></ul><h1 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h1><h2 id="功能及本质"><a href="#功能及本质" class="headerlink" title="功能及本质"></a>功能及本质</h2><blockquote><p>功能：进程管理、文件系统、内存管理、设备管理、网络协议</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1668690644352.png" alt="功能"><br>内存管理：裸板上是物理地址，基于Linux系统则是虚拟地址<br>进程管理：宏观并行、微观串行<br>文件系统：虚拟文件系统。emc</p><p><strong>内核本质：</strong><br>从C语言角度来看内核，C语言函数集合；<br>从硬件角度来看内核，管理者和维护者；<br>从应用程序的角度来看内核，服务提供者；</p><h1 id="data-fs-嵌入式文件系统"><a href="#data-fs-嵌入式文件系统" class="headerlink" title="data fs 嵌入式文件系统"></a>data fs 嵌入式文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>是一种对存储设备上的数据进行<font color="#FF8C00">组织和控制</font>的机制。</li><li>是操作系统的一部分，负责管理和存储文件信息。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668691081644.png" alt="data fs"></p><h1 id="三者之间关系"><a href="#三者之间关系" class="headerlink" title="三者之间关系"></a>三者之间关系</h1><p><strong>Bootloader</strong></p><ul><li>硬件上电后跳到一个固定位置执行相应的代码</li><li>初始化相应的硬件设备</li><li>加载操作系统内核代码到内存</li><li>跳到内核代码起始位置执行</li></ul><p><strong>Kernel</strong></p><ul><li>内核自解压(ulmage)</li><li>初始化相应的硬件设备</li><li>初始化静态编译进内核的驱动模块I</li><li>挂载根文件系统</li><li>直接执行第一个用户空间程序</li></ul><p><strong>第一个用户空间程序</strong></p><ul><li>配置用户环境和执行服务进程</li></ul>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,linux" scheme="https://merlynr.github.io/tags/study-graduate-student-linux/"/>
    
  </entry>
  
  <entry>
    <title>天天PLAN</title>
    <link href="https://merlynr.github.io/2022/11/14/%E5%A4%A9%E5%A4%A9PLAN/"/>
    <id>https://merlynr.github.io/2022/11/14/%E5%A4%A9%E5%A4%A9PLAN/</id>
    <published>2022-11-14T01:11:00.000Z</published>
    <updated>2022-11-14T01:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1114"><a href="#1114" class="headerlink" title="1114"></a>1114</h1><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 08:50~09:40 上午任务一 <strong><font color="#e680ff">STM32第十五节</font></strong></li><li><input checked="" disabled="" type="checkbox"> 09:45~10:10 上午任务二 <strong><font color="#6fd9ea">STM32第十五节done</font></strong></li><li><input checked="" disabled="" type="checkbox"> 10:20~10:50 上午任务三 <strong><font color="#ff7500">STM32第十六节done</font></strong></li><li><input checked="" disabled="" type="checkbox"> 10:50~11:20 总结与反思</li></ul><hr><ul><li><input checked="" disabled="" type="checkbox"> 14:00~15:00 下午任务一   <a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></li><li><input checked="" disabled="" type="checkbox"> 15:00~16:00 下午任务二 <strong><font color="#01274F"><a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></font></strong></li><li><input checked="" disabled="" type="checkbox"> 16:00~16:40 下午任务三 <strong><font color="#2e4e7e"><a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 晚上任务一 <strong><font color="#8B008B">任务</font></strong></li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上任务二 <strong><font color="#2c201f">任务</font></strong></li><li><input checked="" disabled="" type="checkbox"> 21:30~22:10 晚上任务三 <strong><font color="#7FFF00">任务</font></strong></li><li><input checked="" disabled="" type="checkbox"> 22:10~22:30 晚上学习总结与查漏补缺</li></ul><h1 id="1115"><a href="#1115" class="headerlink" title="1115"></a>1115</h1><h1 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 14:00~15:00 下午任务一 <strong><font color="#49e979">STM32</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 下午任务二 <strong><font color="#01274F">任务</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 下午任务三 <strong><font color="#2e4e7e">任务</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 晚上任务一 <strong><font color="#8B008B">任务</font></strong></li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上任务二 <strong><font color="#2c201f">任务</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上任务三 <strong><font color="#7FFF00">任务</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结与查漏补缺</li></ul>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student" scheme="https://merlynr.github.io/tags/study-graduate-student/"/>
    
  </entry>
  
  <entry>
    <title>C/C++基础（二）</title>
    <link href="https://merlynr.github.io/2022/11/14/C/C++%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://merlynr.github.io/2022/11/14/C/C++%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-11-13T20:31:00.000Z</published>
    <updated>2022-11-13T20:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h1><h2 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h2><h3 id="堆栈空间分配不同"><a href="#堆栈空间分配不同" class="headerlink" title="堆栈空间分配不同"></a>堆栈空间分配不同</h3><p>栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</p><h3 id="堆栈缓存方式不同"><a href="#堆栈缓存方式不同" class="headerlink" title="堆栈缓存方式不同"></a>堆栈缓存方式不同</h3><p>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</p><h3 id="堆栈数据结构不同"><a href="#堆栈数据结构不同" class="headerlink" title="堆栈数据结构不同"></a>堆栈数据结构不同</h3><p><font color="#FF00FF">堆类似数组结构</font>；栈类似栈结构，先进后出。</p><h2 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h2><h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><blockquote><p>在C++中，内存分成5个区，他们分别是<font color="#FF00FF">堆、栈、自由存储区、全局/静态存储区和常量存储区</font>。</p></blockquote><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>就是那些由new分配的内存块，一般一个new就要对应一个delete</p><h4 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h4><p><font color="#FF8C00">就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命</font>。</p><h4 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h4><p>全局变量和静态变量被分配到同一块内存中</p><h4 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h4><p>这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p><h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>（1）内存<font color="#FF8C00">分配未成功</font>，却使用了它。<br>（2）内存分配虽然成功，但是尚<font color="#FF8C00">未初始化</font>就引用它。<br>（3）内存分配成功并且已经初始化，但操作<font color="#FF8C00">越过了内存的边界</font>。<br>（4）忘记了释放内存，造成<font color="#FF8C00">内存泄露</font>。<br>（5）<font color="#FF8C00">释放了内存却继续使用它</font>。</p><h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><p>（1）定义指针时，先初始化为NULL。<br>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。<br>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。<br>（4）避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作<br>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong><br>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”<br>（7）使用智能指针。</p><h2 id="内存泄露及解决办法"><a href="#内存泄露及解决办法" class="headerlink" title="内存泄露及解决办法"></a>内存泄露及解决办法</h2><h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；<font color="#FF8C00">（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</font></p><h3 id="怎么检测？"><a href="#怎么检测？" class="headerlink" title="怎么检测？"></a>怎么检测？</h3><p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。<br>第二：<font color="#FF8C00">将分配的内存的指针以链表的形式自行管理</font>，使用完毕之后从链表中删除，程序结束时可检查改链表。<br>第三：使用智能指针。<br>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p><h2 id="malloc和局部变量分配在堆还是栈"><a href="#malloc和局部变量分配在堆还是栈" class="headerlink" title="malloc和局部变量分配在堆还是栈"></a>malloc和局部变量分配在堆还是栈</h2><p><font color="#FF8C00">malloc是在堆上分配内存，需要程序员自己回收内存</font>；<font color="#DEB887">局部变量是在栈中分配内存，超过作用域就自动回收</font>。</p><h2 id="程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？"><a href="#程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？" class="headerlink" title="程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？"></a>程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</h2><p><img src="https://files.shanqianche.cn/202211/1668432991745.png" alt="程序结构图"><br><strong>一个程序有哪些section：</strong></p><blockquote><p>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等组成。</p></blockquote><ol><li><strong>数据段：</strong> 存放程序中已初始化的全局变量和静态变量的一块内存区域。</li><li><strong>代码段</strong>：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</li><li><strong>BSS</strong>：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li><li>可执行程序在运行时又会多出两个区域：<strong>堆区和栈区。</strong><ul><li>堆区：动态申请内存用。堆从低地址向高地址增长。</li><li>栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</li></ul></li><li>最后还有一个共享区，位于堆和栈之间。</li></ol><p><strong><font color="#FF00FF">程序启动的过程</font>：</strong></p><ol><li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。</li><li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。</li><li>加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数</li><li>初始化应用程序的全局变量，对于全局对象自动调用构造函数。</li><li>进入应用程序入口点函数开始执行。</li></ol><p><strong>怎么判断数据分配在栈上还是堆上</strong>：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上</p><h2 id="初始化为0的全局变量在bss还是data"><a href="#初始化为0的全局变量在bss还是data" class="headerlink" title="初始化为0的全局变量在bss还是data"></a>初始化为0的全局变量在bss还是data</h2><p>BSS段通常是指用来<font color="#FF8C00">存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</font>。特点是可读写的，在程序执行之前BSS段会自动清0。</p><h2 id="什么是内存泄露，内存泄露怎么检测？"><a href="#什么是内存泄露，内存泄露怎么检测？" class="headerlink" title="什么是内存泄露，内存泄露怎么检测？"></a>什么是内存泄露，内存泄露怎么检测？</h2><blockquote><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p></blockquote><h2 id="请简述一下atomoic内存顺序"><a href="#请简述一下atomoic内存顺序" class="headerlink" title="请简述一下atomoic内存顺序"></a>请简述一下atomoic内存顺序</h2><p><strong>有六个内存顺序选项可应用于对原子类型的操作：</strong></p><ol><li>memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。</li><li>memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。</li><li>memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。</li><li>memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。</li><li>memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。</li><li>memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个”获取释放”内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。</li></ol><p><strong>除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。</strong></p><h2 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h2><blockquote><p><font color="#FF8C00">内存对齐</font>应用于三种数据类型中：struct/class/union</p></blockquote><p><strong>struct/class/union内存对齐原则有四个：</strong></p><ol><li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li><li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li><li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。</li><li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li></ol><h3 id="什么是内存对齐？"><a href="#什么是内存对齐？" class="headerlink" title="什么是内存对齐？"></a>什么是内存对齐？</h3><p>在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**<font color="#FF8C00">编译器为结构体的每个成员按其自然边界（alignment）分配空间</font>**。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p><p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。<font color="#FF8C00">如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐</font>。</p><p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><h3 id="为什么要字节对齐？"><a href="#为什么要字节对齐？" class="headerlink" title="为什么要字节对齐？"></a>为什么要字节对齐？</h3><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p><p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><h3 id="字节对齐实例"><a href="#字节对齐实例" class="headerlink" title="字节对齐实例"></a>字节对齐实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">example</span> &#123;</span>    <span class="keyword">int</span> a[<span class="number">5</span>];    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;   &#125;; </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(example);   <span class="comment">/* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>    <span class="keyword">int</span> a[<span class="number">5</span>];    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;   &#125;test_struct; <span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);   <span class="comment">/* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;    <span class="keyword">int</span> a;   &#125;test_struct;   <span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);   <span class="comment">/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */</span></span><br></pre></td></tr></table></figure><h1 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h1><h2 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h2><blockquote><p>面向对象的三大特征是封装、继承、多态。</p></blockquote><ol><li><p>封装</p><p> 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。 </p></li><li><p><font color="#FF8C00">继承</font></p><p> 可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p></li></ol><table><thead><tr><th>继承方式</th><th>private继承</th><th>protected继承</th><th>public继承</th></tr></thead><tbody><tr><td>基类的private成员</td><td>不可见</td><td>不可见</td><td>不可见</td></tr><tr><td>基类的protected成员</td><td>变为private成员</td><td>仍为protected成员</td><td>仍为protected成员</td></tr><tr><td>基类的public成员</td><td>变为private成员</td><td>变为protected成员</td><td>仍为public成员仍为public成员</td></tr><tr><td>3. 多态</td><td></td><td></td><td></td></tr></tbody></table><pre><code>&lt;font color=&quot;#FF00FF&quot;&gt;用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。&lt;/font&gt;实现多态，有二种方式，重写，重载。</code></pre><h2 id="简述一下-C-的重载和重写，以及它们的区别"><a href="#简述一下-C-的重载和重写，以及它们的区别" class="headerlink" title="简述一下 C++ 的重载和重写，以及它们的区别"></a>简述一下 C++ 的重载和重写，以及它们的区别</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><pre><code>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&quot;</span>;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>:  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">a-&gt;<span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><pre><code>我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</code></pre><h2 id="说说-C-的重载和重写是如何实现的"><a href="#说说-C-的重载和重写是如何实现的" class="headerlink" title="说说 C++ 的重载和重写是如何实现的"></a>说说 C++ 的重载和重写是如何实现的</h2><h3 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h3><blockquote><p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在<font color="#FF00FF">编译阶段</font>完成的。 </p></blockquote><p><strong>C++定义同名重载函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">float</span> b)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/202211/1668527548093.png" alt="由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数"></p><h3 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h3><blockquote><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，<font color="#FF8C00">运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</font></p></blockquote><ol><li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。 </li><li>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</li><li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。 </li><li>重写用虚函数来实现，结合动态绑定。</li><li>纯虚函数是虚函数再加上 = 0。</li><li>抽象类是指包括至少一个纯虚函数的类。</li><li>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</li></ol><h2 id="说说-C-语言如何实现-C-语言中的重载"><a href="#说说-C-语言如何实现-C-语言中的重载" class="headerlink" title="说说 C 语言如何实现 C++ 语言中的重载"></a>说说 C 语言如何实现 C++ 语言中的重载</h2><blockquote><p><font color="#FF00FF">c语言中不允许有同名函数，因为编译时函数命名是一样的</font>，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：</p></blockquote><ol><li>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</li><li>重载函数使用可变参数，方式如打开文件open函数</li><li>gcc有内置函数，程序使用编译函数可以实现函数重载.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_int</span><span class="params">(<span class="keyword">void</span> * a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%dn&quot;</span>,*(<span class="keyword">int</span>*)a);  <span class="comment">//输出int类型，注意 void * 转化为int </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_double</span><span class="params">(<span class="keyword">void</span> * b)</span> </span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2fn&quot;</span>,*(<span class="keyword">double</span>*)b);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ptr)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;  <span class="comment">//typedef申明一个函数指针   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">(ptr p,<span class="keyword">void</span> *param)</span> </span>&#123;     </span><br><span class="line">      p(param);                <span class="comment">//调用对应函数 </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">23</span>;     </span><br><span class="line">      <span class="keyword">double</span> b = <span class="number">23.23</span>;    </span><br><span class="line">      c_func(func_int,&amp;a);   </span><br><span class="line">      c_func(func_double,&amp;b);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说构造函数有几种，分别什么作用"><a href="#说说构造函数有几种，分别什么作用" class="headerlink" title="说说构造函数有几种，分别什么作用"></a>说说构造函数有几种，分别什么作用</h2><p><strong>strong text</strong></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,C/C++" scheme="https://merlynr.github.io/tags/study-graduate-student-C-C/"/>
    
  </entry>
  
  <entry>
    <title>C/C++基础（一）</title>
    <link href="https://merlynr.github.io/2022/11/14/C%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://merlynr.github.io/2022/11/14/C%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-13T18:30:00.000Z</published>
    <updated>2022-11-13T18:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="C语言和C-的区别"><a href="#C语言和C-的区别" class="headerlink" title="C语言和C++的区别"></a>C语言和C++的区别</h2><ol><li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。</li><li>C++是面对对象的编程语言；C语言是面对过程的编程语言。</li><li>C语言有一些不安全的语言特性，如指<font color="#FF00FF">针使用的潜在危险、强制转换的不确定性、内存泄露</font>等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；</li><li>C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。</li></ol><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++中 struct 和 class 的区别"></a>C++中 struct 和 class 的区别</h2><ol><li>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</li><li>struct 中默认的访问控制权限是 <font color="#FF00FF">public </font>的，而 class 中默认的访问控制权限是<font color="#FF00FF"> private</font> 的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>  <span class="keyword">int</span> iNum; <span class="comment">// 默认访问控制权限是 public &#125; class B&#123;  int iNum; // 默认访问控制权限是 private &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在继承关系中，<font color="#FF8C00">struct 默认是公有继承，而 class 是私有继承</font>；</li><li>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  int Func(const T&amp; t, const Y&amp; y) &#123;      //TODO  &#125;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><font color="#FF8C00">C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下</font>：</li></ol><table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>成员函数</td><td>不能有</td><td>可以</td></tr><tr><td>静态成员</td><td>不能有</td><td>可以</td></tr><tr><td>访问控制</td><td>默认public，不能修改</td><td>public/private/protected</td></tr><tr><td>继承关系</td><td>不可以继承</td><td>可从类或者其他结构体继承</td></tr><tr><td>初始化</td><td>不能直接初始化数据成员</td><td>可以</td></tr><tr><td>6. 使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：</td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>  <span class="keyword">int</span>  iAgeNum;  string strName; &#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Student2</span>;</span> <span class="comment">//C中取别名  struct Student stu1; // C 中正常使用 Student2 stu2;   // C 中通过取别名的使用 Student stu3;   // C++ 中使用</span></span><br></pre></td></tr></table></figure><h2 id="说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><a href="#说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li><li>编译器预处理阶段查找头文件的路径不一样。</li></ol><h3 id="查找路径"><a href="#查找路径" class="headerlink" title="查找路径"></a>查找路径</h3><ol><li>使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</li><li>使用双引号””的头文件的查找路径：<font color="#FF8C00">当前头文件目录</font>–&gt;编译器设置的头文件路径–&gt;系统变量。</li></ol><h2 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h2><ol><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。</li></ol><h2 id="导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>导入C函数的关键字是什么，C++编译时和C有什么不同？</h2><ol><li>关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。<font color="#FF8C00">加上extern “C”后，会指示编译器这部分代码按C语言的进行编译</font>，而不是C++的。</li><li>编译区别：<font color="#FF8C00">由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名</font>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，<font color="#FF8C00">一般只包括函数名。</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 extern &quot;C&quot; int strcmp(const char *s1, const char *s2);  </span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数 extern &quot;C&quot;&#123;     #include &lt;string.h&gt;//string.h里边包含了要调用的C函数的声明 &#125;  //两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure><h2 id="简述C-从代码到可执行二进制文件的过程"><a href="#简述C-从代码到可执行二进制文件的过程" class="headerlink" title="简述C++从代码到可执行二进制文件的过程"></a>简述C++从代码到可执行二进制文件的过程</h2><blockquote><p>C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接。</p></blockquote><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>（1） 将所有的#define删除，并且展开所有的宏定义<br>（2） 处理所有的条件预编译指令，如#if、#ifndef<br>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。<br>（4） 过滤所有的注释<br>（5） 添加行号和文件名标识。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。<br>（2） 语法分析：对记号进行语法分析，产生语法树。<br>（3） 语义分析：判断表达式是否有意义。<br>（4） 代码优化：<br>（5） 目标代码生成：生成汇编代码。<br>（6） 目标代码优化：</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>这个过程主要是将汇编代码转变成机器可以执行的指令。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p><h4 id="链接分为静态链接和动态链接。"><a href="#链接分为静态链接和动态链接。" class="headerlink" title="链接分为静态链接和动态链接。"></a>链接分为静态链接和动态链接。</h4><ol><li><p>静态链接，是在链接的时候就已经把要调用的函数或者过程<font color="#FF00FF">链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行</font>；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p></li><li><p>动态链接，是在链接的时候没有把调用的函数代码链接进去，<font color="#FF00FF">而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行</font>。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></li></ol><h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><ol><li>定义全局静态变量和局部静态变量：在变量前面加上static关键字。<font color="#FF8C00">初始化的静态变量会在数据段分配内存</font>，<font color="#FF8C00">未初始化的静态变量会在BSS段分配内存</font>。直到程序结束，静态变量始终会维持当前值。只不过全局静态变量和局部静态变量的作用域不一样</li><li>定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数。<font color="#FF8C00">静态函数只能在本源文件中使用</font>；</li><li>在变量类型前加上static关键字，变量即被定义为静态变量。<font color="#FF8C00">静态变量只能在本源文件中使用；</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例 static int a; static void func();</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在c++中，static关键字可以用于定义类中的静态成员变量：<font color="#FF8C00">使用静态数据成员</font>，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。<font color="#FF8C00">类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。</font></li><li>在c++中，<font color="#FF8C00">static关键字可以用于定义类中的静态成员函数</font>：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在<font color="#FF8C00">函数前加上关键字static即可</font>。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。</li><li><font color="#FF00FF">当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</font></li></ol><h2 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 </li><li>指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。 指针名指向了内存的首地址。 </li></ol><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，<font color="#FF8C00">数组的存储空间，不是在静态区就是在栈上</font>。<br>指针：指针很灵活，它可以指向任意类型的数据。<font color="#FF8C00">指针的类型说明了它所指向地址空间的内存</font>。由于指针本身就是一个变<font color="#FF00FF">指针的存储空间不能确定。<br></font>量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p><h4 id="求sizeof"><a href="#求sizeof" class="headerlink" title="求sizeof"></a>求sizeof</h4><ol><li>数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）</li><li>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 int a[5] = &#123; 0 &#125;; char b[] = &quot;Hello&quot;; </span></span><br><span class="line"><span class="comment">// 按字符串初始化，大小为6 char c[] = &#123; &#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27; &#125;; </span></span><br><span class="line"><span class="comment">// 按字符初始化 int* arr = new int[10]; // 动态创建一维数组  // 指针 </span></span><br><span class="line"><span class="comment">// 指向对象的指针 int* p = new int(0); delete p; </span></span><br><span class="line"><span class="comment">// 指向数组的指针 int* p1 = new int[10]; delete[] p1; </span></span><br><span class="line"><span class="comment">// 指向类的指针： string* p2 = new string; delete p2; </span></span><br><span class="line"><span class="comment">// 指向指针的指针（二级指针） int** pp = &amp;p; **pp = 10;</span></span><br></pre></td></tr></table></figure><h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><ol><li><font color="#FF8C00">数组名的指针操作</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];   </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组 p = a;    </span></span><br><span class="line"><span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0] p++;          </span></span><br><span class="line"><span class="comment">//该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]               </span></span><br><span class="line"><span class="comment">//所以数组指针也称指向一维数组的指针，亦称行指针。 </span></span><br><span class="line"><span class="comment">//访问数组中第i行j列的一个元素，有几种操作方式： </span></span><br><span class="line"><span class="comment">//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。 //这几种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指针变量的数据操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;hello,douya!&quot;</span>;</span><br><span class="line">str[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">*(str+<span class="number">2</span>) = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">//这两种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure><h2 id="说说什么是函数指针，如何定义函数指针，有什么使用场景"><a href="#说说什么是函数指针，如何定义函数指针，有什么使用场景" class="headerlink" title="说说什么是函数指针，如何定义函数指针，有什么使用场景"></a>说说什么是函数指针，如何定义函数指针，有什么使用场景</h2><ol><li>概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li><li>定义形式如下</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*f)(<span class="keyword">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure><ol start="3"><li>函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；然后如果别人的库里面调用我们的函数，就叫Callback。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">          )</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a , <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="keyword">int</span>* a = (<span class="keyword">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure><h2 id="说说静态变量什么时候初始化"><a href="#说说静态变量什么时候初始化" class="headerlink" title="说说静态变量什么时候初始化"></a>说说静态变量什么时候初始化</h2><blockquote><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于<font color="#FF00FF">编译期初始化</font>。而C++标准规定：<font color="#FF00FF">全局或静态对象当且仅当对象首次用到时才进行构造</font>。</p></blockquote><ol><li>作用域：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。<pre><code> - 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。 - &lt;font color=&quot;#FF8C00&quot;&gt;静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。&lt;/font&gt; - 类静态成员变量：类作用域。</code></pre></li><li>所在空间：都在静态存储区。<font color="#FF8C00">因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</font></li><li>生命周期：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。</li></ol><h2 id="nullptr调用成员函数可以吗？为什么？"><a href="#nullptr调用成员函数可以吗？为什么？" class="headerlink" title="nullptr调用成员函数可以吗？为什么？"></a>nullptr调用成员函数可以吗？为什么？</h2><p>能。原因：<font color="#FF8C00">因为在编译时对象就绑定了函数地址，和指针空不空没关系。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span><span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；<font color="#FF00FF">调用breath(*this), this就等于pAn</font>。<font color="#228B22">由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。</font></p><h2 id="说说什么是野指针，怎么产生的，如何避免？"><a href="#说说什么是野指针，怎么产生的，如何避免？" class="headerlink" title="说说什么是野指针，怎么产生的，如何避免？"></a>说说什么是<a href="https://www.cnblogs.com/idorax/p/6475941.html">野指针</a>，怎么产生的，如何避免？</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>野指针是指针没有初始化，悬空指针是指针指向的内存已被释放。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><font color="#FF8C00">释放内存后指针不及时置空（野指针），依然指向了该内存</font>，那么可能出现非法访问的错误。这些我们都要注意避免。</p><h3 id="避免办法"><a href="#避免办法" class="headerlink" title="避免办法"></a><font color="#FF8C00">避免办法</font></h3><p>（1）初始化置NULL<br>（2）申请内存后判空<br>（3）指针释放后置NULL<br>（4）使用智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生原因</span></span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>避免办法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//避免方法</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure><h2 id="说说静态局部变量，全局变量，局部变量的特点，以及使用场景"><a href="#说说静态局部变量，全局变量，局部变量的特点，以及使用场景" class="headerlink" title="说说静态局部变量，全局变量，局部变量的特点，以及使用场景"></a>说说静态局部变量，全局变量，局部变量的特点，以及使用场景</h2><h3 id="首先从作用域考虑"><a href="#首先从作用域考虑" class="headerlink" title="首先从作用域考虑"></a>首先从作用域考虑</h3><blockquote><p>C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p></blockquote><p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。<br>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。<br>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。<br><font color="#FF8C00">静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</font></p><h3 id="从所在空间考虑"><a href="#从所在空间考虑" class="headerlink" title="从所在空间考虑"></a>从所在空间考虑</h3><p><font color="#FF00FF">除了局部变量在栈上外</font>，其他都在静态存储区。因为静态变量都在静态存储区，<font color="#FF00FF">所以下次调用函数的时候还是能取到原来的值。</font></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>从它们各自特点就可以看出各自的应用场景，不再赘述。</p><h2 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h2><h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><ol><li><font color="#FF8C00">宏定义不是函数</font>，但是使用起来像函数。<font color="#FF00FF">预处理器用复制宏代码的方式代替函数的调用</font>，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，<font color="#FF8C00">不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</font></li><li>宏函数是<font color="#FF00FF">在预编译的时候把所有的宏名用宏体来替</font>换，简单的说就是字符串替换 ；而<font color="#FF8C00">内联函数则是在编译的时候进行代码插入</font>，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li>宏定义是<font color="#FF00FF">没有类型检查的</font>，无论对还是错都是直接替换；而<font color="#FF00FF">内联函数在编译的时候会进行类型的检查</font>，内联函数满足函数的性质，比如有返回值、参数列表等</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="built_in">MAX</span>(a, <span class="string">&quot;Hello&quot;</span>); <span class="comment">//错误地比较int和字符串，没有参数类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span></span><br></pre></td></tr></table></figure><h3 id="使用时的一些注意事项"><a href="#使用时的一些注意事项" class="headerlink" title="使用时的一些注意事项"></a>使用时的一些注意事项</h3><ol><li>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</li><li>inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。</li><li>同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明<font color="#FF8C00">，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</font></li></ol><h3 id="内联函数使用的条件"><a href="#内联函数使用的条件" class="headerlink" title="内联函数使用的条件"></a>内联函数使用的条件</h3><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：<br>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><p><em>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联</em></p><h2 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i ++ 和 ++ i的区别"></a>说说运算符i ++ 和 ++ i的区别</h2><ol><li>赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</li><li><font color="#FF00FF">效率不同</font>：后置++执行速度比前置的慢。</li><li>i++ 不能作为左值，而++i 可以：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// int* p2 = &amp;(i++);//错误</span></span><br><span class="line">++i = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// i++ = 1;//错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li>两者都不是原子操作。</li></ol><h2 id="说说new和malloc的区别，各自底层实现原理"><a href="#说说new和malloc的区别，各自底层实现原理" class="headerlink" title="说说new和malloc的区别，各自底层实现原理"></a><font color="#FF8C00">说说new和malloc的区别，各自底层实现原理</font></h2><h3 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h3><ol><li>new是操作符，而malloc是函数。</li><li><font color="#FF00FF">new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数</font>；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li><font color="#FF00FF">new发生错误抛出异常，malloc返回null</font></li></ol><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>malloc底层实现</strong>：<font color="#FF00FF">当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</font></p><p><strong>new底层实现</strong>：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p><ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><h2 id="说说const和define的区别"><a href="#说说const和define的区别" class="headerlink" title="说说const和define的区别"></a>说说const和define的区别</h2><p>const用于定义常量；<font color="#FF8C00">而define用于定义宏，而宏也可以用于定义常量</font>。都用于常量定义时，它们的区别有：</p><ol><li><font color="#FF8C00">const生效于编译的阶段；define生效于预处理阶段。</font></li><li><font color="#FF8C00">const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</font></li><li>const定义的常量是带类型的；define定义的常量不带类型。因此<font color="#FF00FF">define定义的常量不利于类型检查。</font></li></ol><h2 id="说说C-中函数指针和指针函数的区别"><a href="#说说C-中函数指针和指针函数的区别" class="headerlink" title="说说C++中函数指针和指针函数的区别"></a>说说C++中函数指针和指针函数的区别</h2><p><strong>定义不同</strong> 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。<br><strong>写法不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针函数：<span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">函数指针：<span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure><p><strong>用法不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针函数示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;Data;</span><br><span class="line"><span class="comment">//指针函数</span></span><br><span class="line"><span class="function">Data* <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    Data * data = <span class="keyword">new</span> Data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用指针函数</span></span><br><span class="line">    Data * myData = <span class="built_in">f</span>(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">fun = add;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//(*fun)(1,2) =  3</span></span><br></pre></td></tr></table></figure><h2 id="说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么，有什么特点。"><a href="#说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么，有什么特点。" class="headerlink" title="说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。"></a>说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h2><ol><li>const int a;     //指的是a是一个常量，不允许修改。</li><li>const int <em>a;    //a指针所指向的内存里的值不变，即（</em>a）不变</li><li>int const *a;    //同const int *a;</li><li>int *const a;    //a指针所指向的内存地址不变，即a不变</li><li><font color="#FF00FF">const int <em>const a;   //都不变，即（</em>a）不变，a也不变</font></li></ol><h2 id="说说使用指针需要注意什么"><a href="#说说使用指针需要注意什么" class="headerlink" title="说说使用指针需要注意什么"></a>说说使用指针需要注意什么</h2><ol><li>定义指针时，先初始化为NULL。</li><li>用malloc或new申请内存之后，应该立即检查指针值是否为NULL。<font color="#FF00FF">防止使用指针值为NULL的内存</font>。</li><li><font color="#FF8C00">不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用</font>。</li><li>避免数字或指针的<font color="#FF00FF">下标越界</font>，特别要当心发生“多1”或者“少1”操作</li><li>动态内存的申请与释放必须配对，防止内存泄漏</li><li>用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure><h2 id="说说内联函数和函数的区别，内联函数的作用"><a href="#说说内联函数和函数的区别，内联函数的作用" class="headerlink" title="说说内联函数和函数的区别，内联函数的作用"></a>说说内联函数和函数的区别，内联函数的作用</h2><h3 id="区别-4"><a href="#区别-4" class="headerlink" title="区别"></a>区别</h3><ol><li>内联函数比普通函数多了关键字inline</li><li>内联函数避免了函数<font color="#FF00FF">调用的开销</font>；普通函数有调用的开销</li><li>普通函数在被调用的时候，需要<font color="#FF00FF">寻址（函数入口地址）</font>；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。</li><li>内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</li></ol><h3 id="内联函数使用的注意事项"><a href="#内联函数使用的注意事项" class="headerlink" title="内联函数使用的注意事项"></a>内联函数使用的注意事项</h3><ol><li>在内联函数内<font color="#FF8C00">不允许用循环语句和开关语句</font>。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</li><li><font color="#FF00FF">内联函数的定义必须出现在内联函数第一次被调用之前</font>。</li></ol><h2 id="简述C-有几种传值方式，之间的区别是什么"><a href="#简述C-有几种传值方式，之间的区别是什么" class="headerlink" title="简述C++有几种传值方式，之间的区别是什么"></a>简述C++有几种传值方式，之间的区别是什么</h2><blockquote><p>传参方式有这三种：<strong>值传递、引用传递、指针传递</strong></p></blockquote><ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</li></ol><p><strong>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</strong></p><h2 id="简述const（星号）和（星号）const的区别"><a href="#简述const（星号）和（星号）const的区别" class="headerlink" title="简述const（星号）和（星号）const的区别"></a>简述const（星号）和（星号）const的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;    <span class="comment">//a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;    <span class="comment">//a指针所指向的内存地址不变，即a不变</span></span><br></pre></td></tr></table></figure><p>对于引用：<br>(1)只有一个const，如果const位于&amp;左侧，int const &amp;x /const int &amp;x表示引用所指数据是常量，不能通过引用来修改该数据；底层const。<br>(2)只有一个const，如果const位于&amp;右侧，int &amp; const x，由于int &amp; ref = a，在C++内部会将其转化为int* const ref = &amp;a，已经不变了，再加一个也没啥用吧= =（个人理解）</p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,C/C++" scheme="https://merlynr.github.io/tags/study-graduate-student-C-C/"/>
    
  </entry>
  
  <entry>
    <title>STM32F108的学习</title>
    <link href="https://merlynr.github.io/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://merlynr.github.io/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-11T02:12:00.000Z</published>
    <updated>2022-11-11T02:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="f270768e-6a79-4d1d-8fd8-694008c8a311">天天PLAN</a></p><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><h3 id="LED的注意事项"><a href="#LED的注意事项" class="headerlink" title="LED的注意事项"></a>LED的注意事项</h3><ol><li>需要连接电阻，不然可能击穿LED。</li><li><strong>一般LED所需电流为0~10+的毫安【不要超过20mA】，芯片所提供电压为3.3 or 5v，所以接一个1kΩ电阻【限流电阻】即可。</strong></li><li><a href="https://blog.csdn.net/a419116194/article/details/103238872">高电平、低电平</a>。低电平时电路的阻抗低，噪声造成的电平变化小，也就是说，抗干扰能力更强</li></ol><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><h3 id="GPIO的注意事项"><a href="#GPIO的注意事项" class="headerlink" title="GPIO的注意事项"></a>GPIO的注意事项</h3><ol><li>除了GPIO的为通用<del>， 其余皆为复用</del></li></ol><p><img src="./images/1668134920148.png" alt="端口配置"><br>2. <strong>GPIO大部分使用推挽输出，ⅡC使用的开漏输出。</strong><br>3. 地址=基址+偏移地址<br>4. 端口配置寄存器【输入输出配置（模拟、浮空、上拉下拉、保留）（通用推挽、通用开漏、复用推挽、复用开漏），输入输出模式以及频率】–&gt;端口输出数据寄存器（配置端口地址为1的是输出端口）</p><h2 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h2><ol><li>AHB 高速总线、APB普通外设总结、</li><li><strong>通过APB为GPIO提供RCC时钟源，才可以使外设与CPU连接。</strong></li></ol><p><img src="./images/1668182227309.png" alt="使能GPIO"></p><ol start="3"><li>volatile 避免从缓冲区取值，只能从寄存器中取值。</li></ol><h2 id="第七节"><a href="#第七节" class="headerlink" title="第七节"></a>第七节</h2><ol><li>使用结构体可以定义连续的的相关配置，因为结构体中遍历在内存中是连续的。</li><li>使用STM32官方库需要引入相关文件。</li></ol><p><img src="./images/1668181982839.png" alt="依赖文件"></p><p><img src="./images/1668182057720.png" alt="依赖文件"></p><p><img src="./images/1668182110452.png" alt="库文件"></p><h2 id="第八节-按键控制"><a href="#第八节-按键控制" class="headerlink" title="第八节 按键控制"></a>第八节 按键控制</h2><p><img src="./images/1668242764890.png" alt="低电平输入"></p><ol><li>利用按键进行控制led时，可以利用内部的上拉电位，以此输入高电平，按键后输入低电平，以此控制LED</li></ol><h2 id="第九节呼吸灯"><a href="#第九节呼吸灯" class="headerlink" title="第九节呼吸灯"></a>第九节呼吸灯</h2><ol><li>有两种方式，一种是通过修改平均电平，第二种是通过修改PWM</li></ol><p><img src="./images/1668321362358.png" alt="修改电平，变亮就是增加高电平所占时间"></p><h2 id="第十一节NVIC"><a href="#第十一节NVIC" class="headerlink" title="第十一节NVIC"></a>第十一节NVIC</h2><p><img src="https://files.shanqianche.cn/202211/1668324442560.png" alt="抢占优先级和响应优先级"></p><ol><li>从优先级（响应优先级）,在抢占优先级相同时谁的高谁优先。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668325634113.png" alt="外部中断模式"><br>2. 事件请求：当前事件完成后跳转到中断向量表。中断请求：立刻跳转到中断向量表。</p><p><img src="https://files.shanqianche.cn/202211/1668326173434.png" alt="功能复用"><br>3. 需要考虑到pin复用。时钟和中断。</p><p><img src="https://files.shanqianche.cn/202211/1668326286702.png" alt="外部中断初始化"><br>4. 外部中断EXTI0的配置包括：向量化中断控制器的配置、PA0配置为外部中断、中断工作模式（下降沿检测）</p><h2 id="第十三节SysTick-最后一个异常"><a href="#第十三节SysTick-最后一个异常" class="headerlink" title="第十三节SysTick 最后一个异常"></a>第十三节SysTick 最后一个异常</h2><ol><li>SysTick是系统内部计时器，CorTex-M3内包含。其是一个24位的计时器，基本模式是从一个reload 值递减，为0时触发异常，然后重新计数。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668328540665.png" alt="SysTick CTRL"></p><ol start="2"><li>多久减一可以通过CLKSOURCE来设置，AHB为告诉外部时钟，为72MHZ。频率=1/时钟，所以时钟越大，精度越高。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668329188316.png" alt="时钟为72MHZ，reload value为72，最后1微妙产生一次异常中断"><br>3. 产生一次异常时间的设置。</p><h2 id="第十四节"><a href="#第十四节" class="headerlink" title="第十四节"></a>第十四节</h2><p><img src="https://files.shanqianche.cn/202211/1668346317638.png" alt="时钟配置"></p><p><img src="https://files.shanqianche.cn/202211/1668346298839.png" alt="开启时钟，设置全局变量，使其在异常函数中进行递减"><br><img src="https://files.shanqianche.cn/202211/1668346363077.png" alt="SysTick异常函数"></p><ol><li>延时函数</li></ol><h2 id="第十五节"><a href="#第十五节" class="headerlink" title="第十五节"></a>第十五节</h2><ol><li>stm32 有两个看门狗，一个独立看门狗，一个窗口看门狗</li></ol><p><img src="https://files.shanqianche.cn/202211/1668348073923.png" alt="IWDG"><br><img src="https://files.shanqianche.cn/202211/1668348218257.png" alt="IWDG主要功能"><br>2. 独立看门狗（IWDG）依赖LSI（低速内部时钟），即使晶振，外部时钟不工作，IWDG依旧正常工作</p><p><img src="https://files.shanqianche.cn/202211/1668348022275.png" alt="依赖APB1的外设"><br><img src="https://files.shanqianche.cn/202211/1668348100750.png" alt="WWDG"></p><p><img src="https://files.shanqianche.cn/202211/1668348325069.png" alt="IWDG框图"></p><p><img src="https://files.shanqianche.cn/202211/1668348444032.png" alt="键寄存器"><br><img src="https://files.shanqianche.cn/202211/1668390061020.png" alt="reload value为625，pr预分频因子为4时，IWDG就会每隔一秒钟复位一次"><br>3. WWDG依赖APB1，所以APB1出问题，无法工作。</p><p><img src="https://files.shanqianche.cn/202211/1668390482984.png" alt="设置IWDG，第一步取消写保护，设置PR"></p><p><img src="https://files.shanqianche.cn/202211/1668390706177.png" alt="第一步"><br><img src="https://files.shanqianche.cn/202211/1668390795034.png" alt="第二步PR的设置"></p><p><img src="https://files.shanqianche.cn/202211/1668390820968.png" alt="第三步reload value"><br><img src="https://files.shanqianche.cn/202211/1668390977778.png" alt="第四步装入reload value"></p><p><img src="https://files.shanqianche.cn/202211/1668391016821.png" alt="第五步使能"></p><p><img src="https://files.shanqianche.cn/202211/1668391395544.png" alt="IWDG_initt code"><br>5. 4. IWDG的设置</p><h2 id="第16节课WWDG"><a href="#第16节课WWDG" class="headerlink" title="第16节课WWDG"></a>第16节课WWDG</h2><ol><li><strong>偶尔的两次异常，即正常状态到异常状态、接着异常状态又到正常状态，这属于异常，如果这两步操作在异常恢复时间内，即喂狗时间内，IWDG是无法检测到的。而WWDG可以解决。</strong></li></ol><p><img src="https://files.shanqianche.cn/202211/1668392219848.png" alt="特殊异常"><br>2. WWDG喂狗机制，当WWDG的递减计数器1T[6:0]大于上限窗口W[6:0]时1，如果尝试去喂狗，将立刻产生CPU复位。</p><p><img src="https://files.shanqianche.cn/202211/1668392718745.png" alt="只有在0x60-0x3F内喂狗才有效"><br><img src="https://files.shanqianche.cn/202211/1668393252329.png" alt="WWDG原理"></p><p><img src="https://files.shanqianche.cn/202211/1668393442189.png" alt="enter description here"></p><p><img src="https://files.shanqianche.cn/202211/1668393484988.png" alt="喂狗"></p><ol start="3"><li>WWDG配置code<pre><code>- 因为WWDG是与APB1连接的，所以需要从APB1相关函数使能WWDG- 初始化WWDG，配置计数，计数是有上限的，通过与最大值进行想与来限制。- 设置预分频值（PR）- 设置上窗口值- 使能并且喂狗</code></pre></li></ol><p><img src="https://files.shanqianche.cn/202211/1668495595263.png" alt="WWDG初始化配置"></p><p><img src="https://files.shanqianche.cn/202211/1668495613227.png" alt="中断向量表初始化"></p><p>必须进行喂狗，不然CPU会不断进行重启。<br><img src="https://files.shanqianche.cn/202211/1668495643575.png" alt="喂狗"></p><h2 id="第十七节USART"><a href="#第十七节USART" class="headerlink" title="第十七节USART"></a>第十七节USART</h2><ol><li>主要用于芯片与芯片之间的传输</li><li>芯片与PC之间的通信</li><li>芯片与外围模块之间的通信 </li></ol><p>UART 异步功能<br>USART 同步功能<br>USART_CK具有时钟功能<br>USART_CTS具有流控功能，因为不同设备之间频率不一样，接发速率也不一样，CTS可以控制是否接受或者发送数据【硬件流控】，可以用于判断是否进行发送数据<br>USART_RTS发送请求</p><h3 id="代码-amp-逻辑"><a href="#代码-amp-逻辑" class="headerlink" title="代码&amp;逻辑"></a>代码&amp;逻辑</h3><ol><li>开启对应总线的时钟，同时需要开启GPIO管脚的时钟</li></ol>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,STM32" scheme="https://merlynr.github.io/tags/study-graduate-student-STM32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32-8266 NodeMCU</title>
    <link href="https://merlynr.github.io/2022/11/09/ESP32-8266%20NodeMCU/"/>
    <id>https://merlynr.github.io/2022/11/09/ESP32-8266%20NodeMCU/</id>
    <published>2022-11-08T20:40:00.000Z</published>
    <updated>2022-11-08T20:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1L7411c7jw/?p=3&spm_id_from=pageDriver&vd_source=6dbca05574a96cc5925db86217ad31cc">太极创客</a></p><h1 id="互联网基础"><a href="#互联网基础" class="headerlink" title="互联网基础"></a>互联网基础</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p><img src="https://files.shanqianche.cn/202211/1667983767588.png" alt="OSI"></p><p><img src="https://files.shanqianche.cn/202211/1667983869801.png" alt="WiFi"></p><h2 id="物理链路层（联网的工作模式）"><a href="#物理链路层（联网的工作模式）" class="headerlink" title="物理链路层（联网的工作模式）"></a>物理链路层（联网的工作模式）</h2><h3 id="接入点模式Access-Point"><a href="#接入点模式Access-Point" class="headerlink" title="接入点模式Access Point"></a>接入点模式Access Point</h3><p><img src="https://files.shanqianche.cn/202211/1667983980074.png" alt="接入点模式，AP"></p><h3 id="无线终端模式Wireless-Station"><a href="#无线终端模式Wireless-Station" class="headerlink" title="无线终端模式Wireless Station"></a>无线终端模式Wireless Station</h3><p><img src="https://files.shanqianche.cn/202211/1667984100987.png" alt="无线终端"></p><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p><img src="https://files.shanqianche.cn/202211/1667984176398.png" alt="混合模式"></p><h2 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h2><p><img src="https://files.shanqianche.cn/202211/1667984483353.png" alt="IP协议"></p><p><img src="https://files.shanqianche.cn/202211/1667984514957.png" alt="子网掩码"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h1 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h1>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student,NodeMCU" scheme="https://merlynr.github.io/tags/study-graduate-student-NodeMCU/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32学习Free RTOS</title>
    <link href="https://merlynr.github.io/2022/11/01/%E5%9F%BA%E4%BA%8EESP32%E5%AD%A6%E4%B9%A0Free%20RTOS/"/>
    <id>https://merlynr.github.io/2022/11/01/%E5%9F%BA%E4%BA%8EESP32%E5%AD%A6%E4%B9%A0Free%20RTOS/</id>
    <published>2022-11-01T01:59:00.000Z</published>
    <updated>2022-11-01T01:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><p><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </p><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input disabled="" type="checkbox"> 掌握task</li><li><input disabled="" type="checkbox"> 掌握list </li><li><input disabled="" type="checkbox"> 掌握queue</li></ul><h1 id="GD32F450-移植FreeRTOS"><a href="#GD32F450-移植FreeRTOS" class="headerlink" title="GD32F450 移植FreeRTOS"></a>GD32F450 移植FreeRTOS</h1><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ol><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h4 id="vTaskSuspend-挂起-amp-vTaskResume-恢复"><a href="#vTaskSuspend-挂起-amp-vTaskResume-恢复" class="headerlink" title="vTaskSuspend 挂起 &amp; vTaskResume 恢复"></a>vTaskSuspend 挂起 &amp; vTaskResume 恢复</h4><p><img src="https://files.shanqianche.cn/202212/1670336283287.png" alt="task被挂起并恢复"></p><h4 id="vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有"><a href="#vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有" class="headerlink" title="vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有"></a>vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有</h4><p> 挂起所有task，同时执行完后不能调用FreeRTOS API函数。必须通过vTaskResumeAll（）进行恢复后才能继续直接FreeRTOS API。<strong>保证程序的独立运行</strong></p><p> <img src="https://files.shanqianche.cn/202212/1670336505558.png" alt="指的是系统被挂起后无法被调用"></p><h3 id="vTaskList-任务状态信息"><a href="#vTaskList-任务状态信息" class="headerlink" title="vTaskList() 任务状态信息"></a>vTaskList() 任务状态信息</h3><p> <img src="https://files.shanqianche.cn/202212/1670480943006.png" alt="vTaskList展示task信息"> </p><blockquote><p>运行状态<br>     X: 运行状态<br>    B:阻塞状态<br>    R:准备状态<br>    S:挂起状态<br>    D:删除状态</p></blockquote><h3 id="xTask堆栈"><a href="#xTask堆栈" class="headerlink" title="xTask堆栈"></a>xTask堆栈</h3><p><img src="https://files.shanqianche.cn/202212/1670506507182.png" alt="xTask堆栈的设置"><br><strong>usStackDepth的理解</strong>： 为堆栈的深度。即如果堆栈的宽度为4bytes，深度为100，则堆栈空间为100* 4bytes。</p><p><img src="https://files.shanqianche.cn/202212/1670507145359.png" alt="usStackDepth"></p><h4 id="uxTaskGetStackHighWaterMark-查询剩余堆栈内存"><a href="#uxTaskGetStackHighWaterMark-查询剩余堆栈内存" class="headerlink" title="uxTaskGetStackHighWaterMark() 查询剩余堆栈内存"></a>uxTaskGetStackHighWaterMark() 查询剩余堆栈内存</h4><p>调用vTaskList消耗内存较大，可以通过uxTaskGetStackHighWaterMark来获取内存信息。</p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study, graduate student" scheme="https://merlynr.github.io/tags/study-graduate-student/"/>
    
  </entry>
  
  <entry>
    <title>2022-10-10研究生的第一个十天计划</title>
    <link href="https://merlynr.github.io/2022/10/10/2022-10-10%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%A4%A9%E8%AE%A1%E5%88%92/"/>
    <id>https://merlynr.github.io/2022/10/10/2022-10-10%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%A4%A9%E8%AE%A1%E5%88%92/</id>
    <published>2022-10-10T00:02:00.000Z</published>
    <updated>2022-10-10T16:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="近十天安排"><a href="#近十天安排" class="headerlink" title="近十天安排"></a>近十天安排</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Yv411t7qe/?spm_id_from=333.337.search-card.all.click&vd_source=6dbca05574a96cc5925db86217ad31cc">结合B站邴哲松老师授课 </a><br>C+++Primer+Plus（第6版）</p></blockquote><ol><li>第一天，第一章</li><li>第二天，第四章</li><li>第三天，第五章</li><li>第四天，第六章</li><li>第五天，第七章</li><li>第六天，第八章</li><li>第七天，第九章</li><li>第八天，第十章</li><li>第九天，第十一章，视频没了，自己看书</li><li>第十天，复习一到十章</li></ol><h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><ol><li>第一天，看完主要的几个协议</li><li>第二天，点亮stm32f103c8t6</li><li>第三天，继续学习ARM<h2 id="PCB课程"><a href="#PCB课程" class="headerlink" title="PCB课程"></a>PCB课程</h2><blockquote><p>通过看视频方式学习</p></blockquote></li></ol><p>每天看五节课</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>每天一道算法题，当日任务少则做新类型的题，任务多则做简单题型。</p><h1 id="下一个十天"><a href="#下一个十天" class="headerlink" title="下一个十天"></a>下一个十天</h1><ol><li>模电重新学习</li><li>ARM</li><li>估计要准备中期，so</li></ol>]]></content>
    
    
    <summary type="html">最近十天安排</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="study,graduate student,plan" scheme="https://merlynr.github.io/tags/study-graduate-student-plan/"/>
    
  </entry>
  
  <entry>
    <title>2022-9-13研究生的倒数第245天</title>
    <link href="https://merlynr.github.io/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/"/>
    <id>https://merlynr.github.io/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2022-09-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">前端基础速通</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 上午学习总结        <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 breaking news【一三五】   <strong><font color="#D2691E">js进阶</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 刘畅【二四六】   <strong><font color="#D2691E">微信小程序</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">todo-2</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="graduate student time" scheme="https://merlynr.github.io/categories/graduate-student-time/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
    <category term="FE" scheme="https://merlynr.github.io/tags/FE/"/>
    
    <category term="deep learning" scheme="https://merlynr.github.io/tags/deep-learning/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中原始类型有趣的事</title>
    <link href="https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B-DESKTOP-861NK7E/"/>
    <id>https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B-DESKTOP-861NK7E/</id>
    <published>2022-08-23T16:00:00.000Z</published>
    <updated>2022-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数参数命名出现的问题"><a href="#函数参数命名出现的问题" class="headerlink" title="函数参数命名出现的问题"></a>函数参数命名出现的问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型</span><br><span class="line">let foo = 5;</span><br><span class="line"></span><br><span class="line">// 定义一个貌似可以改变基本类型值的函数</span><br><span class="line">function addTwo(num) &#123;</span><br><span class="line">    num += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 和前面的函数一样</span><br><span class="line">function addTwo_v2(foo) &#123;</span><br><span class="line">    foo += 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用第一个函数，并传入基本类型值作为参数</span><br><span class="line">addTwo(foo);</span><br><span class="line">// Getting the current Primitive value</span><br><span class="line">console.log(foo);   // 5</span><br><span class="line"></span><br><span class="line">// 尝试调用第二个函数...</span><br><span class="line">addTwo_v2(foo);</span><br><span class="line">console.log(foo);   // 5</span><br></pre></td></tr></table></figure><p><strong>你是否认为会得到7，而不是5？如果是，请看看代码是如何运行的：</strong></p><ul><li>addTwo和addTwo_v2函数调用时，JavaScript 会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句。</li><li>找到以后，JavaScript 将其作为参数传递给函数的形参。</li><li>在执行函数体内语句之前，JavaScript 会将传递进来的参数（基本类型的值）复制一份，<font color="#FF00FF">创建一个本地副本。</font>这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（addTwo中的num，addTwo_v2中的foo）。</li><li>接下来，函数体中的语句开始执行：<ul><li>第一个函数中，创建了本地num参数，num的值加 2，但这个值并不是原来的foo的值。</li><li>第二个函数中，创建了本地参数foo，并将它的值加 2，<font color="#FF00FF">这个值不是外部 foo 的值。在这种情况下，外部的foo变量不能以任何方式被访问到。这是因为 JavaScript 的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo。</font>欲知详情，请参阅闭包。</li></ul></li><li>综上所述，函数中的任何操作都不会影响到最初的foo，我们操作的只不过是它的副本。</li></ul>]]></content>
    
    
    <summary type="html">每天学习</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中原始类型有趣的事</title>
    <link href="https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/"/>
    <id>https://merlynr.github.io/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/</id>
    <published>2022-08-23T16:00:00.000Z</published>
    <updated>2022-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数参数命名出现的问题"><a href="#函数参数命名出现的问题" class="headerlink" title="函数参数命名出现的问题"></a>函数参数命名出现的问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型</span><br><span class="line">let foo = 5;</span><br><span class="line"></span><br><span class="line">// 定义一个貌似可以改变基本类型值的函数</span><br><span class="line">function addTwo(num) &#123;</span><br><span class="line">    num += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 和前面的函数一样</span><br><span class="line">function addTwo_v2(foo) &#123;</span><br><span class="line">    foo += 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用第一个函数，并传入基本类型值作为参数</span><br><span class="line">addTwo(foo);</span><br><span class="line">// Getting the current Primitive value</span><br><span class="line">console.log(foo);   // 5</span><br><span class="line"></span><br><span class="line">// 尝试调用第二个函数...</span><br><span class="line">addTwo_v2(foo);</span><br><span class="line">console.log(foo);   // 5</span><br></pre></td></tr></table></figure><p><strong>你是否认为会得到7，而不是5？如果是，请看看代码是如何运行的：</strong></p><ul><li>addTwo和addTwo_v2函数调用时，JavaScript 会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句。</li><li>找到以后，JavaScript 将其作为参数传递给函数的形参。</li><li>在执行函数体内语句之前，JavaScript 会将传递进来的参数（基本类型的值）复制一份，<font color="#FF00FF">创建一个本地副本。</font>这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（addTwo中的num，addTwo_v2中的foo）。</li><li>接下来，函数体中的语句开始执行：<ul><li>第一个函数中，创建了本地num参数，num的值加 2，但这个值并不是原来的foo的值。</li><li>第二个函数中，创建了本地参数foo，并将它的值加 2，<font color="#FF00FF">这个值不是外部 foo 的值。在这种情况下，外部的foo变量不能以任何方式被访问到。这是因为 JavaScript 的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo。</font>欲知详情，请参阅闭包。</li></ul></li><li>综上所述，函数中的任何操作都不会影响到最初的foo，我们操作的只不过是它的副本。</li></ul>]]></content>
    
    
    <summary type="html">每天学习</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>性能优化(第十五天)</title>
    <link href="https://merlynr.github.io/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端性能优化手段"><a href="#前端性能优化手段" class="headerlink" title="前端性能优化手段"></a>前端性能优化手段</h1><p>前端性能优化手段从以下几个方面入手：<strong>加载优化、执行优化、渲染优化、样式优化、脚本优化</strong></p><p><strong>加载优化:</strong> 减少HTTP请求、缓存资源、压缩代码、无阻塞、首屏加载、按需加载、预加载、压缩图像、减少Cookie、避免重定向、异步加载第三方资源</p><p><strong>执行优化：</strong> CSS写在头部，JS写在尾部并异步、避免img、iframe等的src为空、尽量避免重置图像大小、图像尽量避免使用DataURL</p><p><strong>渲染优化：</strong> 设置viewport、减少DOM节点、优化动画、优化高频事件、GPU加速</p><p><strong>样式优化：</strong> 避免在HTML中书写style、避免CSS表达式、移除CSS空规则、正确使用display：display、不滥用float等</p><p><strong>脚本优化：</strong> 减少重绘和回流、缓存DOM选择与计算、缓存.length的值、尽量使用事件代理、尽量使用id选择器、touch事件优化</p><h2 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h2><ol><li>减少HTTP请求：尽量减少页面的请求数(首次加载同时请求数不能超过4个)，移动设备浏览器同时响应请求为4个请求(Android支持4个，iOS5+支持6个)<ul><li>合并CSS和JS</li><li>使用CSS精灵图</li></ul></li><li>缓存资源：使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存，并且尽量使用长缓存(使用时间戳更新缓存)<ul><li>缓存一切可缓存的资源</li><li>使用长缓存</li><li>使用外联的样式和脚本</li></ul></li><li>压缩代码：减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置GZip<ul><li>压缩代码(多余的缩进、空格和换行符)</li><li>启用Gzip</li></ul></li><li>无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用link方式引入，脚本放在尾部并使用<font color="#FF8C00">异步方式加载</font></li><li>首屏加载：首屏快速显示可大大提升用户对页面速度的感知，应尽量针对首屏的快速显示做优化</li><li>按需加载：将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(按需加载会导致大量重绘，影响渲染性能)<ul><li>懒加载</li><li>滚屏加载</li><li>Media Query加载</li></ul></li><li>预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但加载时间过长，会造成用户流失</li></ol><ul><li>可感知Loading：进入页面时Loading</li><li>不可感知Loading：提前加载下一页</li></ul><ol start="8"><li>压缩图像：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中用srcset来按需显示(过度压缩图像大小影响图像显示效果)<ul><li>使用TinyJpg和TinyPng压缩图像</li><li>使用CSS3、SVG、IconFont代替图像</li><li>使用img的srcset按需加载图像</li><li>选择合适的图像：webp优于jpg，png8优于gif</li><li>选择合适的大小：首次加载不大于1014kb、不宽于640px</li><li>PS切图时D端图像保存质量为80，M端图像保存质量为60</li></ul></li><li>减少Cookie：Cookie会影响加载速度，静态资源域名不使用Cookie</li><li>避免重定向：重定向会影响加载速度，在服务器正确设置避免重定向</li><li>异步加载第三方资源：第三方资源不可控会影响页面的加载和显示，要异步加载第三方资源</li></ol><h2 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h2><ul><li><strong>CSS写在头部，JS写在尾部并异步</strong></li><li><font color="#FF00FF">避免img、iframe等的src为空：空src会重新加载当前页面，影响速度和效率</font></li><li><font color="#FF00FF">尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能</font></li><li><font color="#FF00FF">图像尽量避免使用DataURL</font>：DataURL图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长</li></ul><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><ul><li><strong>设置viewport：</strong> HTML的viewport可加速页面的渲染</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>减少DOM节点</strong>：DOM节点太多影响页面的渲染，尽量减少DOM节点</p></li><li><p><strong>优化动画</strong></p><ul><li>尽量使用CSS3动画</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>适当使用Canvas动画：5个元素以内使用CSS动画，5个元素以上使用Canvas动画，iOS8+可使用WebGL动画</li></ul></li><li><p><strong>优化高频事件</strong>：scroll、touchmove等事件可导致多次渲染</p><ul><li>函数节流</li><li>函数防抖</li><li>使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染</li><li>增加响应变化的时间间隔：减少重绘次数</li></ul></li><li><p><strong>GPU加速</strong>：使用某些HTML5标签和CSS3属性会触发GPU渲染，请合理使用(过渡使用会引发手机耗电量增加)</p><ul><li>HTML标签：video、canvas、webgl</li><li>CSS属性：opacity、transform、transition</li></ul></li></ul><h2 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a>样式优化</h2><ol><li>避免在HTML中书写style</li><li>避免CSS表达式：<font color="#FF00FF">CSS表达式的执行需跳出CSS树的渲染</font></li><li>移除CSS空规则：<font color="#FF00FF">CSS空规则增加了css文件的大小，影响CSS树的执行</font></li><li><font color="#FF00FF">正确使用display</font>：display会影响页面的渲染<ul><li>display:inline后不应该再使用float、margin、padding、width和height</li><li>display:inline-block后不应该再使用float</li><li>display:block后不应该再使用vertical-align</li><li>display:table-*后不应该再使用float和margin</li></ul></li><li>不滥用float：<font color="#FF8C00">float在渲染时计算量比较大，尽量减少使用</font></li><li>不滥用Web字体：Web字体需要下载、解析、重绘当前页面，尽量减少使用</li><li>不声明过多的font-size：过多的font-size影响CSS树的效率</li><li><font color="#FF00FF">值为0时不需要任何单位：为了浏览器的兼容性和性能，值为0时不要带单位</font></li><li>标准化各种浏览器前缀<ul><li>无前缀属性应放在最后</li><li>CSS动画属性<font color="#FF00FF">只用-webkit-、无前缀两种</font></li><li>其它前缀为-webkit-、-moz-、-ms-、无前缀四种：Opera改用blink内核，-o-已淘汰</li></ul></li><li>避免让选择符看起来像正则表达式：<font color="#FF00FF">高级选择符执行耗时长且不易读懂，避免使用</font></li></ol><h2 id="脚本优化-【TODO】"><a href="#脚本优化-【TODO】" class="headerlink" title="脚本优化 【TODO】"></a>脚本优化 【TODO】</h2><ol><li>减少重绘和回流<ul><li>避免不必要的DOM操作</li><li>避免使用document.write</li><li>减少drawImage</li><li>尽量改变class而不是style，使用classList代替className</li></ul></li><li>缓存DOM选择与计算：每次DOM选择都要计算和缓存</li><li>缓存.length的值：每次.length计算用一个变量保存值</li><li>尽量使用事件代理：避免批量绑定事件</li><li>尽量使用id选择器：<font color="#FF00FF">id选择器选择元素是最快</font>的</li><li>touch事件优化：使用tap(touchstart和touchend)代替click(注意touch响应过快，易引发误操作)</li></ol><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h3><p><img src="http://files.shanqianche.cn/20228/1660119419712.png" alt="雅虎军规"></p><p><img src="http://files.shanqianche.cn/20228/1660119467606.png" alt="雅虎军规"><br><img src="http://files.shanqianche.cn/20228/1660119493503.png" alt="雅虎军规"></p><h3 id="2-5-8原则"><a href="#2-5-8原则" class="headerlink" title="2-5-8原则"></a>2-5-8原则</h3><p>在前端开发中，此规则作为一种开发指导思路，针对浏览器页面的性能优化。</p><p>用户在2秒内得到响应，会感觉页面的响应速度很快 Fast<br>用户在2<del>5秒间得到响应，会感觉页面的响应速度还行 Medium<br>用户在5</del>8秒间得到响应，会感觉页面的响应速度很慢，但还可以接受 Slow<br>用户在8秒后仍然无法得到响应，会感觉页面的响应速度垃圾死了</p><h1 id="一个官网怎么优化，有哪些性能指标，如何量化"><a href="#一个官网怎么优化，有哪些性能指标，如何量化" class="headerlink" title="一个官网怎么优化，有哪些性能指标，如何量化"></a>一个官网怎么优化，有哪些性能指标，如何量化</h1><blockquote><p><font color="#FF8C00">对首屏加载速度影响最大的还是资源大小，请求数量，请求速度等。代码方面，前端一般很难写出严重影响速度的代码。减小资源大小，可以用各种压缩，懒加载，预加载，异步加载等方法。</font>减少请求数量可以使用雪碧图，搭建node中台将多个请求合并成一个等。<font color="#FF8C00">对于官网这种项目，最好使用服务端渲染</font>，<font color="#FF00FF">首屏快之外，也有利于SEO。</font></p></blockquote><h2 id="检测方案："><a href="#检测方案：" class="headerlink" title="检测方案："></a>检测方案：</h2><p>使用lighthouse进行性能检测，并对lighthouse提出的建议进行优化</p><h2 id="具体优化方案："><a href="#具体优化方案：" class="headerlink" title="具体优化方案："></a>具体优化方案：</h2><p>通过静态化、图片懒加载、图片压缩、异步加载（js和css）、优化代码等方式，以下是具体方法</p><h2 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h2><p><strong>服务端渲染，“直出”页面，具有较好的SEO和首屏加载速度。主要还有以下的优点：</strong></p><ul><li>使用jsp模板语法（百度后发现是用Velocity模板语法）渲染页面，减少了js文件体积</li><li>减少了请求数量</li><li>因为不用等待大量接口返回，加快了首屏时间</li></ul><p><strong>可以尝试Vue的服务端渲染。首页目前有部分是用接口读取数据，然后用jq进行渲染，性能上应该不如Virtual DOM，不过内容不多。</strong></p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p><font color="#FF8C00">这是一个很重要的优化项。</font>因为官网上有很多图片，而且编辑们上传文章图片的时候一般没有压缩，但是很多图片的体积都很大。还有一个轮播图，20张图标，最小的几十K，最大的两百多K。对于图片来源不可控的页面，懒加载是个很实用的操作，直接将首屏加载的资源大小减少了十几M。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>对于来源可控，小图标等图片可以用雪碧图，base64等方法进行优化。目前只是用工具压缩了图片大小，后续可以考虑在webpack打包的时候生成雪碧图。</p><h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p><font color="#FF8C00">通过标签引入的js文件，可以设置defer，async属性让其异步加载，而不会阻塞渲染。defer和async的区别在于async加载完就立即执行，没有考虑依赖，标签顺序等。而defer加载完后会等它前面引入的文件执行完再执行。<font color="#FF8C00">一般defer用的比较多，async只能用在那些跟别的文件没有联系的孤儿脚本上</font>。</font></p><h2 id="异步加载css"><a href="#异步加载css" class="headerlink" title="异步加载css"></a>异步加载css</h2><p>没想到css也能异步加载，但这是lighthouse给出的建议。找了一下发现有以下两种方法：<br>一是通过js脚本在文档中插入标签<br>二是通过<code>&#39;&#39;</code>的media属性<br><font color="#FF8C00">media属性是媒体查询用的，用于在不同情况下加载不同的css。这里是将其设置为一个不适配当前浏览器环境的值，甚至是不能识别的值，浏览器会认为这个样式文件优先级低，会在不阻塞的情况加载。加载完成后再将media`设置为正常值，让浏览器解析css。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//example.css&quot; media=&quot;none&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这里用的是第二种方法。但是webpack注入到html中的外链css还没找到异步加载的方法。</font></p><h2 id="preconnent"><a href="#preconnent" class="headerlink" title="preconnent"></a>preconnent</h2><p>lighthouse建议对于接下来会访问的地址可以<font color="#FF8C00">提前建立连接</font>。一般有一下几种方式。</p><ol><li>dns-prefetch域名预解析</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>preconnet预连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//example.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//cdn.example.com&quot; crossorigin&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>prefetch预加载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;//example.com/next-page.html&quot; as=&quot;html&quot; crossorigin=&quot;use-credentials&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;library.js&quot; as=&quot;script&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>prerender预渲染</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prerender&quot; href=&quot;//example.com/next-page.html&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这四种层层递进，但是不要连接不需要的资源，反而损耗性能</font>。我在页面上对某些资源用了preconnect，但并没有明显的效果。应该对于在线小说，在线漫画这种场景预加载会更适用。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><font color="#FF8C00">lighthouse上显示主线程耗时最多的是样式和布局，所以对这部分进行优化</font>。主要有一下几点：</p><ul><li>去掉页面上用于布局的table，table本身性能较低，且维护性差，是一种过时的布局方案。</li><li>在去掉table布局的同时减少一些无意义的DOM元素，减少DOM元素的数量和嵌套。</li><li>减少css选择器的嵌套。用sass，less这种css预处理器很容易造成多层嵌套。优化前代码里最多的有七八层嵌套，对性能有一定影响。重构后不超过三层。</li></ul><p><strong>通过上面的重构后，样式布局和渲染时间从lighthouse上看大概减少了300ms。但样式和布局的时间还是最长的，感觉还有优化空间。</strong></p><h3 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h3><p>接下来是js代码的优化和重构。因为移除Vue框架，以及用服务端端直出，现在js代码已经减少了大部分。主要有以下几部分：</p><ul><li><font color="#FF8C00">拆分函数，将功能复杂的函数拆分成小函数，让每个函数只做一件事。</font></li><li><font color="#FF8C00">优化分支结构，用对象Object，代替if…else和switch…case</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 优化前</span><br><span class="line">var getState = function (state) &#123;</span><br><span class="line">  switch (state) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      return &#x27;up&#x27;;</span><br><span class="line">    case 0:</span><br><span class="line">      return &#x27;stay&#x27;;</span><br><span class="line">    case 2:</span><br><span class="line">      return &#x27;down&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化后</span><br><span class="line">var getState = function(state) &#123;</span><br><span class="line">  var stateMap = &#123;</span><br><span class="line">    1: &#x27;up&#x27;, 0: &#x27;stay&#x27;, 2: &#x27;down&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  return stateMap[state]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化DOM操作"><a href="#优化DOM操作" class="headerlink" title="优化DOM操作"></a>优化DOM操作</h3><p>DOM操作如改变样式，改变内容可能会引起页面的重绘重排，是比较消耗性能的。网上也有很多优化jq操作的方法。<br>如<font color="#FF8C00">将查询到的DOM使用变量存起来，避免重复查询。以及将多次DOM操作变成一次等。</font>这里重点讲一下第二种。</p><ul><li>常见的需求是渲染一个列表，如果直接在for循环里面append到父元素中，性能是非常差的。幸好原来的操作是将所有DOM用字符串拼接起来，再用html()方法一次性添加到页面中。</li><li>还有另一种方法是使用文档碎片(fragment)。<font color="#FF8C00">通过document.createDocumentFragment()可以新建一个fragment。向fragment中appendChild元素的时候是不会阻塞渲染进程的</font>。最后将fragment替换掉页面上的元素。将fragment元素用appendChild的方法添加到页面上时，实际上添加上去的是它内部的元素，也就是它的子元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment()</span><br><span class="line">for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">  var str = &#x27;&lt;div&gt;&#x27; + i + &#x27;&lt;/div&gt;&#x27;</span><br><span class="line">  fragment.appendChild($(str)[0])</span><br><span class="line">&#125;</span><br><span class="line">$(&#x27;.container&#x27;).append(fragment)</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">经过测试，在当前的场景下，使用fragment的速度和html()是差不多的，都是10ms左右。区别在于最后将fragment添加到页面上$(‘.container’).append(fragment)这行代码仅仅花费1ms。也就是说，将fragment插入页面时不会引起页面重绘重排，不会引起阻塞。</font></p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p><strong>尾调用是指某个函数的最后一步是调用另一个函数。</strong></p><p>函数调用会在内存形成一个“<font color="#FF8C00">调用记录”，又称“调用帧”</font>，保存调用位置和内存变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，依次类推。所有的调用帧，就形成一个“<font color="#FF8C00">调用栈</font>”。</p><p><strong>尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</strong></p><p>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”。注意，<font color="#FF8C00">只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a) &#123;</span><br><span class="line">    var one = 1;</span><br><span class="line">    function inner(b) &#123;</span><br><span class="line">        return b + one;</span><br><span class="line">    &#125;</span><br><span class="line">    return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>浏览器相关内容(第十四天)</title>
    <link href="https://merlynr.github.io/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cookie-sessionStorage-localStorage-区别"><a href="#cookie-sessionStorage-localStorage-区别" class="headerlink" title="cookie sessionStorage localStorage 区别"></a>cookie sessionStorage localStorage 区别</h1><p><strong>共同点：</strong> 都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p></li><li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p></li><li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p></li><li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p></li><li><p>web Storage的api接口使用更方便</p></li></ol><h1 id="如何写一个会过期的localStorage，说说想法"><a href="#如何写一个会过期的localStorage，说说想法" class="headerlink" title="如何写一个会过期的localStorage，说说想法"></a>如何写一个会过期的localStorage，说说想法</h1><p><strong>两种方案：惰性删除 和 定时删除</strong></p><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><blockquote><p>惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    /**</span><br><span class="line">     * 增加一个键值对数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @param val 值</span><br><span class="line">     * @param expires 过期时间，单位为秒</span><br><span class="line">     */</span><br><span class="line">    self.set = function (key, val, expires) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        val = JSON.stringify(&#123;&#x27;val&#x27;: val, &#x27;expires&#x27;: new Date().getTime() + expires * 1000&#125;);</span><br><span class="line">        localStorage.setItem(key, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 读取对应键的值数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @returns &#123;null|*&#125; 对应键的值</span><br><span class="line">     */</span><br><span class="line">    self.get = function (key) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        var val = localStorage.getItem(key);</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        val = JSON.parse(val);</span><br><span class="line">        if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">            localStorage.removeItem(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return val.val;</span><br><span class="line">    &#125;;</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。</p><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="如何定时删除localstorage数据"><a href="#如何定时删除localstorage数据" class="headerlink" title="如何定时删除localstorage数据"></a>如何定时删除localstorage数据</h1><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="localStorage-能跨域吗"><a href="#localStorage-能跨域吗" class="headerlink" title="localStorage 能跨域吗"></a>localStorage 能跨域吗</h1><p><font color="#FF00FF"><strong>不能</strong></font></p><p><strong>解决方案：</strong></p><ul><li>通过postMessage来实现跨源通信</li><li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li><li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li><li>接入对应的SDK操作共享域，从而实现localStorage的跨域存储</li></ul><p><img src="http://files.shanqianche.cn/20228/1660096289332.png" alt="共享域"></p><h1 id="memory-cache-如何开启"><a href="#memory-cache-如何开启" class="headerlink" title="memory cache 如何开启"></a>memory cache 如何开启</h1><blockquote><p>memory cache 如何开启是一种比较特殊的缓存，<font color="#FF8C00">他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器</font>，这一部分用于缓存的内存空间就会被释放掉<font color="#FF8C00">。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，<strong>也不会生效</strong>。</font></p></blockquote><h1 id="localstorage的限制"><a href="#localstorage的限制" class="headerlink" title="localstorage的限制"></a>localstorage的限制</h1><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h1 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h1><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h1 id="浏览器如何渲染页面的"><a href="#浏览器如何渲染页面的" class="headerlink" title="浏览器如何渲染页面的"></a>浏览器如何渲染页面的</h1><ol><li>HTML 被 HTML 解析器解析成 DOM 树；</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><p><strong>不同的浏览器内核不同，所以渲染过程不太一样。</strong></p><p><img src="http://files.shanqianche.cn/20228/1660096647444.png" alt="webwit"><br><img src="http://files.shanqianche.cn/20228/1660096669266.png" alt="Mozilla"></p><p>由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。<br>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它 由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。</p><h1 id="重绘、重排区别如何避免"><a href="#重绘、重排区别如何避免" class="headerlink" title="重绘、重排区别如何避免"></a>重绘、重排区别如何避免</h1><ol><li><p>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p></li><li><p>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</p></li><li><p>区别：重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p></li><li><p>引发重排</p></li><li><p>1 添加、删除可见的dom</p></li><li><p>2 元素的位置改变</p></li><li><p>3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</p></li><li><p>4 页面渲染初始化</p></li><li><p>5 浏览器窗口尺寸改变</p></li><li><p>6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。<strong>所以，在多次使用这些值时应进行缓存。</strong></p></li><li><p>优化</p></li></ol><p><strong>浏览器自己的优化：</strong><br>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p><p><strong>减少 reflow/repaint</strong>：<br>（1）不要一条一条地修改DOM的样式。可以先定义好css的class，然后修改DOM的className。<br>（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。<br>（3）<font color="#FF8C00">为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会 reflow 的。</font><br>（4）千万<font color="#FF00FF">不要使用 table 布局</font>。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)<br>（5）<font color="#FF00FF">不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</font></p><h1 id="事件循环Event-loop"><a href="#事件循环Event-loop" class="headerlink" title="事件循环Event loop"></a>事件循环Event loop</h1><blockquote><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为<strong>事件循环</strong>。此机制具体如下:主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会<strong>检查microtask队列</strong>是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。</p></blockquote><p><strong>详细步骤：</strong></p><ol><li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</li><li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li><li>运行宏任务。</li><li>将事件循环的当前运行任务设置为null。</li><li>将运行完的宏任务从宏任务队列中移除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ol><p><strong>执行进入microtask检查的的具体步骤如下:</strong></p><ol><li>设置进入microtask检查点的标志为true。</li><li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；<strong>设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。</strong></li><li><strong>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。</strong></li><li>清理indexedDB的事务。</li><li>设置进入microtask检查点的标志为<strong>false。</strong></li></ol><p><font color="#FF8C00">需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。同一次事件循环中, 微任务永远在宏任务之前执行。</font></p><p><img src="http://files.shanqianche.cn/20228/1660097684197.png" alt="队列"></p><h1 id="let-a-“sssssss”，存在哪儿"><a href="#let-a-“sssssss”，存在哪儿" class="headerlink" title="let a = “sssssss”，存在哪儿"></a>let a = “sssssss”，存在哪儿</h1><p><strong>使用let声明的全局变量不是挂在window对象下的，声明的全局变量存在于一个块级作用域中。</strong></p><p>打印一个全局函数，在let声明的全局变量在<font color="#FF00FF">全局函数的scope下</font>，我们平时使用时直接 用变量名称就能访问到</p><p><img src="http://files.shanqianche.cn/20228/1660098766506.png" alt="全局函数对象中scope"></p><h1 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h1><p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：<strong>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</strong> 但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，<font color="#FF00FF">全局变量的生命周期直至浏览器卸载页面才会结束。</font>局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，<font color="#FF00FF">而闭包中由于内部函数的原因，外部函数并不能算是结束</font>。</p><p><font color="#FF8C00">标记清除和引用计数</font>。引用计数不太常用，标记清除较为常用。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<font color="#FF00FF">然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）</font>。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var a = &#123;&#125; ;         //a的引用次数为0 </span><br><span class="line">    var b = a ;         //a的引用次数加1，为1 </span><br><span class="line">    var c =a;           //a的引用次数再加1，为2</span><br><span class="line">    var b =&#123;&#125;;          //a的引用次数减1，为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netscape Navigator3是最早使用引用计数策略的浏览器<font color="#FF00FF">，但很快它就遇到一个严重的问题：循环引用</font>。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</p><blockquote><p><font color="#FF00FF">IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</font></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;some_element&quot;);</span><br><span class="line">var myObject = new Object();</span><br><span class="line">myObject.e = element;</span><br><span class="line">element.o = myObject;</span><br></pre></td></tr></table></figure><p>这个例子在一个DOM元素<font color="#FF00FF">（element)与一个原生js对象（myObject)之间创建了循环引用。</font>其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但是obj引用了document.getElementById(‘element’)，<font color="#FF00FF">而document.getElementById(‘element’)的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊</font>。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)</p><p><strong>解决办法：</strong><br>最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = null;</span><br><span class="line">element.o = null;</span><br><span class="line"></span><br><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">    obj=null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。</p><p><strong>要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</strong></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="什么时候触发垃圾回收？"><a href="#什么时候触发垃圾回收？" class="headerlink" title="什么时候触发垃圾回收？"></a>什么时候触发垃圾回收？</h3><p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。<font color="#FF00FF">IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作</font>，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。</p><p>微软在<font color="#FF00FF">IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，</font>说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，<font color="#FF00FF">如果回收的内存高于85%，</font>说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多</p><h3 id="合理的GC方案"><a href="#合理的GC方案" class="headerlink" title="合理的GC方案"></a>合理的GC方案</h3><h4 id="基础方案"><a href="#基础方案" class="headerlink" title="基础方案"></a>基础方案</h4><p>Javascript引擎基础GC方案是（<font color="#FF8C00">simple GC）：mark and sweep（标记清除）</font>，即：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><h4 id="GC的缺陷"><a href="#GC的缺陷" class="headerlink" title="GC的缺陷"></a>GC的缺陷</h4><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：<font color="#FF00FF">避免GC造成的长时间停止响应。</font></p><h4 id="GC优化策略"><a href="#GC优化策略" class="headerlink" title="GC优化策略"></a>GC优化策略</h4><p><strong>David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：</strong></p><ol><li><font color="#FF00FF">分代回收（Generation GC）</font> 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106399857.png" alt="分代回收"><br>这里需要补充的是：<font color="#FF8C00">对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。</font></p><ol start="2"><li><font color="#FF00FF">增量GC </font>这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106521299.png" alt="增量GC"></p><p><font color="#FF00FF">这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。</font></p><p>因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。</p><p><font color="#FF8C00">比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。</font></p><h1 id="顺序存储结构和链式存储结构的比较"><a href="#顺序存储结构和链式存储结构的比较" class="headerlink" title="顺序存储结构和链式存储结构的比较"></a>顺序存储结构和链式存储结构的比较</h1><p><strong>优缺点</strong></p><ol><li>顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。<ul><li>优点：存储密度大（＝1），存储空间利用率高。</li><li>缺点：插入或删除元素时不方便。</li></ul></li><li>链式存储时，相邻数据元素可随意存放，但<font color="#FF8C00">所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针</font><ul><li>优点：插入或删除元素时很方便，使用灵活。</li><li>缺点：存储密度小（&lt;1），存储空间利用率低</li></ul></li></ol><p><strong>使用情况</strong></p><ul><li>顺序表适宜于做查找这样的静态操作；</li><li>链表宜于做插入、删除这样的动态操作。</li><li>若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；</li><li>若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表</li></ul><p><strong>顺序表与链表的比较</strong></p><ul><li><strong>基于空间的比较</strong><ul><li>存储分配的方式<ul><li>顺序表的存储空间是静态分配的</li><li>链表的存储空间是动态分配的</li></ul></li><li>存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量<ul><li>顺序表的存储密度 = 1</li><li>链表的存储密度 &lt; 1</li></ul></li></ul></li><li><strong>基于时间的比较</strong><ul><li><font color="#FF00FF">存取方式</font><ul><li>顺序表可以随机存取，也可以顺序存取</li><li>链表是顺序存取的</li></ul></li><li>插入/删除时移动元素个数<ul><li><font color="#FF00FF">顺序表平均需要移动近一半元素</font></li><li>链表不需要移动元素，只需要修改指针</li></ul></li></ul></li></ul><h1 id="token-能放在cookie中吗"><a href="#token-能放在cookie中吗" class="headerlink" title="token 能放在cookie中吗"></a>token 能放在cookie中吗</h1><p><strong><font color="#FF8C00">能</font></strong></p><p><strong>解析：</strong></p><ul><li><font color="#FF8C00">token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。</font></li><li>「简单 token 的组成」:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><p><img src="http://files.shanqianche.cn/20228/1660107027666.png" alt="token认证流程"></p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端签发一个 token ，并把它发送给客户端</li><li>客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）</li><li>服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据</li></ol><h1 id="js如何获取-禁用cookie"><a href="#js如何获取-禁用cookie" class="headerlink" title="js如何获取/禁用cookie"></a>js如何获取/禁用cookie</h1><h2 id="js如何获取cookies"><a href="#js如何获取cookies" class="headerlink" title="js如何获取cookies"></a>js如何获取cookies</h2><p>假设cookie中存储的内容为：name=jack;password=123，则在B页面中获取变量username的值的JS代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arusername=document.cookie.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1];</span><br><span class="line">//JS操作cookies方法!</span><br><span class="line">//写cookies</span><br><span class="line">function setCookie(name,value)&#123;</span><br><span class="line">var Days = 30;</span><br><span class="line">var exp =newDate();</span><br><span class="line">exp.setTime(exp.getTime() + Days*24*60*60*1000);</span><br><span class="line">document.cookie = name +&quot;=&quot;+ escape (value) +&quot;;expires=&quot;+ exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取cookies</span><br><span class="line">function getCookie(name)&#123;</span><br><span class="line">var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">if(arr=document.cookie.match(reg))</span><br><span class="line">return unescape(arr[2]);</span><br><span class="line">else</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="cookie-是什么？"><a href="#cookie-是什么？" class="headerlink" title="cookie 是什么？"></a>cookie 是什么？</h2><ul><li>cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。</li><li>实际上 cookie 是<font color="#FF8C00">存于用户硬盘的一个文件，这个文件通常对应于一个域名，当</font>浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</li><li>不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。</li></ul><p><strong>PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量</strong></p><h2 id="cookie-能做什么？"><a href="#cookie-能做什么？" class="headerlink" title="cookie 能做什么？"></a>cookie 能做什么？</h2><ul><li>用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。</li></ul><p>PS:虽然 浏览器将信息保存<strong>在 cookie 中是加密了，但是可能还是会造成不安全的信息泄露</strong></p><ul><li>类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。</li></ul><p>PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品</p><ul><li>页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。<strong>后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。</strong></li></ul><p>PS：<font color="#FF8C00">这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。</font></p><h2 id="怎么使用-cookie？"><a href="#怎么使用-cookie？" class="headerlink" title="怎么使用 cookie？"></a>怎么使用 cookie？</h2><ol><li>语法<br>document.cookie = “name=value;expires=evalue; path=pvalue; domain=dvalue; secure;”</li></ol><p><strong>name=value 必选参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie=&quot;name=中文&quot;;</span><br><span class="line">//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码</span><br><span class="line">document.cookie = encodeURIComponent(&quot;name&quot;)+&quot;=&quot;+encodeURIComponent(&quot;中文&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>expires=evalue 可选参数</li></ol><p>该对象的有效时间（可选）只支持GTM 标准时间，即要将时间转换，toUTCString()（默认为当前浏览器 会话有用，关闭浏览器就消失）;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(); 　</span><br><span class="line">date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　</span><br><span class="line">alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果</span><br><span class="line">alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 </span><br><span class="line">document.cookie=&quot;name=vae;expires=&quot;+date.toUTCString(); </span><br><span class="line">alert(document.cookie); // name=vae 　</span><br><span class="line">setTimeout(function()&#123;alert(document.cookie)&#125;,4000);//4 秒后打印空的字符串</span><br></pre></td></tr></table></figure><ol start="3"><li>path=pvalue 可选参数</li></ol><p><strong>限制访问 cookie 的目录，默认情况下对于当前网页所在的同一目录下的所有页面有效</strong></p><ol start="4"><li>domain=dvalue 可选参数</li></ol><p><strong>用于限制只有设置了的域名才可以访问；如果没有设置，则默认在当前域名访问</strong><br>比如设置 test.com 表示域名为test.com的服务器共享该Cookie</p><ol start="5"><li>secure=true|false 可选参数，默认是 true 不安全传输</li></ol><p>安全设置，<font color="#FF8C00">指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,true 不安全，默认值；false 安 全，必须通过 https 来访问</font><br>比如：如果你设置 document.cookie = “name=vae;secure”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　//设置 cookie</span><br><span class="line">function setCookie(objName, objValue, objHours)&#123;//添加cookie</span><br><span class="line">    var str = objName + &quot;=&quot; + encodeURIComponent(objValue);</span><br><span class="line">    if (objHours &gt; 0) &#123;//为0时不设定过期时间，浏览器关闭时cookie自动消失</span><br><span class="line">        var date = new Date();</span><br><span class="line">        var ms = objHours * 3600 * 1000;</span><br><span class="line">        date.setTime(date.getTime() + ms);</span><br><span class="line">        str += &quot;; expires=&quot; + date.toUTCString();</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie = str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//获取 cookie</span><br><span class="line">function getCookie(objName)&#123;//获取指定名称的cookie的值</span><br><span class="line">    //多个cookie 保存的时候是以 ;空格  分开的</span><br><span class="line">    var arrStr = document.cookie.split(&quot;; &quot;);</span><br><span class="line">    for (var i = 0; i &lt; arrStr.length; i++) &#123;</span><br><span class="line">        var temp = arrStr[i].split(&quot;=&quot;);</span><br><span class="line">        if (temp[0] == objName)&#123;</span><br><span class="line">            return decodeURIComponent(temp[1]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间</span><br><span class="line">function delCookie(name)&#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setTime(date.getTime() - 10000);</span><br><span class="line">    document.cookie = name + &quot;=a; expires=&quot; + date.toUTCString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>（1）cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；<br>（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，<font color="#FF8C00">不同浏览器之间所保存的cookie也是不能互相访问的</font>；<br>（3）cookie可能被删除。因为<font color="#FF8C00">每个cookie都是硬盘上的一个文件</font>，因此很有可能被用户删除；<br>（4）cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。<br>（5）cookie 在保存时，只要后面保存的 name 相同，那么就会<font color="#FF8C00">覆盖</font>前面的 cookie，注意是完全覆盖，包括失效时间，pat</p><h1 id="cookie-禁用"><a href="#cookie-禁用" class="headerlink" title="cookie 禁用"></a>cookie 禁用</h1><p><strong>sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响。</strong></p><p><strong>解决这个问题的办法是：<font color="#FF8C00">URL重写</font></strong></p><p><strong>URL重写</strong> [TODO]</p><ol><li>servlet中涉及向客户端输出页面元素的时候，可以在相应的请求地址外面包上一层方法，也就是说使用response.encodeURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li><li>servlet中涉及跳转到新的页面时，可以使用response.encodeRedirectURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li></ol><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><h2 id="谷歌浏览器自带的调试工具"><a href="#谷歌浏览器自带的调试工具" class="headerlink" title="谷歌浏览器自带的调试工具"></a>谷歌浏览器自带的调试工具</h2><ol><li>Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。</li><li>console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。</li><li>Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。</li><li>Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。</li><li>Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。</li><li>Application：记录网站加载的各个资源信息。</li><li>Security：判断网页是否安全。</li><li>Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。</li></ol><h2 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h2><p>地址：<a href="https://sentry.io/welcome/">https://sentry.io/welcome/</a></p><p>无论测试如何完善的程序，bug总是免不了会存在的，有些bug不是每次都会出现，测试时运行好好的代码可能在某个用户使用时就歇菜了，可是当程序在用户面前崩溃时，你是看不到错误的，当然你会说:”Hey, 我有记日志呢”。 但是说实话，程序每天每时都在产生大量的日志，而且分布在各个服务器上，并且如果你有多个服务在维护的话，日志的数量之多你是看不过来的吧。等到某天某个用户实在受不了了，打电话来咆哮的时候，你再去找日志你又会发现日志其实没什么用：缺少上下文，不知道用户什么操作导致的异常，异常太多（从不看日志的缘故）不知如何下手 等等。</p><p>Sentry就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦。</p><p>Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。Sentry 由 python 编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。</p><h2 id="BrowserStack"><a href="#BrowserStack" class="headerlink" title="BrowserStack"></a>BrowserStack</h2><p>地址：<a href="https://www.browserstack.com/">https://www.browserstack.com/</a></p><p>现在拥有各自内核的浏览器越来越多，各自的特性也千差万别。如果作为一个前端攻城师想要检测网站在不同的操作系统和移动平台下的各种浏览器的兼容性，那是相当痛苦不堪的。看到有在自己电脑上装虚拟机配置各种环境，有自己的电脑上组建好这样的环境，然后一一测试，可是人的精力毕竟有限，我们没法在同一台电脑上装那么多系统，那么多浏览器的。幸好出了个 BrowserStack 是前端的福音呀。</p><p>BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备很多虚拟机或者手机模拟器。</p><p>BrowserStack 是一个提供网站浏览器兼容性测试的在线云端应用，支持9大操作系统上的100多款浏览器。支持本地测试，支持与Visual Studio集成。或者你也可以直接前往 <a href="http://modern.ie/">http://modern.ie</a> 在线测试，现在注册可以免费试用三个月，三个月后是收费的，三个月后要是你想用又不想付费作为天朝的开发者你懂得。</p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>webAPI(第十三天)</title>
    <link href="https://merlynr.github.io/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-08-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h1><p><strong>这个方法是用来打开新窗口的</strong></p><ol><li>最基本的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;);</span><br></pre></td></tr></table></figure><ol start="2"><li>经过设置后的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;, &#x27;newwindow&#x27;, &#x27;height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&#x27;)   </span><br><span class="line">  //该句写成一行代码</span><br><span class="line">  //参数解释：</span><br><span class="line">  // window.open 弹出新窗口的命令； </span><br><span class="line">　　//&#x27;page.html&#x27; 弹出窗口的文件名； </span><br><span class="line">　　//&#x27;newwindow&#x27; 弹出窗口的名字（不是文件名），非必须，可用空&#x27;&#x27;代替； </span><br><span class="line">　　//height=100 窗口高度； </span><br><span class="line">　　//width=400 窗口宽度； </span><br><span class="line">　　//top=0 窗口距离屏幕上方的象素值； </span><br><span class="line">　　//left=0 窗口距离屏幕左侧的象素值； </span><br><span class="line">　　//toolbar=no 是否显示工具栏，yes为显示； </span><br><span class="line">　　//menubar，scrollbars 表示菜单栏和滚动栏。 </span><br><span class="line">　　//resizable=no 是否允许改变窗口大小，yes为允许； </span><br><span class="line">　　//location=no 是否显示地址栏，yes为允许； </span><br><span class="line">　　//status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许</span><br></pre></td></tr></table></figure><ol start="3"><li>用函数控制弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&quot;) //写成一行</span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">　　&lt;/script&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body οnlοad=&quot;openwin()&quot;&gt; </span><br><span class="line">　　任意的页面内容... </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><p><strong>解释：</strong> 这里定义了一个函数openwin(), 函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？ 方法一：&lt;body οnlοad=”openwin()”&gt; 浏览器读页面时弹出窗口； 方法二：&lt;body οnunlοad=”openwin()”&gt; 浏览器离开页面时弹出窗口； 方法三：用一个连接调用： &lt;a href=”#” οnclick=”openwin()”&gt; 打开一个窗口 注意：使用的”#”是<font color="#FF00FF">虚连接。</font> 方法四：用一个按扭调用： &lt;input type=”button” οnclick=”openwin()” value=”打开窗口” /&gt;</p><ol start="4"><li>弹出两个窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no&quot;)//写成一行 </span><br><span class="line">　　window.open (&quot;page2.html&quot;, &quot;newwindow2&quot;, &quot;height=100, width=100, top=100, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no&quot;)//写成一行 </span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为<strong>避免弹出的2个窗口覆盖</strong>，用top和left控制一下弹出的位置不要相互覆盖即可。最后用上面的说过的四种方法调用即可。 <font color="#FF8C00">注意：2个窗口的name(newwindow与 newwindow2)不要相同，或者干脆全部为空。</font></p><ol start="5"><li>主窗口打开文件1.htm，同时弹出小窗口page.html</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function openwin()&#123;</span><br><span class="line">    window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line">&#125;</span><br><span class="line">   //加入body区：</span><br><span class="line">&lt;a href=&quot;1.htm&quot; οnclick=&quot;openwin()&quot;&gt;open&lt;/a&gt;即可。</span><br></pre></td></tr></table></figure><ol start="6"><li>弹出的窗口之定时关闭控制</li></ol><p>将一小段代码加入弹出的页面（注意是加入page.html的HTML中，可不是主页面中，否则……），让它在10秒后自动关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function closeit()&#123;</span><br><span class="line">   setTimeout(&quot;self.close()&quot;, 10000)   //毫秒</span><br><span class="line">&#125;</span><br><span class="line">&lt;body οnlοad=&quot;closeit()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>在弹出窗口中加上一个关闭按扭</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;关闭&quot; οnclick=&quot;window.close()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>内包含的弹出窗口—一个页面两个窗口</li></ol><p>内包含的弹出窗口—一个页面两个窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　function openwin() </span><br><span class="line">　　&#123; </span><br><span class="line">　　OpenWindow=window.open(&quot;&quot;, &quot;newwin&quot;, &quot;height=250, width=250,toolbar=no ,scrollbars=&quot;+scroll+&quot;,menubar=no&quot;); </span><br><span class="line">　　//写成一行 </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;TITLE&gt;例子&lt;/TITLE&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;BODY BGCOLOR=#ffffff&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;New window opened!&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/BODY&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/HTML&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.close() </span><br><span class="line">　　&#125; </span><br><span class="line">　　&lt;/SCRIPT&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body&gt; </span><br><span class="line">　　&lt;a href=&quot;#&quot; οnclick=&quot;openwin()&quot;&gt;打开一个窗口&lt;/a&gt; </span><br><span class="line">　　&lt;input type=&quot;button&quot; οnclick=&quot;openwin()&quot; value=&quot;打开窗口&quot;&gt; </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><ol start="9"><li>终极应用—弹出的窗口这Cookie控制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> function openwin()&#123; </span><br><span class="line">　　window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line"> &#125; </span><br><span class="line"> function get_cookie(Name)&#123;</span><br><span class="line">    var search=Name+&quot;=&quot;;</span><br><span class="line">    var returnvalue=&quot;&quot;;</span><br><span class="line">    if(document.cookie.length&gt;0)&#123;</span><br><span class="line">　　    if (offset != -1) &#123; </span><br><span class="line">　　      offset += search.length </span><br><span class="line">　　      end = document.cookie.indexOf(&quot;;&quot;, offset); </span><br><span class="line">　　      if (end == -1) </span><br><span class="line">　　       end = document.cookie.length; </span><br><span class="line">　　        returnvalue=unescape(document.cookie.substring(offset, end));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return returnvalue;</span><br><span class="line"> &#125;</span><br><span class="line"> function ladpopup()&#123;</span><br><span class="line">    if(get_cookie(&#x27;popped=yes&#x27;))&#123;</span><br><span class="line">      openwin()</span><br><span class="line">      document.cookie=&quot;popped=yes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现-Eventemitter-类，有on、emit、off-方法"><a href="#实现-Eventemitter-类，有on、emit、off-方法" class="headerlink" title="实现 Eventemitter 类，有on、emit、off 方法"></a>实现 Eventemitter 类，有on、emit、off 方法</h1><ol><li>on(event,fn)：监听event事件，事件触发时调用fn函数；</li><li>once(event,fn)：为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器；</li><li>emit(event,arg1,arg2,arg3…)：触发event事件，并把参数arg1,arg2,arg3….传给事件处理函数；</li><li>off(event,fn)：停止监听某个事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._envents = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(event, callback) &#123;</span><br><span class="line">    //监听event事件，触发时调用callback函数</span><br><span class="line">    let callbacks = this._events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    this._events[event] = callbacks;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  off(event, callback) &#123;</span><br><span class="line">    //停止监听event事件</span><br><span class="line">    let callbacks = this._events[event];</span><br><span class="line">    this._events[event] =</span><br><span class="line">      callbacks &amp;&amp; callbacks.filter((fn) =&gt; fn !== callback);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(...args) &#123;</span><br><span class="line">    //触发事件，并把参数传给事件的处理函数</span><br><span class="line">    const event = args[0];</span><br><span class="line">    const params = [].slice.call(args, 1);</span><br><span class="line">    const callbacks = this._events[event];</span><br><span class="line">    callbacks.forEach((fn) =&gt; fn.apply(this.params));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  once(event, callback) &#123;</span><br><span class="line">    //为事件注册单次监听器</span><br><span class="line">    let wrapFanc = (...args) =&gt; &#123;</span><br><span class="line">      callback.apply(this.args);</span><br><span class="line">      this.off(event, wrapFanc);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.on(event, wrapFanc);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找给定的两个节点的第一个公共父节点"><a href="#查找给定的两个节点的第一个公共父节点" class="headerlink" title="查找给定的两个节点的第一个公共父节点"></a>查找给定的两个节点的第一个公共父节点</h1><p>递归循环树的节点，因二叉树不能重复的特性,当前节点为 p or q ，返回当前节点 父节点循环中，如果找到一个，则查找其他子树 其他子树没有找到另外一个，就证明当前节点为找到的子树是最近公共祖先 两个都找到了，对应当前节点是两个节点的父节点这种情况，则返回当前节点。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">if (!root || root === p || root === q) return root</span><br><span class="line">    let left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    let right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    if (!left) return right</span><br><span class="line">    if (!right) return left</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>未完成的List</title>
    <link href="https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/"/>
    <id>https://merlynr.github.io/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><ul><li><input disabled="" type="checkbox"> CSS新样式未写完</li><li><input disabled="" type="checkbox"> Promise概念未梳理完</li><li><input disabled="" type="checkbox"> 基本算法</li></ul><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><ul><li><input disabled="" type="checkbox"> 基础算法</li><li><input disabled="" type="checkbox"> 腾讯的小红</li></ul>]]></content>
    
    
    <summary type="html">每周学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>CSS属性(第十二天)</title>
    <link href="https://merlynr.github.io/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>清除浮动其实叫做闭合浮动更合适，因为是把浮动的元素圈起来，让父元素闭合出口和入口不让他们出来影响其他的元素。<br>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;</span><br><span class="line">/*属性值为left,清除左侧浮动的影响</span><br><span class="line">  属性值为right,清除右侧浮动的影响</span><br><span class="line">  属性值为both,同时清除左右两侧浮动的影响*/</span><br></pre></td></tr></table></figure><h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><ol><li>末尾标签法</li></ol><p>通过在浮动元素的末尾添加一个空的标签。这是W3C推荐的做法，虽然比较简单，但是添加了无意义的标 签，结构化比较差，所以不推荐使用。下面三种写法都适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">2. .clear &#123; clear:both &#125;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">3..clear&#123; clear:both &#125;</span><br><span class="line">    &lt;br class=&quot;clear&quot; /&gt;    &lt;!--也可以使用br等别的块级元素来清除浮动--&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>内部标签法，把div放进父盒子里，盒子会撑开，一般也不会用。</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>给父级元素添加overflow样式方法。<br>代码比较简洁，可以通过触发BFC方式，但是<font color="#FF00FF">因为本身overflow的本质是溢出隐藏的效果</font>，所以有的时候也会有<font color="#FF00FF">一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素</font>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">        overflow: auto;  </span><br><span class="line">      /* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="伪元素法（最常用）"><a href="#伪元素法（最常用）" class="headerlink" title="伪元素法（最常用）"></a>伪元素法（最常用）</h2><ol><li>使用after伪元素清除浮动</li></ol><p>after是在父元素中加一个盒子，这个元素是通过css添加上去的，符合闭合浮动思想，结构语义化正确。<br>父元素中加一个类名为clearfix 。但是这个方法IE6，7不识别，要进行兼容，使用zoom:1触发 hasLayout来清除浮动<br>代表网站：百度、淘宝、网易等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:&quot;.&quot;;  /*尽量不要为空，一般写一个点*/</span><br><span class="line">    height:0;     /*盒子高度为0，看不见*/</span><br><span class="line">    display:block;    /*插入伪元素是行内元素，要转化为块级元素*/</span><br><span class="line">    visibility:hidden;      /*content有内容，将元素隐藏*/</span><br><span class="line">    clear:both;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;   /*  *只有IE6,7识别 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>after伪元素空余字符法</li></ol><p>父元素中加一个类名为clearfix，也需要兼容IE6、7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content:&quot;\200B&quot;;   /* content:&#x27;\0200&#x27;; 也可以 */</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用before和after双伪元素清除浮动<font color="#FF00FF">（推荐）</font></li></ol><p>完全符合闭合浮动思想的方法。<br>父元素中加一个类名为clearfix,需要兼容IE6、7<br>代表网站：小米、腾讯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">       content: &quot;&quot;; </span><br><span class="line">       display: table;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix:after &#123;</span><br><span class="line">       clear: both;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix &#123;</span><br><span class="line">       *zoom: 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="padding-margin-百分比单位依据"><a href="#padding-margin-百分比单位依据" class="headerlink" title="padding , margin 百分比单位依据"></a>padding , margin 百分比单位依据</h1><p>在CSS 盒模型中，依据CSS2.2文档，<font color="#FF00FF">margin与padding的百分比指定值时，一律参考包含盒的宽度。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.son&#123;</span><br><span class="line">    margin: 20%;</span><br><span class="line">    padding: 20%;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图，包括padding-top/bottom,margin-top/bottom在内，所有padding和margin均是参考的包含块的宽度，故它们的值为200px * 20% = 40px。</p><h1 id="父子边距重合"><a href="#父子边距重合" class="headerlink" title="父子边距重合"></a>父子边距重合</h1><p><strong>效果：</strong><br>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。<br><strong>父子元素的边界重叠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background: #e7a1c5;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent .child &#123;</span><br><span class="line">    background: #c8cdf5;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;section class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659687771174.png" alt="以为期待的效果"></p><p><img src="http://files.shanqianche.cn/20228/1659687834728.png" alt="而实际上效果如下"><br><font color="#FF00FF">在这里父元素的高度不是 110px，而是 100px，在这里发生了高度坍塌。</font><br><strong>产生原因：</strong><br><font color="#FF8C00">如果块元素的margin-top与它的第一个子元素的margin-top之间没有border、padding、inlinecontent、clearance来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有border、padding、inlinecontent、height、min-height、max-height分隔，那么外边距会塌陷</font>。子元素多余的外边距会被父元素的外边距截断。<br><strong>解决办法：</strong><br>父子元素的边界重叠得解决方案： 在父元素上加上 overflow:hidden;使其成为 BFC。</p><h1 id="css字体大小设置（三种）-em-rem-px"><a href="#css字体大小设置（三种）-em-rem-px" class="headerlink" title="css字体大小设置（三种）.em rem px"></a>css字体大小设置（三种）.em rem px</h1><h2 id="px（绝对长度单位）"><a href="#px（绝对长度单位）" class="headerlink" title="px（绝对长度单位）"></a>px（绝对长度单位）</h2><p>相信对于前端来说px这个单位是大家并不陌生，px这个单位，兼容性可以说是相当可以，大家对px的了解肯 定是没有很大的问题的。</p><h2 id="em（相对长度单位）"><a href="#em（相对长度单位）" class="headerlink" title="em（相对长度单位）"></a>em（相对长度单位）</h2><p><strong>使用：</strong></p><ol><li>浏览器的默认字体都是16px，那么<font color="#FF8C00">1em=16px</font>，以此类推计算12px=0.75em，10px=0.625em,2em=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75em、0.625em全是小数点)</li><li>为了<font color="#FF00FF">简化font-size的换算，我们在body中写入一下代码</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */ </span><br></pre></td></tr></table></figure><p>这样页面中1em=10px,1.2em=12px,1.4em=14px,1.6em=16px，使得视觉、使用、书写都得到了极大的帮助。<br>例子如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="keyword">class</span>=<span class="string">&quot;font1&quot;</span> style=<span class="string">&#x27;font-size:1.6em&#x27;</span>&gt;我是<span class="number">1.6</span>em&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>em的值并不是固定的；</li><li>em会<font color="#FF00FF">继承父级元素的字体大小</font>（参考物是<font color="#FF00FF">父元素的font-size</font>；）；</li><li>em中所有的字体都是相对于父元素的大小决定的；所以如果一个设置了font-size:1.2em的元素在另一个设置了font-size:1.2em的元素里，而这个元素又在另一个设置了font-size:1.2em的元素里，那么最后计算的结果是1.2X1.2X1.2=1.728em</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是大字体</span><br><span class="line">   &lt;div class=&quot;small&quot;&gt;我是小字体&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">     body &#123;font-size: 62.5%; &#125; /*  公式:16px*62.5%=10px  */ </span><br><span class="line">    .big&#123;font-size: 1.2em&#125;</span><br><span class="line">    .small&#123;font-size: 1.2em&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>但运行结果small的字体大小为：1.2em*1.2em=1.44em</strong></p><h2 id="rem（相对长度单位）"><a href="#rem（相对长度单位）" class="headerlink" title="rem（相对长度单位）"></a>rem（相对长度单位）</h2><p><strong>使用：</strong></p><ul><li>浏览器的默认字体都是16px，那么1rem=16px，以此类推计算12px=0.75rem，10px=0.625rem，2rem=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75rem、0.625em全是小数点) ；</li><li>为了简化font-size的换算，<font color="#FF8C00">我们在根元素html中加入font-size: 62.5%;</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */  </span><br></pre></td></tr></table></figure><p>这样页面中1rem=10px,1.2rem=12px,1.4rem=14px,1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;font1&quot; style=&#x27;font-size:1.6rem&#x27;&gt;我是1.6rem=16px&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>rem单位可谓集相对大小和绝对大小的优点于一身</li><li><font color="#FF8C00">和em不同的是rem总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单</font>。</li><li><font color="#FF8C00">rem支持IE9及以上，意思是相对于根元素html（网页），不会像em那样，依赖于父元素的字体大小，而造成混乱</font>。使用起来安全了很多。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是14px=1.4rem&lt;div class=&quot;small&quot;&gt;我是12px=1.2rem&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    html &#123;font-size: 10px;  &#125; /*  公式16px*62.5%=10px  */  </span><br><span class="line">    .big&#123;font-size: 1.4rem&#125;</span><br><span class="line">    .small&#123;font-size: 1.2rem&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>值得注意的浏览器支持问<font color="#FF8C00">题： IE8，Safari 4或 iOS 3.2中不支持rem单位。</font><br>如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p><h1 id="css3新特性-TODO-未完成"><a href="#css3新特性-TODO-未完成" class="headerlink" title="css3新特性 [TODO 未完成]"></a>css3新特性 [TODO 未完成]</h1><h2 id="CSS3-边框"><a href="#CSS3-边框" class="headerlink" title="CSS3 边框"></a>CSS3 边框</h2><h3 id="创建圆角"><a href="#创建圆角" class="headerlink" title="创建圆角"></a>创建圆角</h3><blockquote><p>语法： border-radius :number number;</p></blockquote><p>length： 由浮点数字和单位标识符组成的长度值（如：20px）。不可为负值，<font color="#FF8C00">如果为负值则与0展示效果一样</font>。<font color="#FF8C00">第一个值设置其水平半径，第二个值设置其垂直半径</font>，<em>如果第二个值省略则默认第二个值等于第一个值</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 设置每个圆角水平半径和垂直半径都为30px */</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius是4个角的缩写方法。四个角的表示顺序与border类似<font color="#FF8C00">按照border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius的顺序来设置</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 如果 / 前后的值都存在，那么 / 前面的值设置其水平半径，/ 后面值设置其垂直半径，如果没有 / ，则水平和垂直半径相等 */</span><br><span class="line">  border-radius: 10px 15px 20px 30px / 20px 30px 10px 15px;</span><br><span class="line"></span><br><span class="line">  /* 上面写法等价于下面的写法，第一个值是水平半径，第二个值是垂直半径 */</span><br><span class="line">  border-top-left-radius: 10px 20px;</span><br><span class="line">  border-top-right-radius: 15px 30px;</span><br><span class="line">  border-bottom-right-radius: 20px 10px;</span><br><span class="line">  border-bottom-left-radius: 30px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius指定不同数量的值遵循对角相等的原则，即指定了值的取指定值，没有指定值的与对角值相等，对角相等模型</p><h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><p>通过属性box-shadow向边框添加阴影。<br>语法： {box-shadow : [inset] x-offset y-offset blur-radius extension-radius spread-radiuscolor}<br>说明：<strong>对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量 模糊半径 阴影扩展半径 阴影颜色}</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  /* 内阴影，向右偏移10px，向下偏移10px，模糊半径5px，阴影缩小10px */</span><br><span class="line">  box-shadow: inset 10px 10px 5px -10px #888888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><p>语法：<br><strong>border-image : border-image-source || border-image-slice [ / border-image-width] || border-image-repeat</strong><br>border-image ： none | image [ number | percentage]{1,4} [ / border-width&gt;{1,4} ] ? [ stretch | repeat | round ]{0,2}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border-image:url(border.png) 30 30 round;</span><br><span class="line"></span><br><span class="line">  border-image: url(border.png) 20/10px repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-背景"><a href="#CSS3-背景" class="headerlink" title="CSS3 背景"></a>CSS3 背景</h2><h3 id="background-size属性"><a href="#background-size属性" class="headerlink" title="background-size属性"></a>background-size属性</h3><p>在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以设置背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。可以像素或百分比规定尺寸。<strong>如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  /* 通过像素规定尺寸 */</span><br><span class="line">  background-size:63px 100px;</span><br><span class="line"></span><br><span class="line">  /* 通过百分比规定尺寸 */</span><br><span class="line">  background-size:100% 50%;</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-origin属性"><a href="#background-origin属性" class="headerlink" title="background-origin属性"></a>background-origin属性</h3><p>规定背景图片的定位区域，背景图片可以放置于content-box、padding-box或border-box区域，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">  background-size:100% 100%;</span><br><span class="line">  /* 规定背景图片的定位区域 */</span><br><span class="line">  background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-clip属性"><a href="#background-clip属性" class="headerlink" title="background-clip属性"></a>background-clip属性</h3><p>与background-origin属性相似，规定背景颜色的绘制区域，区域划分与background-origin属性相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">  background-clip:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-多重背景图片"><a href="#CSS3-多重背景图片" class="headerlink" title="CSS3 多重背景图片"></a>CSS3 多重背景图片</h3><p>CSS3 允许为元素设置多个背景图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background-image:url(bg_flower.gif),url(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-文本效果"><a href="#CSS3-文本效果" class="headerlink" title="CSS3 文本效果"></a>CSS3 文本效果</h2><ol><li>text-shadow属性</li></ol><p>给为本添加阴影，能够<font color="#FF8C00">设置水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">  text-shadow: 5px 5px 5px #FF0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>text-wrap 属性</li></ol><p>设置区域内的<font color="#FF00FF">自动换行。</font><br>语法：text-wrap: normal | none | unrestricted | suppress | break-word;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 允许对长单词进行拆分，并换行到下一行 */</span><br><span class="line">p &#123;word-wrap:break-word;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>只在允许的换行点进行换行。</td></tr><tr><td>none</td><td>不换行。元素无法容纳的文本会溢出。</td></tr><tr><td>break-word</td><td>在任意两个字符间换行。</td></tr><tr><td>suppress</td><td>压缩元素中的换行。<font color="#FF00FF">浏览器只在行中没有其他有效换行点时进行换行。</font></td></tr></tbody></table><h2 id="CSS3-字体"><a href="#CSS3-字体" class="headerlink" title="CSS3 字体"></a>CSS3 字体</h2><ol><li>字体定义</li></ol><p><font color="#FF8C00">在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。但是通过 CSS3，web 设计师可以使用他 们喜欢的任意字体。当找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时 被自动下载到用户的计算机上。</font>字体<font color="#FF00FF">需要在 CSS3 @font-face 规则</font>中定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 定义字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFont;</span><br><span class="line">  src: url(&#x27;Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;Sansation_Light.eot&#x27;);     /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFont;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用粗体字体</li></ol><p>“Sansation_Light.ttf”文件 是定义的正常字体，”Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。<font color="#FF8C00">只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。</font><br><strong>（其实没弄清楚这样处理的原因，经测试直接在html中通过 b 标签也可以实现加粗的效果）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 定义正常字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Light.eot&#x27;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义粗体时使用的字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Bold.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Bold.eot&#x27;); /* IE9+ */</span><br><span class="line">  /* 标识属性 */</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFirstFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-2D-转换"><a href="#CSS3-2D-转换" class="headerlink" title="CSS3 2D 转换"></a>CSS3 2D 转换</h2><p>通过 CSS3 转换，我们能够对元素进行<strong>移动、缩放、转动、拉长或拉伸，转换</strong>是使元素改变形状、尺寸和位置的一种效果。</p><h4 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h4><p>通过 translate(x , y) 方法，元素根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数<font color="#FF8C00">从其当前位置</font>移动，x为正值向右移动，为负值向左移动；y为正值向下移动，为负值向上移动；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: translate(50px,100px);</span><br><span class="line">  -ms-transform: translate(50px,100px);        /* IE 9 */</span><br><span class="line">  -webkit-transform: translate(50px,100px);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: translate(50px,100px);         /* Opera */</span><br><span class="line">  -moz-transform: translate(50px,100px);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h3><p>控制元素顺时针旋转给定的角度。为正值，元素将顺时针旋转。为负值，元素将逆时针旋转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: rotate(30deg);</span><br><span class="line">  -ms-transform: rotate(30deg);        /* IE 9 */</span><br><span class="line">  -webkit-transform: rotate(30deg);    /* Safari and Chrome */</span><br><span class="line">  -o-transform: rotate(30deg);         /* Opera */</span><br><span class="line">  -moz-transform: rotate(30deg);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h3><p>根据给定的宽度（X 轴）和高度（Y 轴）参数，<font color="#FF8C00">控制元素的尺寸的增加、减少。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: scale(2,4);</span><br><span class="line">  -ms-transform: scale(2,4);         /* IE 9 */</span><br><span class="line">  -webkit-transform: scale(2,4);     /* Safari 和 Chrome */</span><br><span class="line">  -o-transform: scale(2,4);         /* Opera */</span><br><span class="line">  -moz-transform: scale(2,4);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h3><p><strong>根据给定的水平线（X 轴）和垂直线（Y 轴）参数设置元素翻转给定的角度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 设置围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: skew(30deg,20deg);</span><br><span class="line">  -ms-transform: skew(30deg,20deg);         /* IE 9 */</span><br><span class="line">  -webkit-transform: skew(30deg,20deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: skew(30deg,20deg);          /* Opera */</span><br><span class="line">  -moz-transform: skew(30deg,20deg);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p><font color="#FF00FF">matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 使用 matrix 方法将 div 元素旋转 30 度 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class="line">  -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0);          /* IE 9 */</span><br><span class="line">  -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0);         /* Firefox */</span><br><span class="line">  -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0);      /* Safari and Chrome */</span><br><span class="line">  -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0);           /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2D-Transform-方法汇总"><a href="#2D-Transform-方法汇总" class="headerlink" title="2D Transform 方法汇总"></a>2D Transform 方法汇总</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>matrix(n,n,n,n,n,n)</td><td>定义 2D 转换，使用六个值的矩阵。</td></tr><tr><td>translate(x,y)</td><td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td></tr><tr><td>translateX(n)</td><td>定义 2D 转换，沿着 X 轴移动元素。</td></tr><tr><td>translateY(n)</td><td>定义 2D 转换，沿着 Y 轴移动元素。</td></tr><tr><td>scale(x,y)</td><td>定义 2D 缩放转换，改变元素的宽度和高度。</td></tr><tr><td>scaleX(n)</td><td>定义 2D 缩放转换，改变元素的宽度。</td></tr><tr><td>scaleY(n)</td><td>定义 2D 缩放转换，改变元素的高度。</td></tr><tr><td>rotate(angle)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr><tr><td>skew(x-angle,y-angle)</td><td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td></tr><tr><td>skewX(angle)</td><td>定义 2D 倾斜转换，沿着 X 轴。</td></tr><tr><td>skewY(angle)</td><td>定义 2D 倾斜转换，沿着 Y 轴。</td></tr></tbody></table><h2 id="CSS3-3D-转换"><a href="#CSS3-3D-转换" class="headerlink" title="CSS3 3D 转换"></a>CSS3 3D 转换</h2><p>CSS3 允许使用 3D 转换来对元素进行格式化</p><h3 id="rotateX-方法"><a href="#rotateX-方法" class="headerlink" title="rotateX() 方法"></a>rotateX() 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 X 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateX(120deg);</span><br><span class="line">  -webkit-transform: rotateX(120deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateX(120deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY-旋转"><a href="#rotateY-旋转" class="headerlink" title="rotateY() 旋转"></a>rotateY() 旋转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 Y 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateY(130deg);</span><br><span class="line">  -webkit-transform: rotateY(130deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateY(130deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h2><p><strong>通过 CSS3可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果</strong><br>要实现这一点，必须规定以下两项内容：</p><ul><li>设置添加过渡效果的 CSS 属性；</li><li>设置过渡效果的时长；</li></ul><p><strong>注意： 如果时长未设置，则不会有过渡效果，因为默认值是 0。</strong></p><h3 id="单项改变"><a href="#单项改变" class="headerlink" title="单项改变"></a>单项改变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 设置将变化效果添加在“宽度”上，时长为2秒；该时长在其他属性上并不适用 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s;</span><br><span class="line">  -moz-transition: width 2s;         /* Firefox 4 */</span><br><span class="line">  -webkit-transition: width 2s;      /* Safari 和 Chrome */</span><br><span class="line">  -o-transition: width 2s;           /* Opera */</span><br><span class="line">&#125;</span><br><span class="line">/* 配合在一起使用的效果就是当鼠标移上去的时候宽度变为300px，这个过程耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 当鼠标移出元素时，它会逐渐变回原来的样式。</strong></p><h3 id="多项改变"><a href="#多项改变" class="headerlink" title="多项改变"></a>多项改变</h3><p><strong>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 同时向宽度、高度和转换添加过渡效果 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s, height 2s, transform 2s;</span><br><span class="line">  -moz-transition: width 2s, height 2s, -moz-transform 2s;</span><br><span class="line">  -webkit-transition: width 2s, height 2s, -webkit-transform 2s;</span><br><span class="line">  -o-transition: width 2s, height 2s,-o-transform 2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 当鼠标移上时宽度和高度都变成200px，同时旋转180度，每个属性变化都耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  height:200px;</span><br><span class="line">  transform:rotate(180deg);</span><br><span class="line">  -moz-transform:rotate(180deg);        /* Firefox 4 */</span><br><span class="line">  -webkit-transform:rotate(180deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform:rotate(180deg);          /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="过渡属性详解"><a href="#过渡属性详解" class="headerlink" title="过渡属性详解"></a>过渡属性详解</h3><p><strong><font color="#FF8C00">transition是简写属性</font></strong><br><strong>语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>transition</td><td>简写属性，用于在一个属性中设置四个过渡属性。</td></tr><tr><td>transition-property</td><td>规定应用过渡的 CSS 属性的名称。</td></tr><tr><td>transition-duration</td><td>定义过渡效果花费的时间。默认是 0。</td></tr><tr><td>transition-timing-function</td><td>规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td>transition-delay</td><td>规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>通过 CSS3可以创建动画，这些动画可以取代网页中的画图片、Flash 动画以及 JavaScript。</p><p>CSS3 中通过<font color="#FF00FF">@keyframes 规则</font>来创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式（动画开始前的样式）逐渐改为新样式（需要变到的样式）的动画效果。</p><h3 id="通过from-to关键字设置动画发生的时间"><a href="#通过from-to关键字设置动画发生的时间" class="headerlink" title="通过from , to关键字设置动画发生的时间"></a>通过from , to关键字设置动画发生的时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 通过@keyframes 创建动画 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Firefox */</span><br><span class="line">@-moz-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Safari 和 Chrome */</span><br><span class="line">@-webkit-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Opera */</span><br><span class="line">@-o-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   将创建的动画绑定到选择器，并至少指定以下两项 CSS3 动画属性</span><br><span class="line">   1.指定动画的名称；</span><br><span class="line">   2.指定动画的时长；</span><br><span class="line">*/</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s;</span><br><span class="line">  -moz-animation: myfirst 5s;       /* Firefox */</span><br><span class="line">  -webkit-animation: myfirst 5s;    /* Safari 和 Chrome */</span><br><span class="line">  -o-animation: myfirst 5s;         /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过百分比设置动画发生的时间"><a href="#通过百分比设置动画发生的时间" class="headerlink" title="通过百分比设置动画发生的时间"></a>通过百分比设置动画发生的时间</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。可以用关键词 “from” 和 “to”来设置动画变化发生的时间，其效果等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，应该始终定义 0% 和 100% 选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red;&#125;</span><br><span class="line">  25%  &#123;background: yellow;&#125;</span><br><span class="line">  50%  &#123;background: blue;&#125;</span><br><span class="line">  100% &#123;background: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 同时改变背景色和位置 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">  25%  &#123;background: yellow; left:200px; top:0px;&#125;</span><br><span class="line">  50%  &#123;background: blue; left:200px; top:200px;&#125;</span><br><span class="line">  75%  &#123;background: green; left:0px; top:200px;&#125;</span><br><span class="line">  100% &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画属性详解"><a href="#动画属性详解" class="headerlink" title="动画属性详解"></a>动画属性详解</h3><p><strong>animation是<font color="#FF00FF">除了animation-play-state属性所有动画属性的简写属性</font>。</strong></p><p>语法： animation : animation-name | animation-duration | animation-timing-function | animation-delay | animation-iteration-count | animation-direction</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 应用的动画为myfirst，一个动画周期为5秒，动画的速度曲线为linear，动画2秒后播放，播放次数为infinite，即无限循环，动画下一周期是否逆向播放取值alternate，即逆向播放 */</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Firefox: */</span><br><span class="line">  -moz-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Safari 和 Chrome: */</span><br><span class="line">  -webkit-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Opera: */</span><br><span class="line">  -o-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画。</td></tr><tr><td>animation</td><td>所有动画属性的简写属性，除了 animation-play-state 属性。</td></tr><tr><td>animation-name</td><td>规定 @keyframes 动画的名称。</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是 “ease”。</td></tr><tr><td>animation-delay</td><td>规定动画何时开始。默认是 0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是 1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是 “running”。</td></tr><tr><td>animation-fill-mode</td><td>规定对象动画时间之外的状态。</td></tr></tbody></table><h2 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h2><p>通过 CSS3够创建多个列来对文本进行布局，就像我们经常看到的报纸的布局一样。</p><h3 id="CSS3-创建多列"><a href="#CSS3-创建多列" class="headerlink" title="CSS3 创建多列"></a>CSS3 创建多列</h3><p><strong>column-count属性规定元素应该被分隔的列数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 将div中的文本分为3列 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-count:3;</span><br><span class="line">  -moz-column-count:3;        /* Firefox */</span><br><span class="line">  -webkit-column-count:3;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-规定列之间的间隔"><a href="#CSS3-规定列之间的间隔" class="headerlink" title="CSS3 规定列之间的间隔"></a>CSS3 规定列之间的间隔</h3><p><strong>column-gap属性规定列之间的间隔。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置列之间的间隔为 40 像素 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-gap:40px;</span><br><span class="line">  -moz-column-gap:40px;        /* Firefox */</span><br><span class="line">  -webkit-column-gap:40px;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-列规则"><a href="#CSS3-列规则" class="headerlink" title="CSS3 列规则"></a>CSS3 列规则</h3><p><strong>column-rule属性设置列之间的宽度、样式和颜色规则。</strong><br>语法： column-rule : column-rule-width | column-rule-style | column-rule-color</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  column-rule:3px outset #ff0000;</span><br><span class="line">  -moz-column-rule:3px outset #ff0000;       /* Firefox */</span><br><span class="line">  -webkit-column-rule:3px outset #ff0000;    /* Safari and Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column-count</td><td>规定元素应该被分隔的列数。</td></tr><tr><td>column-fill</td><td>规定如何填充列。</td></tr><tr><td>column-gap</td><td>规定列之间的间隔。</td></tr><tr><td>column-rule</td><td>设置所有 column-rule-* 属性的简写属性。</td></tr><tr><td>column-rule-width</td><td>规定列之间规则的宽度。</td></tr><tr><td>column-rule-style</td><td>规定列之间规则的样式。</td></tr><tr><td>column-rule-color</td><td>规定列之间规则的颜色。</td></tr><tr><td>column-span</td><td>规定元素应该横跨的列数。</td></tr><tr><td>column-width</td><td>规定列的宽度。</td></tr><tr><td>columns</td><td>语法 : column-width column-count。</td></tr></tbody></table><h2 id="CSS3-用户界面"><a href="#CSS3-用户界面" class="headerlink" title="CSS3 用户界面"></a>CSS3 用户界面</h2><h3 id="CSS3-resize"><a href="#CSS3-resize" class="headerlink" title="CSS3 resize"></a>CSS3 resize</h3><p><strong>在 CSS3中resize属性设置是否可由用户调整元素尺寸。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置div可以由用户调整大小 */</span><br><span class="line">div&#123;</span><br><span class="line">  resize:both;</span><br><span class="line">  overflow:auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CSS3-box-sizing"><a href="#CSS3-box-sizing" class="headerlink" title="CSS3 box-sizing"></a>CSS3 box-sizing</h3><p><strong>box-sizing属性允许您以确切的方式定义适应某个区域的具体内容。边框计算在width中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 规定两个并排的带边框方框 */</span><br><span class="line">div&#123;</span><br><span class="line">  box-sizing:border-box;</span><br><span class="line">  -moz-box-sizing:border-box;        /* Firefox */</span><br><span class="line">  -webkit-box-sizing:border-box;     /* Safari */</span><br><span class="line">  width:50%;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-outline-offset"><a href="#CSS3-outline-offset" class="headerlink" title="CSS3 outline-offset"></a>CSS3 outline-offset</h3><p><strong>outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</strong><br>轮廓与边框有两点不同：</p><ul><li>轮廓不占用空间；</li><li>轮廓可能是非矩形；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 规定边框边缘之外 15 像素处的轮廓 */</span><br><span class="line">div&#123;</span><br><span class="line">  border:2px solid black;</span><br><span class="line">  outline:2px solid red;</span><br><span class="line">  outline-offset:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1660027998787.png" alt="outline-offset"></p><h1 id="css：inline-block-的-div-之间的空隙，原因及解决"><a href="#css：inline-block-的-div-之间的空隙，原因及解决" class="headerlink" title="css：inline-block 的 div 之间的空隙，原因及解决"></a>css：inline-block 的 div 之间的空隙，原因及解决</h1><p>display:inline-block布局的元素<strong>在chrome下会出现几像素的间隙</strong>，原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一行以保持代码的整齐可读性，<font color="#FF00FF">即inline-block布局的元素在编辑器里不在同一行</font>，即存在换行符，因此这就是著名的<font color="#FF00FF">inline-block“换行符/空格间隙问题”</font>。<font color="#FF8C00">如果inline-block元素间有空格或是换行产生了间隙，那是正常的，应该的。如果没有空格与间隙才是不正常的（IE6/7 block水平元素）。</font><br><strong>解决方法：</strong></p><ol><li>把img标签的display属性改成block：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img&#123;dispaly:block;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把div中的字体大小设为0：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;font-size:0;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果是img，修改img的vertical-align属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img&#123;vertical-align:buttom;&#125;</span><br><span class="line">img&#123;vertical-align:middle;&#125;</span><br><span class="line">img&#123;vertical-align:top;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>移除标签间的空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式二：在标签结束处消除换行符</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式三：HTML注释标签</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>布局(第十一天)</title>
    <link href="https://merlynr.github.io/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2022-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="未知高度元素垂直居中、垂直居中的实现方式有哪些"><a href="#未知高度元素垂直居中、垂直居中的实现方式有哪些" class="headerlink" title="未知高度元素垂直居中、垂直居中的实现方式有哪些"></a>未知高度元素垂直居中、垂直居中的实现方式有哪些</h1><ol><li>绝对定位+css3 transform:translate(-50%，-50%)</li></ol><p><img src="http://files.shanqianche.cn/20228/1659665882690.png" alt="绝对定位+CSS"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;</span><br><span class="line">  left:50%;</span><br><span class="line">  -webkit-transform:translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>css3 的flex布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  align-self:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>table布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">          &lt;div&gt;sadgsdgasgd&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wrap&#123;</span><br><span class="line">  display:table;</span><br><span class="line">  text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  background:#ccc;</span><br><span class="line">  display:table-cell;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">&#125;</span><br><span class="line">.child div&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:150px;</span><br><span class="line">    background:red;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现图片垂直居中"><a href="#实现图片垂直居中" class="headerlink" title="实现图片垂直居中"></a>实现图片垂直居中</h1><ol><li>使用flex实现图片垂直居中</li></ol><blockquote><p>利用 display: flex;align-items: center 实现垂直居中。flex可能不是实现垂直居中最好的选择，<strong>因为IE8,9并不支持它。</strong></p></blockquote><p><img src="http://files.shanqianche.cn/20228/1659666725528.png" alt="垂直居中"><br>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;flexbox&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123; background:#999&#125;</span><br><span class="line">.flexbox&#123;width: 300px;height: 250px;background:#fff;display: flex;align-items: center&#125;</span><br><span class="line">.flexbox img&#123;width: 100px;height: 100px;align-items: center;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Display: table;实现img图片垂直居中</li></ol><p>给最外层的div设置display属性为table;img的父元素div设置display:table-cell,vertical-align: middle;<strong>如果你也想实现水平居中，你可以给最外层的div元素添加text-align: center属</strong>性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tablebox&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;imgbox&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tablebox&#123;width: 300px;height: 250px;background: #fff;display: table&#125;</span><br><span class="line">#imgbox&#123;display: table-cell;vertical-align: middle;&#125;</span><br><span class="line">#imgbox img&#123;width: 100px&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>用绝对定位实现垂直居中（推荐-兼容性好）</li></ol><ul><li>给img的父元素添加相对定位属性（position: relative），同时，要给子元素也就是图片img元素添加绝对定位属性（position: absolute）。</li><li>将图片元素的top属性设置为50%。</li><li>现在我们需要给img元素设置一个负的margin-top值，<font color="#FF00FF">这个值为你想要实现垂直居中的元素高度的一半，*如果不确定元素的高度，可以不使用margin-top，而是使用transform:translateY(-50%);属性</font>。</li></ul><p>记住：如果你想要同时实现水平居中，那么你可以用实现垂直居中的一样的技巧来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;background: #ccc;&#125;</span><br><span class="line">.posdiv&#123;width: 300px;height: 250px;background: #fff;position: relative; margin:0 auto&#125;</span><br><span class="line">.posdiv img&#123;width: 100px;position: absolute;top: 50%;margin-top: -50px;&#125;</span><br></pre></td></tr></table></figure><h1 id="设置斑马线表格-纯css"><a href="#设置斑马线表格-纯css" class="headerlink" title="设置斑马线表格(纯css)"></a>设置斑马线表格(纯css)</h1><p><img src="http://files.shanqianche.cn/20228/1659667287150.png" alt="斑马线表格"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;斑马线表格&lt;/title&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"> *&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  /*清处浏览器默认设置*/</span><br><span class="line"> &#125;</span><br><span class="line"> table&#123;</span><br><span class="line">  /*表格的外边距和大小*/</span><br><span class="line">  margin: 10px 0 0 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  border-spacing: 0;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">  /*collapse 表格单元格边框合并 </span><br><span class="line">   border-spacing 表格单元格间距为零</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> caption&#123;</span><br><span class="line">  font: 30px &quot;楷体&quot;;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  /*表格标题*/</span><br><span class="line"> &#125;</span><br><span class="line"> td&#123;</span><br><span class="line">  width: 32%;</span><br><span class="line">  height: 50px;</span><br><span class="line">  /*单元格大小*/</span><br><span class="line"> &#125;</span><br><span class="line"> tbody td&#123;</span><br><span class="line">   border: 1px solid;</span><br><span class="line">   /*表格主体的边框*/</span><br><span class="line"> &#125;</span><br><span class="line"> thead&#123;</span><br><span class="line">  background-color: #A2A5A7;</span><br><span class="line">  /*表格头部*/</span><br><span class="line"> &#125;</span><br><span class="line"> tr:hover&#123;</span><br><span class="line">  background-color: #66D9EF;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  /*鼠标悬停在表格上时，表格的背景和鼠标的形状*/</span><br><span class="line"> &#125;</span><br><span class="line"> table tbody tr:nth-child(even)&#123;</span><br><span class="line">  background-color: #8F908A;</span><br><span class="line">  box-shadow: inset 0 5px rgba(255,255,255,0.5);</span><br><span class="line">  /*even为偶数行 odd为奇数行</span><br><span class="line">    设置表格的主体部分偶数行的样式</span><br><span class="line">    shadow 阴影  inset将外部阴影改为内部阴影</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr th:first-child</span><br><span class="line"> &#123;</span><br><span class="line">  /*表头部分th 第一个th左上角设置圆角*/</span><br><span class="line">  border-radius: 15px 0 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr td:last-child&#123;</span><br><span class="line">  /*最后一个单元格右上角设置圆角*/</span><br><span class="line">  border-radius: 0 15px 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;table&gt;</span><br><span class="line"> &lt;caption&gt;斑马线表格&lt;/caption&gt;</span><br><span class="line"> &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;th&gt;&lt;/th&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/thead&gt;</span><br><span class="line"> &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/tbody&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">  &lt;/tfoot&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="文本元素如何居中"><a href="#文本元素如何居中" class="headerlink" title="文本元素如何居中"></a>文本元素如何居中</h1><ol><li>CSS设置文字水平居中</li></ol><p>在CSS中可以使用text-align属性来设置文字水平居中。该属性规定元素中的文本的水平对齐方式，通过使用center值设置文本居中。<br>text-align是一个基本的属性，它会影响一个元素中的文本行互相间的对齐方式。值left、right和center会导致元素中的文本分别左对齐、右对齐和居中，想要使文本居中，直接使用center即可。<br><strong>该属性设置文本和img标签等一些内联对象（或与之类似的元素）的居中</strong>。<br><strong>该属性有如下几个特点：</strong></p><ul><li>text-align的center应用在一个容器上，它只针对容器里面的文字以及容器里面的display为inline或者inline-block的容器，<font color="#FF00FF">如果里面的容器display为block，则里面的容器的内容不会居中</font>。</li><li>text-align<font color="#FF00FF">具有向下传递性，会不断地向子元素传递。如果设置一个div，则其子div中的内容也会居中</font>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 水平居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: pink;</span><br><span class="line">                text-align:center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 水平居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>CSS设置字体垂直居中</li></ol><p><strong>单行文字垂直居中</strong><br>对于单行文本，我们只需要将文本行高(line-height属性)和所在区域高度(height)设置一致就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                line-height:300px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>多行文本垂直居中</strong><br>说明：多行文本垂直居中分为两种情况，一个是父级元素高度不固定，随着内容变化；另一个是父级元素高度固定。</p><ul><li>父级元素高度不固定</li></ul><p>父级高度不固定的时，高度只能通过内部文本来撑开。所以，我们可以通过设置内填充（padding）的值来使文本看起来垂直居中<font color="#FF00FF">，只需设置padding-top和padding-bottom的值相等</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                margin: 50px auto;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                padding: 50px 20px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>父级元素高度固定</li></ul><p><font color="#FF00FF">使用vertical-align:middle +display:table-cell 使文字垂直居中</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .box &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: paleturquoise;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        display: table-cell;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字。</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：vertical-align:middle +display:table-cell能够使单行文字、多行文字都居中。<font color="#FF00FF">但是因为 table-cell 是 inline 类型，所以会导致原来的块级元素每个 div 一行移动到了同一行。如果需要分列两行，需要在外面额外添加容器对位置进行控制</font></p></blockquote><h1 id="用flex实现九宫格讲思路"><a href="#用flex实现九宫格讲思路" class="headerlink" title="用flex实现九宫格讲思路"></a>用flex实现九宫格讲思路</h1><blockquote><p>利用了padding-top和flex-wrap:wrap，当设置background-color时，是包括盒子模型中的content和padding的，但是为什么不设置height呢？因为父元素没有高度，所以定义height:30%是没有用的，且若想每个block都为正方形，最好的方式就是设置padding-top/padding-bottom：a%，因为此时的百分比是父元素宽度的百分比，而width也为父元素宽度的百分比，所以block可以成为正方形。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .block &#123;</span><br><span class="line">      padding-top: 30%;</span><br><span class="line">      margin-top: 3%;</span><br><span class="line">      border-radius: 10%;</span><br><span class="line">      background-color: orange;</span><br><span class="line">      width: 30%;</span><br><span class="line">    &#125;</span><br><span class="line">    .container-flex2 &#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-wrap: wrap;</span><br><span class="line">      justify-content: space-around;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container-flex2&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CSS实现一个等腰三角形"><a href="#CSS实现一个等腰三角形" class="headerlink" title="CSS实现一个等腰三角形"></a>CSS实现一个等腰三角形</h1><p>主要是通过把宽高设置成0，边框宽度设置宽一些，设置其中三个边透明，只留一个边显示</p><p>等边三角形是特殊的等腰三角形，它的三条边都相等，顶角为60度，而高是边长的3^(1/2)/2倍，约等于0.866……假设底为160px，则高约为138.56px，因此要做边长为160px的等边三角形，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">             width:0px;height:0px;margin:100px auto;</span><br><span class="line">             border-left:80px solid transparent; </span><br><span class="line">             border-right:80px solid transparent; </span><br><span class="line">             border-bottom:138.56px solid #A962CE; /*--三角形的高--*/</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>用CSS实现一个等边三角形：<br>根据各个边之间的长度关系，我们易知：需要展示的边框的宽度：相邻的透明的边框的宽度 = √3 ：1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    border-left: 10px solid transparent;</span><br><span class="line">    border-right: 10px solid transparent;;</span><br><span class="line">    border-top: 17.32px solid transparent;</span><br><span class="line">    border-bottom: 17.32px solid red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现扇形、圆形"><a href="#实现扇形、圆形" class="headerlink" title="实现扇形、圆形"></a>实现扇形、圆形</h1><ol><li>圆形：</li></ol><p>border-radius圆角的四个值按顺序取值分别为：左上、右上、右下、左下。这里只设置一个值，代表四个角的取值都为为50%</p><p>原理：border-radius: 50% 弯曲元素的边框以创建圆。<br>由于圆在任何给定点具有相同的半径，故宽和高都需要保证一样的值，不同的值将创建椭圆。<br>2. 扇形：</p><ul><li> 利用border-radius，实现90度角的扇形：</li></ul><p>原理：<br>左上角是圆角，其余三个角都是直角：左上角的值为宽和高一样的值，其他三个角的值不变（等于0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;sector&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .sector &#123;</span><br><span class="line">        border-radius: 80px 0 0;</span><br><span class="line">        width: 80px;</span><br><span class="line">        height: 80px;</span><br><span class="line">        background: #666;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>绘制任意角度的扇形</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669167367.png" alt="任意角度扇形"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div class=&quot;shanxing shanxing1&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个85度扇形*/--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing2&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--*绘制一个向右扇形，90度扇形*--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing3&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个颜色扇形 */--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing4&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--/*绘制一个不同颜色半圆夹角 */--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing5&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .shanxing&#123;</span><br><span class="line">          position: relative;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: yellow;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx1&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px); /*这个clip属性用来绘制半圆，在clip的rect范围内的内容显示出来，使用clip属性，元素必须是absolute的 */</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an1 2s infinite linear; */</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx2&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px);</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an2 2s infinite linear;*/</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个60度扇形*/</span><br><span class="line">      .shanxing1 .sx1&#123;transform: rotate(-30deg);&#125;</span><br><span class="line">      .shanxing1 .sx2&#123;transform: rotate(-150deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个85度扇形*/</span><br><span class="line">      .shanxing2 .sx1&#123;transform: rotate(-45deg);&#125;</span><br><span class="line">      .shanxing2 .sx2&#123;transform: rotate(-140deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个向右扇形，90度扇形*/</span><br><span class="line">      .shanxing3 .sx1&#123;transform: rotate(45deg);&#125;</span><br><span class="line">      .shanxing3 .sx2&#123;transform: rotate(-45deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个颜色扇形 */</span><br><span class="line">      .shanxing4 .sx1&#123;transform: rotate(45deg);background-color: #fff;&#125;</span><br><span class="line">      .shanxing4 .sx2&#123;transform: rotate(-45deg);background-color: #fff;&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个不同颜色半圆夹角 */</span><br><span class="line">      .shanxing5 .sx1&#123;transform: rotate(45deg);background-color: #f00;&#125;</span><br><span class="line">      .shanxing5 .sx2&#123;transform: rotate(-45deg);background-color: #0f0;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="旋转45度"><a href="#旋转45度" class="headerlink" title="旋转45度"></a>旋转45度</h1><p><strong>CSS中使用rotate方法来实现对元素的旋转，在参数中加入角度值，旋转方式为顺时针旋转。</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669277112.png" alt="旋转"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Transform旋转&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        margin: 150px auto;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">        text-align: center;</span><br><span class="line">        -webkit-transform: rotate(45deg); /* for Chrome || Safari */</span><br><span class="line">        -moz-transform: rotate(45deg); /* for Firefox */</span><br><span class="line">        -ms-transform: rotate(45deg); /* for IE */</span><br><span class="line">        -o-transform: rotate(45deg); /* for Opera */</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;黄色div&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="画-0-5px-的直线"><a href="#画-0-5px-的直线" class="headerlink" title="画 0.5px 的直线"></a>画 0.5px 的直线</h1><h2 id="使用scale缩放"><a href="#使用scale缩放" class="headerlink" title="使用scale缩放"></a>使用scale缩放</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">    &lt;p&gt;1px + scaleY(0.5)&lt;/p&gt;</span><br><span class="line">    &lt;div class=&quot;hr scale-half&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669346282.png" alt="效果"><br><strong>Chrome/Safari都变虚了，只有Firefox比较完美看起来是实的而且还很细，效果和直接设置0.5px一样。</strong> 所以通过transform: scale会导致Chrome变虚了，而粗细几乎没有变化。但是如果加上transform-origin: 50% 100%：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">    transform-origin: 50% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chrome现在的效果如下</p><p><img src="http://files.shanqianche.cn/20228/1659669651765.png" alt="chrome"></p><h2 id="线性渐变linear-gradient"><a href="#线性渐变linear-gradient" class="headerlink" title="线性渐变linear-gradient"></a>线性渐变linear-gradient</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.gradient &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: linear-gradient(0deg, #fff, #000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;linear-gradient(0deg, #fff, #000)&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr gradient&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669787124.png" alt="效果"></p><p>inear-gradient(0deg, #fff, #000)的意思是：<font color="#FF00FF">渐变的角度从下往上</font>，<font color="#FF00FF">从白色#fff渐变到黑色#000，而且是线性的，在高清屏上，1px的逻辑像素代表的物理（设备）像素有2px，由于是线性渐变，所以第1个px只能是#fff，而剩下的那个像素只能是#000，这样就达到了画一半的目的。</font></p><h2 id="boxshadow"><a href="#boxshadow" class="headerlink" title="boxshadow"></a>boxshadow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.boxshadow &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: none;</span><br><span class="line">    box-shadow: 0 0.5px 0 #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;box-shadow: 0 0.5px 0 #000&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr boxshadow&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中width=device-width<strong>表示将viewport视窗的宽度调整为设备的宽度，</strong> 这个宽度通常是指物理上宽度。默认的缩放比例为1时，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。但是我们可以改成0.5，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。</p><h1 id="css-切换主题"><a href="#css-切换主题" class="headerlink" title="css 切换主题"></a>css 切换主题</h1><h2 id="主题层"><a href="#主题层" class="headerlink" title="主题层"></a>主题层</h2><p>这应该是实现主题功能的一种最常用的手段了。首先，我们的站点会有一个最初的基础样式（或者叫默认样式）；然后通过添加一些后续的额外的CSS来覆盖与重新定义部分样式。</p><p><strong>具体实现</strong><br>首先，我们引入基础的样式components.*文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br></pre></td></tr></table></figure><p>其中components.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    background-color: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，假设我们的*<em>某个主题的样式文件存放于theme.<em>文件：</em></em><br>对应于components.tabs，theme.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们只需要引入主题样式文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br><span class="line"></span><br><span class="line">@import &quot;theme.tabs&quot;;</span><br></pre></td></tr></table></figure><p>这样当前的样式就变为了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    /* background-color: gray; */</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>实现方式简单<br>可以实现将主题应用与所有元素<br><strong>缺点</strong><br>过多的冗余代码<br>许多的CSS其实是无用的，浪费了带宽<br>把样式文件切分到许多文件中，更加琐碎</p><h2 id="有状态的主题"><a href="#有状态的主题" class="headerlink" title="有状态的主题"></a>有状态的主题</h2><blockquote><p>该方式可以实现基于条件选择不同的主题皮肤，并允许用户在客户端随时切换主题。非常适合需要客户端样式切换功能，或者需要对站点某一部分（区域）进行独立样式设置的场景。</p></blockquote><p><strong>具体实现</strong><br>还是类似上一节中 Tab 的这个例子，我们可以将 Tab 部分的 (S)CSS 改为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: gray;</span><br><span class="line"></span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们<font color="#FF00FF">把.t-red与.t-blue称为 Tab 元素的上下文环境（context）。Tab 元素会根据 context 的不同展示出不同的样式。</font><br>最后我们给body元素加上这个开关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;tabs&quot;&gt;...&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>此时 Tab 的颜色为红色。</p><p>当我们将t-red改为t-blue时，Tab 就变为了蓝色主题。</p><p>进一步的，<font color="#FF00FF">我们可以创建一些 (S)CSS 的 util class（工具类）来专门控制一些 CSS 属性</font>，帮助我们更好地控制主题。例如我们使用如下的.u-color-current类来控制不同主题下的字体颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.u-color-current &#123;</span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们在不同主题上下文环境下使用.u-color-current时，就<font color="#FF00FF">可以控制元素展示出不同主题的字体</font>颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;h1 class=&quot;page-title u-color-current&quot;&gt;...&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>将许多主题放在了同一处代码中<br>非常适合主题切换的功能<br>非常适合站点局部的主题化<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>有时有点也是缺点，将许多主题混杂在了同一块代码中<br>可能会存在冗余</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>这种方式其实是在开发侧来实现主题样式的区分与切换的。基于不同的配置，配合一些开发的自动化工具，我们可以在开发时期根据配置文件，编译生成不同主题的 CSS 文件。</p><p>它一般会结合使用一些 CSS 预处理器，可以对不同的 UI 元素进行主题分离，并且向客户端直接提供主题样式下最终的 CSS。</p><p><strong>具体实现</strong><br>我们还是以 Sass 为例：<br>首先会有一份 Sass 的配置文件，例如settings.config.scss，在这份配置中定义当前的主题值以及一些其他变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$theme: red;</span><br></pre></td></tr></table></figure><p>然后对于一个 Tab 组件，我们这么来写它的 Sass 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if ($theme == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们在其之前引入相应的配置文件后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.config&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br></pre></td></tr></table></figure><p>Tab 组件就会呈现出红色主题。</p><p>当然，我们也可以把我们的settings.config.scss做的更健壮与易扩展一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$config: (</span><br><span class="line">    theme: red,</span><br><span class="line">    env: dev,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 从$config中获取相应的配置变量</span><br><span class="line">@function config($key) &#123;</span><br><span class="line">    @return map-get($config, $key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前相比，这时候使用起来只需要进行一些小的修改，将直接使用theme变量改为调用config方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if (config(theme) == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>访问网站时，只会传输所需的 CSS，节省带宽<br>将主题的控制位置放在了一个地方（例如上例中的settings.config.scss文件）<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>在 Sass 中会有非常多逻辑代码<br>只支持有限数量的主题<br>主题相关的信息会遍布代码库中<br>添加一个新主题会非常费劲</p><h2 id="主题调色板"><a href="#主题调色板" class="headerlink" title="主题调色板"></a>主题调色板</h2><p>这种方式有些类似于我们绘图时，预设了一个调色板（palette），然后使用的颜色都从其中取出一样。<br>在实现主题功能时，我们也会有一个类似的“调色板”，其中定义了主题所需要的各种属性值，之后再将这些信息注入到项目中。<br>当你经常需要为客户端提供完全的定制化主题，并且经常希望更新或添加主题时，这种模式会是一个不错的选择。</p><p><strong>具体实现</strong></p><p>在方式三中，我们在一个独立的配置文件中设置了一些“环境”变量，来标示当前所处的主题。而在方式四中，我们会更进一步，抽取出一个专门的 palette 文件，用于存放不同主题的变量信息。</p><p>例如，现在我们有一个settings.palette.red.scss文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$color: red;</span><br><span class="line">$color-tabs-background: $color-red;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们的components.tabs.scss文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tabs &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    backgroung-color: $color-tabs-background;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们只需要引入这两个文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.palette.red&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，components.tabs.scss中并没有关于主题的逻辑判断，我们只需要专注于编辑样式，剩下就是选择所需的主题调色板（palette）即可。</p><p><strong>优点</strong><br>编译出来的样式代码无冗余<br>非常适合做一些定制化主题，例如一个公司采购了你们的系统，你可以很方便实现一个该公司的主题<br>可以从一个文件中完全重制出你需要的主题样式<br><strong>缺点</strong><br>由于主要通过设定不同变量，所以代码确定后，能实现的修改范围会是有限的</p><h2 id="用户定制化"><a href="#用户定制化" class="headerlink" title="用户定制化"></a>用户定制化</h2><p>这种模式一般会提供一个个性化配置与管理界面，让用户能自己定义页面的展示样式。<br>“用户定制化”在社交媒体产品、SaaS 平台或者是 Brandable Software 中最为常见。<br><strong>具体实现</strong><br>要实现定制化，可以结合方式二中提到的 util class。<br>首先，页面中支持自定义的元素会被预先添加 util class，例如 Tab 元素中的u-user-color-background</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;tabs u-user-color-background&quot;&gt;...&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>此时，u-user-color-background还并未定义任何样式。而当用户输入了一个背景色时，我们会创建一个标签，并将 hex 值注入其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style id=&quot;my-custom&quot;&gt;</span><br><span class="line">    .u-user-color-background &#123;</span><br><span class="line">        background-color: #00ffff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时用户就得到了一个红色的 Tab。</p><p><strong>优点</strong><br>不需要开发人员的输入信息（是用户定义的）<br>允许用户拥有自己“独一无二”的站点<br>非常实用<br><strong>缺点</strong><br>不需要开发人员的输入信息也意味着你需要处理更多的“不可控”情况<br>会有许多的冗余<br>会浪费 CSS 的带宽<br>失去部分 CSS 的浏览器缓存能力</p><h1 id="布局-三栏布局-平均分布"><a href="#布局-三栏布局-平均分布" class="headerlink" title="布局: 三栏布局(平均分布)"></a>布局: 三栏布局(平均分布)</h1><ol><li>flex: 设置父级弹性盒，子盒子三个各占1份</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.Grid &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Grid-cell &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  background: #eee;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>flex 百分比</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>流式布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.col3 &#123;</span><br><span class="line">  width: 33.33%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动端-1px-问题"><a href="#移动端-1px-问题" class="headerlink" title="移动端 1px 问题"></a>移动端 1px 问题</h1><p><strong>问题：</strong> 1px 的边框，在高清屏下，移动端的1px 会很粗</p><p><strong>产生原因</strong><br>那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio=物理像素 /CSS像素</span><br></pre></td></tr></table></figure><p>目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。<br><strong>解决方案</strong></p><ol><li>WWDC对iOS统给出的方案</li></ol><p>在 WWDC大会上，给出来了1px方案，<strong>当写 0.5px的时候，就会显示一个物理像素宽度的 border，</strong> 而不是一个css像素的 border。 所以在iOS下，你可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:0.5px solid #E5E5E5</span><br></pre></td></tr></table></figure><p>可能你会问为什么在3倍屏下，不是0.3333px 这样的？经过测试，在Chrome上模拟iPhone 8Plus，发现小于0.46px的时候是显示不出来。<br><strong>总结：</strong><br>优点：简单，没有副作用<br>缺点：支持iOS 8+，不支持安卓。后期安卓follow就好了。</p><ol start="2"><li>使用边框图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid transparent;</span><br><span class="line">border-image: url(&#x27;./../../image/96.jpg&#x27;) 2 repeat;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>优点：没有副作用<br>缺点：border颜色变了就得重新制作图片；圆角会比较模糊。</p><ol start="3"><li>使用box-shadow实现</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线</span><br><span class="line">            1px  0  1px -1px #e5e5e5,   //右边线</span><br><span class="line">            0  1px  1px -1px #e5e5e5,   //下边线</span><br><span class="line">            -1px 0  1px -1px #e5e5e5;   //左边线</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：使用简单，圆角也可以实现<br>缺点：模拟的实现方法，仔细看谁看不出来这是阴影不是边框。</p><ol start="4"><li><p>使用伪元素</p><ul><li><p>1条border</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.setOnePx&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  &amp;::after&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    background-color: #e5e5e5;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 1px; /*no*/</span><br><span class="line">    transform: scale(1, 0.5);</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小0.5倍。</p><ul><li>4条border<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.setBorderAll&#123;</span><br><span class="line">     position: relative;</span><br><span class="line">       &amp;:after&#123;</span><br><span class="line">           content:&quot; &quot;;</span><br><span class="line">           position:absolute;</span><br><span class="line">           top: 0;</span><br><span class="line">           left: 0;</span><br><span class="line">           width: 200%;</span><br><span class="line">           height: 200%;</span><br><span class="line">           transform: scale(0.5);</span><br><span class="line">           transform-origin: left top;</span><br><span class="line">           box-sizing: border-box;</span><br><span class="line">           border: 1px solid #E5E5E5;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍</li></ul></li></ul></li></ol><p><strong>总结：</strong><br><font color="#FF00FF">优点：全机型兼容，实现了真正的1px，而且可以圆角。</font><br>缺点：暂用了after 伪元素，可能影响清除浮动。</p><ol start="5"><li>设置viewport的scale值</li></ol><p>这个解决方案是利用<strong>viewport+rem+js</strong> 实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;title&gt;1px question&lt;/title&gt;</span><br><span class="line">      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;</span><br><span class="line">      &lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;        </span><br><span class="line">      &lt;style&gt;</span><br><span class="line">          html &#123;</span><br><span class="line">              font-size: 1px;</span><br><span class="line">          &#125;            </span><br><span class="line">          * &#123;</span><br><span class="line">              padding: 0;</span><br><span class="line">              margin: 0;</span><br><span class="line">          &#125;</span><br><span class="line">          .top_b &#123;</span><br><span class="line">              border-bottom: 1px solid #E5E5E5;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a,.b &#123;</span><br><span class="line">                      box-sizing: border-box;</span><br><span class="line">              margin-top: 1rem;</span><br><span class="line">              padding: 1rem;                </span><br><span class="line">              font-size: 1.4rem;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a &#123;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .b &#123;</span><br><span class="line">              background: #f5f5f5;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);</span><br><span class="line">          //下面是根据设备像素设置viewport</span><br><span class="line">          if (window.devicePixelRatio == 1) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 2) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 3) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          var docEl = document.documentElement;</span><br><span class="line">          var fontsize = 32* (docEl.clientWidth / 750) + &#x27;px&#x27;;</span><br><span class="line">          docEl.style.fontSize = fontsize;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;top_b a&quot;&gt;下面的底边宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;b&quot;&gt;上面的边框宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：全机型兼容，直接写1px不能再方便<br>缺点：适用于新的项目，老项目可能改动大</p><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在解释BFC之前，先说一下文档流。我们常说的文档流其实分为<font color="#FF8C00">定位流、浮动流、普通流</font>三种。而普通流其实就是指BFC中的FC。FC(Formatting Context)，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。</p><p>BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释<font color="#FF8C00">：BFC是Web页面 CSS 视觉渲染的一部分，<strong>用于决定块盒子的布局</strong>及浮动相互影响范围的一个区域</font>。</p><p><strong>注意：</strong> <font color="#FF00FF">一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素</font>。这从另一方角度说明，一个元素不能同时存在于两个BFC中。<font color="#FF8C00">因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。</font></p><h2 id="三种文档流的定位方案"><a href="#三种文档流的定位方案" class="headerlink" title="三种文档流的定位方案"></a>三种文档流的定位方案</h2><h3 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流(Normal flow)"></a>常规流(Normal flow)</h3><ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li><font color="#FF00FF">当position为static或relative，并且float为none时会触发常规流</font>；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul><h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h3><ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</li></ul><h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h3><ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</li></ul><h2 id="BFC触发方式"><a href="#BFC触发方式" class="headerlink" title="BFC触发方式"></a>BFC触发方式</h2><ul><li>根元素，即HTML标签</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为auto、scroll、hidden</li><li>display值为inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>定位元素：position值为absolute、fixed</li></ul><p><strong>注意：</strong> <font color="#FF00FF">display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。</font></p><h2 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h2><p><strong>浏览器对BFC区域的约束规则：</strong></p><ol><li>生成BFC元素的子元素会一个接一个的放置。</li><li>垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素的外边距会折叠(Mastering margin collapsing)</li><li>生成BFC元素的子元素中，每一个子元素左外边距与包含块的左边界相接触（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。</li></ol><p><strong>规则解读：</strong></p><ol><li>内部的Box会在垂直方向上一个接一个的放置</li><li>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素</strong>，反之亦然。我们可以利用BFC的这个特性来做很多事。</p><ol><li>阻止元素被浮动元素覆盖<br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、 display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</li><li>可以包含浮动元素<br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</li><li>阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一 列触发BFC的形式来阻止换行的发生。比如下面栗子的特殊情况</li><li>阻止相邻元素的margin合并<br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平 margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。<br>这里给任一个相邻块级盒子的外面包一个div，通过改变此div的属性使两个原盒子分属于两个不同的BFC，以此来阻止margin重叠。</li></ol><h1 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h1><p><strong>适配思路</strong><br>设计稿（750*1334） —&gt; 开发 —&gt; 适配不同的手机屏幕，使其显得合理</p><p><strong>原则</strong><br>开发时方便，写代码时设置的值要和标注的 160px 相关<br>方案要适配大多数手机屏幕，并且无 BUG<br>用户体验要好，页面看着没有不适感</p><p><strong>思路</strong><br>写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用<br>按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px<br>固定尺寸+弹性布局，不需要缩放</p><p><strong>viewport 适配</strong><br>根据设计稿标准（750px 宽度）开发页面，写完后页面及元素自动缩小，适配 375 宽度的屏幕</p><p>在 head 里设置如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=750,initial-scale=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>initial-scale = 屏幕的宽度 / 设计稿的宽度</strong><br>为了适配其他屏幕，需要动态的设置 initial-scale 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    const mobileAdapter = () =&gt; &#123;</span><br><span class="line">      let scale = screen.width / WIDTH</span><br><span class="line">      let content = `width=$&#123;WIDTH&#125;, initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;`</span><br><span class="line">      let meta = document.querySelector(&#x27;meta[name=viewport]&#x27;)</span><br><span class="line">      if (!meta) &#123;</span><br><span class="line">        meta = document.createElement(&#x27;meta&#x27;)</span><br><span class="line">        meta.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;)</span><br><span class="line">        document.head.appendChild(meta)</span><br><span class="line">      &#125;</span><br><span class="line">      meta.setAttribute(&#x27;content&#x27;,content)</span><br><span class="line">    &#125;</span><br><span class="line">    mobileAdapter()</span><br><span class="line">    window.onorientationchange = mobileAdapter //屏幕翻转时再次执行</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</strong></p><p><strong>vw 适配（部分等比缩放）</strong></p><ol><li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，<font color="#FF00FF">换成vw为 (100/750)*32 vw</font></li><li>对于需要等比缩放的元素，CSS使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li></ol><p>关于换算，为了开发方便，利用自定义属性，CSS变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    //:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw</span><br><span class="line">    document.documentElement.style.setProperty(&#x27;--width&#x27;, (100 / WIDTH)) </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>注意此时，meta 里就不要去设置缩放了</strong></p><p>业务代码里就可以写，实现了按需缩放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: calc(28vw * var(--width))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rem 适配</strong></p><p>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标是基于此宽度标注）<br>开始开发，对设计稿的标注进行转换<br>对于需要等比缩放的元素，CSS使用转换后的单位<br>对于不需要缩放的元素，比如边框阴影，使用固定单位px</p><p>假设设计稿的某个字体大小是 40px, 手机屏幕上的字体大小应为 420/750*40 = 22.4px (体验好)，换算成 rem（相对于 html 根节点，假设 html 的 font-size = 100px,）则这个字体大小为 0.224 rem，写样式时，对应的字体设置为 0.224 rem 即可，其他元素尺寸也做换算.</p><p><strong>但是有问题</strong><br>举个例子，设计稿的标注 是40px，写页面时还得去做计算，很麻烦（全部都要计算）<br>能不能规定一下，看到40px ,就应该写40/100 = 0.4 rem,这样看到就知道写多少了（不用计算），此时的html 的 font-size 就不能是 100px 了，应该为 (420*100)/750 = 56px，100为我们要规定的那个参数<br><strong>根据不同屏幕宽度，设置 html 的 font-size 值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750 //设计稿尺寸</span><br><span class="line">    const setView = () =&gt; &#123;</span><br><span class="line">      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    window.onorientationchange = setView</span><br><span class="line">    setView()</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于需要等比缩放的元素，CSS使用转换后的单位</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: .28rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于不需要缩放的元素，比如边框阴影，使用固定单位px</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header &gt; span.active &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  border-bottom: 2px solid rgba(255, 255, 255, 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 html 的 font size = 1px 的话，就可以写 28 rem 了，更方便了，但是浏览器对字体大小有限制，设为 1px 的话，在浏览器中是失效的，会以 12px（或者其他值） 做一个计算 , 就会得到一个很夸张的结果，所以可以把 html 写的大一些<br><strong>使用 sass 库时</strong><br>JS 处理还是一样的，但看着好看些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  @return $px * 1rem / 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header &#123;</span><br><span class="line">  font-size: px2rem(28);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的三种适配方案，都是等比缩放，放到 ipad 上时（设计稿以手机屏幕设计的），页面元素会很大很丑，有些场景下，并不需要页面整体缩放（viewport 自动处理的也很好了），所以有时只需要合理的布局即可。</p><p><strong><font color="#FF8C00">弹性盒适配（合理布局）</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure><p>使用 flex 布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#FF00FF">总结一下，什么样的页面需要做适配（等比缩放）呢</font></strong></p><ol><li>页面中的布局是栅格化的</li></ol><p>换了屏幕后，到底有多宽多高很难去做设置，整体的都需要改变，所以需要整体的缩放</p><ol start="2"><li>头屏大图，宽度自适应，高度固定的话，对于不同的屏幕，形状就会发生改变（放到ipad上就变成长条了），宽度变化后，高度也要保持等比例变化</li><li>大屏，需要适配很多的电视尺寸，要求撑满屏幕，不能有滚动条，此时若换个屏幕</li></ol><p>此时需要考虑小元素用 vh, 宽和高都用 vh 去表示，中间的大块去自适应，这就做到了大屏的适配，屏幕变小了，整体变小了（体验更好），中间这块撑满了屏幕</p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>模块化(第九天)</title>
    <link href="https://merlynr.github.io/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/"/>
    <id>https://merlynr.github.io/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1><p>CommonJS规范加载模块是<font color="#FF8C00">同步</font>的，只有加载完成，才能执行后面的操作。<br>CommonJS规范中的module、exports和require</p><ul><li>每个文件就是一个模块，有自己的作用域。每个模块内部，<font color="#FF00FF">module变量代表当前模块，是一个对象，它的exports属性（即module.exports）是对外的接口。</font></li><li><font color="#FF8C00">module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量</font>。</li><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let exports = module.exports;</span><br></pre></td></tr></table></figure><blockquote><p> //name.js<br>  exports.name = function(){return ‘李婷婷’}; //导出<br>  //getName.js<br>  let getName = require(‘name’); //引入</p></blockquote><p><font color="#FF00FF">不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</font>：如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x)&#123;console.log(x)&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出</font>。</p><p>CommonJS模块导入用require，导出用module.exports。导出的对象需注意，<font color="#FF00FF">如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值</font>。导入的参数，是可以随意改动的，所以使用时要注意</p><h1 id="ES6-module-和-CommonJS-module-的区别"><a href="#ES6-module-和-CommonJS-module-的区别" class="headerlink" title="ES6 module 和 CommonJS module 的区别"></a>ES6 module 和 CommonJS module 的区别</h1><ul><li>为CommonJS的require语法是同步的，所以就导致了<strong>CommonJS</strong>模块规范<font color="#FF00FF">只适合用在服务端</font>，而<strong>ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用</strong> ；</li><li>CommonJS 模块输出的是一个<font color="#FF00FF">值的拷贝</font>，而ES6 模块输出的是<font color="#FF00FF">值的引用</font>；</li><li>CommonJS 模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能</li><li>因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。<font color="#FF00FF">CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</font></li><li>关于模块顶层的this指向问题，<font color="#FF00FF">在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined；</font></li><li>关于两个模块互相引用的问题，<font color="#FF00FF">在ES6模块当中，是支持加载CommonJS模块的。但是反过来，CommonJS并不能requireES6模块，在NodeJS中，两种模块方案是分开处理的</font>。<h1 id="ES6-module、CommonJS-module-循环引用的问题"><a href="#ES6-module、CommonJS-module-循环引用的问题" class="headerlink" title="ES6 module、CommonJS module 循环引用的问题"></a>ES6 module、CommonJS module 循环引用的问题</h1></li><li><em>循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本</em>*</li></ul><ol><li><font color="#FF00FF">CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</li><li><font color="#FF00FF">ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。</font></li></ol><p>CommonJS模块规范主要适用于后端Node.js，后端Node.js是<font color="#FF00FF">同步</font>模块加载，所以在模块循环引入时模块已经执行完毕。推荐前端工程中使用ES6的模块规范，<font color="#FF8C00">通过安装Babel转码插件支持ES6模块引入</font>的语法。</p><h2 id="CommonJS模块的加载原理"><a href="#CommonJS模块的加载原理" class="headerlink" title="CommonJS模块的加载原理"></a>CommonJS模块的加载原理</h2><p>CommonJS模块就是一个脚本文件，require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成该模块的一个说明对象。</p><blockquote><p>{<br>    id: ‘’,  //模块名，唯一<br>    exports: {  //模块输出的各个接口<br>        …<br>    },<br>    loaded: true,  //模块的脚本是否执行完毕<br>    …<br>}</p></blockquote><p>以后用到这个模块时，就会到对象的exports属性中取值。<font color="#FF8C00">即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。</font></p><p><font color="#FF00FF">CommonJS模块是加载时执行，即脚本代码在require时就全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</p><p><strong>案例说明：</strong></p><blockquote><p>//a.js<br>exports.done = false;<br>var b = require(‘./b.js’);<br>console.log(‘在a.js中，b.done = %j’, b.done);<br>exports.done = true;<br>console.log(‘a.js执行完毕！’)<br>//b.js<br>exports.done = false;<br>var a = require(‘./a.js’);<br>console.log(‘在b.js中，a.done = %j’, a.done);<br>exports.done = true;<br>console.log(‘b.js执行完毕！’)<br>//main.js<br>var a = require(‘./a.js’);<br>var b = require(‘./b.js’);<br>console.log(‘在main.js中，a.done = %j, b.done = %j’, a.done, b.done);</p></blockquote><p><strong>输出结果如下：</strong></p><blockquote><p>//node环境下运行main.js<br>node main.js<br>在b.js中，a.done = false<br>b.js执行完毕！<br>在a.js中，b.done = true<br>a.js执行完毕！<br>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>JS代码执行顺序如下：</strong><br>1）main.js中先加载a.js，a脚本先输出done变量，值为false，然后加载b脚本，a的代码停止执行，等待b脚本执行完成后，才会继续往下执行。<br>2）b.js执行到第二行会去加载a.js，这时发生循环加载，系统会去a.js模块对应对象的exports属性取值，因为a.js没执行完，从exports属性只能取回已经执行的部分，未执行的部分不返回，所以取回的值并不是最后的值。<br>3）a.js已执行的代码只有一行，exports.done = false;所以对于b.js来说，require a.js只输出了一个变量done，值为false。往下执行console.log(‘在b.js中，a.done = %j’, a.done);控制台打印出：</p><blockquote><p>在b.js中，a.done = false</p></blockquote><p>4）b.js继续往下执行，done变量设置为true，console.log(‘b.js执行完毕！’)，等到全部执行完毕，将执行权交还给a.js。此时控制台输出：</p><blockquote><p>b.js执行完毕！</p></blockquote><p>5）执行权交给a.js后，a.js接着往下执行，执行console.log(‘在a.js中，b.done = %j’, b.done);控制台打印出：</p><blockquote><p>在a.js中，b.done = true</p></blockquote><p>6）a.js继续执行，变量done设置为true，直到a.js执行完毕。</p><blockquote><p>a.js执行完毕！</p></blockquote><p>7）main.js中第二行不会再次执行b.js，直接输出缓存结果。最后控制台输出：</p><blockquote><p>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>总结：</strong></p>]]></content>
    
    
    <summary type="html">每天学习计划</summary>
    
    
    
    <category term="plan" scheme="https://merlynr.github.io/categories/plan/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="daily" scheme="https://merlynr.github.io/tags/daily/"/>
    
  </entry>
  
</feed>
