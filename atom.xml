<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾辈之人，自当自强不息！</title>
  
  <subtitle>博客</subtitle>
  <link href="https://merlynr.github.io/atom.xml" rel="self"/>
  
  <link href="https://merlynr.github.io/"/>
  <updated>2023-02-13T18:42:00.000Z</updated>
  <id>https://merlynr.github.io/</id>
  
  <author>
    <name>Merlynr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核移植</title>
    <link href="https://merlynr.github.io/2023/02/14/Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
    <id>https://merlynr.github.io/2023/02/14/Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/</id>
    <published>2023-02-13T18:42:00.000Z</published>
    <updated>2023-02-13T18:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux内核"><a class="markdownIt-Anchor" href="#linux内核"></a> Linux内核</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h3 id="linux内核特性"><a class="markdownIt-Anchor" href="#linux内核特性"></a> Linux内核特性</h3><ol start="2"><li>可移植性，支持的硬件平台广泛</li><li>超强的网络功能</li><li>多任务多用户系统</li><li>模块化的设计</li></ol><h3 id="五大子系统"><a class="markdownIt-Anchor" href="#五大子系统"></a> 五大子系统</h3><ol><li>进程管理子系统</li><li>内存管理子系统</li><li>文件系统子系统</li><li>网络协议子系统</li><li>设备管理子系统</li></ol><p><img src="https://files.shanqianche.cn/20232/1676358031975.png" alt="五大子系统" /></p><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2><p>目录结构的描述：</p><p><img src="https://files.shanqianche.cn/20232/1676358789549.png" alt="目录结构的描述" /></p><blockquote><p><strong><font color="#FF8C00">与平台相关的kernel会和与平台无关的kernel功能相辅相成，无关的会依赖相关代码</font></strong></p></blockquote><p><img src="https://files.shanqianche.cn/20232/1676359087019.png" alt="相辅相成" /></p><h3 id="平台无关"><a class="markdownIt-Anchor" href="#平台无关"></a> 平台无关</h3><p>与平台无关的目录树：</p><p><img src="https://files.shanqianche.cn/20232/1676358964090.png" alt="与平台无关的目录树" /></p><h3 id="平台有关arch"><a class="markdownIt-Anchor" href="#平台有关arch"></a> 平台有关–arch</h3><p>arch中与平台相关代码：</p><p><img src="https://files.shanqianche.cn/20232/1676359060457.png" alt="arch中与平台相关" /></p><h3 id="命名规律"><a class="markdownIt-Anchor" href="#命名规律"></a> 命名规律</h3><p><strong>当内核中头文件重名如何解决？</strong></p><p><img src="https://files.shanqianche.cn/20232/1676359708418.png" alt="问题" /><br />头文件命名规范：</p><p><img src="https://files.shanqianche.cn/20232/1676359840359.png" alt="头文件命名规范" /></p><h1 id="内核配置"><a class="markdownIt-Anchor" href="#内核配置"></a> 内核配置</h1><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ul><li>配置哪些目录需要编译</li><li>配置哪些文件需要编译<br />编译时到底文件是哪个目录？<br /><strong><font color="#FF8C00">Makefile</font></strong></li></ul><h2 id="方法与思路"><a class="markdownIt-Anchor" href="#方法与思路"></a> 方法与思路</h2><p><strong>配置步骤：</strong></p><ol><li>配置仓库选取，即配置单的修改</li><li>交叉编译器的修改</li><li>体系结构体的选择</li><li>增删改查</li></ol><h3 id="体系结构选择的配置交叉编译方式的选择"><a class="markdownIt-Anchor" href="#体系结构选择的配置交叉编译方式的选择"></a> 体系结构选择的配置，交叉编译方式的选择</h3><p><strong><font color="#DC143C">修改Makefile</font></strong></p><blockquote><p>各个目录的编译有Makefile进行选择编译。</p></blockquote><p><strong>各个子目录Makefile</strong></p><ul><li>obj-y : 编译进内核</li><li>obj-   : 不编译进去</li><li>obj-m: 以模块形式编译<br />条件编译：</li></ul><p><img src="https://files.shanqianche.cn/20232/1676363951788.png" alt="条件编译" /></p><p>**主目录Makefile的修改： **</p><p>修改连接的平台相关代码：【hdr-arch，SRCARCH变量表示平台】</p><p><img src="https://files.shanqianche.cn/20232/1676361796332.png" alt="修改连接的平台相关代码" /></p><p><img src="https://files.shanqianche.cn/20232/1676361955637.png" alt="修改连接的平台相关代码" /></p><ol><li>修改变量，其中SRCARCH等于ARCH</li></ol><p><img src="https://files.shanqianche.cn/20232/1676362046399.png" alt="修改ARCH变量" /><br />SUBARCH默认就是X86的，内核默认配置按照X86。所以根据要求进行修好ARCH这个变量为ARM或其它。</p><ol start="2"><li>编译方式修改</li></ol><p><img src="https://files.shanqianche.cn/20232/1676362801063.png" alt="修改编译方式" /></p><h3 id="确定哪些文件要编译配置单"><a class="markdownIt-Anchor" href="#确定哪些文件要编译配置单"></a> 确定哪些文件要编译—配置单</h3><p>文件命名规范：<strong>CONFIG_XXXXX</strong></p><blockquote><p>选择配置单并移动到主目录下，将其命名为xxxx.config（其中这个配置单并不满足，所以芯片公司会提供默认配置单defconfig） 。<br />修改defconfig使其使用开发板<br />找到系统对应的配置单：</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1676363349776.png" alt="找到系统对应的配置单" /></p><h3 id="make-menuconfig增删改查"><a class="markdownIt-Anchor" href="#make-menuconfig增删改查"></a> make menuconfig（增删改查）</h3><p>menuconfig界面：</p><p><img src="https://files.shanqianche.cn/20232/1676363610169.png" alt="menuconfig" /></p><p><strong>流程：</strong><br />通过一个Kconfig构成menuconfig界面的组成，然后通过menuconfig生成.config文件。最后.config文件构成Makefile的链接，进行编译。</p><blockquote><p>Kconfig–&gt;make menuconfig–&gt;.config–&gt;Makefile</p></blockquote><h1 id="内核编译"><a class="markdownIt-Anchor" href="#内核编译"></a> 内核编译</h1><p>过程：</p><p><img src="https://files.shanqianche.cn/20232/1676365212990.png" alt="编译过程" /></p><ol><li>编译生成vmlinux：OS elf file。（不可被执行的，操作系统可执行文件）</li><li>将vmlinux copy出来到Image</li><li>Image太大，将其压缩为zImage</li><li>为了满足uBoot规则，进行封装格式化为uImage</li></ol>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="1. Linux" scheme="https://merlynr.github.io/categories/1-Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>IIC设备驱动及子系统开发</title>
    <link href="https://merlynr.github.io/2023/02/13/IIC%E5%8D%8F%E8%AE%AE/"/>
    <id>https://merlynr.github.io/2023/02/13/IIC%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-02-13T03:01:00.000Z</published>
    <updated>2023-02-13T03:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li>设备都有自己得设备地址，EEprom存储设备信息，包括设备地址</li></ol><p><img src="https://files.shanqianche.cn/20232/1676290667605.png" alt="设备地址" /></p><p>一般为7位，前四位已经固化好了，其余三位可以通过设计图，上图，看出接地为000，P0，P1也在数据手册中进行描述，为未接，为0. 即AT24LC08（上图有误）地址为1010 000.</p><p><img src="https://files.shanqianche.cn/20232/1676290764830.png" alt="数据手册描述IIC设备地址" /></p><ol start="2"><li>总线速度：标准速度100kbps,快速模式400kbps,高速模式3.4Mbps（一般为100，四百也多一点）</li><li>IIC特点： 半双工（串行方式），仅需要两根线(所以又被称为2-wixe总线)</li></ol><h2 id="设备操作时序"><a class="markdownIt-Anchor" href="#设备操作时序"></a> 设备操作时序</h2><blockquote><p><font color="#FF8C00">IIC从机设备地址是由主机写进去的</font></p></blockquote><ol><li>低电平写，高电平读</li></ol><p><img src="https://files.shanqianche.cn/20232/1676291488761.png" alt="高读低写" /></p><ol><li>IIC开始条件和终止条件，基本时序图如下</li></ol><p><img src="https://files.shanqianche.cn/20232/1676291865962.png" alt="基本时序图" /></p><h2 id="读写时序分析"><a class="markdownIt-Anchor" href="#读写时序分析"></a> 读写时序分析</h2><h3 id="按字节进行写操作"><a class="markdownIt-Anchor" href="#按字节进行写操作"></a> 按字节进行写操作</h3><p>主设备设备地址为1010 000，发送数据，写到地址0x3，写入0x5。</p><p><img src="https://files.shanqianche.cn/20232/1676292418897.png" alt="主设备设备地址为1010 000，发送数据，写到地址0x3，写入0x5" /><br />写入逻辑图</p><p><img src="https://files.shanqianche.cn/20232/1676292629813.png" alt="写入" /></p><h3 id="按页进行写操作"><a class="markdownIt-Anchor" href="#按页进行写操作"></a> 按页进行写操作</h3><p>按页进行写操作如下图。</p><p><img src="https://files.shanqianche.cn/20232/1676292714459.png" alt="按页进行写操作" /></p><h3 id="当前地址读操作"><a class="markdownIt-Anchor" href="#当前地址读操作"></a> 当前地址读操作</h3><p>当前地址读操作如下图。</p><p><img src="https://files.shanqianche.cn/20232/1676292311650.png" alt="当前地址读操作" /></p><h3 id="随机读操作"><a class="markdownIt-Anchor" href="#随机读操作"></a> 随机读操作</h3><p>随机读操作如下图。</p><p><img src="https://files.shanqianche.cn/20232/1676293198697.png" alt="读操作" /></p><h3 id="序列号读操作"><a class="markdownIt-Anchor" href="#序列号读操作"></a> 序列号读操作</h3><p>序列化读操作如下图。</p><p><img src="https://files.shanqianche.cn/20232/1676292161811.png" alt="序列化读操作" /></p><h3 id="读写逻辑"><a class="markdownIt-Anchor" href="#读写逻辑"></a> 读写逻辑</h3><blockquote><p>结合上图随机读操作进行理解。</p></blockquote><p><strong>写数据</strong></p><ol><li><p>装载AT24C08设备地址：0xA0</p></li><li><p>设置IIC开始条件</p></li><li><p>使能ACK</p></li><li><p>检测状态</p></li><li><p>装载存储地址    //写数据</p></li><li><p>使能ACK</p></li><li><p>检测状态</p></li><li><p>写数据</p></li><li><p>使能ACK</p></li><li><p>设置IIC停止条件</p></li></ol><p><strong>读数据</strong></p><ol><li><p>装载AT24C08设备地址：0xA0</p></li><li><p>设置IIC开始条件</p></li><li><p>使能ACK</p></li><li><p>检测状态</p></li><li><p>装载存储地址    //读取数据</p></li><li><p>使能ACK</p></li><li><p>检测状态</p></li><li><p>装载设备地址：0xA0|0x1</p></li><li><p>设置IIC开始条件</p></li><li><p>使能ACK信号</p></li><li><p>检测状态</p></li><li><p>读取数据</p></li><li><p>关闭ACK信号</p></li><li><p>设置停止条件</p></li></ol><h2 id="相关寄存器分析"><a class="markdownIt-Anchor" href="#相关寄存器分析"></a> 相关寄存器分析</h2><p>基本寄存器如下。</p><p><img src="https://files.shanqianche.cn/20232/1676293657140.png" alt="基本寄存器" /></p><ol><li>I2CCON:使能ACK,选择时钟源，使能Ix/Rx,检测状态</li><li>I2CSTAT:主机发送/接收，设置开始/停止条件，数据Tx/Rx使能，AcK能否被接收？</li><li>I2CDS0:装载设备地址，发送/接收数据</li></ol><h1 id="设备驱动框架功能分析"><a class="markdownIt-Anchor" href="#设备驱动框架功能分析"></a> 设备驱动框架功能分析</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><p><strong>IIC基本特征</strong></p><ol><li>IIC是一种数据传输协议(sPI,USB,SDIo,UART.··.)</li><li>速度比较：IIC(100K,400K,3.4M)&lt;SPI&lt;SDI0&lt;网络&lt;‘USB’</li><li>IIC是一个半双工通信方式，两根总线（SCL，SDA），每个设备都有唯一设备地址</li><li>一次传输8bit,高位在前，低位在后；总线空闲状态：数据线SDA拉为高电平</li></ol><p>IIC设备驱动框架图如下。</p><p><img src="https://files.shanqianche.cn/20232/1676294519137.png" alt="IIC设备驱动框架图" /></p><blockquote><p>i2c设备驱动层组件(i2c-dev.c)</p></blockquote><ol><li>给用户提供调用接口</li><li>实现策略问题：它知道发什么数据，但不知道怎么发数据</li></ol><blockquote><p>i2c核心层组件(i2c-core.c)</p></blockquote><ol><li>注册一根i2c总线</li><li>给驱动编程人员提供编程接口</li></ol><blockquote><p>i2c总线驱动层组件(I2c-s3c2410.c)</p></blockquote><ol><li>初始化硬件(初始化12c控制器)：</li><li>实现操作方法(根据I2c操作时序进行控制I2c空制器买现数据接收/发送)：它知道怎么去发数据，但不知道发什么数据</li></ol><h2 id="核心层分析"><a class="markdownIt-Anchor" href="#核心层分析"></a> 核心层分析</h2><p>核心层作用如图下：</p><p><img src="https://files.shanqianche.cn/20232/1676295790880.png" alt="核心层作用" /><br /><strong>读源码：</strong></p><ol><li>注册一根总线</li></ol><p><img src="https://files.shanqianche.cn/20232/1676294699385.png" alt="注册一根总线" /></p><ol start="2"><li>返回一个设备与驱动相对应的结构体，个人连接就是将设备与驱动相连接</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295086347.png" alt="结构体" /></p><pre><code>- 通过匹配设备名称进行关联，设备匹配函数如下</code></pre><p><img src="https://files.shanqianche.cn/20232/1676295150899.png" alt="设备匹配函数" /></p><ol start="3"><li>注册I2C驱动</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295251175.png" alt="注册I2C驱动" /></p><p><strong>linux设备驱动涉及重要结构体(linux/i2c.h)</strong></p><ol><li>表示I2C的驱动</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295448709.png" alt="表示I2C的驱动" /></p><ol start="2"><li>表示I2C的设备</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295529801.png" alt="表示I2C的设备" /></p><ol start="3"><li>表示I2C的适配器/控制器</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295580196.png" alt="表示I2C的适配器/控制器" /></p><ol start="4"><li>表示I2C数据包</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295622485.png" alt="表示I2C数据包" /></p><ol start="5"><li>表示I2C板卡信息</li></ol><p><img src="https://files.shanqianche.cn/20232/1676295715402.png" alt="表示I2C板卡信息" /></p><h2 id="设备驱动层分析"><a class="markdownIt-Anchor" href="#设备驱动层分析"></a> 设备驱动层分析</h2><p>IIC主设备号，系统已经设置。</p><p><img src="https://files.shanqianche.cn/20232/1676295878457.png" alt="IIC主设备号" /></p><ol><li>注册主设备号，返回设备描述符</li></ol><p><img src="https://files.shanqianche.cn/20232/1676296498487.png" alt="注册主设备号，返回设备文件描述结构体" /><br />2. 创建设备类</p><p><img src="https://files.shanqianche.cn/20232/1676296529780.png" alt="创建设备类" /><br />3. 绑定适配器</p><p><img src="https://files.shanqianche.cn/20232/1676296559682.png" alt="绑定适配器" /></p><h2 id="iic设备驱动层移植"><a class="markdownIt-Anchor" href="#iic设备驱动层移植"></a> IIC设备驱动层移植</h2><p>系统内核构成，如图下：</p><p><img src="https://files.shanqianche.cn/20232/1676297787708.png" alt="系统内核构成" /></p><h2 id="系统流程分析"><a class="markdownIt-Anchor" href="#系统流程分析"></a> 系统流程分析</h2><p>整体流程如下：</p><p><img src="https://files.shanqianche.cn/20232/1676346004233.png" alt="整体流程如下" /></p><p>open函数对应的操作流程（包括获取从机的信息）：</p><p><img src="https://files.shanqianche.cn/20232/1676298154641.png" alt="open对应的操作，获取从机的信息" /></p><p>ioctl函数对应的操作流程（指定client设备地址）：</p><p><img src="https://files.shanqianche.cn/20232/1676344207322.png" alt="指定client设备地址" /><br />write函数对应的操作流程：</p><p><img src="https://files.shanqianche.cn/20232/1676355320639.png" alt="平台资源构建" /></p><h2 id="资源层分析"><a class="markdownIt-Anchor" href="#资源层分析"></a> 资源层分析</h2><p>资源层分析图如下：</p><p><img src="https://files.shanqianche.cn/20232/1676355672692.png" alt="资源层分析图" /></p><h3 id="平台资源构建"><a class="markdownIt-Anchor" href="#平台资源构建"></a> 平台资源构建</h3><p>平台资源构建如下：</p><p><img src="https://files.shanqianche.cn/20232/1676356225041.png" alt="enter description here" /></p><p>平台数据构建如下：</p><p><img src="https://files.shanqianche.cn/20232/1676356321652.png" alt="平台数据" /></p><h3 id="注册平台设备"><a class="markdownIt-Anchor" href="#注册平台设备"></a> 注册平台设备</h3><p>注册平台设备如下：</p><p><img src="https://files.shanqianche.cn/20232/1676356388303.png" alt="注册平台" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Embedded" scheme="https://merlynr.github.io/categories/Embedded/"/>
    
    
    <category term="study, graduate student,embedded" scheme="https://merlynr.github.io/tags/study-graduate-student-embedded/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://merlynr.github.io/2023/02/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20%E9%80%9F%E6%95%88%E6%95%91%E5%BF%83%E4%B8%B8/"/>
    <id>https://merlynr.github.io/2023/02/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20%E9%80%9F%E6%95%88%E6%95%91%E5%BF%83%E4%B8%B8/</id>
    <published>2023-02-12T19:00:59.624Z</published>
    <updated>2023-02-12T19:00:59.624Z</updated>
    
    <content type="html"><![CDATA[<p>帮助快速上手汇编语言编程，虽然只限于编程</p><h1 id="vscode配置调试环境"><a class="markdownIt-Anchor" href="#vscode配置调试环境"></a> VScode配置调试环境</h1><ol><li>安装插件TASM/MASM</li><li>右键扩展设置，选择Assembler：MASM</li><li>右键调试即可开始调试了！</li></ol><h1 id="debugexe"><a class="markdownIt-Anchor" href="#debugexe"></a> Debug.exe</h1><blockquote><p>R命令：查看、改变CPU寄存器的内容<br />D命令：查看内存中的内容<br />T命令：执行一条机器指令<br />G命令：从停顿的地方运行到底</p></blockquote><h1 id="第一段代码hello-world"><a class="markdownIt-Anchor" href="#第一段代码hello-world"></a> 第一段代码：Hello World</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DSEG SEGMENT</span><br><span class="line">        MESS DB &#x27;Hello, World!&#x27;,0DH,0AH,24H</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">SSEG SEGMENT PARA STACK</span><br><span class="line">             DW 256 DUP(?)</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">              ASSUME CS:CSEG, DS:DSEG</span><br><span class="line">        BEGIN:MOV    AX,DSEG</span><br><span class="line">              MOV    DS,AX</span><br><span class="line">              MOV    DX,OFFSET MESS</span><br><span class="line">              </span><br><span class="line">              MOV    AH,9</span><br><span class="line">              INT    21H</span><br><span class="line">              </span><br><span class="line">              MOV    AH,4CH</span><br><span class="line">              INT    21H</span><br><span class="line">CSEG ENDS</span><br><span class="line">END BEGIN</span><br></pre></td></tr></table></figure><h1 id="基础指令"><a class="markdownIt-Anchor" href="#基础指令"></a> 基础指令</h1><p>用以下指令可以写一个基础的程序：</p><ol><li>段定义+Assume</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXX SEGMENT(XXX:DATA/STACK/CODE)</span><br><span class="line">XXX ENDS</span><br></pre></td></tr></table></figure><blockquote><p>DS和SS都需要重新装载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CSEG, DS:DSEG, SS:SSEG</span><br><span class="line">MOV AX,DSEG</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV AX,SSEG</span><br><span class="line">MOV SS,AX</span><br></pre></td></tr></table></figure><ol start="2"><li>数据定义</li></ol><blockquote><p>名称可定义可不定义，常用 DB(define a bit)，DW(define a word)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(ORG 1000)</span><br><span class="line">(NAME) DB ?/...（留空）</span><br><span class="line">(NAME) DB N DUP(?/...)（定义N个DB空间）</span><br><span class="line">db:12H/dw:1234H(16进制)</span><br></pre></td></tr></table></figure><ol start="3"><li>MOV</li></ol><blockquote><p>不能内存到内存</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,Y(内存到寄存器)</span><br><span class="line">MOV Y,AX（寄存器到内存）</span><br><span class="line">MOV AX,BX（寄存器到寄存器）</span><br></pre></td></tr></table></figure><ol start="4"><li>±</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD AX,X;AX+=X</span><br><span class="line">SUB AX,X;</span><br><span class="line">INC AX;AX++</span><br><span class="line">DEC AX;AX--</span><br><span class="line"></span><br><span class="line">NEG AX ;取负</span><br></pre></td></tr></table></figure><ol start="5"><li>程序的终止</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ol start="6"><li>输出指令</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>AH,<span class="number">9</span></span><br><span class="line"><span class="symbol">INT</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure><p>稍后会讲的进阶指令：</p><ol><li>Label和JUMP：跳转</li><li>分支和循环</li><li>堆栈的使用</li><li>&lt;函数&gt;：PROC和MACRO</li><li>INT 21H指令：输入/输出</li></ol><h1 id="寄存器的使用"><a class="markdownIt-Anchor" href="#寄存器的使用"></a> 寄存器的使用</h1><p>在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先<code>MOV</code>到寄存器中再进行处理。<br />为了写代码的过程更顺滑，最好先简单了解一下这些寄存器的使用，当然，你也可以只了解通用寄存器的使用，别的等用到了再去查询。<br />我会尽可能简单地表述。</p><p>8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：<code>123AH</code>（H表示16进制)在查看内存情况的时候，由于数据从高位到低位存储，BeLike：<code>3A 12</code></p><p><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h3 id="通用寄存器axbxcxdx"><a class="markdownIt-Anchor" href="#通用寄存器axbxcxdx"></a> 通用寄存器：AX，BX，CX，DX</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DSEG ...  ;data段落</span><br><span class="line">X DB 12H;定义</span><br><span class="line">Y DB ?;定义</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">CSEG...;code段落</span><br><span class="line">...</span><br><span class="line">MOV AH,X</span><br><span class="line">MOV Y,AH ;Y==12H</span><br></pre></td></tr></table></figure><p>可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的</p><p>说到底为什么&lt;通用&gt;寄存器会有&lt;独特的作用&gt;？<br />这是因为<mark>一些内置的指令依靠<strong>固定</strong>的寄存器传递参数</mark>，所以这些寄存器也有了独特的作用</p><p>一般来说随便用就可以，反正里面的东西不久存，只是用来做<mark>中转</mark></p><h5 id="axaccumlator-累加器"><a class="markdownIt-Anchor" href="#axaccumlator-累加器"></a> AX：Accumlator 累加器</h5><p>特殊功能和MUL/DIV有关，后面再说</p><h5 id="bxbase-基地址寄存器"><a class="markdownIt-Anchor" href="#bxbase-基地址寄存器"></a> BX：Base 基地址寄存器</h5><p>可以存储地址并访问<br />说到地址，就得提一下汇编语言里地址的表示方法<br />在汇编语言里，内存中的地址BeLike：<code>204B:1001</code> （以16进制表示）<br /><code>204B</code>是<strong>段地址</strong>，<code>1001</code>是<strong>偏移地址</strong>，各需要一个Word进行存储<br />有两个指令对应的获取内存单元的这两种地址<br /><code>SEG</code>可以获取<strong>段地址</strong>（这个段就是指我们程序对应的段Segment），<code>OFFSET</code>可以获取<strong>偏移地址</strong><br />使用这两个词只需要在MOV时加在变量前即可，比如<code>MOV BX offset X</code><br />在“通过地址找内容”这件事方面，一般用BX存储偏移地址<br />比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X DW 1234H</span><br><span class="line">Y DW ?</span><br><span class="line">...</span><br><span class="line">MOV BX, OFFSET X;BX中存储了X的偏移地址</span><br><span class="line">MOV Y, [BX];BX存储的偏移地址对应的内容被存放到y</span><br></pre></td></tr></table></figure><p>一般来说，<code>[BX]</code>就是指 <code>DS:[BX]</code>，默认段地址为数据段，当然你也可以指定为CS和SS</p><h5 id="cxcount-计数器"><a class="markdownIt-Anchor" href="#cxcount-计数器"></a> CX：Count 计数器</h5><p>和循环指令<code>LOOP</code>有关</p><p>LOOP指令类似于C语言中的For循环，<code>loop NAME</code>近似于<code>for(cx;;cx--)</code><br />关于LOOP的用法，具体到程序结构再说好了~。</p><h5 id="dxdata-数据寄存器"><a class="markdownIt-Anchor" href="#dxdata-数据寄存器"></a> DX：Data 数据寄存器</h5><p>特殊功能和MUL/DIV有关，后面再说<br />也有与输入输出的暂存有关的功能（9.10号指令）</p><h3 id="指针变址寄存器spbpsidi"><a class="markdownIt-Anchor" href="#指针变址寄存器spbpsidi"></a> 指针变址寄存器：SP，BP，SI，DI</h3><p>都倾向于用来存地址</p><h5 id="spstack-pointer"><a class="markdownIt-Anchor" href="#spstack-pointer"></a> SP：Stack Pointer</h5><p>和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶</p><h5 id="bpbase-pointer"><a class="markdownIt-Anchor" href="#bpbase-pointer"></a> BP：Base Pointer</h5><p>和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，<code>[BP]</code>默认为<code>SS:[BP]</code></p><h5 id="sisource-index"><a class="markdownIt-Anchor" href="#sisource-index"></a> SI：Source Index</h5><h5 id="didestination-index"><a class="markdownIt-Anchor" href="#didestination-index"></a> DI：Destination Index</h5><p>和BX有类似的用法，<code>[SI]</code>默认为<code>DS:[SI]</code><br />如果要转移数据，倾向于用SI存原地址，DI存新地址</p><h3 id="段寄存器csdssses额外段ip"><a class="markdownIt-Anchor" href="#段寄存器csdssses额外段ip"></a> 段寄存器：CS，DS，SS，ES(额外段)，IP</h3><p>段的存在方便我们以<mark>段地址+偏移地址</mark>的方式定位内存单元<br />刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的</p><p>这些寄存器都和程序段还有程序的运行有关。<br />在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令（显然我们可以用IP玩一些花活，但是对于简单的程序，我们没有必要操作IP）</p><p>在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址<br />和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）</p><p>ES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多</p><h3 id="标志寄存器-flag"><a class="markdownIt-Anchor" href="#标志寄存器-flag"></a> 标志寄存器 FLAG</h3><p>只是写代码的话不用管它<br />16位分开使用，有各自不同的意思，结果会以下面的形式呈现在-R中</p><p><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="" /></p><h1 id="阶段练习"><a class="markdownIt-Anchor" href="#阶段练习"></a> 阶段练习</h1><p>有以上的知识已经能写很多代码。</p><h4 id="练习a-xy"><a class="markdownIt-Anchor" href="#练习a-xy"></a> 练习a: x+y</h4><blockquote><ol><li>在数据段（data segment）中定义3个word，其中x=1234H，y=2345H, z=?</li><li>将x+y的结果保存在z中</li></ol></blockquote><h1 id="进阶指令"><a class="markdownIt-Anchor" href="#进阶指令"></a> 进阶指令</h1><p>这里开始会有一点复杂，建议一边写一边看</p><h3 id="1-label和jump跳转"><a class="markdownIt-Anchor" href="#1-label和jump跳转"></a> 1. Label和Jump：跳转</h3><p>一段代码可以拥有label，Jump NAME 即可跳转至label位置<br />比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAIN：MOV X,AX</span><br><span class="line">JUMP DONE</span><br><span class="line">MOV AX,Y</span><br><span class="line">...</span><br><span class="line">DONE:</span><br><span class="line">MOV AH, 4CH</span><br><span class="line">INT 21</span><br></pre></td></tr></table></figure><p>在这段程序中，<code>MOV AX,Y</code>就会直接被跳过</p><h3 id="2-分支和循环"><a class="markdownIt-Anchor" href="#2-分支和循环"></a> 2. 分支和循环</h3><h4 id="分支-cmp-jge"><a class="markdownIt-Anchor" href="#分支-cmp-jge"></a> 分支 CMP-JGE/…</h4><p><img src="assets/Pasted%20image%2020221206112205.png" alt="" /></p><p>BeLike:(求abs(AX)保存在AX中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">...</span><br><span class="line">CMP AX,0</span><br><span class="line">JGE DONE; Jump if Greater or Equal</span><br><span class="line">NEG AX</span><br><span class="line">DONE:</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h5 id="练习b-求最大值"><a class="markdownIt-Anchor" href="#练习b-求最大值"></a> 练习b: 求最大值</h5><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="循环-loop"><a class="markdownIt-Anchor" href="#循环-loop"></a> 循环  LOOP</h4><p>一种简单的循环，类似于<code>for(cx;;cx--)</code>。（事实上，你可以用JUMP和分支结构来实现循环）</p><p>LOOP NM过程中：<br />0. CMP CX,0<br />1. 如果CX&gt;0，继续执行以下语句，否则跳出<br />2. DEC CX(CX&gt;0)<br />3. JUMP NM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV CX,6</span><br><span class="line">NM: ...</span><br><span class="line">LOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）</span><br></pre></td></tr></table></figure><h5 id="练习c-数组初始化"><a class="markdownIt-Anchor" href="#练习c-数组初始化"></a> 练习c: 数组初始化</h5><blockquote><p>在数据段（data segment）中分配100字节，并为每个字节依次赋值0-99。</p></blockquote><h3 id="3-堆栈的使用"><a class="markdownIt-Anchor" href="#3-堆栈的使用"></a> 3. 堆栈的使用</h3><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><p>两个好用的方法</p><h5 id="比较直观的堆栈段中做定义"><a class="markdownIt-Anchor" href="#比较直观的堆栈段中做定义"></a> 比较直观的（堆栈段中做定义）</h5><ol><li>在堆栈段划分位置，保存栈顶位置</li><li>在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">      STACK DW  128 dup(?)</span><br><span class="line">      TOP   DW LENGTH STACK ;划定范围</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">           ASSUME CS:CSEG,DS:DSEG,SS:SSEG</span><br><span class="line">      MAIN:</span><br><span class="line">           MOV    AX,DSEG</span><br><span class="line">           MOV    DS,AX</span><br><span class="line">           MOV    AX,SSEG</span><br><span class="line">           MOV    SS,AX</span><br><span class="line">           MOV    AX,TOP</span><br><span class="line">           MOV    SP,AX                        ;栈顶地址载入</span><br></pre></td></tr></table></figure><h5 id="稍微没那么直观的程序段中划空间"><a class="markdownIt-Anchor" href="#稍微没那么直观的程序段中划空间"></a> 稍微没那么直观的（程序段中划空间）</h5><p>直接给SP赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">SSEG ENDS</span><br><span class="line">;ss:0000-ss:1000</span><br><span class="line">CSEG SEGMENT</span><br><span class="line">            ASSUME CS:CSEG, DS:DSEG,SS:SSEG</span><br><span class="line">      BEGIN:MOV    AX,DSEG</span><br><span class="line">            MOV    DS,AX</span><br><span class="line">            MOV    AX,SSEG</span><br><span class="line">            MOV    SS,AX</span><br><span class="line">            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)</span><br></pre></td></tr></table></figure><h4 id="push和pop"><a class="markdownIt-Anchor" href="#push和pop"></a> PUSH和POP</h4><p>注意：<mark>只能操作寄存器</mark>，不能直接操作内存单元<br /><code>PUSH AX</code>：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2）<br /><code>POP AX</code>：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）</p><h4 id="用sp和bp操作堆栈"><a class="markdownIt-Anchor" href="#用sp和bp操作堆栈"></a> 用SP和BP操作堆栈</h4><p>在主程序只是暂存数据用的话，一般<mark>不用</mark>操作指针<br />但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释</p><h3 id="4-函数proc和macro"><a class="markdownIt-Anchor" href="#4-函数proc和macro"></a> 4. &lt;函数&gt;：PROC和MACRO</h3><h4 id="proccall子程序结构"><a class="markdownIt-Anchor" href="#proccall子程序结构"></a> PROC&amp;CALL（子程序结构）</h4><h5 id="定义-proc-ret-endp"><a class="markdownIt-Anchor" href="#定义-proc-ret-endp"></a> 定义 PROC-RET-ENDP</h5><p>(Near 属性是默认值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">CALL NM</span><br><span class="line"></span><br><span class="line">NM PROC</span><br><span class="line">...</span><br><span class="line">RET</span><br><span class="line">NM ENDP</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>完整的表达式：<br />调用：<code>CALL FAR/NEAR PTR NM</code><br />定义：<code>NM PROC FAR/NEAR</code></p><h5 id="子程序属性和调用"><a class="markdownIt-Anchor" href="#子程序属性和调用"></a> 子程序属性和调用</h5><h6 id="段内调用"><a class="markdownIt-Anchor" href="#段内调用"></a> 段内调用</h6><p>只需要Main（主Label调用）的话空置即可（默认Near）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:...</span><br><span class="line">CALL B;调用B</span><br><span class="line"></span><br><span class="line">PROC B:...;默认为near属性子程序</span><br><span class="line">RET</span><br><span class="line">B ENDP</span><br><span class="line">...</span><br><span class="line">END A</span><br></pre></td></tr></table></figure><h6 id="段间调用"><a class="markdownIt-Anchor" href="#段间调用"></a> 段间调用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROC A:CALL FAR PTR B</span><br><span class="line">RET</span><br><span class="line">ENDP</span><br><span class="line"></span><br><span class="line">PROC B FAR:...;写明属性</span><br><span class="line">RET ENDP</span><br></pre></td></tr></table></figure><h5 id="小心堆栈"><a class="markdownIt-Anchor" href="#小心堆栈"></a> 小心堆栈！</h5><p>PROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置<br />所以：</p><ol><li>第一个出栈元素会是一个偏移地址</li><li>如果最后SP的指针位置不对，就无法正确RET</li></ol><p>简单的方法：<mark>用寄存器BP保护SP</mark>，使用BP进行数据的读取</p><h6 id="例子a1-xy子程序化"><a class="markdownIt-Anchor" href="#例子a1-xy子程序化"></a> 例子a(1): x+y子程序化</h6><blockquote><p>…</p><ol><li>在堆栈段push任意两个长度为1word的数据</li><li>使用子程序，将这两个数据的和存储于AX<br />…</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUM PROC ;取两个栈顶元素求和储存到AX中</span><br><span class="line">         MOV    BP,SP</span><br><span class="line">         MOV    AX,[BP+2]</span><br><span class="line">         ADD    AX,[BP+4]</span><br><span class="line">         RET</span><br><span class="line">SUM ENDP</span><br></pre></td></tr></table></figure><h6 id="练习b1-求最大值-子程序化"><a class="markdownIt-Anchor" href="#练习b1-求最大值-子程序化"></a> 练习b(1) 求最大值 子程序化</h6><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>在堆栈段push x,y,z</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="macro宏定义"><a class="markdownIt-Anchor" href="#macro宏定义"></a> *Macro（宏定义）</h4><p>PROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有<br />MACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NM MACRO R1,R2...(参数)</span><br><span class="line">...</span><br><span class="line">END M</span><br><span class="line"></span><br><span class="line">NM MACRO AX,BX...(寄存器取值)</span><br></pre></td></tr></table></figure><h3 id="5-int-21h指令输入输出"><a class="markdownIt-Anchor" href="#5-int-21h指令输入输出"></a> 5. INT 21H指令：输入/输出</h3><p>其实查书就可以了</p><p>到这里汇编语言编程的&lt;大局&gt;已经描述完全</p><p>关于一些语句的细节可以通过搜索引擎和汇编相关的任何书籍进行确认~</p><h4 id="键盘输入"><a class="markdownIt-Anchor" href="#键盘输入"></a> 键盘输入</h4><h5 id="1号指令单个字符输入"><a class="markdownIt-Anchor" href="#1号指令单个字符输入"></a> 1号指令：单个字符输入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,1</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>(内容会保存在AL)</p><h5 id="10号指令从键盘输入字符串"><a class="markdownIt-Anchor" href="#10号指令从键盘输入字符串"></a> 10号指令：从键盘输入字符串</h5><p>内存里需要划分三个部分：<br />1.一个字节存放最大长度（你写，溢出会被裁掉）<br />2.一个字节存放实际长度（指令运行完CPU会写）<br />3.一些字节用来存字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度</span><br><span class="line">    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写</span><br><span class="line">    STRING       DB 100 DUP(?)    ;用来存字符串</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">         ASSUME DS:DATA,SS:STACK,CS:CODE</span><br><span class="line">    MAIN:</span><br><span class="line">         MOV    AX,DATA</span><br><span class="line">         MOV    DS,AX</span><br><span class="line">         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX</span><br><span class="line"></span><br><span class="line">         MOV    AH,10</span><br><span class="line">         INT    21H</span><br><span class="line"></span><br><span class="line">         MOV    AH,4CH</span><br><span class="line">         INT    21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h4 id="显示器输出"><a class="markdownIt-Anchor" href="#显示器输出"></a> 显示器输出</h4><h5 id="2号调用单个字符输出"><a class="markdownIt-Anchor" href="#2号调用单个字符输出"></a> 2号调用：单个字符输出</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,&#x27;A&#x27;</span><br><span class="line">MOV AH,2</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h5 id="9号调用字符串输出"><a class="markdownIt-Anchor" href="#9号调用字符串输出"></a> 9号调用：字符串输出</h5><p>你的字符串必须要以’$‘结尾！不然输出不会结束！（类似于’\0’，’$‘是一种字符串的终止符）<br />程序会将DS:DX地址开始输出字符到’$'结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,OFFSET STRING</span><br><span class="line">MOV AH,9</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a class="markdownIt-Anchor" href="#综合练习"></a> 综合练习</h3><h4 id="练习d-大小写转换输入输出"><a class="markdownIt-Anchor" href="#练习d-大小写转换输入输出"></a> 练习d. 大小写转换+输入输出</h4><blockquote><p>（分支/循环/子程序+输入输出）<br />用户输入一个单词，程序将所有大写转换为小写并输出到显示器<br />(注：‘a’=‘A’+20H)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;帮助快速上手汇编语言编程，虽然只限于编程&lt;/p&gt;
&lt;h1 id=&quot;vscode配置调试环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode配置调试环境&quot;&gt;&lt;/a&gt; VScode配置调试环境&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安装插件TASM</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ARM硬件基础</title>
    <link href="https://merlynr.github.io/2023/02/06/ARM%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>https://merlynr.github.io/2023/02/06/ARM%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-06T03:12:00.000Z</published>
    <updated>2023-02-06T03:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu核心"><a class="markdownIt-Anchor" href="#cpu核心"></a> CPU核心</h1><p><img src="https://files.shanqianche.cn/20232/1675698820635.png" alt="CPU" /></p><ol><li>SIMD：Single Instruction Multiple Data,单指令多数据流。单次处理多条数据。</li><li>NEON：加速多媒体和信号处理算法（如视频编码/解码、2D/3D图形、游戏、音频和语音处理图像处理技术、电话和声音合成），其性能至少为ARM5性能的3倍，为ARMv6SIMD性能的2倍。<strong>主要处理浮点数</strong></li></ol><h2 id="系统外围"><a class="markdownIt-Anchor" href="#系统外围"></a> 系统外围</h2><ol><li>RTC：real-time clock</li><li>PLL：Phase Locked Loop，为锁相回路或锁相环，用来统一整合时脉讯号，使内存能正确的存取资料。</li><li>PWM Timer：脉冲宽度调制（Pulse Width Modulation），脉宽调制</li><li>Watchdog Timer：</li><li>DMA：帮助存储器与外设进行交互，减轻CPU压力</li><li>Keypad：按钮</li><li>ADC：Analog to Digital Converter,模数转换器</li></ol><h2 id="sisdsimd"><a class="markdownIt-Anchor" href="#sisdsimd"></a> SISD&amp;SIMD</h2><p>SISD：单指令单数据<br />SIMD：单指令多数据</p><p><img src="https://files.shanqianche.cn/20232/1675699987677.png" alt="SISD与SOMD比较" /></p><blockquote><p>NEON：对SIMD进行扩展，加入向量表提高数据集的压缩，进而提高浮点数运算效率。</p></blockquote><h2 id="cache-高速缓存"><a class="markdownIt-Anchor" href="#cache-高速缓存"></a> Cache 高速缓存</h2><blockquote><p>二级缓存的优化会大大影响程序运行速度。涉及到调优。</p></blockquote><p><strong>为何需要Cache？</strong> (我们现在采用的存储器结构成为多体交叉存储器体系)</p><ul><li>I/O向主存请求的级别高于CPU访存</li><li>主存速度跟不上CPU的发展</li><li>主存一般都是片外，频繁进出速度慢，能耗高</li></ul><p><strong>Cache工作原理：</strong></p><ul><li>程序访问的局部性原理，采用了SRAM，即<strong>程序连续的被CPU处理，可以找到运行规律，预测执行的下一部分，所以形成缓存</strong></li><li>命中率（读取指令的准确度）</li><li>大小比例，4：：1000,128K-32M（缓存大小与内存大小比例）</li></ul><p><img src="https://files.shanqianche.cn/20232/1675741016994.png" alt="一个存储器的层级结构" /></p><blockquote><p>上级缓存一般都可以作为下级的缓存</p></blockquote><p><strong>缓存控制器Cache Controller：</strong>（控制缓存与内存的交互规则）</p><ul><li>直接映射缓存Direct Mapped Cache</li><li>联合缓存Set-association Cache</li></ul><p><img src="https://files.shanqianche.cn/20232/1675701473304.png" alt="直接映射，固定计算方式" /></p><p><img src="https://files.shanqianche.cn/20232/1675701605833.png" alt="联合缓存，映射位置不确定，有controller确定" /></p><p><img src="https://files.shanqianche.cn/20232/1675701720973.png" alt="缓存结构" /></p><ul><li>line是缓存最小单元，指向主存的连续字单元</li><li>index是存储器地址的一部分，用来决定找到缓存的第几行</li><li>way是一个特定的索引线路</li></ul><h1 id="mmumemory-manage-unit"><a class="markdownIt-Anchor" href="#mmumemory-manage-unit"></a> MMU（Memory Manage Unit）</h1><p>PM：物理内存</p><h2 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器"></a> 虚拟存储器</h2><p><strong>作用：</strong></p><ol><li>允许多道程序之间有效而安全的共享存储器</li><li>消除一个小而受限的主存容对程序设计造成的影响</li></ol><p><img src="https://files.shanqianche.cn/20232/1675741989673.png" alt="通过虚拟内存满足程序需要大容量的要求" /><br />如果CPU在利用缓存的过程中没有<strong>命中</strong>，则称为<strong>缺页</strong></p><ul><li>如果不缺页直接读物理内存</li><li>如果缺页，则把控制权交给操作系统，操作系统一般是从磁盘地址去读</li></ul><blockquote><ol><li>虚拟地址空间非实体，只是逻辑上的</li><li>虚拟地址对物理地址的映射是由MMU控制的</li><li>MMU会控制一个物理地址只能对应一个虚拟地址的映射，保护内存。页保护与锁定</li><li>分段。对程序代码进行分类，例如变量放入堆栈的物理内存等</li></ol></blockquote><h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2><blockquote><p>加快地址转换，对虚拟地址进行划分，加快查询<br />address-&gt;MMU-&gt;TLB-&gt;pageTable-&gt;PM</p></blockquote><h1 id="异常中断"><a class="markdownIt-Anchor" href="#异常中断"></a> 异常中断</h1><p>ARM体系结构中存在7种异常处理。异常发生时，处理器会把PC指向一个特殊地址，这个地址放在存储器中一个特定表中，称为向里表</p><p><img src="https://files.shanqianche.cn/20232/1675744367257.png" alt="中断向量表" /></p><blockquote><p>一般向量表起始地址是0x0开始，又称<strong>低地址向量表</strong>。而微软是从0xffff0000开始，成为<strong>高地址向量表</strong>。</p></blockquote><p><strong>触发异常过程：</strong> 系统接收异常-&gt;CPU切换模式同时保存当前位置和状态-&gt;CPSR、SPSR-&gt;根据中断向量表查找处理程序-&gt;返回还原</p><p><img src="https://files.shanqianche.cn/20232/1675746695888.png" alt="FIQ发生的伪代码" /></p><h3 id="复位异常"><a class="markdownIt-Anchor" href="#复位异常"></a> 复位异常</h3><p><img src="https://files.shanqianche.cn/20232/1675746519944.png" alt="复位异常" /></p><p><img src="https://files.shanqianche.cn/20232/1675746737387.png" alt="复位异常的伪代码" /></p><blockquote><p>内存出现问题为<strong>数据异常</strong></p></blockquote><h3 id="未定义异常"><a class="markdownIt-Anchor" href="#未定义异常"></a> 未定义异常</h3><p><img src="https://files.shanqianche.cn/20232/1675746885612.png" alt="未定义异常伪代码" /></p><h3 id="异常优先级"><a class="markdownIt-Anchor" href="#异常优先级"></a> 异常优先级</h3><p><img src="https://files.shanqianche.cn/20232/1675746990091.png" alt="异常优先级" /></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p><img src="https://files.shanqianche.cn/20232/1675747392475.png" alt="总结" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="ARM" scheme="https://merlynr.github.io/categories/ARM/"/>
    
    
    <category term="study, graduate student,ARM" scheme="https://merlynr.github.io/tags/study-graduate-student-ARM/"/>
    
  </entry>
  
  <entry>
    <title>bootloader概述</title>
    <link href="https://merlynr.github.io/2023/02/06/bootloader%E6%A6%82%E8%BF%B0/"/>
    <id>https://merlynr.github.io/2023/02/06/bootloader%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-06T00:13:00.000Z</published>
    <updated>2023-02-06T00:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bootloader的作用和概述"><a class="markdownIt-Anchor" href="#bootloader的作用和概述"></a> bootloader的作用和概述</h1><h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2><p><strong>boot的目的（跳到C语言中）：</strong></p><ol><li>关闭看门狗，中断，MMU,CACHE(影响数据完整性)</li><li>配置系统工作时钟（不同处理器、外设对于时钟要求不一样）</li><li>配置SDRAM的控制器（行地址数、列地址数、多少块，周期性的充电【难点 】</li><li>让sp指向可读可写的设备区间中，满足递减栈的规则SDAM</li></ol><ul><li>用哪些模式，就要初始化哪些模式下的SP</li><li>每个模式值不能覆盖其他模式</li></ul><ol start="5"><li>代码搬移（code太大需要转移到DRAM）</li></ol><ul><li>方式一，执行速度问题，把程序从存储器(nor-flash)搬移到快速的内存</li><li>方式二，只把存储器的一部分代码执行出来，把存储在其他位置上的低码搬移到内存，<strong>对应存储器的控制器的初始化</strong></li></ul><ol start="6"><li>bl main</li></ol><p><strong>loader的目的：</strong><br />执行应用逻辑，点灯、uart,load linux kernel</p><p><img src="https://files.shanqianche.cn/20232/1675996979583.png" alt="S5PV210boot流程" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>ARM汇编</title>
    <link href="https://merlynr.github.io/2023/02/06/ARM%E6%B1%87%E7%BC%96/"/>
    <id>https://merlynr.github.io/2023/02/06/ARM%E6%B1%87%E7%BC%96/</id>
    <published>2023-02-05T17:04:00.000Z</published>
    <updated>2023-02-05T17:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编"><a class="markdownIt-Anchor" href="#汇编"></a> 汇编</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p><img src="https://files.shanqianche.cn/20232/1675616964555.png" alt="ARM汇编指令格式" /></p><blockquote><p>不同系统种汇编指令有差异</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675616803862.png" alt="向寄存器种一个值添加100，68K是摩托罗拉的" /></p><p><img src="https://files.shanqianche.cn/20232/1675616858831.png" alt="从一个寄存器指针加载到寄存器" /></p><p><img src="https://files.shanqianche.cn/20232/1675660690508.png" alt="指令条件Cond" /></p><p><img src="https://files.shanqianche.cn/20232/1675660746122.png" alt="状态Status码" /><br /><strong>如何判断一个立即数是否合规：此数除以4，如果在0-255之间则合规。</strong><br />0x102：是立即数<br />0x104：不是立即数</p><h2 id="寻址模式"><a class="markdownIt-Anchor" href="#寻址模式"></a> 寻址模式</h2><p><img src="https://files.shanqianche.cn/20232/1675662351290.png" alt="寻址模式" /></p><h2 id="arm堆栈"><a class="markdownIt-Anchor" href="#arm堆栈"></a> ARM堆栈</h2><ul><li>满堆栈：堆栈指针指向栈顶</li><li>空堆栈：堆栈指针指向栈底</li><li>递增堆栈：从低地址向高地址压栈</li><li>递减堆栈：从高地址向低地址压栈</li></ul><h1 id="汇编算数操作"><a class="markdownIt-Anchor" href="#汇编算数操作"></a> 汇编算数操作</h1><p><img src="https://files.shanqianche.cn/20232/1675663997815.png" alt="算术操作" /></p><p><img src="https://files.shanqianche.cn/20232/1675664094454.png" alt="逻辑操作" /></p><p><img src="https://files.shanqianche.cn/20232/1675664138437.png" alt="比较操作" /></p><h1 id="内存操作"><a class="markdownIt-Anchor" href="#内存操作"></a> 内存操作</h1><p><img src="https://files.shanqianche.cn/20232/1675664745146.png" alt="单寄存器读取指令" /></p><p><img src="https://files.shanqianche.cn/20232/1675664924191.png" alt="多寄存器操作指令" /></p><p><img src="https://files.shanqianche.cn/20232/1675664975217.png" alt="数据交换指令" /></p><h2 id="跳转与状态操作"><a class="markdownIt-Anchor" href="#跳转与状态操作"></a> 跳转与状态操作</h2><blockquote><p>跳转实质：给PC传程序地址，告诉CPU下一个执行的程序。<br />BL：mov LR，PC 这样执行完可以在LR中找到执行记录返回</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675672444539.png" alt="跳转指令" /></p><p><img src="https://files.shanqianche.cn/20232/1675672581433.png" alt="状态操作" /></p><p><img src="https://files.shanqianche.cn/20232/1675674945700.png" alt="异常产生指令" /></p><h2 id="常用伪指令"><a class="markdownIt-Anchor" href="#常用伪指令"></a> 常用伪指令</h2><p><img src="https://files.shanqianche.cn/20232/1675677426535.png" alt="汇编常用伪指令" /></p><p><img src="https://files.shanqianche.cn/20232/1675677625977.png" alt="ARM(Thumb)汇编程序所支持的变里有数字变量、逻辑变量和字符串变量" /></p><p><img src="https://files.shanqianche.cn/20232/1675677816200.png" alt="表达式与运算符" /></p><p><img src="https://files.shanqianche.cn/20232/1675678107876.png" alt="寄存器操作" /></p><p><img src="https://files.shanqianche.cn/20232/1675679704354.png" alt="数据定义伪汇编" /></p><p><img src="https://files.shanqianche.cn/20232/1675679746728.png" alt="控制伪指令" /></p><h1 id="混合编程"><a class="markdownIt-Anchor" href="#混合编程"></a> 混合编程</h1><ul><li>在C/C++代码中嵌入汇编指令。</li><li>汇编调用C/C+</li><li>C/C++调用汇编</li></ul><h2 id="c语言嵌入汇编"><a class="markdownIt-Anchor" href="#c语言嵌入汇编"></a> C语言嵌入汇编</h2><p><img src="https://files.shanqianche.cn/20232/1675680401325.png" alt="格式" /><br /><strong><font color="#FF00FF">限制条件：</font></strong></p><ul><li>不能直接向PC寄存器赋值，程序跳转要使用<strong>B或者BL</strong>指令；</li><li>在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突；</li><li>R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能把R0-R3、R12及R14用于子程序调用，因此避免直接使用这些物理寄存器；</li></ul><h3 id="在c中嵌入汇编指令"><a class="markdownIt-Anchor" href="#在c中嵌入汇编指令"></a> 在C中嵌入汇编指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_str_cpy</span><span class="params">(<span class="keyword">char</span> *src,<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">__asm&#123;</span><br><span class="line">loop:</span><br><span class="line">LDRB ch,[src],#<span class="number">1</span>  ;每次读取一个字节，指向src的指针加一，然后赋值给ch</span><br><span class="line">STRB ch,[dest],#<span class="number">1</span> ;将ch赋值给dest，指向src的指针加一</span><br><span class="line">CMP ch,#<span class="number">0</span>;比较，字符串最后一位为\<span class="number">0</span>，所以通过比较判断是否读完</span><br><span class="line">BNE loop;如果ch不等于<span class="number">0</span>，则跳转</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">&quot;hello sunday&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">64</span>];</span><br><span class="line">my_str_cpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c语言调用汇编"><a class="markdownIt-Anchor" href="#c语言调用汇编"></a> C语言调用汇编</h3><p><strong>步骤：</strong></p><ol><li>汇编export</li><li>c语言定义extern function</li><li>c语言使用</li></ol><p><font color="#228B22">C语言和汇编语言之间的参数传递是通过对应的用R0-R3来进行传递，即R0传递第一个参数，R1传递第二个参数，多于4个时借助栈完成，函数的返回值通过Ro来传递。这个规定叫作ATPCS(ARM Thumb Procedure Call Standard),具体见ATPCS规范</font></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">AREA</span> myARM,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line"><span class="meta">EXPORT</span> my_strcpy</span><br><span class="line"></span><br><span class="line"><span class="symbol">my_strcpy</span></span><br><span class="line"><span class="symbol">loop</span></span><br><span class="line"><span class="keyword">LDRB</span> <span class="built_in">R4</span>,[<span class="built_in">R0</span>],<span class="number">#1</span></span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R4</span>,<span class="number">#0</span></span><br><span class="line"><span class="keyword">BEQ</span> over</span><br><span class="line"><span class="keyword">STRB</span> <span class="built_in">R4</span>,[<span class="built_in">R1</span>],<span class="number">#1</span></span><br><span class="line"><span class="keyword">B</span> loop</span><br><span class="line"><span class="symbol">over</span></span><br><span class="line"><span class="meta">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *src,<span class="keyword">char</span> *dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">&quot;hello sunday&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">64</span>];</span><br><span class="line">my_str_cpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="汇编调用c语言"><a class="markdownIt-Anchor" href="#汇编调用c语言"></a> 汇编调用C语言</h3><p><strong>步骤：</strong></p><ol><li>c语言实现函数</li><li>汇编import函数名</li><li>BL函数名</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">AREA</span> myARM,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line"><span class="meta">EXPORT</span> my_strcpy</span><br><span class="line"><span class="meta">IMPORT</span> cFUN</span><br><span class="line"><span class="meta">ENTRY</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#1</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#2</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="number">#3</span></span><br><span class="line">BL,cFUN</span><br><span class="line"><span class="symbol">my_strcpy</span></span><br><span class="line"><span class="symbol">loop</span></span><br><span class="line"><span class="keyword">LDRB</span> <span class="built_in">R4</span>,[<span class="built_in">R0</span>],<span class="number">#1</span></span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R4</span>,<span class="number">#0</span></span><br><span class="line"><span class="keyword">BEQ</span> over</span><br><span class="line"><span class="keyword">STRB</span> <span class="built_in">R4</span>,[<span class="built_in">R1</span>],<span class="number">#1</span></span><br><span class="line"><span class="keyword">B</span> loop</span><br><span class="line"><span class="symbol">over</span></span><br><span class="line"><span class="meta">END</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cFun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="汇编" scheme="https://merlynr.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="study, graduate student,汇编" scheme="https://merlynr.github.io/tags/study-graduate-student-%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>ARM 体系架构粗了解</title>
    <link href="https://merlynr.github.io/2023/02/05/ARM%20%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <id>https://merlynr.github.io/2023/02/05/ARM%20%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</id>
    <published>2023-02-04T22:08:00.000Z</published>
    <updated>2023-02-04T22:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本差异"><a class="markdownIt-Anchor" href="#版本差异"></a> 版本差异</h2><p><img src="https://files.shanqianche.cn/20232/1675595525009.png" alt="版本差异" /></p><p><img src="https://files.shanqianche.cn/20232/1675602227092.png" alt="术语" /><br /><strong>副处理器可以省电70%</strong></p><p><img src="https://files.shanqianche.cn/20232/1675606315822.png" alt="A系列关键技术点" /></p><p><img src="https://files.shanqianche.cn/20232/1675609865655.png" alt="交叉编译工具" /></p><h2 id="cpu组成"><a class="markdownIt-Anchor" href="#cpu组成"></a> CPU组成</h2><blockquote><p>基本组成：ALU（计算单元，累加器）、控制器（切换）、寄存器、总线（连接）</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675610644529.png" alt="CPU基本结果" /></p><h2 id="处理模式"><a class="markdownIt-Anchor" href="#处理模式"></a> 处理模式</h2><p>ARM7、ARM9：7中<br />Cortex-A：9种。8种特权模式，一种非特权模式即用户模式</p><p><img src="https://files.shanqianche.cn/20232/1675611499740.png" alt="处理器模式" /></p><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><ul><li>SP：堆栈寄存器</li><li>LR：链接寄存器</li><li>PC：程序寄存器</li><li>PSR：程序状态寄存器</li><li>APSR：应用程序状态寄存器</li><li>CPSR：当前程序状态寄存器</li><li>SPSR：已存储程序状态寄存器</li></ul><p><strong>只有在用户模式下才是ASPR，其它模式都是CSPR</strong></p><ol><li>R0-R12通用寄存器，放通用数据，<strong>32bit</strong></li><li>各个模式的R0-R12与USR模式是共享的(除了FIQ,R8-R12),PC,CPSR共享的</li><li>USRR模式没有SPSR</li></ol><p><img src="https://files.shanqianche.cn/20232/1675612963542.png" alt="寄存器模式" /></p><p><img src="https://files.shanqianche.cn/20232/1675613628412.png" alt="Thumb精简指令集只能访问0-7位寄存器" /></p><h2 id="cspr指令格式"><a class="markdownIt-Anchor" href="#cspr指令格式"></a> CSPR指令格式</h2><p><img src="https://files.shanqianche.cn/20232/1675614193016.png" alt="CSPR指令格式" /></p><ul><li>M：九种模式，五位表示</li><li>T：是否使用Thumb指令</li><li>F：是否<strong>禁用</strong>FIQ</li><li>I：是否<strong>禁用</strong>IRQ</li><li>A：是否<strong>禁用</strong>ABT</li><li>E：存储字节的顺序（大段还是小段，因为存储时以字为单位，所以需要选择存储顺序）</li><li>IT：Thumb2指令的if…then…条件执行</li><li>GE：SIMD</li><li>J：Jazelle（Java）</li><li>Q：累计饱和instructions</li><li>V：ALU操作溢出</li><li>C：ALU进位操作</li><li>Z：ALU零位</li><li>N：ALU负数</li></ul><h2 id="指令流水线"><a class="markdownIt-Anchor" href="#指令流水线"></a> 指令流水线</h2><p><img src="https://files.shanqianche.cn/20232/1675614681987.png" alt="三级指令流水线Pipeline" /><br /><strong>F-&gt;D-&gt;E：取码-&gt;译码-&gt;执行</strong></p><ul><li>扩展到无极流水（<strong>分解指令过程</strong>）：<br />-指令预读取（决定从内存哪儿取指令）。PerFetch<ul><li>指令读取（从内存系统中读取指令）。Fetch</li><li>指令译码（解读指令并且生成控制信号）</li><li>寄存器牍取（提供寄存器的值给操作单元）</li><li>分配（分配指令给执行单元）</li><li>执行(实际的ALU单元处理)</li><li>内存访问（数据的存取）</li><li>寄存器回写（更新运行结果到寄存器）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="ARM" scheme="https://merlynr.github.io/categories/ARM/"/>
    
    
    <category term="study, graduate student,ARM" scheme="https://merlynr.github.io/tags/study-graduate-student-ARM/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程的同步</title>
    <link href="https://merlynr.github.io/2023/02/04/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
    <id>https://merlynr.github.io/2023/02/04/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/</id>
    <published>2023-02-04T04:05:00.000Z</published>
    <updated>2023-02-04T04:05:00.000Z</updated>
    
    
    <summary type="html">Linux,多线程，同步</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多进程之间的通信(二)</title>
    <link href="https://merlynr.github.io/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/"/>
    <id>https://merlynr.github.io/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/</id>
    <published>2023-02-01T02:01:00.000Z</published>
    <updated>2023-02-01T02:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ipc-基本结构"><a class="markdownIt-Anchor" href="#ipc-基本结构"></a> IPC 基本结构</h1><h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><blockquote><p>IPC通信包括：共享内存，消息队列，信号灯</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675260317404.png" alt="IPC结构" /></p><p><img src="https://files.shanqianche.cn/20232/1675261800916.png" alt="三种通信方式的函数" /></p><h2 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h2><p><img src="https://files.shanqianche.cn/20232/1675262145597.png" alt="shmget创建共享内存" /><br /><strong>打开或创建一个共享内存对象，共享内核在内核是什么样子的？</strong><br />一块缓存，变类似于用户空间的数组或malloc函数分配的空间一样。</p><blockquote><p>查看IPC对象：ipcs -m【查看共享内存】| -q【队列】| -s【信号灯】<br />删除IPC对象：ipcrm -m | -q | -s id【IPC的ID】</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262428512.png" alt="共享内存的读" /></p><blockquote><p>共享内存可以通过memcpy写入，也可以通过键盘输入stdin</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262526768.png" alt="删除映射到用户的内存" /></p><h3 id="利用键盘输入读取共享内存"><a class="markdownIt-Anchor" href="#利用键盘输入读取共享内存"></a> 利用键盘输入读取共享内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="comment">//create user memoey mapping </span></span><br><span class="line">p = (<span class="keyword">char</span> *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write to memory by keymap</span></span><br><span class="line">fgets(p,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675263694621.gif" alt="ret" /></p><p><strong><font color="#FF8C00">共享内存特点</font></strong>：</p><ol><li>共享内存创建之后，一直存在于内核中，直到被删除或系统关闭：</li><li>共享内存和管道不一样，读取后，内容仍在其共享内存中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上一段代码的修改</span></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second read :%s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">shmdt(p);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(p,<span class="string">&quot;abcd&quot;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675264544802.gif" alt="shmdt后，共享内存依旧存在但用户无法写入，说明映射到用户的内存被删除了" /></p><p><img src="https://files.shanqianche.cn/20232/1675264693642.png" alt="查看，设置，删除共享内存，shmctl" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除共享内存</span></span><br><span class="line">shmdt(p);</span><br><span class="line"><span class="comment">//system(&quot;ipcs -m&quot;);</span></span><br><span class="line"><span class="comment">//memcpy(p,&quot;abcd&quot;,4);</span></span><br><span class="line"><span class="comment">//printf(&quot;third read :%s\n&quot;,p);</span></span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;have delete share memory\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675265486449.gif" alt="ret" /></p><h3 id="不同进程之间的通信"><a class="markdownIt-Anchor" href="#不同进程之间的通信"></a> 不同进程之间的通信</h3><blockquote><p>宏IPC_PRIVATE:只可以打开亲属之间的共享内存，不同进程之间的需要ftok来获取shmid。</p></blockquote><p><strong>服务端代码，进程通过kill发送SIGUSR1给客户端进程告知已写入share memory。同时接收SIGUSR2信号。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR2,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;pid = getpid();<span class="comment">//write server pid to share memory</span></span><br><span class="line">pause(); <span class="comment">// wait client read server pid;</span></span><br><span class="line">pid = p-&gt;pid;<span class="comment">//read client pid;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process start write share memory!\n&quot;</span>);</span><br><span class="line">fgets(p-&gt;buf,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line">kill(pid,SIGUSR1);<span class="comment">// client process read data</span></span><br><span class="line">pause();<span class="comment">//wait client process read</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码，进程通过kill发送SIGUSR2给服务端进程告知已读取share memory。同时接收SIGUSR1信号，进行读取。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR1,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get serve pid</span></span><br><span class="line"><span class="comment">// read share memory</span></span><br><span class="line">pid = p-&gt;pid;</span><br><span class="line"><span class="comment">//write client pid to share memory</span></span><br><span class="line">p-&gt;pid = getpid();</span><br><span class="line">kill(pid,SIGUSR2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pause();<span class="comment">//waits server  process read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client has read: %s\n&quot;</span>,p-&gt;buf);</span><br><span class="line">kill(pid,SIGUSR2);<span class="comment">// server can write share memory</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675269810736.gif" alt="ret" /></p><h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p><img src="https://files.shanqianche.cn/20232/1675269875809.png" alt="kernel中的消息队列" /></p><p><img src="https://files.shanqianche.cn/20232/1675269995630.png" alt="msgget创建消息队列" /></p><p><img src="https://files.shanqianche.cn/20232/1675270095098.png" alt="msgctl消息队列读取，设置，删除" /></p><p><img src="https://files.shanqianche.cn/20232/1675270271071.png" alt="msgsnd发送数据" /><br /><strong>其中消息类型要与队列中消息类型进行匹配</strong></p><p><img src="https://files.shanqianche.cn/20232/1675270412264.png" alt="msgrcv读取消息队列" /></p><h3 id="无亲缘关系的读写"><a class="markdownIt-Anchor" href="#无亲缘关系的读写"></a> 无亲缘关系的读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_write.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(sendbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear send buffer</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PLZ inout msg: &quot;</span>);</span><br><span class="line">fgets(sendbuf.msg,<span class="number">124</span>,<span class="built_in">stdin</span>);</span><br><span class="line">msgsnd(msgid,(<span class="keyword">void</span> *)&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.msg),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_read.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(readbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear read buffer</span></span><br><span class="line">msgrcv(msgid,(<span class="keyword">void</span> *)&amp;readbuf,<span class="number">124</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv msg : %s\n&quot;</span>,readbuf.msg);</span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675272294978.gif" alt="非亲缘关系的通信" /></p><h2 id="信号灯"><a class="markdownIt-Anchor" href="#信号灯"></a> 信号灯</h2><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3><p><strong>信号灯</strong>：信号灯集合（可以包含多个信号灯）PC对象是一个信号灯集（多个信号量）</p><p><img src="https://files.shanqianche.cn/20232/1675272452939.png" alt="由两组值构成的某个信号灯集的内核数据结构" /></p><p><img src="https://files.shanqianche.cn/20232/1675272509363.png" alt="semget创建" /></p><p><img src="https://files.shanqianche.cn/20232/1675272576680.png" alt="semctl：获取、设置、删除信号灯" /></p><p><img src="https://files.shanqianche.cn/20232/1675335695421.png" alt="PV操作" /></p><h3 id="利用信号灯进行通信"><a class="markdownIt-Anchor" href="#利用信号灯进行通信"></a> 利用信号灯进行通信</h3><blockquote><p>利用ftok创建key，然后构建信号灯。首先运行客户端，信号量初始化在客户端上，并进行V操作，所以信号量资源被释放，无法利用。下一步执行服务端，服务端先执行任务，然后发送P操作信息，由此分配资源给客户端。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_server.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess! key=%d\n&quot;</span>,key);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess! semid = %d\n&quot;</span>,semid);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line"><span class="comment">//mysemun.val = 0;</span></span><br><span class="line"><span class="comment">//semctl(semid,0,SETVAL,mysemun);</span></span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端才可以进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">mysembuf.sem_op =<span class="number">1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_client.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess\n&quot;</span>);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line">mysemun.val = <span class="number">0</span>;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,mysemun);</span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//p wait</span></span><br><span class="line">mysembuf.sem_op=<span class="number">-1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//mysembuf.sem_op =1;</span></span><br><span class="line"><span class="comment">//semop(semid,&amp;mysembuf,1);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675351711955.gif" alt="ret" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多进程之间的通信(一)</title>
    <link href="https://merlynr.github.io/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/"/>
    <id>https://merlynr.github.io/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/</id>
    <published>2023-01-30T17:02:00.000Z</published>
    <updated>2023-01-30T17:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><h2 id="关键"><a class="markdownIt-Anchor" href="#关键"></a> 关键</h2><p>进程通信：在用户空间实现进程通信是不可能的，通过<strong>Linux内核通信</strong><br />线程间通信：可以<strong>在用户空间</strong>就可以实现，可以通过<strong>全局变量</strong>通信。</p><h2 id="方式"><a class="markdownIt-Anchor" href="#方式"></a> 方式</h2><p><font color="#FF8C00">管道通信</font>：无名管道、有名管道（文件系统中有名,文件系统）<br /><font color="#FF8C00">信号通信</font>：信号（通知）通信包括：信号的发送、信号的接收和信号的处理。<br /><font color="#FF8C00">IPC(Inter-Process Communication)通信</font>：共享内存、消息队列和信号灯。<br />以上是<strong>单机模式</strong>下的进程通信(只有一个L加ux内核)<br /><em>Socket通信：存在于一个网络中两个进程之间的通信(两个Linux内核)。</em></p><h2 id="通信实现的思想"><a class="markdownIt-Anchor" href="#通信实现的思想"></a> 通信实现的思想</h2><blockquote><p><strong>基于文件IO理念</strong></p></blockquote><p>open:功能：创建或打开进程通信对象。函数形式不一样，有的是有多个函数完成。<br />write:功能：向进程通信对象中写入内容。函数形式可能不一样。<br />read:功能：从进程通信对象中读取内容。函数形式可能不一样。<br />close:功能：关闭或删除进程通信对象。形式可能不一样。</p><h1 id="管道通信"><a class="markdownIt-Anchor" href="#管道通信"></a> 管道通信</h1><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><img src="https://files.shanqianche.cn/20231/1675161823138.png" alt="管道原理" /></p><blockquote><p>管道文件是一个特殊的文件，是由队列来实现的。</p></blockquote><h2 id="无名管道"><a class="markdownIt-Anchor" href="#无名管道"></a> 无名管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><strong>水从高处流</strong><br />The array pipefd is used to return two file descriptors referring to the ends of the pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by  the kernel until it is read from the read end of the pipe.</p><blockquote><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就删除了；队列</li><li>如果管道中没有东西可读，则会阻塞</li></ol></blockquote><h3 id="无名管道的创建"><a class="markdownIt-Anchor" href="#无名管道的创建"></a> 无名管道的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c </span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><strong>Linux内核在创建进程的时候会默认创建三个文件描述符，即0，1，2。所以无名管道返回的文件描述符为3，1、4</strong></p><p><img src="https://files.shanqianche.cn/20231/1675163282239.png" alt="res" /></p><h3 id="无名管道的读写"><a class="markdownIt-Anchor" href="#无名管道的读写"></a> 无名管道的读写</h3><p><strong>关键</strong></p><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就别除了：队列</li><li>如果管道中没有东西可读，则会阻塞。</li><li>验证写阻塞：可以计算出内核开辟的管道有多大,队列超过这么大会发生写<strong>堵塞</strong>。5456 5457.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> writebuff[]=<span class="string">&quot;hello Linux&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> readbuff[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// write</span></span><br><span class="line">write(fd[<span class="number">1</span>],writebuff,<span class="keyword">sizeof</span>(writebuff));</span><br><span class="line"></span><br><span class="line"><span class="comment">//first read</span></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//second read </span></span><br><span class="line"></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675164287464.png" alt="只能读一次，发生读堵塞" /></p><p><img src="https://files.shanqianche.cn/20231/1675164430147.png" alt="阻塞状态ps -axj" /></p><p>无名管道的<font color="#FF00FF">缺点</font>：不能实现不是父子进程（亲缘关系）之间的通信。</p><h2 id="有名管道"><a class="markdownIt-Anchor" href="#有名管道"></a> 有名管道</h2><blockquote><p>由于无名管道的缺点，对无名管道进行改进：有名管道<br />所谓的有名，即文件系统中存在这个一样文件节点，每一个文件节点都有一个node号<br />而且这是一个特殊的文件类型：<strong>p管道类型</strong>。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1675165035697.png" alt="mkfifo函数" /></p><blockquote><p>Create named pipes (FIFOs) with the given NAMEs</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时38分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = mkfifo(<span class="string">&quot;./myfifo&quot;</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip failure by file. ret = %d/n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create sucess\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675165870881.png" alt="基于文件系统的有名管道的创建" /></p><ol><li>创建这个文件节点，不可以通过open函数，open函数只能创建普通文件，不能创建特殊文件（管道-mkdifo,套接字-socket,字符设备文件-mknod,块设备文件-mknod, 符号链接文件-ln-s,目录文件mkdir）</li><li>管道文件<font color="#FF8C00">只有node号，不占磁盘块空间</font>，<strong>和套接字、字符设备文件、块设备文件一<br />样。普通文件和符号链接文件及目录文件，不仅有node号，还占磁盘块空间。</strong></li><li><font color="#FF8C00">mkfifo用来创建管道文件的<strong>节点</strong>，<strong>没有在内核中创建管道</strong>。只有通过open函数打开这个文件时才会在内核空间创建管道。</font></li></ol><h3 id="利用有名管道进行进程通信"><a class="markdownIt-Anchor" href="#利用有名管道进行进程通信"></a> 利用有名管道进行进程通信</h3><blockquote><p>基于上一步创建的管道节点进行通信，进程一等待五秒后向通道发送信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is first process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">process_state = <span class="number">1</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">write(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line">read(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(process_state==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is second process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675167881162.png" alt="ret" /></p><h1 id="信号通信"><a class="markdownIt-Anchor" href="#信号通信"></a> 信号通信</h1><h2 id="信号发送"><a class="markdownIt-Anchor" href="#信号发送"></a> 信号发送</h2><p><img src="https://files.shanqianche.cn/20231/1675167965840.png" alt="Linux中的64种信号" /></p><p><img src="https://files.shanqianche.cn/20231/1675173652422.png" alt="kill命令" /></p><p><img src="https://files.shanqianche.cn/20231/1675174619900.png" alt="raise函数" /></p><p><img src="https://files.shanqianche.cn/20231/1675179787808.png" alt="alarm函数" /><br /><strong>信号通信的框架</strong></p><ol><li>信号的发送（发送信号进程）：kill raise alarm</li><li>信号的接收（接收信号进程）：pause() sleep while(1)</li><li>信号的处理（接收信号进程）：signal</li></ol><p><strong>kill函数的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: kill_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时04分08秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input param\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sig = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">pid = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sig=%d, pid = %d\n&quot;</span>,sig,pid);</span><br><span class="line"></span><br><span class="line">kill(pid,sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675174377994.png" alt="ret" /></p><h2 id="简单使用killwaitpid"><a class="markdownIt-Anchor" href="#简单使用killwaitpid"></a> 简单使用kill，waitpid</h2><blockquote><p>案例: 开始时主进程处于睡眠状态S,子进程处于暂停T. 八秒后主进程杀死子进程并利用while进入S. 但是子进程被杀死后没有回收资源所以进入僵尸状态Z.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,WNOHANG) ==<span class="number">0</span>) <span class="comment">//等待进程状态，返回值为0时表示并未退出。pid为进程id，NULL为不获取进程返回值，WNOHANG为非阻塞</span></span><br><span class="line">&#123;</span><br><span class="line">kill(pid,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait(NULL);//回收进程资源</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function before\n&quot;</span>);</span><br><span class="line">raise(SIGTSTP);<span class="comment">//SIGSTP 暂停交互，== Ctrl+Z</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function after\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675176776671.gif" alt="process" /></p><p><img src="https://files.shanqianche.cn/20231/1675179547533.gif" alt="使用wait函数回收资源" /></p><h2 id="信号处理"><a class="markdownIt-Anchor" href="#信号处理"></a> 信号处理</h2><p><img src="https://files.shanqianche.cn/20231/1675180318371.png" alt="signal函数" /></p><blockquote><p>signal函数:返回一个函数指针. 含有两个参数,第一个为信号值, 第二个为一个函数指针,其中返回值为void.<br /><strong><font color="#FF8C00">默认处理信号方式为终止信号.</font></strong></p></blockquote><h3 id="alarm处理信号"><a class="markdownIt-Anchor" href="#alarm处理信号"></a> alarm处理信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: signal_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 23时56分47秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process sleep %d s!\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">signal(<span class="number">14</span>,myfun); <span class="comment">// 14为SIGALRM</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;alarm start\n&quot;</span>);</span><br><span class="line">alarm(<span class="number">9</span>);<span class="comment">//九秒后触发myfun</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;next step\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main do %d s\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675184647775.png" alt="ret" /></p><h3 id="signal信号处理"><a class="markdownIt-Anchor" href="#signal信号处理"></a> signal信号处理</h3><blockquote><p>父子进程进行通信</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;receive signum = %d, i = %d\n&quot;</span>,signum,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> myfun1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PID is %d\n&quot;</span>,pid);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">signal(<span class="number">10</span>,myfun);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A say %d\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">kill(getppid(),<span class="number">10</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//kill SIGCHILD</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675188572460.png" alt="ret" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>信号通信fork函数</title>
    <link href="https://merlynr.github.io/2023/01/31/%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1fork%E5%87%BD%E6%95%B0/"/>
    <id>https://merlynr.github.io/2023/01/31/%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1fork%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-30T17:02:00.000Z</published>
    <updated>2023-01-30T17:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-fork-后的父子进程"><a class="markdownIt-Anchor" href="#一-fork-后的父子进程"></a> 一、fork 后的父子进程</h1><p>由 fork 创建的新进程被称为子进程（child process）。<strong>该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是 0</strong>，而<strong>父进程的返回值则是新进程（子进程）的进程 id。将子进程 id 返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程 id</strong>。对子进程来说，之所以 fork 返回 0 给它，是因为它随时可以调用 <strong>getpid() 来获取自己的 pid；也可以调用 getppid() 来获取父进程的 id</strong>。(进程 id 0 总是由交换进程使用，所以一个子进程的进程 id 不可能为 0)。</p><p>fork 之后，<strong><a href="http://lib.csdn.net/base/operatingsystem" title="操作系统知识库">操作系统</a>会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这 2 个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置</strong>（两进程的程序计数器 pc 值相同，也就是说，子进程是从 fork 返回处开始执行的），但有一点不同，如果 fork 成功，子进程中 fork 的返回值是 0，父进程中 fork 的返回值是子进程的进程号，如果 fork 不成功，父进程会返回错误。<br />可以这样想象，2 个进程一直同时运行，而且步调一致，在 fork 之后，他们分别作不同的工作，也就是分岔了。这也是 fork 为什么叫 fork 的原因</p><p>至于那一个最先运行，可能与操作系统（调度<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库">算法</a>）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。</p><p><strong>[cpp]</strong>  <a href="http://blog.csdn.net/koudaidai/article/details/8014782#" title="view plain">view plain</a> <a href="http://blog.csdn.net/koudaidai/article/details/8014782#" title="copy">copy</a></p><ol><li><p>include &lt;stdio.h&gt;</p></li><li><p>#include &lt;unistd.h&gt;</p></li><li><p>#include &lt;stdlib.h&gt;</p></li><li><p>#include &lt;errno.h&gt;</p></li><li><p>int main(void)</p></li><li><p>{</p></li><li><p>pid_t pid=fork();</p></li><li><p>if(pid==0)</p></li><li><p>{</p></li><li><p>int j ;</p></li><li><p>for(j=0;j&lt;10;j++)</p></li><li><p>{</p></li><li><p>printf(“child: %d\n”,j);</p></li><li><p>sleep(1);</p></li><li><p>}</p></li><li><p>}</p></li><li><p>else if (pid&gt;0)</p></li><li><p>{</p></li><li><p>int i;</p></li><li><p>for(i=0;i&lt;10;i++)</p></li><li><p>{</p></li><li><p>printf(“parent: %d\n”,i);</p></li><li><p>sleep(1);</p></li><li><p>}</p></li><li><p>}</p></li><li><p>else</p></li><li><p>{</p></li><li><p>fprintf(stderr,“can’t fork ,error %d\n”,errno);</p></li><li><p>exit(1);</p></li><li><p>}</p></li><li><p>printf(“This is the end !”);</p></li><li><p>}</p></li></ol><h1 id="二-fork-出的子进程和父进程的继承关系"><a class="markdownIt-Anchor" href="#二-fork-出的子进程和父进程的继承关系"></a> 二、fork 出的子进程和父进程的继承关系</h1><p>fork 出来的子进程，基本上除了进程号之外父进程的所有东西都有一份拷贝，基本就意味着不是全部，下面我们要说的是子进程从父进程那里继承了什么东西，什么东西没有继承。还有一点需要注意，子进程得到的只是父进程的拷贝，而不是父进程资源的本身。</p><p><strong>由子进程自父进程继承到：</strong></p><ol><li>进程的资格 (真实(real)/ 有效(effective)/ 已保存(saved) 用户号 (UIDs) 和组号(GIDs))</li><li>环境 (environment)</li><li>堆栈</li><li>内存</li><li>打开文件的描述符 (注意对应的文件的位置由父子进程共享，这会引起含糊情况)</li><li>执行时关闭 (close-on-exec) 标志 (译者注：close-on-exec 标志可通过 fnctl() 对文件描述符设置，POSIX.1 要求所有目录流都必须在 exec 函数调用时关闭。更详细说明，参见《UNIX 环境高级编程》 W. R. Stevens, 1993, 尤晋元等译(以下简称《高级编程》), 3.13 节和 8.9 节)</li><li>信号 (signal) 控制设定<br />8.nice 值 (译者注：nice 值由 nice 函数设定，该值表示进程的优先级，数值越小，优先级越高)<br />进程调度类别 (scheduler class)(译者注：进程调度类别指进程在系统中被调度时所属的类别，不同类别有不同优先级，根据进程调度类别和 nice 值，进程调度程序可计算出每个进程的全局优先级 (Global process prority)，优先级高的进程优先执行)</li><li>进程组号</li><li>对话期 ID(Session ID) (译者注：译文取自《高级编程》，指：进程所属的对话期 (session)ID， 一个对话期包括一个或多个进程组， 更详细说明参见《高级编程》9.5 节)</li><li>当前工作目录</li><li>根目录 (译者注：根目录不一定是 “/”，它可由 chroot 函数改变)</li><li>文件方式创建屏蔽字 (file mode creation mask (umask))(译者注：译文取自《高级编程》，指：创建新文件的缺省屏蔽字)</li><li>资源限制</li><li>控制终端</li></ol><p><strong>子进程所独有：</strong></p><p>进程号</p><ol><li>不同的父进程号 (译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由 getppid 函数得到)</li><li>自己的文件描述符和目录流的拷贝 (译者注：目录流由 opendir 函数创建，因其为顺序读取，顾称 “目录流”)</li><li>子进程不继承父进程的进程，正文 (text)， 数据和其它锁定内存 (memory locks)(译者注：锁定内存指被锁定的虚拟内存页，锁定后，4. 不允许内核将其在必要时换出 (page out)，详细说明参见《The GNU C Library Reference Manual》 2.2 版， 1999, 3.4.2 节)</li><li>在 tms 结构中的系统时间 (译者注：tms 结构可由 times 函数获得，它保存四个数据用于记录进程使用中央处理器 (CPU：Central Processing Unit) 的时间，包括：用户时间，系统时间， 用户各子进程合计时间，系统各子进程合计时间)</li><li>资源使用 (resource utilizations) 设定为 0</li><li>阻塞信号集初始化为空集 (译者注：原文此处不明确，译文根据 fork 函数手册页稍做修改)</li><li>不继承由 timer_create 函数创建的计时器</li><li>不继承异步输入和输出</li></ol>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study,graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程</title>
    <link href="https://merlynr.github.io/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://merlynr.github.io/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-01-29T03:56:00.000Z</published>
    <updated>2023-01-29T03:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><blockquote><p>进程：一个正在执行的程序，它是<strong>资源分配的最小单位</strong><br />进程中的事情需要按照一定的顺序透个进行，那么如何让一个进程中的一些事情同时执行？<br /><strong>线程</strong></p></blockquote><blockquote><p>线程：有时又称轻里级进程，<strong>程序执行的最小单位</strong>，系统独立调度和分派cu的基本单位，它是进程中的一个实<br />体。一个进程中可以有多中线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。<br />进程出现了很多弊端，一是由于进程是资源拥有者，创建、微消与切换存在较大的时空开销，因此需要引入轻型进<br />程：二是由于对称多处理机(SMP)出现，可以满足多个运行单位，而多个进程并行开销过大。</p></blockquote><blockquote><p>并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执<br />行的效果。看起来同时发生，实际上单核内轮询执行。</p></blockquote><blockquote><p>并行是指在同一时刻，有多条指令在多个处理器上同时执行。真正的同时发生</p></blockquote><blockquote><p>同步：彼比有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情</p></blockquote><blockquote><p>异步的解念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生</p></blockquote><h1 id="主线程"><a class="markdownIt-Anchor" href="#主线程"></a> 主线程</h1><ol><li>当c程序运行时，首先运行main函数。在统程代码中，这个特殊的执行流被称作<strong>初始线程或者主线程</strong>。你可以在初始线程中做任何普通线程可以做的串情。<br />2、主线程的特殊性在于，它在main函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用pthread_exit函数，这样进程就会等待所有线程结束时才终止。</li><li>主线程接受参数的方式是通过<strong>argc和argv</strong>,而<strong>普通的线程只有</strong>一个参数&quot;void *”</li><li>在绝大乡数情况下，主统程在默认堆栈上运行，这个堆栈可以增长到<strong>足够的长度</strong>。而普通线程的堆栈是<strong>受限制</strong>的，一旦溢出就会产生错误</li></ol><h2 id="主线程的创建"><a class="markdownIt-Anchor" href="#主线程的创建"></a> 主线程的创建</h2><p>1、主线程是随着进程的创建而创建<br />2、其他线程可以通过调用函数来创建，主要调用pthread_create<br /><em>请注意，新线程可能在当前线程从函数pthread create返回之前就已经运行了，甚至新线程可能在当前线程从函数pthread create返回之前就已经运行完毕了</em></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础之文件系统</title>
    <link href="https://merlynr.github.io/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://merlynr.github.io/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-01-27T18:35:00.000Z</published>
    <updated>2023-01-27T18:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统功能"><a class="markdownIt-Anchor" href="#文件系统功能"></a> 文件系统功能</h1><ul><li>能定义文件的组织方式，文件结构</li><li>提供建立和存取文件的环境：目录和文件</li><li>能对文件存储器空间进行组织和分配</li><li>负责文件存储并对存入的文件进行保护和检索</li><li>负责建立文件，存入、读出、修改、转储文件，控制文件的存取，撤销文件等</li></ul><h1 id="文件系统分类"><a class="markdownIt-Anchor" href="#文件系统分类"></a> 文件系统分类</h1><ul><li>磁盘文件系：NTFS，EXT3</li><li>闪存文件系统，JFFS2,YAFFS</li><li>数据库文件系统，BFFS,WINFS</li><li>网络文件系统：NFS</li><li>虚拟文件系统，VFS(Proc)</li></ul><h1 id="linux文件系统"><a class="markdownIt-Anchor" href="#linux文件系统"></a> Linux文件系统</h1><h2 id="ext3"><a class="markdownIt-Anchor" href="#ext3"></a> EXT3</h2><ul><li>EXT3是<strong>基于日志方式</strong>的文件系统</li><li>系统中每个文件都是有<strong>索引</strong>，</li><li>用户对对文件的每一个操作都会<strong>记录日志</strong>，</li><li>形成一个任务<strong>队列</strong>排着执行</li><li><strong>性能</strong>是比较好</li></ul><h2 id="swap"><a class="markdownIt-Anchor" href="#swap"></a> SWAP</h2><p>swap是<strong>交换分区</strong>的文件系统，类似windows的虚拟内存<br />虚拟内存的实现：两种方式</p><ol><li>第一种是进行内存的排列像内存池一样，进行一个优化</li><li>第二种是把硬盘上的空间模拟成内存<br />swap是Linux的虚拟内存，在安装时要设好大小，是<strong>物理内存的2倍</strong></li></ol><h1 id="linux与window目录结构的区别"><a class="markdownIt-Anchor" href="#linux与window目录结构的区别"></a> Linux与Window目录结构的区别</h1><ol><li>根目录<br />Linux:/<br />Windows:\</li><li>命名写区分<br />Linux:命名区分大小写；<br />Windows:命名不区分大小写</li><li>结构管理<br />Linux:磁盘逻辑结构管理物理结构，格式化将磁盘分为很多的文件块区<br />Windows:物理结构管理逻结构，先分区再格式化建立结构</li></ol><h1 id="linux文件系统目录"><a class="markdownIt-Anchor" href="#linux文件系统目录"></a> Linux文件系统目录</h1><p><img src="https://files.shanqianche.cn/20231/1674895536500.png" alt="结构" /><br /><strong>/lib</strong> 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><h1 id="shell-特殊字符"><a class="markdownIt-Anchor" href="#shell-特殊字符"></a> shell 特殊字符</h1><ol><li>通配符* ？ []</li></ol><p><img src="https://files.shanqianche.cn/20231/1674895793138.png" alt="通配符" /><br />2. 单次执行多条命令。可以通过‘；’隔开<br />3. 输入输出重定向：&gt;,&lt;,&gt;&gt;</p><p><img src="https://files.shanqianche.cn/20231/1674895877046.png" alt="重定向" /><br />4. 管道符：|</p><p>将一个进程的输出作为另一个进程的输入<br />5. 其它%，$,~</p><p><img src="https://files.shanqianche.cn/20231/1674895997064.png" alt="其它符合" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="Linux" scheme="https://merlynr.github.io/categories/Linux/"/>
    
    
    <category term="study, graduate student,Linux" scheme="https://merlynr.github.io/tags/study-graduate-student-Linux/"/>
    
  </entry>
  
  <entry>
    <title>C语言之编译</title>
    <link href="https://merlynr.github.io/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/"/>
    <id>https://merlynr.github.io/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/</id>
    <published>2023-01-26T21:08:00.000Z</published>
    <updated>2023-01-26T21:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译过程"><a class="markdownIt-Anchor" href="#编译过程"></a> 编译过程</h1><p><img src="https://files.shanqianche.cn/20231/1674819567025.png" alt="C语言编译过程，层次递增，后边命令包含上边命令所有功能" /></p><blockquote><p><font color="#FF00FF">define include 不是关键字，他们在预编译的时候就被替代了。</font></p></blockquote><h1 id="常见编译错误"><a class="markdownIt-Anchor" href="#常见编译错误"></a> 常见编译错误</h1><ol><li>预处理错误</li></ol><p>#include”file.h“  默认先从<font color="#FF00FF">当前路径</font>中寻找，找不到再从系统环境中查找。<br />#include&lt;file.h&gt; 直接从系统环境中寻找</p><p><strong><font color="#DC143C">NOT FIND</font></strong> 注意自己创建用双引号。<br />解决方法：可以通过相对路径；通过写入头文件路径的方式。</p><p><img src="https://files.shanqianche.cn/20231/1674838061382.png" alt="相对路径" /></p><p><img src="https://files.shanqianche.cn/20231/1674838095708.png" alt="-I+路径" /><br />2. 链接错误<br /><strong>原材料不够或者溢出。</strong></p><ul><li>缺少原材料</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838261605.png" alt="函数缺少实现" /></p><p><img src="https://files.shanqianche.cn/20231/1674838294886.png" alt="链接器报错" /></p><ul><li>原材料溢出</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838515227.png" alt="链接器错误" /></p><p><strong>原因是链接重复的函数。</strong></p><h1 id="预处理的使用"><a class="markdownIt-Anchor" href="#预处理的使用"></a> 预处理的使用</h1><ol><li>#include 包含头文件</li><li>#define 宏，替换   <strong><font color="#FF8C00">预处理时不进行检查直接进行替换，在编译时才进行检查</font></strong></li><li>#define 宏名 宏体 <strong>为了避免错误，加括号</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 3+5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//3+5*5=28</span></span><br><span class="line"><span class="comment">//正确例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 (3+5)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//(3+5)*5=40</span></span><br></pre></td></tr></table></figure><ol start="4"><li>系统预定义宏</li></ol><p><img src="https://files.shanqianche.cn/20231/1674839269964.png" alt="前后双下划线" /></p><p><img src="https://files.shanqianche.cn/20231/1674839409010.png" alt="方便用于调试" /><br />5. 条件宏变量</p><blockquote><p>多用于控制不同版本的变量。（开发版与测试版）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674839665789.png" alt="如果定义了ABC则会输出，不定义则没有输出结果" /><br /><strong>同时可以通过命令来进行控制宏变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -D:</span><br><span class="line">gcc -DABC == <span class="meta">#<span class="meta-keyword">define</span> ABC</span></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1674839837663.png" alt="gcc -D" /><br />6. 宏展开下的 #、##</p><p><img src="https://files.shanqianche.cn/20231/1674839991226.png" alt="#、##" /></p><p><img src="https://files.shanqianche.cn/20231/1674840072964.png" alt="#" /></p><p><img src="https://files.shanqianche.cn/20231/1674840240184.png" alt="##" /></p><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><h2 id="注意数据类型所占位数防止溢出"><a class="markdownIt-Anchor" href="#注意数据类型所占位数防止溢出"></a> 注意数据类型所占位数，防止溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8b</span>it = <span class="number">1B</span></span><br><span class="line"><span class="keyword">char</span> = <span class="number">1B</span></span><br><span class="line">所以<span class="keyword">char</span>最大不超过 <span class="number">2</span>^<span class="number">8</span>=<span class="number">256.</span></span><br><span class="line"><span class="keyword">char</span> a =<span class="number">300.</span> a++会报错。</span><br></pre></td></tr></table></figure><h2 id="int大小的定义"><a class="markdownIt-Anchor" href="#int大小的定义"></a> int大小的定义</h2><blockquote><p>编译器最优的处理大小（由编译器决定）：<br />系统一个周期，所能接受的最大处理单位，int<br />32位系统，单词执行32bit，所以int大小32bit=4byte<br />单片机中存在16位系统，则int = 2B</p></blockquote><h1 id="signed与unsigned的注意"><a class="markdownIt-Anchor" href="#signed与unsigned的注意"></a> signed与unsigned的注意</h1><p>signed包含符号位，而unsigned不包含，所以进行位操作的时候会出现不同情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>=<span class="number">0xff</span></span><br><span class="line"><span class="keyword">signed</span>右移后不会变化。而<span class="keyword">unsigned</span>会变化，最后变为<span class="number">0.</span></span><br></pre></td></tr></table></figure><h1 id="类型修饰符"><a class="markdownIt-Anchor" href="#类型修饰符"></a> 类型修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674842433715.png" alt="类型修饰符" /></p><p><img src="https://files.shanqianche.cn/20231/1674842419473.png" alt="auto" /></p><p><img src="https://files.shanqianche.cn/20231/1674842567442.png" alt="register" /></p><blockquote><p><font color="#FF00FF">由于寄存器没有地址，所以对存入寄存器的值进行取址是无效的。</font></p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674842689701.png" alt="取址失败" /></p><h1 id="volatile-关键字"><a class="markdownIt-Anchor" href="#volatile-关键字"></a> volatile 关键字</h1><p><img src="https://files.shanqianche.cn/20231/1674842913259.png" alt="volatile" /></p><h1 id="硬件中乘除法需要注意"><a class="markdownIt-Anchor" href="#硬件中乘除法需要注意"></a> 硬件中乘除法需要注意</h1><p><img src="https://files.shanqianche.cn/20231/1674843024138.png" alt="乘除法" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>C语言之函数的使用</title>
    <link href="https://merlynr.github.io/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://merlynr.github.io/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-01-25T03:13:00.000Z</published>
    <updated>2023-01-25T03:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符空间与非字符空间的区别"><a class="markdownIt-Anchor" href="#字符空间与非字符空间的区别"></a> 字符空间与非字符空间的区别</h2><p><img src="https://files.shanqianche.cn/20231/1674544158303.png" alt="结束标符的不同" /></p><h2 id="函数地址传址"><a class="markdownIt-Anchor" href="#函数地址传址"></a> 函数地址传址</h2><p>嵌入式中对于单个值进行修改的可以使用int *，char *,long *。如果传递的是空间则默认为void *。</p><h2 id="指针指向的合法性"><a class="markdownIt-Anchor" href="#指针指向的合法性"></a> 指针指向的合法性</h2><blockquote><p>即函数中的局部变量在函数指向完会被清除，如果直接return局部变量会造成指针异常。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674807930550.png" alt="不合法例子" /></p><blockquote><p>合法空间：<font color="#FF8C00">非局部变量</font>，即非栈空间变量。static，常量，堆区（malloc，free）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674808110649.png" alt="通过static设置为静态变量" /></p><p><img src="https://files.shanqianche.cn/20231/1674810427874.png" alt="返回常量，不可修改" /></p><p><img src="https://files.shanqianche.cn/20231/1674810459713.png" alt="堆区" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>C语言之内存的操作</title>
    <link href="https://merlynr.github.io/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://merlynr.github.io/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2023-01-24T03:42:00.000Z</published>
    <updated>2023-01-24T03:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言格式符合"><a class="markdownIt-Anchor" href="#c语言格式符合"></a> c语言格式符合</h1><p><img src="https://files.shanqianche.cn/20231/1674625839183.png" alt="c语言格式符合" /></p><h1 id="const-修饰符"><a class="markdownIt-Anchor" href="#const-修饰符"></a> const 修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674626595923.png" alt="const" /></p><h1 id="volatile-修饰"><a class="markdownIt-Anchor" href="#volatile-修饰"></a> volatile 修饰</h1><p>防止内存优化，每次从地址读值</p><h1 id="typedef-别名"><a class="markdownIt-Anchor" href="#typedef-别名"></a> typedef 别名</h1><p><img src="https://files.shanqianche.cn/20231/1674626987035.png" alt="typedef" /></p><h1 id="指针运算操作"><a class="markdownIt-Anchor" href="#指针运算操作"></a> 指针运算操作</h1><p><img src="https://files.shanqianche.cn/20231/1674627210213.png" alt="指针加减运算" /></p><p><img src="https://files.shanqianche.cn/20231/1674627280255.png" alt="指针非线性访问数据" /></p><blockquote><p>指针运算：p+n取得的是地址，p[n]取出的是内容，值</p></blockquote><h1 id="内存越界"><a class="markdownIt-Anchor" href="#内存越界"></a> 内存越界</h1><blockquote><p>c语言存在内存越界，c++并不存在</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674628812520.png" alt="内存越界" /></p><h1 id="值比较"><a class="markdownIt-Anchor" href="#值比较"></a> 值比较</h1><p><img src="https://files.shanqianche.cn/20231/1674628996361.png" alt="NULL与0x0类似，但是0x0有的编译器不支持，所以推荐使用NULL" /></p><h1 id="多级指针的例子"><a class="markdownIt-Anchor" href="#多级指针的例子"></a> 多级指针的例子</h1><p><img src="https://files.shanqianche.cn/20231/1674629440012.png" alt="**grav表示数组中的字符串的地址" /></p><p><img src="https://files.shanqianche.cn/20231/1674629683298.png" alt="与上一个函数一样" /></p><p><img src="https://files.shanqianche.cn/20231/1674629432130.png" alt="res" /></p><h1 id="数组的初始化"><a class="markdownIt-Anchor" href="#数组的初始化"></a> 数组的初始化</h1><p><img src="https://files.shanqianche.cn/20231/1674630239737.png" alt="差异" /></p><blockquote><p>字符串末尾默认加‘\0’</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630294413.png" alt="\0" /></p><p><font color="#FF00FF">编译器只有第一次赋值可以一次性解决，以后对于数组操作，只能逐一操作，即一位一位进行修改。</font></p><h1 id="字符拷贝的问题"><a class="markdownIt-Anchor" href="#字符拷贝的问题"></a> 字符拷贝的问题</h1><blockquote><p>字符拷贝函数的原贝则：<br />内存空间和内存空间的逐一赋值的功能的一个封装体一旦空间中出现了0这个特殊值，函数就即将结束。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630865267.png" alt="strcpy" /><br />strcpy()函数存在问题，如果destination值后面没有’\0’，则会一直拷贝。工程中尽量不用。</p><p><img src="https://files.shanqianche.cn/20231/1674630876329.png" alt="strncpy" /><br />strncpy可以设置拷贝字符长度，避免内存泄漏。</p><h1 id="字符空间"><a class="markdownIt-Anchor" href="#字符空间"></a> 字符空间</h1><p><img src="https://files.shanqianche.cn/20231/1674631169177.png" alt="字符与非字符空间" /></p><h1 id="内存拷贝"><a class="markdownIt-Anchor" href="#内存拷贝"></a> 内存拷贝</h1><p><img src="https://files.shanqianche.cn/20231/1674631384044.png" alt="memcpy" /></p><h1 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h1><p><img src="https://files.shanqianche.cn/20231/1674632522625.png" alt="二维数组表达方式" /></p><p><img src="https://files.shanqianche.cn/20231/1674632589989.png" alt="三维" /></p><h1 id="结构体中字节对齐"><a class="markdownIt-Anchor" href="#结构体中字节对齐"></a> 结构体中字节对齐</h1><blockquote><p>即空间换效率，采取最大字节单位进行对其，所以空间大小都为4的倍数</p></blockquote><h1 id="代码编码后的地址位置"><a class="markdownIt-Anchor" href="#代码编码后的地址位置"></a> 代码编码后的地址位置</h1><blockquote><p>一般系统（ARM，x86等）的代码地址位于低地址</p></blockquote><p><font color="#FF00FF">x86：一般为于0x8084.</font>.</p><p><img src="https://files.shanqianche.cn/20231/1674634481092.png" alt="代码地址" /></p><h1 id="内存空间结构"><a class="markdownIt-Anchor" href="#内存空间结构"></a> 内存空间结构</h1><p><img src="https://files.shanqianche.cn/20231/1674659004309.png" alt="结构" /></p><p><img src="https://files.shanqianche.cn/20231/1674658712364.png" alt="内存查看" /></p><blockquote><p>只读空间：静态空间，整个程序结束时释放内存，生存周期最长<br />栈空军：运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内<br />堆空间：运行时，可以自我管理分配和释放的空间，程序员决定的。</p></blockquote><p><strong>堆空间分配：</strong> malloc(),一旦成功，返回分配好的地址给我们，只需要接受，对于这个新地址的读法，由程序员灵活把握输入参数指定分配的大小，单位就是B。</p><p><img src="https://files.shanqianche.cn/20231/1674659425331.png" alt="malloc函数" /></p><p><strong>释放空间：</strong> free§</p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="C Language" scheme="https://merlynr.github.io/categories/C-Language/"/>
    
    
    <category term="study, graduate student,C Language" scheme="https://merlynr.github.io/tags/study-graduate-student-C-Language/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之事件组(五)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/</id>
    <published>2022-12-16T03:39:00.000Z</published>
    <updated>2022-12-16T03:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件组等待"><a class="markdownIt-Anchor" href="#事件组等待"></a> 事件组等待</h2><p><img src="https://files.shanqianche.cn/202212/1671172487143.png" alt="创建事件组，返回一个event group句柄" /></p><p><img src="https://files.shanqianche.cn/202212/1671173162132.png" alt="查看当前事件组的位是否被设置，如果设置了则跳过，否则发生阻塞" /></p><p><img src="https://files.shanqianche.cn/202212/1671173611753.png" alt="设置事件组的值" /></p><blockquote><p>设置事件组大小，如果宏定义USE_16_BIT_TICKS设置为1则，事件组大小为8；如果为0则为24位。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671172754108.png" alt="Esp32的配置" /></p><p><img src="https://files.shanqianche.cn/202212/1671174406593.png" alt="创建事件组" /></p><p><img src="https://files.shanqianche.cn/202212/1671174563092.png" alt="事件组的判断，零位 | 四位 为1." /></p><p><img src="https://files.shanqianche.cn/202212/1671174626150.png" alt="Task2中对事件组0位和四位依次设置为1" /></p><p><img src="https://files.shanqianche.cn/202212/1671174723965.png" alt="条件为或时的结果" /></p><p><img src="https://files.shanqianche.cn/202212/1671174771887.png" alt="条件为与的结果" /></p><h2 id="事件组同"><a class="markdownIt-Anchor" href="#事件组同"></a> 事件组同</h2><blockquote><p>事件组等待的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175636282.png" alt="Step1：task1阻塞，task2，task3依次设置位" /></p><p><img src="https://files.shanqianche.cn/202212/1671175673767.png" alt="Step2：task1等待task2，3完成后开始设置自己的位" /></p><blockquote><p>事件组同步的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175874589.png" alt="事件组同步" /></p><p><img src="https://files.shanqianche.cn/202212/1671175906159.png" alt="Step1：三个事件依次设置，并等待" /></p><p><img src="https://files.shanqianche.cn/202212/1671175935762.png" alt="Step2：同时开始" /></p><p><strong>code</strong></p><p><img src="https://files.shanqianche.cn/202212/1671176947195.png" alt="BITS" /></p><p><img src="https://files.shanqianche.cn/202212/1671177513328.png" alt="创建事件组" /></p><p><img src="https://files.shanqianche.cn/202212/1671177624437.png" alt="Task0" /></p><p><img src="https://files.shanqianche.cn/202212/1671177635589.png" alt="Task1" /></p><p><img src="https://files.shanqianche.cn/202212/1671177641240.png" alt="Task2" /></p><p><img src="https://files.shanqianche.cn/202212/1671177663458.png" alt="结果" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之定时器(四)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/</id>
    <published>2022-12-16T03:37:00.000Z</published>
    <updated>2022-12-16T03:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="software-timer-软件定时器"><a class="markdownIt-Anchor" href="#software-timer-软件定时器"></a> Software Timer 软件定时器</h2><blockquote><p>基于Daemon Task，定时器任务通过定时器命令队列进行发送给执行指令，然后任务调用相应的程序，执行软件定时器的回调函数。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670983470929.png" alt="Software Timer" /></p><p><strong>软件定时器的特点</strong></p><ol><li>不受硬件影响，不受MCU的影响</li><li>软件定时器的数量与堆栈，TIMER_TASK_STACK_DEPTH的影响。不受影响影响</li></ol><p><img src="https://files.shanqianche.cn/202212/1670983728618.png" alt="xTimerCreate" /></p><p><img src="https://files.shanqianche.cn/202212/1670984266679.png" alt="启动定时器" /></p><p><img src="https://files.shanqianche.cn/202212/1670984718155.png" alt="xTimerStop" /></p><p><img src="https://files.shanqianche.cn/202212/1670984850319.png" alt="取得Timer的名字" /></p><p><img src="https://files.shanqianche.cn/202212/1670985084226.png" alt="获取Timer ID，返回一个指针" /></p><p><img src="https://files.shanqianche.cn/202212/1670985575931.png" alt="只要执行reset函数，定时器将不执行回调函数，类似于喂狗" /></p><p><img src="https://files.shanqianche.cn/202212/1670985661744.png" alt="改变定时器周期" /></p><p><strong>创建并启动定时器</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984663776.png" alt="创建并启动定时器" /><br /><strong>延时并停止</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984772340.png" alt="延时等待6s并停止" /></p><p><img src="https://files.shanqianche.cn/202212/1670984803629.png" alt="result" /></p><p><strong>获取Timer名字</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984974432.png" alt="公用一个回调函数" /></p><p><img src="https://files.shanqianche.cn/202212/1670985000934.png" alt="由于两秒执行一次Timer2，一秒一次Timer1；所以结果如此" /></p><p><strong>获取一个Timer ID</strong></p><p><img src="https://files.shanqianche.cn/202212/1670985351262.png" alt="方法一，Get Timer ID" /></p><p><img src="https://files.shanqianche.cn/202212/1670985502589.png" alt="方法二，返回指针获取ID" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之信号量(六)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/</id>
    <published>2022-12-16T03:35:00.000Z</published>
    <updated>2022-12-16T03:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="binary-semaphore-二进制信号"><a class="markdownIt-Anchor" href="#binary-semaphore-二进制信号"></a> Binary Semaphore 二进制信号</h2><p><img src="https://files.shanqianche.cn/202212/1670986242028.png" alt="创建信号量，向下兼容，不推荐使用" /></p><p><img src="https://files.shanqianche.cn/202212/1670986404539.png" alt="推荐使用这个创建信号" /></p><p><img src="https://files.shanqianche.cn/202212/1671088363753.png" alt="释放信号量" /></p><ol><li>使用信号量执行任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671088852864.png" alt="enter description here" /></p><blockquote><p>创建信号量之后为了使用它必须要释放它。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671089225283.png" alt="文档中提到了创建之后要释放它" /></p><ol><li>创建信号量并调用任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089333679.png" alt="创建信号量并释放，task才可以调用" /></p><ol start="2"><li>任务一进行调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089371462.png" alt="任务一" /></p><ol start="3"><li>任务二调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089387925.png" alt="Task2" /></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089481464.png" alt="全局变量" /></p><p><img src="https://files.shanqianche.cn/202212/1671089428031.png" alt="说明Task1和Task2锁住了全局变量" /></p><ol start="5"><li>未使用信号量呢</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089497958.png" alt="Task" /></p><ol start="6"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089571227.png" alt="没有使用信号量则会交替进行加一" /></p><h2 id="计数信号量"><a class="markdownIt-Anchor" href="#计数信号量"></a> 计数信号量</h2><p><img src="https://files.shanqianche.cn/202212/1671091200737.png" alt="获取信号量数目" /></p><p><img src="https://files.shanqianche.cn/202212/1671091310069.png" alt="取得可用信号成功则锁住" /></p><p><img src="https://files.shanqianche.cn/202212/1671091477101.png" alt="创建计数信号量" /></p><ol><li>创建任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091690613.png" alt="创建任务" /></p><ol start="2"><li>使用计数信号量，最大信号量减减</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091848978.png" alt="使用信号量" /></p><ol start="3"><li>释放信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091878388.png" alt="每到第六秒释放一个信号量" /></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091971061.png" alt="第五秒后没有信号量，第六秒进行释放后进行使用" /></p><p><img src="https://files.shanqianche.cn/202212/1671092027319.png" alt="每隔六秒可以获得一个信号量" /></p><h2 id="互斥量-mutex"><a class="markdownIt-Anchor" href="#互斥量-mutex"></a> 互斥量 mutex</h2><p><img src="https://files.shanqianche.cn/202212/1671099188414.png" alt="创建互斥量" /></p><p><strong>这块需要反复理解</strong></p><ol><li>创建信号量，挂起任务调度器，创建执行任务，开启任务调度器</li></ol><p><img src="https://files.shanqianche.cn/202212/1671107894154.png" alt="创建互斥信号量、挂起任务调度器、创建执行任务、开启任务调度器" /></p><p><img src="https://files.shanqianche.cn/202212/1671108236775.png" alt="Task1" /></p><p><img src="https://files.shanqianche.cn/202212/1671108106925.png" alt="Task2" /></p><p><img src="https://files.shanqianche.cn/202212/1671108024642.png" alt="Task3" /></p><blockquote><p>主要是优先级的继承，task1继承了task3所以可以执行任务</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671110095196.png" alt="互斥信号量" /></p><p><img src="https://files.shanqianche.cn/202212/1671110147625.png" alt="互斥信号量" /></p><blockquote><p>task3优先级最高首先运行，发生阻塞后task2开始执行，task2发生阻塞，task1开始执行，获取信号量并锁定。<br /><strong>由于task3的优先级高，所以task3开始执行，然而信号量依旧在task1那</strong>，并未被释放task1超出时间片，看门狗被触发，idle任务因为要用于内存的清理回收，idle任务无法执行，就会触发看门狗。<br />所以task3尝试取信号量，尝试失败后进入task2while循环，循环超时触发看门狗，然后task继续3尝试获取信号量。以此反复。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671111112169.png" alt="使用二进制信号量" /></p><p><img src="https://files.shanqianche.cn/202212/1671108979371.png" alt="二进制信号量的结果" /></p><h2 id="recursive-mutex-递归互斥锁"><a class="markdownIt-Anchor" href="#recursive-mutex-递归互斥锁"></a> Recursive Mutex 递归互斥锁</h2><p><img src="https://files.shanqianche.cn/202212/1671160318532.png" alt="task1获取A信号量并锁住，A需要B，所以继续获取B并锁住" /></p><p><img src="https://files.shanqianche.cn/202212/1671160501852.png" alt="创建递归互斥锁" /></p><p><img src="https://files.shanqianche.cn/202212/1671165183178.png" alt="创建并执行任务调度器" /></p><p><img src="https://files.shanqianche.cn/202212/1671172338333.png" alt="Task2" /></p><p><img src="https://files.shanqianche.cn/202212/1671172326291.png" alt="Task1" /></p><p><strong>结果：</strong></p><p><img src="https://files.shanqianche.cn/202212/1671172370707.png" alt="结果" /></p><p><img src="https://files.shanqianche.cn/202212/1671172394998.png" alt="结果" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
  <entry>
    <title>基于ESP32S3的FreeRTOS之队列(三)</title>
    <link href="https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/"/>
    <id>https://merlynr.github.io/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/</id>
    <published>2022-12-16T03:09:00.000Z</published>
    <updated>2022-12-16T03:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="queue队列"><a class="markdownIt-Anchor" href="#queue队列"></a> queue队列</h2><blockquote><p>常用于传递<font color="#FF00FF">整形、结构体及指针</font></p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670937269638.png" alt="queue" /></p><p><img src="https://files.shanqianche.cn/202212/1670937418178.png" alt="xQueueCreate" /></p><h3 id="传递整形"><a class="markdownIt-Anchor" href="#传递整形"></a> 传递整形</h3><ol><li>创建队列</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938179291.png" alt="创建队列" /></p><ol start="2"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938268578.png" alt="接收函数" /></p><ol start="3"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938366706.png" alt="接收函数" /></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938348411.png" alt="运行结果" /></p><ol start="5"><li>对接收函数进行优化</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938507920.png" alt="监控接收队列是否为空，不为才进行接收并打印" /></p><h3 id="传递结构体"><a class="markdownIt-Anchor" href="#传递结构体"></a> 传递结构体</h3><ol><li>结构体</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938695866.png" alt="结构体" /></p><ol start="2"><li>发送函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938716857.png" alt="发送函数" /><br />3. 接收函数</p><p><img src="https://files.shanqianche.cn/202212/1670938766379.png" alt="接收函数" /><br />4. 队列</p><p><img src="https://files.shanqianche.cn/202212/1670938806106.png" alt="修改队列宽度，即数据所占位数" /></p><h3 id="传递指针"><a class="markdownIt-Anchor" href="#传递指针"></a> 传递指针</h3><p><strong>小心内存的分配和清除，其它差不多</strong></p><h3 id="队列的多近单出"><a class="markdownIt-Anchor" href="#队列的多近单出"></a> 队列的多近单出</h3><ol><li>发送任务一</li></ol><blockquote><p>发送数字111</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940015975.png" alt="task1" /></p><ol start="2"><li>发送任务2</li></ol><blockquote><p>发送数字222</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940046663.png" alt="task2" /><br />3. 接收任务</p><p><img src="https://files.shanqianche.cn/202212/1670940095025.png" alt="接收并打印，并设置接收延时最大，阻塞一直等待接收" /><br />4. 队列管理</p><p><img src="https://files.shanqianche.cn/202212/1670940125054.png" alt="发送任务优先级一样，接收任务级别为2" /></p><h3 id="queue-set"><a class="markdownIt-Anchor" href="#queue-set"></a> Queue Set</h3><p><img src="https://files.shanqianche.cn/202212/1670942546618.png" alt="队列集合，当集合中中的队列哪个有数据则获取哪个队列的数据" /></p><ol><li>创建发送Task1</li></ol><p><img src="https://files.shanqianche.cn/202212/1670943244590.png" alt="Task1" /><br />2. 发送Task2</p><p><img src="https://files.shanqianche.cn/202212/1670943270669.png" alt="Task2" /><br />3. 接收Task</p><p><img src="https://files.shanqianche.cn/202212/1670944978777.png" alt="接收Task" /><br />4. Queue 将队列加入Set</p><p><img src="https://files.shanqianche.cn/202212/1670945004119.png" alt="Queue" /></p><h3 id="队列邮箱"><a class="markdownIt-Anchor" href="#队列邮箱"></a> 队列邮箱</h3><blockquote><p>里面存放一个数据<strong>即队列长度为1</strong>，有一个写入邮箱的task，有一个或多个读出邮箱的task</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670945120071.png" alt="Queue Mail" /></p><ol><li>queue mail</li></ol><p><img src="https://files.shanqianche.cn/202212/1670946095803.png" alt="三个read一个write" /><br />2. readTask</p><p><img src="https://files.shanqianche.cn/202212/1670946068507.png" alt="readTask" /><br />3. writeTask</p><p><img src="https://files.shanqianche.cn/202212/1670946161788.png" alt="readTask" /><br />4. 结果</p><p><img src="https://files.shanqianche.cn/202212/1670946264134.png" alt="写入延迟为6秒" /></p>]]></content>
    
    
    <summary type="html">description</summary>
    
    
    
    <category term="RTOS" scheme="https://merlynr.github.io/categories/RTOS/"/>
    
    
    <category term="study, graduate student,RTOS" scheme="https://merlynr.github.io/tags/study-graduate-student-RTOS/"/>
    
  </entry>
  
</feed>
