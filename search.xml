<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux多进程之间的通信(二)</title>
      <link href="/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/"/>
      <url>/2023/02/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-基本结构"><a href="#IPC-基本结构" class="headerlink" title="IPC 基本结构"></a>IPC 基本结构</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>IPC通信包括：共享内存，消息队列，信号灯</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675260317404.png" alt="IPC结构"></p><p><img src="https://files.shanqianche.cn/20232/1675261800916.png" alt="三种通信方式的函数"></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p><img src="https://files.shanqianche.cn/20232/1675262145597.png" alt="shmget创建共享内存"><br><strong>打开或创建一个共享内存对象，共享内核在内核是什么样子的？</strong><br>一块缓存，变类似于用户空间的数组或malloc函数分配的空间一样。</p><blockquote><p>查看IPC对象：ipcs -m【查看共享内存】| -q【队列】| -s【信号灯】<br>删除IPC对象：ipcrm -m | -q | -s id【IPC的ID】</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262428512.png" alt="共享内存的读"></p><blockquote><p>共享内存可以通过memcpy写入，也可以通过键盘输入stdin</p></blockquote><p><img src="https://files.shanqianche.cn/20232/1675262526768.png" alt="删除映射到用户的内存"></p><h3 id="利用键盘输入读取共享内存"><a href="#利用键盘输入读取共享内存" class="headerlink" title="利用键盘输入读取共享内存"></a>利用键盘输入读取共享内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="comment">//create user memoey mapping </span></span><br><span class="line">p = (<span class="keyword">char</span> *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write to memory by keymap</span></span><br><span class="line">fgets(p,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675263694621.gif" alt="ret"></p><p>**<font color="#FF8C00">共享内存特点</font>**：</p><ol><li>共享内存创建之后，一直存在于内核中，直到被删除或系统关闭：</li><li>共享内存和管道不一样，读取后，内容仍在其共享内存中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上一段代码的修改</span></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;share memory data: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second read :%s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">shmdt(p);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(p,<span class="string">&quot;abcd&quot;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675264544802.gif" alt="shmdt后，共享内存依旧存在但用户无法写入，说明映射到用户的内存被删除了"></p><p><img src="https://files.shanqianche.cn/20232/1675264693642.png" alt="查看，设置，删除共享内存，shmctl"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除共享内存</span></span><br><span class="line">shmdt(p);</span><br><span class="line"><span class="comment">//system(&quot;ipcs -m&quot;);</span></span><br><span class="line"><span class="comment">//memcpy(p,&quot;abcd&quot;,4);</span></span><br><span class="line"><span class="comment">//printf(&quot;third read :%s\n&quot;,p);</span></span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;have delete share memory\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675265486449.gif" alt="ret"></p><h3 id="不同进程之间的通信"><a href="#不同进程之间的通信" class="headerlink" title="不同进程之间的通信"></a>不同进程之间的通信</h3><blockquote><p>宏IPC_PRIVATE:只可以打开亲属之间的共享内存，不同进程之间的需要ftok来获取shmid。</p></blockquote><p><strong>服务端代码，进程通过kill发送SIGUSR1给客户端进程告知已写入share memory。同时接收SIGUSR2信号。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR2,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;pid = getpid();<span class="comment">//write server pid to share memory</span></span><br><span class="line">pause(); <span class="comment">// wait client read server pid;</span></span><br><span class="line">pid = p-&gt;pid;<span class="comment">//read client pid;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process start write share memory!\n&quot;</span>);</span><br><span class="line">fgets(p-&gt;buf,<span class="number">128</span>,<span class="built_in">stdin</span>);</span><br><span class="line">kill(pid,SIGUSR1);<span class="comment">// client process read data</span></span><br><span class="line">pause();<span class="comment">//wait client process read</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码，进程通过kill发送SIGUSR2给服务端进程告知已读取share memory。同时接收SIGUSR1信号，进行读取。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: shm_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月01日 星期三 22时44分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;myfun\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess key = %X\n&quot;</span>,key);</span><br><span class="line">shmid = shmget(key,<span class="number">128</span>,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(shmid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create share memory sucess shmid = %X\n&quot;</span>,shmid);</span><br><span class="line">signal(SIGUSR1,myfun);</span><br><span class="line"></span><br><span class="line">p = (struct mybuf *)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shmat func failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get serve pid</span></span><br><span class="line"><span class="comment">// read share memory</span></span><br><span class="line">pid = p-&gt;pid;</span><br><span class="line"><span class="comment">//write client pid to share memory</span></span><br><span class="line">p-&gt;pid = getpid();</span><br><span class="line">kill(pid,SIGUSR2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pause();<span class="comment">//waits server  process read</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client has read: %s\n&quot;</span>,p-&gt;buf);</span><br><span class="line">kill(pid,SIGUSR2);<span class="comment">// server can write share memory</span></span><br><span class="line">&#125;</span><br><span class="line">shmdt(p);</span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675269810736.gif" alt="ret"></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://files.shanqianche.cn/20232/1675269875809.png" alt="kernel中的消息队列"></p><p><img src="https://files.shanqianche.cn/20232/1675269995630.png" alt="msgget创建消息队列"></p><p><img src="https://files.shanqianche.cn/20232/1675270095098.png" alt="msgctl消息队列读取，设置，删除"></p><p><img src="https://files.shanqianche.cn/20232/1675270271071.png" alt="msgsnd发送数据"><br><strong>其中消息类型要与队列中消息类型进行匹配</strong></p><p><img src="https://files.shanqianche.cn/20232/1675270412264.png" alt="msgrcv读取消息队列"></p><h3 id="无亲缘关系的读写"><a href="#无亲缘关系的读写" class="headerlink" title="无亲缘关系的读写"></a>无亲缘关系的读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_write.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(sendbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear send buffer</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PLZ inout msg: &quot;</span>);</span><br><span class="line">fgets(sendbuf.msg,<span class="number">124</span>,<span class="built_in">stdin</span>);</span><br><span class="line">msgsnd(msgid,(<span class="keyword">void</span> *)&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.msg),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: msg_read.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 00时57分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> type;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">124</span>];</span><br><span class="line"><span class="keyword">char</span> next[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> readret;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>,<span class="title">readbuf</span>;</span></span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create msgid  failure!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="comment">//init send buf</span></span><br><span class="line">sendbuf.type = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(readbuf.msg,<span class="number">0</span>,<span class="number">124</span>); <span class="comment">//clear read buffer</span></span><br><span class="line">msgrcv(msgid,(<span class="keyword">void</span> *)&amp;readbuf,<span class="number">124</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv msg : %s\n&quot;</span>,readbuf.msg);</span><br><span class="line">&#125;</span><br><span class="line">msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675272294978.gif" alt="非亲缘关系的通信"></p><h2 id="信号灯"><a href="#信号灯" class="headerlink" title="信号灯"></a>信号灯</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>信号灯</strong>：信号灯集合（可以包含多个信号灯）PC对象是一个信号灯集（多个信号量）</p><p><img src="https://files.shanqianche.cn/20232/1675272452939.png" alt="由两组值构成的某个信号灯集的内核数据结构"></p><p><img src="https://files.shanqianche.cn/20232/1675272509363.png" alt="semget创建"></p><p><img src="https://files.shanqianche.cn/20232/1675272576680.png" alt="semctl：获取、设置、删除信号灯"></p><p><img src="https://files.shanqianche.cn/20232/1675335695421.png" alt="PV操作"></p><h3 id="利用信号灯进行通信"><a href="#利用信号灯进行通信" class="headerlink" title="利用信号灯进行通信"></a>利用信号灯进行通信</h3><blockquote><p>利用ftok创建key，然后构建信号灯。首先运行客户端，信号量初始化在客户端上，并进行V操作，所以信号量资源被释放，无法利用。下一步执行服务端，服务端先执行任务，然后发送P操作信息，由此分配资源给客户端。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_server.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess! key=%d\n&quot;</span>,key);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess! semid = %d\n&quot;</span>,semid);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line"><span class="comment">//mysemun.val = 0;</span></span><br><span class="line"><span class="comment">//semctl(semid,0,SETVAL,mysemun);</span></span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端才可以进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">mysembuf.sem_op =<span class="number">1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: seg_client.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年02月02日 星期四 22时41分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">mysemun</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">key = ftok(<span class="string">&quot;./myfifo&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(key&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create key sucess\n&quot;</span>);</span><br><span class="line">semid = semget(key,<span class="number">3</span>,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create semid sucess\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;ipcs -s&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init sem </span></span><br><span class="line">mysemun.val = <span class="number">0</span>;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,mysemun);</span><br><span class="line"></span><br><span class="line">mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">mysembuf.sem_flg = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//p wait</span></span><br><span class="line">mysembuf.sem_op=<span class="number">-1</span>;</span><br><span class="line">semop(semid,&amp;mysembuf,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is main func i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v opt 客户端进行p操作处于暂停，服务端执行完任务之后进行v操作，然后客户端进行分配资源，然后执行任务</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//mysembuf.sem_op =1;</span></span><br><span class="line"><span class="comment">//semop(semid,&amp;mysembuf,1);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675351711955.gif" alt="ret"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程之间的通信(一)</title>
      <link href="/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/"/>
      <url>/2023/01/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>进程通信：在用户空间实现进程通信是不可能的，通过<strong>Linux内核通信</strong><br>线程间通信：可以<strong>在用户空间</strong>就可以实现，可以通过<strong>全局变量</strong>通信。</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p><font color="#FF8C00">管道通信</font>：无名管道、有名管道（文件系统中有名,文件系统）<br><font color="#FF8C00">信号通信</font>：信号（通知）通信包括：信号的发送、信号的接收和信号的处理。<br><font color="#FF8C00">IPC(Inter-Process Communication)通信</font>：共享内存、消息队列和信号灯。<br>以上是<strong>单机模式</strong>下的进程通信(只有一个L加ux内核)<br><em>Socket通信：存在于一个网络中两个进程之间的通信(两个Linux内核)。</em></p><h2 id="通信实现的思想"><a href="#通信实现的思想" class="headerlink" title="通信实现的思想"></a>通信实现的思想</h2><blockquote><p><strong>基于文件IO理念</strong></p></blockquote><p>open:功能：创建或打开进程通信对象。函数形式不一样，有的是有多个函数完成。<br>write:功能：向进程通信对象中写入内容。函数形式可能不一样。<br>read:功能：从进程通信对象中读取内容。函数形式可能不一样。<br>close:功能：关闭或删除进程通信对象。形式可能不一样。</p><h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://files.shanqianche.cn/20231/1675161823138.png" alt="管道原理"></p><blockquote><p>管道文件是一个特殊的文件，是由队列来实现的。</p></blockquote><h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><strong>水从高处流</strong><br> The array pipefd is used to return two file descriptors referring to the ends of the pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by  the kernel until it is read from the read end of the pipe.</p><blockquote><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就删除了；队列</li><li>如果管道中没有东西可读，则会阻塞</li></ol></blockquote><h3 id="无名管道的创建"><a href="#无名管道的创建" class="headerlink" title="无名管道的创建"></a>无名管道的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c </span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><strong>Linux内核在创建进程的时候会默认创建三个文件描述符，即0，1，2。所以无名管道返回的文件描述符为3，1、4</strong></p><p><img src="https://files.shanqianche.cn/20231/1675163282239.png" alt="res"></p><h3 id="无名管道的读写"><a href="#无名管道的读写" class="headerlink" title="无名管道的读写"></a>无名管道的读写</h3><p><strong>关键</strong></p><ol><li>管道是创建在内存中的，进程结束，空间释放，管道就不存在了；</li><li>管道中的东西，读完了就别除了：队列</li><li>如果管道中没有东西可读，则会阻塞。</li><li>验证写阻塞：可以计算出内核开辟的管道有多大,队列超过这么大会发生写<strong>堵塞</strong>。5456 5457.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: wmgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 18时59分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> writebuff[]=<span class="string">&quot;hello Linux&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> readbuff[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pipe failure&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip sucess fd[0]=%d,fd[1]=%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// write</span></span><br><span class="line">write(fd[<span class="number">1</span>],writebuff,<span class="keyword">sizeof</span>(writebuff));</span><br><span class="line"></span><br><span class="line"><span class="comment">//first read</span></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//second read </span></span><br><span class="line"></span><br><span class="line">read(fd[<span class="number">0</span>],readbuff,<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second readbuff = %s\n&quot;</span>,readbuff);</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675164287464.png" alt="只能读一次，发生读堵塞"></p><p><img src="https://files.shanqianche.cn/20231/1675164430147.png" alt="阻塞状态ps -axj"></p><p>无名管道的<font color="#FF00FF">缺点</font>：不能实现不是父子进程（亲缘关系）之间的通信。</p><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><blockquote><p>由于无名管道的缺点，对无名管道进行改进：有名管道<br>所谓的有名，即文件系统中存在这个一样文件节点，每一个文件节点都有一个node号<br>而且这是一个特殊的文件类型：<strong>p管道类型</strong>。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1675165035697.png" alt="mkfifo函数"></p><blockquote><p>Create named pipes (FIFOs) with the given NAMEs</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时38分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = mkfifo(<span class="string">&quot;./myfifo&quot;</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create pip failure by file. ret = %d/n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create sucess\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675165870881.png" alt="基于文件系统的有名管道的创建"></p><ol><li>创建这个文件节点，不可以通过open函数，open函数只能创建普通文件，不能创建特殊文件（管道-mkdifo,套接字-socket,字符设备文件-mknod,块设备文件-mknod, 符号链接文件-ln-s,目录文件mkdir）</li><li>管道文件<font color="#FF8C00">只有node号，不占磁盘块空间</font>，<strong>和套接字、字符设备文件、块设备文件一<br>样。普通文件和符号链接文件及目录文件，不仅有node号，还占磁盘块空间。</strong></li><li><font color="#FF8C00">mkfifo用来创建管道文件的<strong>节点</strong>，<strong>没有在内核中创建管道</strong>。只有通过open函数打开这个文件时才会在内核空间创建管道。</font></li></ol><h3 id="利用有名管道进行进程通信"><a href="#利用有名管道进行进程通信" class="headerlink" title="利用有名管道进行进程通信"></a>利用有名管道进行进程通信</h3><blockquote><p>基于上一步创建的管道节点进行通信，进程一等待五秒后向通道发送信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is first process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">process_state = <span class="number">1</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">write(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: ymgd_1.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 19时57分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> process_state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;./myfifo&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe node sucess\n&quot;</span>);</span><br><span class="line">read(fd,&amp;process_state,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(process_state==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; this is second process i=%d\n&quot;</span>,i);</span><br><span class="line">usleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675167881162.png" alt="ret"></p><h1 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h1><h2 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h2><p><img src="https://files.shanqianche.cn/20231/1675167965840.png" alt="Linux中的64种信号"></p><p><img src="https://files.shanqianche.cn/20231/1675173652422.png" alt="kill命令"></p><p><img src="https://files.shanqianche.cn/20231/1675174619900.png" alt="raise函数"></p><p><img src="https://files.shanqianche.cn/20231/1675179787808.png" alt="alarm函数"><br><strong>信号通信的框架</strong></p><ol><li>信号的发送（发送信号进程）：kill raise alarm</li><li>信号的接收（接收信号进程）：pause() sleep while(1)</li><li>信号的处理（接收信号进程）：signal</li></ol><p><strong>kill函数的使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: kill_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时04分08秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input param\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sig = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">pid = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sig=%d, pid = %d\n&quot;</span>,sig,pid);</span><br><span class="line"></span><br><span class="line">kill(pid,sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675174377994.png" alt="ret"></p><h2 id="简单使用kill，waitpid"><a href="#简单使用kill，waitpid" class="headerlink" title="简单使用kill，waitpid"></a>简单使用kill，waitpid</h2><blockquote><p>案例: 开始时主进程处于睡眠状态S,子进程处于暂停T. 八秒后主进程杀死子进程并利用while进入S. 但是子进程被杀死后没有回收资源所以进入僵尸状态Z.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,WNOHANG) ==<span class="number">0</span>) <span class="comment">//等待进程状态，返回值为0时表示并未退出。pid为进程id，NULL为不获取进程返回值，WNOHANG为非阻塞</span></span><br><span class="line">&#123;</span><br><span class="line">kill(pid,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait(NULL);//回收进程资源</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function before\n&quot;</span>);</span><br><span class="line">raise(SIGTSTP);<span class="comment">//SIGSTP 暂停交互，== Ctrl+Z</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;raise function after\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1675176776671.gif" alt="process"></p><p><img src="https://files.shanqianche.cn/20231/1675179547533.gif" alt="使用wait函数回收资源"></p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p><img src="https://files.shanqianche.cn/20231/1675180318371.png" alt="signal函数"></p><blockquote><p>signal函数:返回一个函数指针. 含有两个参数,第一个为信号值, 第二个为一个函数指针,其中返回值为void.<br><strong><font color="#FF8C00">默认处理信号方式为终止信号.</font></strong></p></blockquote><h3 id="alarm处理信号"><a href="#alarm处理信号" class="headerlink" title="alarm处理信号"></a>alarm处理信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: signal_0.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 23时56分47秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process sleep %d s!\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">signal(<span class="number">14</span>,myfun); <span class="comment">// 14为SIGALRM</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;alarm start\n&quot;</span>);</span><br><span class="line">alarm(<span class="number">9</span>);<span class="comment">//九秒后触发myfun</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;next step\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main do %d s\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675184647775.png" alt="ret"></p><h3 id="signal信号处理"><a href="#signal信号处理" class="headerlink" title="signal信号处理"></a>signal信号处理</h3><blockquote><p>父子进程进行通信</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: jiangshijinchengyanshi.c</span></span><br><span class="line"><span class="comment">&gt; Author: Merlynr</span></span><br><span class="line"><span class="comment">&gt; Mail: lcq1013962426@gmail.com </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2023年01月31日 星期二 22时21分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;receive signum = %d, i = %d\n&quot;</span>,signum,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> myfun1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PID is %d\n&quot;</span>,pid);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">signal(<span class="number">10</span>,myfun);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A say %d\n&quot;</span>,i);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">kill(getppid(),<span class="number">10</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//kill SIGCHILD</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20232/1675188572460.png" alt="ret"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程</title>
      <link href="/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/01/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>进程：一个正在执行的程序，它是<strong>资源分配的最小单位</strong><br>进程中的事情需要按照一定的顺序透个进行，那么如何让一个进程中的一些事情同时执行？<br><strong>线程</strong></p></blockquote><blockquote><p>线程：有时又称轻里级进程，<strong>程序执行的最小单位</strong>，系统独立调度和分派cu的基本单位，它是进程中的一个实<br>体。一个进程中可以有多中线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。<br>进程出现了很多弊端，一是由于进程是资源拥有者，创建、微消与切换存在较大的时空开销，因此需要引入轻型进<br>程：二是由于对称多处理机(SMP)出现，可以满足多个运行单位，而多个进程并行开销过大。</p></blockquote><blockquote><p>并发是指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执<br>行的效果。看起来同时发生，实际上单核内轮询执行。</p></blockquote><blockquote><p>并行是指在同一时刻，有多条指令在多个处理器上同时执行。真正的同时发生</p></blockquote><blockquote><p>同步：彼比有依赖关系的调用不应该“同时发生”，而同步就是要阻止那些“同时发生”的事情</p></blockquote><blockquote><p>异步的解念和同步相对，任何两个彼此独立的操作是异步的，它表明事情独立的发生</p></blockquote><h1 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h1><ol><li>当c程序运行时，首先运行main函数。在统程代码中，这个特殊的执行流被称作<strong>初始线程或者主线程</strong>。你可以在初始线程中做任何普通线程可以做的串情。<br>2、主线程的特殊性在于，它在main函数返回的时候，会导致进程结束，进程内所有的线程也将会结束。这可不是一个好的现象，你可以在主线程中调用pthread_exit函数，这样进程就会等待所有线程结束时才终止。</li><li>主线程接受参数的方式是通过<strong>argc和argv</strong>,而<strong>普通的线程只有</strong>一个参数”void *”</li><li>在绝大乡数情况下，主统程在默认堆栈上运行，这个堆栈可以增长到<strong>足够的长度</strong>。而普通线程的堆栈是<strong>受限制</strong>的，一旦溢出就会产生错误<h2 id="主线程的创建"><a href="#主线程的创建" class="headerlink" title="主线程的创建"></a>主线程的创建</h2>1、主线程是随着进程的创建而创建<br>2、其他线程可以通过调用函数来创建，主要调用pthread_create</li></ol><p><em>请注意，新线程可能在当前线程从函数pthread create返回之前就已经运行了，甚至新线程可能在当前线程从函数pthread create返回之前就已经运行完毕了</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础之文件系统</title>
      <link href="/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/01/28/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h1><ul><li>能定义文件的组织方式，文件结构</li><li>提供建立和存取文件的环境：目录和文件</li><li>能对文件存储器空间进行组织和分配</li><li>负责文件存储并对存入的文件进行保护和检索</li><li>负责建立文件，存入、读出、修改、转储文件，控制文件的存取，撤销文件等</li></ul><h1 id="文件系统分类"><a href="#文件系统分类" class="headerlink" title="文件系统分类"></a>文件系统分类</h1><ul><li>磁盘文件系：NTFS，EXT3</li><li>闪存文件系统，JFFS2,YAFFS</li><li>数据库文件系统，BFFS,WINFS</li><li>网络文件系统：NFS</li><li>虚拟文件系统，VFS(Proc)</li></ul><h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h2 id="EXT3"><a href="#EXT3" class="headerlink" title="EXT3"></a>EXT3</h2><ul><li>EXT3是<strong>基于日志方式</strong>的文件系统</li><li>系统中每个文件都是有<strong>索引</strong>，</li><li>用户对对文件的每一个操作都会<strong>记录日志</strong>，</li><li>形成一个任务<strong>队列</strong>排着执行</li><li><strong>性能</strong>是比较好</li></ul><h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><p>swap是<strong>交换分区</strong>的文件系统，类似windows的虚拟内存<br>虚拟内存的实现：两种方式</p><ol><li>第一种是进行内存的排列像内存池一样，进行一个优化</li><li>第二种是把硬盘上的空间模拟成内存<br>swap是Linux的虚拟内存，在安装时要设好大小，是<strong>物理内存的2倍</strong></li></ol><h1 id="Linux与Window目录结构的区别"><a href="#Linux与Window目录结构的区别" class="headerlink" title="Linux与Window目录结构的区别"></a>Linux与Window目录结构的区别</h1><ol><li>根目录<br>Linux:/<br>Windows:\</li><li>命名写区分<br>Linux:命名区分大小写；<br>Windows:命名不区分大小写</li><li>结构管理<br>Linux:磁盘逻辑结构管理物理结构，格式化将磁盘分为很多的文件块区<br>Windows:物理结构管理逻结构，先分区再格式化建立结构</li></ol><h1 id="Linux文件系统目录"><a href="#Linux文件系统目录" class="headerlink" title="Linux文件系统目录"></a>Linux文件系统目录</h1><p><img src="https://files.shanqianche.cn/20231/1674895536500.png" alt="结构"><br><strong>/lib</strong> 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><h1 id="shell-特殊字符"><a href="#shell-特殊字符" class="headerlink" title="shell 特殊字符"></a>shell 特殊字符</h1><ol><li>通配符* ？ []</li></ol><p><img src="https://files.shanqianche.cn/20231/1674895793138.png" alt="通配符"><br>2. 单次执行多条命令。可以通过‘；’隔开<br>3. 输入输出重定向：&gt;,&lt;,&gt;&gt;</p><p><img src="https://files.shanqianche.cn/20231/1674895877046.png" alt="重定向"><br>4. 管道符：|</p><p>将一个进程的输出作为另一个进程的输入<br>5. 其它%，$,~</p><p><img src="https://files.shanqianche.cn/20231/1674895997064.png" alt="其它符合"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之编译</title>
      <link href="/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/"/>
      <url>/2023/01/27/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p><img src="https://files.shanqianche.cn/20231/1674819567025.png" alt="C语言编译过程，层次递增，后边命令包含上边命令所有功能"></p><blockquote><p><font color="#FF00FF">define include 不是关键字，他们在预编译的时候就被替代了。</font></p></blockquote><h1 id="常见编译错误"><a href="#常见编译错误" class="headerlink" title="常见编译错误"></a>常见编译错误</h1><ol><li>预处理错误</li></ol><p>#include”file.h“      默认先从<font color="#FF00FF">当前路径</font>中寻找，找不到再从系统环境中查找。<br>#include&lt;file.h&gt;     直接从系统环境中寻找</p><p><strong><font color="#DC143C">NOT FIND</font></strong> 注意自己创建用双引号。<br>解决方法：可以通过相对路径；通过写入头文件路径的方式。</p><p><img src="https://files.shanqianche.cn/20231/1674838061382.png" alt="相对路径"></p><p><img src="https://files.shanqianche.cn/20231/1674838095708.png" alt="-I+路径"><br>2. 链接错误<br>    <strong>原材料不够或者溢出。</strong></p><ul><li>缺少原材料</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838261605.png" alt="函数缺少实现"></p><p><img src="https://files.shanqianche.cn/20231/1674838294886.png" alt="链接器报错"></p><ul><li>原材料溢出</li></ul><p><img src="https://files.shanqianche.cn/20231/1674838515227.png" alt="链接器错误"></p><p><strong>原因是链接重复的函数。</strong></p><h1 id="预处理的使用"><a href="#预处理的使用" class="headerlink" title="预处理的使用"></a>预处理的使用</h1><ol><li>#include 包含头文件</li><li>#define 宏，替换   <strong><font color="#FF8C00">预处理时不进行检查直接进行替换，在编译时才进行检查</font></strong></li><li>#define 宏名 宏体 <strong>为了避免错误，加括号</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 3+5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//3+5*5=28</span></span><br><span class="line"><span class="comment">//正确例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD35 (3+5)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ADD35 *<span class="number">5</span>); <span class="comment">//(3+5)*5=40</span></span><br></pre></td></tr></table></figure><ol start="4"><li>系统预定义宏</li></ol><p><img src="https://files.shanqianche.cn/20231/1674839269964.png" alt="前后双下划线"></p><p><img src="https://files.shanqianche.cn/20231/1674839409010.png" alt="方便用于调试"><br>5. 条件宏变量</p><blockquote><p>多用于控制不同版本的变量。（开发版与测试版）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674839665789.png" alt="如果定义了ABC则会输出，不定义则没有输出结果"><br><strong>同时可以通过命令来进行控制宏变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -D:</span><br><span class="line">gcc -DABC == <span class="meta">#<span class="meta-keyword">define</span> ABC</span></span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20231/1674839837663.png" alt="gcc -D"><br>6. 宏展开下的 #、##</p><p><img src="https://files.shanqianche.cn/20231/1674839991226.png" alt="#、##"></p><p><img src="https://files.shanqianche.cn/20231/1674840072964.png" alt="#"></p><p><img src="https://files.shanqianche.cn/20231/1674840240184.png" alt="##"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="注意数据类型所占位数，防止溢出"><a href="#注意数据类型所占位数，防止溢出" class="headerlink" title="注意数据类型所占位数，防止溢出"></a>注意数据类型所占位数，防止溢出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8b</span>it = <span class="number">1B</span></span><br><span class="line"><span class="keyword">char</span> = <span class="number">1B</span></span><br><span class="line">所以<span class="keyword">char</span>最大不超过 <span class="number">2</span>^<span class="number">8</span>=<span class="number">256.</span></span><br><span class="line"><span class="keyword">char</span> a =<span class="number">300.</span> a++会报错。</span><br></pre></td></tr></table></figure><h2 id="int大小的定义"><a href="#int大小的定义" class="headerlink" title="int大小的定义"></a>int大小的定义</h2><blockquote><p>编译器最优的处理大小（由编译器决定）：<br>        系统一个周期，所能接受的最大处理单位，int<br>        32位系统，单词执行32bit，所以int大小32bit=4byte<br>        单片机中存在16位系统，则int = 2B</p></blockquote><h1 id="signed与unsigned的注意"><a href="#signed与unsigned的注意" class="headerlink" title="signed与unsigned的注意"></a>signed与unsigned的注意</h1><p>signed包含符号位，而unsigned不包含，所以进行位操作的时候会出现不同情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>=<span class="number">0xff</span></span><br><span class="line"><span class="keyword">signed</span>右移后不会变化。而<span class="keyword">unsigned</span>会变化，最后变为<span class="number">0.</span></span><br></pre></td></tr></table></figure><h1 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674842433715.png" alt="类型修饰符"></p><p><img src="https://files.shanqianche.cn/20231/1674842419473.png" alt="auto"></p><p><img src="https://files.shanqianche.cn/20231/1674842567442.png" alt="register"></p><blockquote><p><font color="#FF00FF">由于寄存器没有地址，所以对存入寄存器的值进行取址是无效的。</font></p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674842689701.png" alt="取址失败"></p><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h1><p><img src="https://files.shanqianche.cn/20231/1674842913259.png" alt="volatile"></p><h1 id="硬件中乘除法需要注意"><a href="#硬件中乘除法需要注意" class="headerlink" title="硬件中乘除法需要注意"></a>硬件中乘除法需要注意</h1><p><img src="https://files.shanqianche.cn/20231/1674843024138.png" alt="乘除法"></p>]]></content>
      
      
      <categories>
          
          <category> C Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之函数的使用</title>
      <link href="/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/25/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="字符空间与非字符空间的区别"><a href="#字符空间与非字符空间的区别" class="headerlink" title="字符空间与非字符空间的区别"></a>字符空间与非字符空间的区别</h2><p><img src="https://files.shanqianche.cn/20231/1674544158303.png" alt="结束标符的不同"></p><h2 id="函数地址传址"><a href="#函数地址传址" class="headerlink" title="函数地址传址"></a>函数地址传址</h2><p>嵌入式中对于单个值进行修改的可以使用int *，char *,long *。如果传递的是空间则默认为void *。</p><h2 id="指针指向的合法性"><a href="#指针指向的合法性" class="headerlink" title="指针指向的合法性"></a>指针指向的合法性</h2><blockquote><p>即函数中的局部变量在函数指向完会被清除，如果直接return局部变量会造成指针异常。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674807930550.png" alt="不合法例子"></p><blockquote><p>合法空间：<font color="#FF8C00">非局部变量</font>，即非栈空间变量。static，常量，堆区（malloc，free）</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674808110649.png" alt="通过static设置为静态变量"></p><p><img src="https://files.shanqianche.cn/20231/1674810427874.png" alt="返回常量，不可修改"></p><p><img src="https://files.shanqianche.cn/20231/1674810459713.png" alt="堆区"></p>]]></content>
      
      
      <categories>
          
          <category> C Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言之内存的操作</title>
      <link href="/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/01/24/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言格式符合"><a href="#c语言格式符合" class="headerlink" title="c语言格式符合"></a>c语言格式符合</h1><p><img src="https://files.shanqianche.cn/20231/1674625839183.png" alt="c语言格式符合"></p><h1 id="const-修饰符"><a href="#const-修饰符" class="headerlink" title="const 修饰符"></a>const 修饰符</h1><p><img src="https://files.shanqianche.cn/20231/1674626595923.png" alt="const"></p><h1 id="volatile-修饰"><a href="#volatile-修饰" class="headerlink" title="volatile 修饰"></a>volatile 修饰</h1><p>防止内存优化，每次从地址读值</p><h1 id="typedef-别名"><a href="#typedef-别名" class="headerlink" title="typedef 别名"></a>typedef 别名</h1><p><img src="https://files.shanqianche.cn/20231/1674626987035.png" alt="typedef"></p><h1 id="指针运算操作"><a href="#指针运算操作" class="headerlink" title="指针运算操作"></a>指针运算操作</h1><p><img src="https://files.shanqianche.cn/20231/1674627210213.png" alt="指针加减运算"></p><p><img src="https://files.shanqianche.cn/20231/1674627280255.png" alt="指针非线性访问数据"></p><blockquote><p>指针运算：p+n取得的是地址，p[n]取出的是内容，值</p></blockquote><h1 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h1><blockquote><p>c语言存在内存越界，c++并不存在</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674628812520.png" alt="内存越界"></p><h1 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h1><p><img src="https://files.shanqianche.cn/20231/1674628996361.png" alt="NULL与0x0类似，但是0x0有的编译器不支持，所以推荐使用NULL"></p><h1 id="多级指针的例子"><a href="#多级指针的例子" class="headerlink" title="多级指针的例子"></a>多级指针的例子</h1><p><img src="https://files.shanqianche.cn/20231/1674629440012.png" alt="**grav表示数组中的字符串的地址"></p><p><img src="https://files.shanqianche.cn/20231/1674629683298.png" alt="与上一个函数一样"></p><p><img src="https://files.shanqianche.cn/20231/1674629432130.png" alt="res"></p><h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><p><img src="https://files.shanqianche.cn/20231/1674630239737.png" alt="差异"></p><blockquote><p>字符串末尾默认加‘\0’</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630294413.png" alt="\0"></p><p><font color="#FF00FF">编译器只有第一次赋值可以一次性解决，以后对于数组操作，只能逐一操作，即一位一位进行修改。</font></p><h1 id="字符拷贝的问题"><a href="#字符拷贝的问题" class="headerlink" title="字符拷贝的问题"></a>字符拷贝的问题</h1><blockquote><p>字符拷贝函数的原贝则：<br>内存空间和内存空间的逐一赋值的功能的一个封装体一旦空间中出现了0这个特殊值，函数就即将结束。</p></blockquote><p><img src="https://files.shanqianche.cn/20231/1674630865267.png" alt="strcpy"><br>strcpy()函数存在问题，如果destination值后面没有’\0’，则会一直拷贝。工程中尽量不用。</p><p><img src="https://files.shanqianche.cn/20231/1674630876329.png" alt="strncpy"><br>strncpy可以设置拷贝字符长度，避免内存泄漏。</p><h1 id="字符空间"><a href="#字符空间" class="headerlink" title="字符空间"></a>字符空间</h1><p><img src="https://files.shanqianche.cn/20231/1674631169177.png" alt="字符与非字符空间"></p><h1 id="内存拷贝"><a href="#内存拷贝" class="headerlink" title="内存拷贝"></a>内存拷贝</h1><p><img src="https://files.shanqianche.cn/20231/1674631384044.png" alt="memcpy"></p><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p><img src="https://files.shanqianche.cn/20231/1674632522625.png" alt="二维数组表达方式"></p><p><img src="https://files.shanqianche.cn/20231/1674632589989.png" alt="三维"></p><h1 id="结构体中字节对齐"><a href="#结构体中字节对齐" class="headerlink" title="结构体中字节对齐"></a>结构体中字节对齐</h1><blockquote><p>即空间换效率，采取最大字节单位进行对其，所以空间大小都为4的倍数</p></blockquote><h1 id="代码编码后的地址位置"><a href="#代码编码后的地址位置" class="headerlink" title="代码编码后的地址位置"></a>代码编码后的地址位置</h1><blockquote><p>一般系统（ARM，x86等）的代码地址位于低地址</p></blockquote><p><font color="#FF00FF">x86：一般为于0x8084.</font>.</p><p><img src="https://files.shanqianche.cn/20231/1674634481092.png" alt="代码地址"></p><h1 id="内存空间结构"><a href="#内存空间结构" class="headerlink" title="内存空间结构"></a>内存空间结构</h1><p><img src="https://files.shanqianche.cn/20231/1674659004309.png" alt="结构"></p><p><img src="https://files.shanqianche.cn/20231/1674658712364.png" alt="内存查看"></p><blockquote><p>只读空间：静态空间，整个程序结束时释放内存，生存周期最长<br>栈空军：运行时，函数内部使用的变量，函数一旦返回，就释放，生存周期是函数内<br>堆空间：运行时，可以自我管理分配和释放的空间，程序员决定的。</p></blockquote><p><strong>堆空间分配：</strong> malloc(),一旦成功，返回分配好的地址给我们，只需要接受，对于这个新地址的读法，由程序员灵活把握输入参数指定分配的大小，单位就是B。</p><p><img src="https://files.shanqianche.cn/20231/1674659425331.png" alt="malloc函数"></p><p><strong>释放空间：</strong> free(p)</p>]]></content>
      
      
      <categories>
          
          <category> C Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之事件组(五)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%84(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<h2 id="事件组等待"><a href="#事件组等待" class="headerlink" title="事件组等待"></a>事件组等待</h2><p><img src="https://files.shanqianche.cn/202212/1671172487143.png" alt="创建事件组，返回一个event group句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671173162132.png" alt="查看当前事件组的位是否被设置，如果设置了则跳过，否则发生阻塞"></p><p><img src="https://files.shanqianche.cn/202212/1671173611753.png" alt="设置事件组的值"></p><blockquote><p>设置事件组大小，如果宏定义USE_16_BIT_TICKS设置为1则，事件组大小为8；如果为0则为24位。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671172754108.png" alt="Esp32的配置"></p><p><img src="https://files.shanqianche.cn/202212/1671174406593.png" alt="创建事件组"></p><p><img src="https://files.shanqianche.cn/202212/1671174563092.png" alt="事件组的判断，零位 | 四位 为1."></p><p><img src="https://files.shanqianche.cn/202212/1671174626150.png" alt="Task2中对事件组0位和四位依次设置为1"></p><p><img src="https://files.shanqianche.cn/202212/1671174723965.png" alt="条件为或时的结果"></p><p><img src="https://files.shanqianche.cn/202212/1671174771887.png" alt="条件为与的结果"></p><h2 id="事件组同"><a href="#事件组同" class="headerlink" title="事件组同"></a>事件组同</h2><blockquote><p>事件组等待的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175636282.png" alt="Step1：task1阻塞，task2，task3依次设置位"></p><p><img src="https://files.shanqianche.cn/202212/1671175673767.png" alt="Step2：task1等待task2，3完成后开始设置自己的位"></p><blockquote><p>事件组同步的执行逻辑</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671175874589.png" alt="事件组同步"></p><p><img src="https://files.shanqianche.cn/202212/1671175906159.png" alt="Step1：三个事件依次设置，并等待"></p><p><img src="https://files.shanqianche.cn/202212/1671175935762.png" alt="Step2：同时开始"></p><p><strong>code</strong></p><p><img src="https://files.shanqianche.cn/202212/1671176947195.png" alt="BITS"></p><p><img src="https://files.shanqianche.cn/202212/1671177513328.png" alt="创建事件组"></p><p><img src="https://files.shanqianche.cn/202212/1671177624437.png" alt="Task0"></p><p><img src="https://files.shanqianche.cn/202212/1671177635589.png" alt="Task1"></p><p><img src="https://files.shanqianche.cn/202212/1671177641240.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671177663458.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之定时器(四)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h2 id="Software-Timer-软件定时器"><a href="#Software-Timer-软件定时器" class="headerlink" title="Software Timer 软件定时器"></a>Software Timer 软件定时器</h2><blockquote><p>基于Daemon Task，定时器任务通过定时器命令队列进行发送给执行指令，然后任务调用相应的程序，执行软件定时器的回调函数。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670983470929.png" alt="Software Timer"></p><p><strong>软件定时器的特点</strong></p><ol><li>不受硬件影响，不受MCU的影响</li><li>软件定时器的数量与堆栈，TIMER_TASK_STACK_DEPTH的影响。不受影响影响</li></ol><p><img src="https://files.shanqianche.cn/202212/1670983728618.png" alt="xTimerCreate"></p><p><img src="https://files.shanqianche.cn/202212/1670984266679.png" alt="启动定时器"></p><p><img src="https://files.shanqianche.cn/202212/1670984718155.png" alt="xTimerStop"></p><p><img src="https://files.shanqianche.cn/202212/1670984850319.png" alt="取得Timer的名字"></p><p><img src="https://files.shanqianche.cn/202212/1670985084226.png" alt="获取Timer ID，返回一个指针"></p><p><img src="https://files.shanqianche.cn/202212/1670985575931.png" alt="只要执行reset函数，定时器将不执行回调函数，类似于喂狗"></p><p><img src="https://files.shanqianche.cn/202212/1670985661744.png" alt="改变定时器周期"></p><p><strong>创建并启动定时器</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984663776.png" alt="创建并启动定时器"><br><strong>延时并停止</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984772340.png" alt="延时等待6s并停止"></p><p><img src="https://files.shanqianche.cn/202212/1670984803629.png" alt="result"></p><p><strong>获取Timer名字</strong></p><p><img src="https://files.shanqianche.cn/202212/1670984974432.png" alt="公用一个回调函数"></p><p><img src="https://files.shanqianche.cn/202212/1670985000934.png" alt="由于两秒执行一次Timer2，一秒一次Timer1；所以结果如此"></p><p><strong>获取一个Timer ID</strong></p><p><img src="https://files.shanqianche.cn/202212/1670985351262.png" alt="方法一，Get Timer ID"></p><p><img src="https://files.shanqianche.cn/202212/1670985502589.png" alt="方法二，返回指针获取ID"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之信号量(六)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<h2 id="Binary-Semaphore-二进制信号"><a href="#Binary-Semaphore-二进制信号" class="headerlink" title="Binary Semaphore 二进制信号"></a>Binary Semaphore 二进制信号</h2><p><img src="https://files.shanqianche.cn/202212/1670986242028.png" alt="创建信号量，向下兼容，不推荐使用"></p><p><img src="https://files.shanqianche.cn/202212/1670986404539.png" alt="推荐使用这个创建信号"></p><p><img src="https://files.shanqianche.cn/202212/1671088363753.png" alt="释放信号量"></p><ol><li>使用信号量执行任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671088852864.png" alt="enter description here"></p><blockquote><p>创建信号量之后为了使用它必须要释放它。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671089225283.png" alt="文档中提到了创建之后要释放它"></p><ol><li>创建信号量并调用任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089333679.png" alt="创建信号量并释放，task才可以调用"></p><ol start="2"><li>任务一进行调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089371462.png" alt="任务一"></p><ol start="3"><li>任务二调用使用信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089387925.png" alt="Task2"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089481464.png" alt="全局变量"></p><p><img src="https://files.shanqianche.cn/202212/1671089428031.png" alt="说明Task1和Task2锁住了全局变量"></p><ol start="5"><li>未使用信号量呢</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089497958.png" alt="Task"></p><ol start="6"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671089571227.png" alt="没有使用信号量则会交替进行加一"></p><h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p><img src="https://files.shanqianche.cn/202212/1671091200737.png" alt="获取信号量数目"></p><p><img src="https://files.shanqianche.cn/202212/1671091310069.png" alt="取得可用信号成功则锁住"></p><p><img src="https://files.shanqianche.cn/202212/1671091477101.png" alt="创建计数信号量"></p><ol><li>创建任务</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091690613.png" alt="创建任务"></p><ol start="2"><li>使用计数信号量，最大信号量减减</li></ol><p> <img src="https://files.shanqianche.cn/202212/1671091848978.png" alt="使用信号量"></p><ol start="3"><li>释放信号量</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091878388.png" alt="每到第六秒释放一个信号量"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1671091971061.png" alt="第五秒后没有信号量，第六秒进行释放后进行使用"></p><p><img src="https://files.shanqianche.cn/202212/1671092027319.png" alt="每隔六秒可以获得一个信号量"></p><h2 id="互斥量-mutex"><a href="#互斥量-mutex" class="headerlink" title="互斥量 mutex"></a>互斥量 mutex</h2><p><img src="https://files.shanqianche.cn/202212/1671099188414.png" alt="创建互斥量"></p><p><strong>这块需要反复理解</strong></p><ol><li>创建信号量，挂起任务调度器，创建执行任务，开启任务调度器</li></ol><p><img src="https://files.shanqianche.cn/202212/1671107894154.png" alt="创建互斥信号量、挂起任务调度器、创建执行任务、开启任务调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671108236775.png" alt="Task1"></p><p><img src="https://files.shanqianche.cn/202212/1671108106925.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671108024642.png" alt="Task3"></p><blockquote><p>主要是优先级的继承，task1继承了task3所以可以执行任务</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671110095196.png" alt="互斥信号量"></p><p><img src="https://files.shanqianche.cn/202212/1671110147625.png" alt="互斥信号量"></p><blockquote><p>task3优先级最高首先运行，发生阻塞后task2开始执行，task2发生阻塞，task1开始执行，获取信号量并锁定。<br><strong>由于task3的优先级高，所以task3开始执行，然而信号量依旧在task1那</strong>，并未被释放task1超出时间片，看门狗被触发，idle任务因为要用于内存的清理回收，idle任务无法执行，就会触发看门狗。<br>所以task3尝试取信号量，尝试失败后进入task2while循环，循环超时触发看门狗，然后task继续3尝试获取信号量。以此反复。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671111112169.png" alt="使用二进制信号量"></p><p><img src="https://files.shanqianche.cn/202212/1671108979371.png" alt="二进制信号量的结果"></p><h2 id="Recursive-Mutex-递归互斥锁"><a href="#Recursive-Mutex-递归互斥锁" class="headerlink" title="Recursive Mutex 递归互斥锁"></a>Recursive Mutex 递归互斥锁</h2><p><img src="https://files.shanqianche.cn/202212/1671160318532.png" alt="task1获取A信号量并锁住，A需要B，所以继续获取B并锁住"></p><p><img src="https://files.shanqianche.cn/202212/1671160501852.png" alt="创建递归互斥锁"></p><p><img src="https://files.shanqianche.cn/202212/1671165183178.png" alt="创建并执行任务调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671172338333.png" alt="Task2"></p><p><img src="https://files.shanqianche.cn/202212/1671172326291.png" alt="Task1"></p><p><strong>结果：</strong></p><p><img src="https://files.shanqianche.cn/202212/1671172370707.png" alt="结果"></p><p><img src="https://files.shanqianche.cn/202212/1671172394998.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之队列(三)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E9%98%9F%E5%88%97(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="queue队列"><a href="#queue队列" class="headerlink" title="queue队列"></a>queue队列</h2><blockquote><p>常用于传递<font color="#FF00FF">整形、结构体及指针</font></p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670937269638.png" alt="queue"></p><p><img src="https://files.shanqianche.cn/202212/1670937418178.png" alt="xQueueCreate"></p><h3 id="传递整形"><a href="#传递整形" class="headerlink" title="传递整形"></a>传递整形</h3><ol><li>创建队列</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938179291.png" alt="创建队列"></p><ol start="2"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938268578.png" alt="接收函数"></p><ol start="3"><li>接收函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938366706.png" alt="接收函数"></p><ol start="4"><li>结果</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938348411.png" alt="运行结果"></p><ol start="5"><li>对接收函数进行优化</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938507920.png" alt="监控接收队列是否为空，不为才进行接收并打印"></p><h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><ol><li>结构体</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938695866.png" alt="结构体"></p><ol start="2"><li>发送函数</li></ol><p><img src="https://files.shanqianche.cn/202212/1670938716857.png" alt="发送函数"><br>3. 接收函数</p><p><img src="https://files.shanqianche.cn/202212/1670938766379.png" alt="接收函数"><br>4. 队列</p><p><img src="https://files.shanqianche.cn/202212/1670938806106.png" alt="修改队列宽度，即数据所占位数"></p><h3 id="传递指针"><a href="#传递指针" class="headerlink" title="传递指针"></a>传递指针</h3><p> <strong>小心内存的分配和清除，其它差不多</strong></p><h3 id="队列的多近单出"><a href="#队列的多近单出" class="headerlink" title="队列的多近单出"></a>队列的多近单出</h3><ol><li>发送任务一</li></ol><blockquote><p>发送数字111</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940015975.png" alt="task1"></p><ol start="2"><li>发送任务2</li></ol><blockquote><p>发送数字222</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670940046663.png" alt="task2"><br>3. 接收任务</p><p><img src="https://files.shanqianche.cn/202212/1670940095025.png" alt="接收并打印，并设置接收延时最大，阻塞一直等待接收"><br>4. 队列管理</p><p><img src="https://files.shanqianche.cn/202212/1670940125054.png" alt="发送任务优先级一样，接收任务级别为2"></p><h3 id="Queue-Set"><a href="#Queue-Set" class="headerlink" title="Queue Set"></a>Queue Set</h3><p><img src="https://files.shanqianche.cn/202212/1670942546618.png" alt="队列集合，当集合中中的队列哪个有数据则获取哪个队列的数据"></p><ol><li>创建发送Task1</li></ol><p><img src="https://files.shanqianche.cn/202212/1670943244590.png" alt="Task1"><br>2. 发送Task2</p><p><img src="https://files.shanqianche.cn/202212/1670943270669.png" alt="Task2"><br>3. 接收Task</p><p><img src="https://files.shanqianche.cn/202212/1670944978777.png" alt="接收Task"><br>4. Queue 将队列加入Set</p><p><img src="https://files.shanqianche.cn/202212/1670945004119.png" alt="Queue"></p><h3 id="队列邮箱"><a href="#队列邮箱" class="headerlink" title="队列邮箱"></a>队列邮箱</h3><blockquote><p>里面存放一个数据<strong>即队列长度为1</strong>，有一个写入邮箱的task，有一个或多个读出邮箱的task</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1670945120071.png" alt="Queue Mail"></p><ol><li>queue mail</li></ol><p><img src="https://files.shanqianche.cn/202212/1670946095803.png" alt="三个read一个write"><br>2. readTask</p><p><img src="https://files.shanqianche.cn/202212/1670946068507.png" alt="readTask"><br>3. writeTask</p><p><img src="https://files.shanqianche.cn/202212/1670946161788.png" alt="readTask"><br>4. 结果</p><p><img src="https://files.shanqianche.cn/202212/1670946264134.png" alt="写入延迟为6秒"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之Task(二)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8BTask(%E4%BA%8C)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8BTask(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h4 id="vTaskSuspend-挂起-amp-vTaskResume-恢复"><a href="#vTaskSuspend-挂起-amp-vTaskResume-恢复" class="headerlink" title="vTaskSuspend 挂起 &amp; vTaskResume 恢复"></a>vTaskSuspend 挂起 &amp; vTaskResume 恢复</h4><p><img src="https://files.shanqianche.cn/202212/1670336283287.png" alt="task被挂起并恢复"></p><h4 id="vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有"><a href="#vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有" class="headerlink" title="vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有"></a>vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有</h4><p> 挂起所有task，同时执行完后不能调用FreeRTOS API函数。必须通过vTaskResumeAll（）进行恢复后才能继续直接FreeRTOS API。<strong>保证程序的独立运行</strong></p><p> <img src="https://files.shanqianche.cn/202212/1670336505558.png" alt="指的是系统被挂起后无法被调用"></p><h3 id="vTaskList-任务状态信息"><a href="#vTaskList-任务状态信息" class="headerlink" title="vTaskList() 任务状态信息"></a>vTaskList() 任务状态信息</h3><p> <img src="https://files.shanqianche.cn/202212/1670480943006.png" alt="vTaskList展示task信息"> </p><blockquote><p>运行状态<br>     X: 运行状态<br>    B:阻塞状态<br>    R:准备状态<br>    S:挂起状态<br>    D:删除状态</p></blockquote><h3 id="xTask堆栈"><a href="#xTask堆栈" class="headerlink" title="xTask堆栈"></a>xTask堆栈</h3><p><img src="https://files.shanqianche.cn/202212/1670506507182.png" alt="xTask堆栈的设置"><br><strong>usStackDepth的理解</strong>： 为堆栈的深度。即如果堆栈的宽度为4bytes，深度为100，则堆栈空间为100* 4bytes。</p><p><img src="https://files.shanqianche.cn/202212/1670507145359.png" alt="usStackDepth"></p><h4 id="uxTaskGetStackHighWaterMark-查询剩余堆栈内存"><a href="#uxTaskGetStackHighWaterMark-查询剩余堆栈内存" class="headerlink" title="uxTaskGetStackHighWaterMark() 查询剩余堆栈内存"></a>uxTaskGetStackHighWaterMark() 查询剩余堆栈内存</h4><p>调用vTaskList消耗内存较大，可以通过uxTaskGetStackHighWaterMark来获取内存信息。</p><p><strong>可以用于调试代码</strong></p><h3 id="task-Watchdogs"><a href="#task-Watchdogs" class="headerlink" title="task Watchdogs"></a>task Watchdogs</h3><blockquote><ol><li>中断看门狗300ms、2.task看门狗5s</li></ol></blockquote><h4 id="中断看门狗"><a href="#中断看门狗" class="headerlink" title="中断看门狗"></a>中断看门狗</h4><p><img src="https://files.shanqianche.cn/202212/1670832506559.png" alt="中断看门狗调用的是定时器组一"></p><p><img src="https://files.shanqianche.cn/202212/1670832612635.png" alt="中断看梦的配置"></p><h4 id="task看门狗"><a href="#task看门狗" class="headerlink" title="task看门狗"></a>task看门狗</h4><p><img src="https://files.shanqianche.cn/202212/1670915250123.png" alt="创建时引用"></p><p><img src="https://files.shanqianche.cn/202212/1670937111595.png" alt="将任务加入任务看门狗，并喂狗，如果不喂狗则会报idle错误"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之基本运行原理(一)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86(%E4%B8%80)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><p><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </p><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input checked="" disabled="" type="checkbox"> 掌握task</li><li><input checked="" disabled="" type="checkbox"> 掌握list </li><li><input checked="" disabled="" type="checkbox"> 掌握queue</li></ul><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ol><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之数据流(八)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B5%81(%E5%85%AB)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B5%81(%E5%85%AB)/</url>
      
        <content type="html"><![CDATA[<h2 id="Message-buffer"><a href="#Message-buffer" class="headerlink" title="Message buffer"></a>Message buffer</h2><blockquote><p>与stream buffer 的不同：<br>（1）：一次只能接收完整一条buffer；<br>（2）：如果数据长度超过接收buffer的大小，stream会继续接收(接收buffer大小的数据量)，而message不接收</p></blockquote><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p><img src="https://files.shanqianche.cn/202212/1671202136155.png" alt="创建"></p><p><img src="https://files.shanqianche.cn/202212/1671202226329.png" alt="接收function"></p><p><img src="https://files.shanqianche.cn/202212/1671202240298.png" alt="发送function"></p><h3 id="实验一：验证区别一"><a href="#实验一：验证区别一" class="headerlink" title="实验一：验证区别一"></a>实验一：验证区别一</h3><p><img src="https://files.shanqianche.cn/202212/1671202461368.png" alt="全局变量 message buffer句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671202272589.png" alt="调度器"></p><p><img src="https://files.shanqianche.cn/202212/1671202413471.png" alt="创建三天message buffer并发送到buffer中"><br><img src="https://files.shanqianche.cn/202212/1671202330991.png"></p><p><img src="https://files.shanqianche.cn/202212/1671202495555.png" alt="结果：每次只接收一条数据"></p><p><img src="https://files.shanqianche.cn/202212/1671202554503.png" alt="修改为stream buffer继续实验"></p><p><img src="https://files.shanqianche.cn/202212/1671202604076.png" alt="结果：一次接收所有数据"></p><h3 id="实验二：验证区别二"><a href="#实验二：验证区别二" class="headerlink" title="实验二：验证区别二"></a>实验二：验证区别二</h3><h4 id="stream-buffer"><a href="#stream-buffer" class="headerlink" title="stream buffer"></a>stream buffer</h4><p><img src="https://files.shanqianche.cn/202212/1671202816481.png" alt="发送function"></p><p><img src="https://files.shanqianche.cn/202212/1671202862644.png" alt="接收function，buffer小"></p><p><img src="https://files.shanqianche.cn/202212/1671202933240.png" alt="结果：接收"></p><h4 id="message-buffer"><a href="#message-buffer" class="headerlink" title="message buffer"></a>message buffer</h4><p><img src="https://files.shanqianche.cn/202212/1671202988047.png" alt="结果：不在接收"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32S3的FreeRTOS之数据流(七)</title>
      <link href="/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%B8%83)/"/>
      <url>/2022/12/16/%E5%9F%BA%E4%BA%8EESP32S3%E7%9A%84FreeRTOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81(%E4%B8%83)/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream-Buffer"><a href="#Stream-Buffer" class="headerlink" title="Stream Buffer"></a>Stream Buffer</h2><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><blockquote><p>大部分音频以这种形式传输数据。</p></blockquote><p><img src="https://files.shanqianche.cn/202212/1671199467534.png" alt="创建流"></p><p><img src="https://files.shanqianche.cn/202212/1671199642131.png" alt="发送stream buffer"></p><p><img src="https://files.shanqianche.cn/202212/1671199751798.png" alt="接收stream buffer"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="https://files.shanqianche.cn/202212/1671199532838.png" alt="全局变量stream buffer句柄"></p><p><img src="https://files.shanqianche.cn/202212/1671199578431.png" alt="创建stream buffer"></p><p><img src="https://files.shanqianche.cn/202212/1671199702196.png" alt="发送handle"></p><p><img src="https://files.shanqianche.cn/202212/1671199794137.png" alt="接收handle"></p><h3 id="实验结果与改进"><a href="#实验结果与改进" class="headerlink" title="实验结果与改进"></a>实验结果与改进</h3><p><img src="https://files.shanqianche.cn/202212/1671199830149.png" alt="结果"></p><p><img src="https://files.shanqianche.cn/202212/1671200002220.png" alt="修改触发量"></p><p><img src="https://files.shanqianche.cn/202212/1671200519994.png" alt="接收"></p><p><img src="https://files.shanqianche.cn/202212/1671200339750.png" alt="基于上修改，将阻塞提前"></p><p><img src="https://files.shanqianche.cn/202212/1671200373451.png" alt="结果，先发送五次后再接收"></p><h2 id="监控stream-buffer-剩余空间"><a href="#监控stream-buffer-剩余空间" class="headerlink" title="监控stream buffer 剩余空间"></a>监控stream buffer 剩余空间</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://files.shanqianche.cn/202212/1671200744509.png" alt="task3监控stream buffer剩余空间"></p><h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p><img src="https://files.shanqianche.cn/202212/1671201588256.png" alt="查看剩余空间"></p><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p><img src="https://files.shanqianche.cn/202212/1671201719717.png" alt="监控剩余空间"></p><p><img src="https://files.shanqianche.cn/202212/1671201759665.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student, RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F108的学习</title>
      <link href="/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="f270768e-6a79-4d1d-8fd8-694008c8a311">天天PLAN</a></p><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><h3 id="LED的注意事项"><a href="#LED的注意事项" class="headerlink" title="LED的注意事项"></a>LED的注意事项</h3><ol><li>需要连接电阻，不然可能击穿LED。</li><li><strong>一般LED所需电流为0~10+的毫安【不要超过20mA】，芯片所提供电压为3.3 or 5v，所以接一个1kΩ电阻【限流电阻】即可。</strong></li><li><a href="https://blog.csdn.net/a419116194/article/details/103238872">高电平、低电平</a>。低电平时电路的阻抗低，噪声造成的电平变化小，也就是说，抗干扰能力更强</li></ol><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><h3 id="GPIO的注意事项"><a href="#GPIO的注意事项" class="headerlink" title="GPIO的注意事项"></a>GPIO的注意事项</h3><ol><li>除了GPIO的为通用<del>， 其余皆为复用</del></li></ol><p><img src="./images/1668134920148.png" alt="端口配置"><br>2. <strong>GPIO大部分使用推挽输出，ⅡC使用的开漏输出。</strong><br>3. 地址=基址+偏移地址<br>4. 端口配置寄存器【输入输出配置（模拟、浮空、上拉下拉、保留）（通用推挽、通用开漏、复用推挽、复用开漏），输入输出模式以及频率】–&gt;端口输出数据寄存器（配置端口地址为1的是输出端口）</p><h2 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h2><ol><li>AHB 高速总线、APB普通外设总结、</li><li><strong>通过APB为GPIO提供RCC时钟源，才可以使外设与CPU连接。</strong></li></ol><p><img src="./images/1668182227309.png" alt="使能GPIO"></p><ol start="3"><li>volatile 避免从缓冲区取值，只能从寄存器中取值。</li></ol><h2 id="第七节"><a href="#第七节" class="headerlink" title="第七节"></a>第七节</h2><ol><li>使用结构体可以定义连续的的相关配置，因为结构体中遍历在内存中是连续的。</li><li>使用STM32官方库需要引入相关文件。</li></ol><p><img src="./images/1668181982839.png" alt="依赖文件"></p><p><img src="./images/1668182057720.png" alt="依赖文件"></p><p><img src="./images/1668182110452.png" alt="库文件"></p><h2 id="第八节-按键控制"><a href="#第八节-按键控制" class="headerlink" title="第八节 按键控制"></a>第八节 按键控制</h2><p><img src="./images/1668242764890.png" alt="低电平输入"></p><ol><li>利用按键进行控制led时，可以利用内部的上拉电位，以此输入高电平，按键后输入低电平，以此控制LED</li></ol><h2 id="第九节呼吸灯"><a href="#第九节呼吸灯" class="headerlink" title="第九节呼吸灯"></a>第九节呼吸灯</h2><ol><li>有两种方式，一种是通过修改平均电平，第二种是通过修改PWM</li></ol><p><img src="./images/1668321362358.png" alt="修改电平，变亮就是增加高电平所占时间"></p><h2 id="第十一节NVIC"><a href="#第十一节NVIC" class="headerlink" title="第十一节NVIC"></a>第十一节NVIC</h2><p><img src="https://files.shanqianche.cn/202211/1668324442560.png" alt="抢占优先级和响应优先级"></p><ol><li>从优先级（响应优先级）,在抢占优先级相同时谁的高谁优先。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668325634113.png" alt="外部中断模式"><br>2. 事件请求：当前事件完成后跳转到中断向量表。中断请求：立刻跳转到中断向量表。</p><p><img src="https://files.shanqianche.cn/202211/1668326173434.png" alt="功能复用"><br>3. 需要考虑到pin复用。时钟和中断。</p><p><img src="https://files.shanqianche.cn/202211/1668326286702.png" alt="外部中断初始化"><br>4. 外部中断EXTI0的配置包括：向量化中断控制器的配置、PA0配置为外部中断、中断工作模式（下降沿检测）</p><h2 id="第十三节SysTick-最后一个异常"><a href="#第十三节SysTick-最后一个异常" class="headerlink" title="第十三节SysTick 最后一个异常"></a>第十三节SysTick 最后一个异常</h2><ol><li>SysTick是系统内部计时器，CorTex-M3内包含。其是一个24位的计时器，基本模式是从一个reload 值递减，为0时触发异常，然后重新计数。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668328540665.png" alt="SysTick CTRL"></p><ol start="2"><li>多久减一可以通过CLKSOURCE来设置，AHB为告诉外部时钟，为72MHZ。频率=1/时钟，所以时钟越大，精度越高。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668329188316.png" alt="时钟为72MHZ，reload value为72，最后1微妙产生一次异常中断"><br>3. 产生一次异常时间的设置。</p><h2 id="第十四节"><a href="#第十四节" class="headerlink" title="第十四节"></a>第十四节</h2><p><img src="https://files.shanqianche.cn/202211/1668346317638.png" alt="时钟配置"></p><p><img src="https://files.shanqianche.cn/202211/1668346298839.png" alt="开启时钟，设置全局变量，使其在异常函数中进行递减"><br><img src="https://files.shanqianche.cn/202211/1668346363077.png" alt="SysTick异常函数"></p><ol><li>延时函数</li></ol><h2 id="第十五节"><a href="#第十五节" class="headerlink" title="第十五节"></a>第十五节</h2><ol><li>stm32 有两个看门狗，一个独立看门狗，一个窗口看门狗</li></ol><p><img src="https://files.shanqianche.cn/202211/1668348073923.png" alt="IWDG"><br><img src="https://files.shanqianche.cn/202211/1668348218257.png" alt="IWDG主要功能"><br>2. 独立看门狗（IWDG）依赖LSI（低速内部时钟），即使晶振，外部时钟不工作，IWDG依旧正常工作</p><p><img src="https://files.shanqianche.cn/202211/1668348022275.png" alt="依赖APB1的外设"><br><img src="https://files.shanqianche.cn/202211/1668348100750.png" alt="WWDG"></p><p><img src="https://files.shanqianche.cn/202211/1668348325069.png" alt="IWDG框图"></p><p><img src="https://files.shanqianche.cn/202211/1668348444032.png" alt="键寄存器"><br><img src="https://files.shanqianche.cn/202211/1668390061020.png" alt="reload value为625，pr预分频因子为4时，IWDG就会每隔一秒钟复位一次"><br>3. WWDG依赖APB1，所以APB1出问题，无法工作。</p><p><img src="https://files.shanqianche.cn/202211/1668390482984.png" alt="设置IWDG，第一步取消写保护，设置PR"></p><p><img src="https://files.shanqianche.cn/202211/1668390706177.png" alt="第一步"><br><img src="https://files.shanqianche.cn/202211/1668390795034.png" alt="第二步PR的设置"></p><p><img src="https://files.shanqianche.cn/202211/1668390820968.png" alt="第三步reload value"><br><img src="https://files.shanqianche.cn/202211/1668390977778.png" alt="第四步装入reload value"></p><p><img src="https://files.shanqianche.cn/202211/1668391016821.png" alt="第五步使能"></p><p><img src="https://files.shanqianche.cn/202211/1668391395544.png" alt="IWDG_initt code"><br>5. 4. IWDG的设置</p><h2 id="第16节课WWDG"><a href="#第16节课WWDG" class="headerlink" title="第16节课WWDG"></a>第16节课WWDG</h2><ol><li><strong>偶尔的两次异常，即正常状态到异常状态、接着异常状态又到正常状态，这属于异常，如果这两步操作在异常恢复时间内，即喂狗时间内，IWDG是无法检测到的。而WWDG可以解决。</strong></li></ol><p><img src="https://files.shanqianche.cn/202211/1668392219848.png" alt="特殊异常"><br>2. WWDG喂狗机制，当WWDG的递减计数器1T[6:0]大于上限窗口W[6:0]时1，如果尝试去喂狗，将立刻产生CPU复位。</p><p><img src="https://files.shanqianche.cn/202211/1668392718745.png" alt="只有在0x60-0x3F内喂狗才有效"><br><img src="https://files.shanqianche.cn/202211/1668393252329.png" alt="WWDG原理"></p><p><img src="https://files.shanqianche.cn/202211/1668393442189.png" alt="enter description here"></p><p><img src="https://files.shanqianche.cn/202211/1668393484988.png" alt="喂狗"></p><ol start="3"><li>WWDG配置code<pre><code>- 因为WWDG是与APB1连接的，所以需要从APB1相关函数使能WWDG- 初始化WWDG，配置计数，计数是有上限的，通过与最大值进行想与来限制。- 设置预分频值（PR）- 设置上窗口值- 使能并且喂狗</code></pre></li></ol><p><img src="https://files.shanqianche.cn/202211/1668495595263.png" alt="WWDG初始化配置"></p><p><img src="https://files.shanqianche.cn/202211/1668495613227.png" alt="中断向量表初始化"></p><p>必须进行喂狗，不然CPU会不断进行重启。<br><img src="https://files.shanqianche.cn/202211/1668495643575.png" alt="喂狗"></p><h2 id="第十七节USART"><a href="#第十七节USART" class="headerlink" title="第十七节USART"></a>第十七节USART</h2><ol><li>主要用于芯片与芯片之间的传输</li><li>芯片与PC之间的通信</li><li>芯片与外围模块之间的通信 </li></ol><p>UART 异步功能<br>USART 同步功能<br>USART_CK具有时钟功能<br>USART_CTS具有流控功能，因为不同设备之间频率不一样，接发速率也不一样，CTS可以控制是否接受或者发送数据【硬件流控】，可以用于判断是否进行发送数据<br>USART_RTS发送请求</p><h3 id="代码-amp-逻辑"><a href="#代码-amp-逻辑" class="headerlink" title="代码&amp;逻辑"></a>代码&amp;逻辑</h3><ol><li>开启对应总线的时钟，同时需要开启GPIO管脚的时钟</li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计第四版</title>
      <link href="/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="戴师帮忙选的important-point"><a href="#戴师帮忙选的important-point" class="headerlink" title="戴师帮忙选的important point"></a>戴师帮忙选的important point</h1><p><img src="http://files.shanqianche.cn/20225/1652971169338.png" alt="important point page-1"></p><p><img src="http://files.shanqianche.cn/20225/1652971169333.png" alt="important point page-2"></p><p><img src="http://files.shanqianche.cn/20225/1652971169335.png" alt="important point page-3"></p><p><img src="http://files.shanqianche.cn/20225/1652971169334.png" alt="important point page-4"></p><p><img src="http://files.shanqianche.cn/20225/1652971169337.png" alt="important point page-5"></p><p><img src="http://files.shanqianche.cn/20225/1652971169336.png" alt="important point page-6"></p><p><img src="http://files.shanqianche.cn/20225/1652971169339.png" alt="important point page-7"></p><p><img src="http://files.shanqianche.cn/20225/1652971169340.png" alt="important point page-8"></p><p><img src="http://files.shanqianche.cn/20225/1652971169411.png" alt="important point page-9"></p><p><img src="http://files.shanqianche.cn/20225/1652971169408.png" alt="important point page-X"></p><h1 id="第二章-HTML-中的-JavaScript"><a href="#第二章-HTML-中的-JavaScript" class="headerlink" title="第二章 HTML 中的 JavaScript"></a>第二章 HTML 中的 JavaScript</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>第2.1中提到type中设置为module，代码当成了<font color="#8B0000">ES6模块</font>，需要实践来验证。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169412.png" alt="script标签中type属性"></p><ol start="2"><li>第2.1中提到浏览器不会对文件扩展名进行检测，为服务器<font color="#8B0000">动态生成js</font>提供可能性，不是很理解。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169413.png" alt="不对文件后缀检测的作用"></p><ol start="3"><li>第2.1不是很懂其中提到的<font color="#8B0000">MIME</font>的作用及判断原理</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169416.png" alt="返回正确MIME类型"></p><ol start="4"><li>第2.1中提到src中url的请求策略，不理解<font color="#bf242a">同源策略</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169414.png" alt="src的请求策略，以及返回的JavaScript的受限规则"></p><ol start="5"><li>第2.1.2中推迟脚本执行中提到DOMContentLoad事件，没见过，下次学习一下HTML</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169421.png" alt="delay属性设置后依旧会在DOMContentLoad事件之前执行"></p><ol start="6"><li>第2.1.3async可以保证脚本在<font color="#E9967A">页面load事件之前执行</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169415.png" alt="async在页面中的执行顺序"></p><h2 id="理解与解决"><a href="#理解与解决" class="headerlink" title="理解与解决"></a>理解与解决</h2><h1 id="第三章语言基础"><a href="#第三章语言基础" class="headerlink" title="第三章语言基础"></a>第三章语言基础</h1><h2 id="学习与反思"><a href="#学习与反思" class="headerlink" title="学习与反思"></a>学习与反思</h2><ol><li>声明的提升</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169420.png" alt="var声明提升"></p><ol start="2"><li><p>补充：<font color="#8B0000"><a href="https://www.javascripttutorial.net/javascript-event-loop/">Event Loop</a></font></p></li><li><p>var，let与const在for中的使用</p></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169419.png" alt="for循环"></p><p>setTimeOut会在for循环结束后进行输出，var在这里读取的是一个全局变了 $i$ ,所有只会输出五，但是JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，所以有五个 $i$ 进行输出。</p><p><img src="http://files.shanqianche.cn/20225/1652971169494.png" alt="for中的let"></p><p><img src="http://files.shanqianche.cn/20225/1652971169495.png" alt="for中的const"></p><h2 id="问题与解释"><a href="#问题与解释" class="headerlink" title="问题与解释"></a>问题与解释</h2><ol><li>第3.4.5中提到八进制和十六进制在数学操作中都被视为十进制，什么意思？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169496.png" alt="八进制和十六进制的运算方式"><br>答：都转化为十进制再进行计算。</p><ol start="2"><li>第3.4.7中为什么要避免Symbol()包装对象？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169497.png" alt="Symbol()无法包装对象"><br>解：对象是引用类型，返回的是指针，针对同一类型的对象是同一个指针，这就与Symbol（）矛盾了。<br>3. 第3.4.7.4的使用Symbol实现异步迭代以及后续的内容不是很懂。</p><p><img src="http://files.shanqianche.cn/20225/1652971169498.png" alt="相关异步的问题"><br>解：重构了迭代函数<br>4. 第3.4.7.16中with环境啥意思</p><p>解：</p><p><img src="http://files.shanqianche.cn/20225/1652971169499.png" alt="with的使用"></p><ol start="5"><li>第3.6.7中标签语句进行学习</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169500.png" alt="标签语句"><br>解：</p><h1 id="第四章变量、作用域与内存"><a href="#第四章变量、作用域与内存" class="headerlink" title="第四章变量、作用域与内存"></a>第四章变量、作用域与内存</h1><h2 id="问题与解"><a href="#问题与解" class="headerlink" title="问题与解"></a>问题与解</h2><ol><li>第4.2.2中let与var的提升的区别，let提升出现暂时性死区啥意思？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655395936285.png" alt="let与var的hoisting"><br>2. 第4.3.4.3中提到内存泄漏的原因，那么如何检测内存泄漏呢？</p><h1 id="第五章基本引用类型"><a href="#第五章基本引用类型" class="headerlink" title="第五章基本引用类型"></a>第五章基本引用类型</h1><ol><li>引用值与传统面向对象编程语言中的类相似，但实现不同？<b>理解</b></li></ol><h1 id="第六章集合引用类型"><a href="#第六章集合引用类型" class="headerlink" title="第六章集合引用类型"></a>第六章集合引用类型</h1><ol><li>第6.2.4中提到会出现无法判断一个对象是否为数组的现象？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655908202281.png" alt="无法判断是否为数组"></p><ol start="2"><li>第6.2.13中迭代器的作用域对象的使用。</li></ol><p><a href="https://blog.csdn.net/qq_35087256/article/details/79658253">相关文档</a></p><p><img src="http://files.shanqianche.cn/20226/1656118450989.png" alt="作用域对象"></p><ol start="3"><li>第6.3.4中提到的上溢和下溢不是很懂。</li></ol><p><img src="http://files.shanqianche.cn/20226/1656257982512.png" alt="解决上溢下溢问题"><br>4. 第6.9中，“每种包装类型都映射到同名的原始类型”什么意思？<br>5. 第6.9中，“在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。”？<br>6. 第6.9中，“涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。”？</p><h1 id="第七章迭代器与生成器"><a href="#第七章迭代器与生成器" class="headerlink" title="第七章迭代器与生成器"></a>第七章迭代器与生成器</h1><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><ol><li>第7.3.2.4中描述到yied*实现递归，没看懂代码</li></ol><p><img src="http://files.shanqianche.cn/20226/1656581774389.png" alt="enter description here"></p><h1 id="第八章对象、类与面向对象变成"><a href="#第八章对象、类与面向对象变成" class="headerlink" title="第八章对象、类与面向对象变成"></a>第八章对象、类与面向对象变成</h1><ol><li>第8.1.7中对象结构中提到解构在内部使用函数这块不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1656743508866.png" alt="解构在内部使用函数"></p><p><strong><font color="#FF1493">结构这的语法糖还是比较怪的，建议都看</font></strong></p><ol start="2"><li>第8.3.2.2中提到盗用构造函数的缺点不是很理解 <img src="https://files.shanqianche.cn/20227/1657633886960.png" alt="缺点"> <img src="https://files.shanqianche.cn/20227/1657633898659.png" alt="缺点"></li><li>第8.3.4中原型式的继承不是很懂作用</li></ol><p><img src="https://files.shanqianche.cn/20227/1657635961798.png" alt="原型式继承"><br>3. 第8.3.6中寄生组合继承，重新梳理一下继承中的逻辑</p><p><img src="https://files.shanqianche.cn/20227/1657637338484.png" alt="理论"></p><p><img src="https://files.shanqianche.cn/20227/1657637456555.png" alt="为什么说只调用一次"><br>4. 第8.4.4.5中类混入提到利用辅助函数进行展开嵌套，不是很懂原理和作用。</p><p><img src="https://files.shanqianche.cn/20227/1657711373381.png" alt="展开嵌套"></p><h1 id="第九章代理与反射"><a href="#第九章代理与反射" class="headerlink" title="第九章代理与反射"></a>第九章代理与反射</h1><ol><li>第9.1.6.2中提到使用反射不在抛错而是返回false，与实际代码不一样。</li></ol><p><img src="https://files.shanqianche.cn/20227/1657938559413.png" alt="文档"></p><p><img src="https://files.shanqianche.cn/20227/1657938590087.png" alt="实际演示"></p><h1 id="第十章函数"><a href="#第十章函数" class="headerlink" title="第十章函数"></a>第十章函数</h1><ol><li>第10.14闭包的作用和定义依旧不是很懂</li><li>第10.14.1中this对象的作用域不清楚</li></ol><p><img src="http://files.shanqianche.cn/20227/1658048008355.png" alt="this对象的作用域"></p><ol start="3"><li>第10.14.2中</li></ol><p><img src="http://files.shanqianche.cn/20227/1658049551215.png" alt="闭包问题"></p><ol start="4"><li>第10.15，10.16都不是很懂了</li></ol><h1 id="期约和异步函数"><a href="#期约和异步函数" class="headerlink" title="期约和异步函数"></a>期约和异步函数</h1><ol><li>第11.2.4.4中对于reduce的使用不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1658200969767.png" alt="promise+reduce"></p><p><img src="http://files.shanqianche.cn/20227/1658201198623.png" alt="promise reduce"></p><ol start="2"><li>第11.2.5.1中期约的取消，实现这块函数不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/code.png" alt="期约取消功能的实现"></p><h1 id="第十四"><a href="#第十四" class="headerlink" title="第十四"></a>第十四</h1><ol><li>第14.3.3 微任务队列及为啥处理两次</li></ol><p><img src="https://files.shanqianche.cn/20227/1658421089137.png" alt="记录队列"></p><h1 id="第二十章"><a href="#第二十章" class="headerlink" title="第二十章"></a>第二十章</h1><ol><li>第20.9.2，3，4看不懂可读流，可写流和转换流</li></ol><h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><ol><li>第24.6中fetch API的数据绑定不是很懂，尤其stream那块</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> daily </tag>
            
            <tag> JavaScript </tag>
            
            <tag> book </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务流程的LSTM精准模型</title>
      <link href="/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>使用LSTM模型对事件下一步，时间戳和调用的资源进行预测。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要是对于前人提出在LSTM中利用近似前缀预测—<a href="https://blog.zuishuailcq.xyz/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/">基于LSTM神经网络的业务过程预测监控 | 吾辈之人，自当自强不息！</a>的缺陷的改进，缺陷：</p><ol><li>无法处理数字变量</li><li>不能生成带有时间戳的时间序列</li><li>后续有文章提出通过one-hot编码来对事件进行分类，而不是使用嵌入维度来实现的，这样<strong>随着事件类型的增加，精度就会极度下降</strong>。</li></ol><blockquote><p>知识补充<br>后处理：在模型训练后，人为的修改模型结果使之预测结果更加符合真实情况。<br><a href="https://blog.csdn.net/xieyan0811/article/details/80549001">数据挖掘之_后处理_谢彦的技术博客-CSDN博客_数据后处理</a></p></blockquote><dl><dt><strong><font color="#006400">解决：</font></strong><br>本文通过提出用于建立新的预处理和后处理方法和架构以及使用LSTM神经网络的事件日志的生成模型来解决上述方法的局限性。</dt><dd>具体地说，本文提出了一种方法去学习模型，该方法可以生成由三组(事件类型、角色、时间戳)组成的轨迹(或从给定前缀开始的轨迹的后缀)。提出的方法结合了Tax等人[13]和Evermann等人[2]的优点，<font color="#483D8B">通过使用嵌入维度，同时支持事件日志中的分类属性和数字属性</font>。本文考虑了神经网络中共享层和特有层的不同组合所对应的三种体系结构。</dd></dl><p><strong><font color="#FF8C00">评估：</font></strong></p><ol><li>第一种方法比较了与不同体系结构、预处理和后处理选择相对应的所提出方法的备选实例。该评估的目的是<font color="#00008B">根据获取到的日志的特征</font>，得出关于哪些设计选择更可取的指南。</li><li>比较提出方法在上面三条约束的表现。</li></ol><h1 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h1><h2 id="LSTM-当前的进展"><a href="#LSTM-当前的进展" class="headerlink" title="LSTM 当前的进展"></a>LSTM 当前的进展</h2><ol><li>使用LSTM对于事件类型较少的序列进行迭代循环预测，使用的是one-hot编码将事件类型，事件戳映射到向量特征向量，并使用事件发生的时间特征对其进行补充。<strong>缺点</strong>是当事件类型较多的时候，该方法效果会变差。</li></ol><ul><li>该模型由共享LSTM层构成，其中包括一个专门用于预测事件的LSTM和一个预测事件的LSTM</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627633758272.png" alt="2017-使用LSTM神经网络进行预测性业务流程监控"></p><ol start="2"><li>使用嵌入维度的LSTMs，可以减少输入长度和增加新的特征。<strong>缺点</strong>是依旧无法处理数值变量，所以也不能预测时间戳。<strong>优点</strong>是可以处理大量事件类型。</li></ol><ul><li>使用两层LSTMs隐藏层。</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627636620079.png" alt="2017-利用深度学习预测过程行为"></p><ol start="3"><li>提出基于RNN的模型MM-Pred来预测下一步事件和流程后续。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>这种方法同时使用控制流信息（事件类型）和案例数据（事件属性）。</li><li>该结构由编码器、调制器和解码器组成。</li><li>编码器和解码器使用LSTM网络将每个事件的属性转换为隐藏表示或从隐藏表示转换为隐藏表示。</li><li>调制器组件求出可变长度序列比对权重向量，其中每个权重表示用于预测未来事件和属性的属性的相关性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627873762436.png" alt="多属性事件序列的深度预测模型"></p><ol start="4"><li>使用多阶段深度学习的方法来预测下一个事件。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>首先是将每个事件映射到特征向量</li><li>下一步使用transformations降低输入维度，通常有，通过提取n-gram、使用hash、将输入通过两个自动编码层等方法</li><li>将转化后的输入传给负责预测的前馈神经网络</li></ul><p><img src="http://files.shanqianche.cn/202182/1627887742568.png" alt="业务流程事件预测的多阶段深度学习方法"></p><ol start="5"><li>作者提出一种基于GRU的神经网络架构BINet，用于业务流程执行中的实时异常检测。该架构用于预测下一个事件及属性。</li></ol><ul><li>该方法旨在为跟踪中的每个事件分配一个似然分数，然后用于检测异常。这种方法表明，过程行为的生成模型也可用于异常检测。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907436804.png" alt="基于深度学习的多元业务流程异常检测"></p><ol start="6"><li>作者比较几种真实数据集在MMs，all-k MMs以及基于自动机的模型中预测下一步的准确性和性能。</li></ol><ul><li>结果表明，AKOM模型具有最高的精度（在某些情况下优于RNN体系结构），而基于自动机的模型具有较高的可解释性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907971849.png" alt="下一个元素预测序列建模方法的跨学科比较"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="http://files.shanqianche.cn/2021811/1628666548975.png" alt="构建模型的步骤"></p><h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><h3 id="Data-transformation"><a href="#Data-transformation" class="headerlink" title="Data transformation"></a>Data transformation</h3><p><strong>根据属性性质（分类或连续）进行特定预处理。</strong></p><p><strong><font color="#294B71">分类：</font></strong></p><p>处理数据：将事件和资源作为类别属性，使用嵌入维度。</p><blockquote><p>向训练网络提供属性之间关联的正面和负面示例，使网络能够识别和定位具有相似特征的近似属性。根据NLP社区4中使用的一项通用建议，嵌入维度的数量被确定为类别数量的第四根，以避免它们之间可能发生冲突。生成的值作为不可训练的参数导出并在所有实验中重用，这样就不会增加模型的复杂性</p></blockquote><p><img src="http://files.shanqianche.cn/2021811/1628683817654.png" alt="用于训练嵌入层的网络结构和生成的4d空间被缩减为3d的空间"></p><p> <strong><font color="#E9967A">连续：</font></strong></p><p><font color="#1E90FF"> 对数据进行归一化，以供预测模型解释</font>。这里处理的事件之间的相对时间，问题在于不同日志，相对时间可能具有很大的可变性。 这种高可变性可以隐藏有关过程行为的有用信息，例如时间瓶颈或异常行为，如果不小心执行属性缩放，则可以隐藏这些信息。</p><p> 寻求一种合适的缩放方法。</p><p> <img src="http://files.shanqianche.cn/2021811/1628685428211.png" alt="最大值和对数归一化两种方法的对比"></p><h3 id="Sequences-creation"><a href="#Sequences-creation" class="headerlink" title="Sequences creation"></a>Sequences creation</h3><p> <strong>提取每个事件日志跟踪的固定大小的n-gram，以创建输入序列和预期事件来训练预测网络。</strong></p><p> <img src="http://files.shanqianche.cn/2021811/1628686156534.png" alt="从BPI 2012事件日志的案例id 174770中提取的五个n-gram"></p><p> <em>role表示的是事件与资源的关联</em></p><h2 id="Model-Structure-Definition-Phase"><a href="#Model-Structure-Definition-Phase" class="headerlink" title="Model Structure Definition Phase"></a>Model Structure Definition Phase</h2><p><img src="http://files.shanqianche.cn/2021811/1628686308297.png" alt="Baseline architecture"></p><p><img src="http://files.shanqianche.cn/2021811/1628687598994.png" alt="Tested architectures"></p><h2 id="Post-processing-Phase"><a href="#Post-processing-Phase" class="headerlink" title="Post-processing Phase"></a>Post-processing Phase</h2><p>从零前缀开始生成业务流程的完整跟踪中，传统使用的是arg max，直接根据下一个事件的最大概率来跟踪，但是这就会所有追踪的事件都倾向于概率最大值，对于低概率发生的事件无法追踪。这里作者使用的是arg max和随机选择的参数作为下一个事件的选择。</p><blockquote><p>我觉得应该使用softmax</p></blockquote><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><blockquote><p>本节描述了两个实验评估。第一个实验比较了三种架构在前处理和后处理选择方面的不同实例。第二个实验将提出的方法与技术背景中其它论文中的下一个事件、后缀和剩余时间预测任务的三条基线进行比较</p></blockquote><h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data Set"></a>Data Set</h2><pre><code>在本实验中，使用了九个来自不同领域、具有不同特征的真实事件日志</code></pre><ul><li>Helpdesk5事件日志包含来自意大利软件公司helpdesk票务管理过程的记录</li><li>BPI 20126 中的两个事件日志与来自德国金融机构的贷款申请流程相关。 这个过程由三个子过程组成，我们从中使用了 W 子过程，以便与”下一个元素预测序列建模方法的跨学科比较”进行比较 。</li><li>BPI 20137中的事件日志与沃尔沃的IT事件和问题管理有关。我们使用完整的案例学习生成模型</li><li>BPI 20158中的五个事件日志包含五个荷兰城市在四年期间提供的建筑许可证申请数据。原始事件日志分为五个部分（每个市政局一个）。所有事件日志都在子流程级别指定，包括345多个活动。因此，按照”Diagnostics of building per-mit application process in dutch municipalities”中所述的步骤对其进行预处理，以便在阶段级别进行管理</li></ul><p><img src="http://files.shanqianche.cn/2021811/1628688257014.png" alt="Event logs description"></p><ol><li><em><font color="#A9A9A9">SF指根据其在记录道数量、事件、活动和序列长度方面的组成分为简单、中等和复杂。</font></em></li><li><em><font color="#A9A9A9">TV指据每个事件日志的平均持续时间和最大持续时间之间的关系，将时间变异性（TV）分为稳定或可变</font></em></li></ol><h2 id="Experimental-setup"><a href="#Experimental-setup" class="headerlink" title="Experimental setup"></a>Experimental setup</h2><p><strong><font color="#8A2BE2">目的：</font></strong><br>    使用 LSTM 模型从大小为0的前缀开始跟踪生成完整的事件日志，然后将生成的跟踪与原始日志中的流程进行比较。</p><p><font color="#1E90FF">方法：使用两个指标来评估生成的事件日志的相似性。</font></p><ol><li>Demerau-Levinstain（DL）算法根据一个字符串与另一个字符串相等所需的版本数测量序列之间的距离。该算法在每次执行插入、删除、替换和转置等操作时都进行惩罚。因此，我们使用其倒数来衡量生成的活动或角色序列与实际事件日志中观察到的序列之间的相似性。然后，较高的值意味着序列之间的相似性较高。</li><li>平均绝对误差（MAE）度量用于测量预测时间戳的误差。通过取观测值和预测值之间距离的绝对值，然后计算这些震级的平均值来计算该测量值。我们使用该度量来评估每对（生成轨迹、地面真值轨迹）的生成相对时间和观测时间之间的距离。</li></ol><blockquote><p>使用交叉验证，将事件日志分为两部分：70%用于培训，30%用于验证。第一个折叠被用作训练2000个模型的输入（每个事件日志大约220个模型）。<br>这平均220个模型配置了不同的预处理技术和体系结构。配置值是从972个组合的完整搜索空间中随机选择的。然后，使用每个经过培训的模型生成完整事件的新事件日志（参见第3节中描述的选择下一个活动的技术）。生成了每个配置的15个日志，并对其结果进行了平均。评估了32000多个生成的事件日志。</p></blockquote><h2 id="Results-and-Interpretation"><a href="#Results-and-Interpretation" class="headerlink" title="Results and Interpretation."></a>Results and Interpretation.</h2><p><img src="http://files.shanqianche.cn/2021811/1628689342024.png" alt="不同配置的事件日志中的相似性结果"></p><ul><li><font color="#A9A9A9">MAE列对应于预测记录道周期时间的平均绝对误差</font> </li></ul><p>结果表明，使用这种方法可以训练学习并可靠地再现原始日志的观察行为模式的模型。此外，研究结果表明，对于LSTM模型来说， <strong><font color="#A52A2A">学习词汇量较大</font></strong> 的序列比学习较长的序列更困难。要了解这些模式，需要更多的示例，如BPI2012和BPI2015的结果所示。这两个日志都有30多个活动，但在跟踪数量上有很大差异（见表2）。BPI2012的高度相似性还表明，使用嵌入维度处理大量事件类型可以改善结果，只要示例数量足以学习底层模式。</p><p>针对本实验中评估的模型结构构件，我们按照预处理、模型结构和超参数选择以及预测等阶段对其进行分析，以构建生成模型。</p><p><img src="http://files.shanqianche.cn/2021811/1628689921162.png" alt="Preprocessing phase components comparison"></p><p><strong><font color="#FF8C00">这里主要比较的是对于相对时间缩放方式，和进行缩放的作用。</font></strong></p><ol><li>a 说明了如何使用最大值作为缩放技术，具有很小时间变化的日志呈现更好的结果。相比之下，具有不规则结构的日志使用对数归一化具有较低的<font color="#0000FF"> MAE</font>【横坐标】。</li><li>b 展示了使用不同大小的 n-gram 时的 DL 相似性结果，与事件日志的结构有关。 我们可以观察到，使用更长的n-grams对于trace更长的日志有更好的结果，呈现出稳定的增长趋势。 相比之下，中、简单结构的事件日志趋势不明显。 因此，应将长 n-gram 的使用保留给具有很长跟踪的日志。**<font color="#006400">这里体现的是n-gram size对于预测结果的作用，只有复杂的日志呈现良好的正相关。</font>**</li></ol><p><img src="http://files.shanqianche.cn/2021811/1628690528922.png" alt="共享层的总体相似性"></p><p>关于模型结构定义阶段，图说明连接结构的总体相似度最低。相比之下，仅在分类属性之间共享信息的模型体系结构具有中等最佳性能。然而，它与专门的体系结构并不遥远，尽管它的分布范围更广。这意味着在不同性质的属性之间共享信息会在网络正在处理的模式中产生噪声，从而阻碍学习过程。</p><p><img src="http://files.shanqianche.cn/2021811/1628690699173.png" alt="下一个事件选择方法的比较"></p><p>关于预测阶段，图显示了随机选择在所有事件日志中如何优于arg max。这种行为在具有较长和复杂跟踪的事件日志中更为明显。结果表明，无论事件日志结构如何，随机选择都是评估学习过程的可取方法。</p><h2 id="Comparison-Against-Baselines"><a href="#Comparison-Against-Baselines" class="headerlink" title="Comparison Against Baselines"></a>Comparison Against Baselines</h2><h3 id="Experimental-setup-1"><a href="#Experimental-setup-1" class="headerlink" title="Experimental setup"></a>Experimental setup</h3><p><strong><font color="#FF00FF">目的：</font></strong><br>    评估我们的方法在预测下一个事件、剩余事件序列（即后缀）和剩余时间（对于不同长度的跟踪前缀）方面的相对性能。</p><ol><li>next event prediction — 为每个模型提供长度增加的跟踪前缀，从 1 到每个跟踪的长度。 对于每个前缀，我们预测下一个事件并测量准确性（正确预测的百分比）。</li><li> suffix and remaining time prediction — 为模型提供了长度增加的前缀，直到案件结束。</li></ol><p><strong><font color="#8A2BE2">baselines:</font></strong></p><ul><li>next event and suffix prediction</li></ul><ol><li> Predictive business process monitoring with LSTM neural networks</li><li> Predicting process behaviour using deep learning</li><li> A deep predictive model for multi-attribute event sequence</li></ol><ul><li>remaining time prediction</li></ul><ol><li>Predictive business process monitoring with LSTM neural networks【Helpdesk, BPI2012W and BPI2012 event logs】</li></ol><h3 id="Results-and-Interpretation-1"><a href="#Results-and-Interpretation-1" class="headerlink" title="Results and Interpretation"></a>Results and Interpretation</h3><p><img src="http://files.shanqianche.cn/2021811/1628691394455.png" alt="下一个事件和后缀预测结果"></p><p><strong>这些结果表明，分类属性的维度控制所采用的措施，使我们的方法即使在长序列中也能获得始终如一的良好性能。</strong></p><p><img src="http://files.shanqianche.cn/2021811/1628691420458.png" alt="剩余循环时间MAE的结果（以天为单位）"></p><p>图10显示了剩余循环时间预测的MAE。尽管我们的技术目标不是预测剩余时间，但与Tax等人相比，它在这项任务中实现了类似的性能——在一个日志中略逊于它，在另一个日志中略逊于它的长前缀。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><strong><font color="#FF8C00">优</font></strong></p><ol><li>评估表明，使用更长的n-gram可获得更高的精度</li><li>对数归一化是适用于高可变性测井的缩放方法，与总是选择最有可能的下一个事件相比，使用LSTM产生的概率随机选择下一个事件可导致更广泛的记录道和更高的精度。论文还表明，该方法在预测剩余事件序列及其从给定跟踪前缀开始的时间戳方面优于现有的基于LSTM的方法</li></ol><blockquote><p>作者预计，所提出的方法可以作为业务流程模拟的工具。实际上，从本质上讲，流程模拟器是一种通用模型，它生成由事件类型、资源和时间戳组成的跟踪集，并从中计算性能度量，如等待时间、循环时间和资源利用率。虽然流程模拟器依赖于可解释的流程模型（例如BPMN模型），但原则上可以使用能够生成事件跟踪的任何模型来模拟流程，其中每个事件都由事件类型（活动标签）、时间戳和资源组成。使用LSTM网络进行流程模拟的一个关键挑战是如何捕获“假设”场景（例如，删除任务或删除资源的效果）。</p></blockquote><p><strong><font color="#2F4F4F">future</font></strong><br>计划应用技术，使用”An eye into the future: Leveraging a-priori knowledge in predictive business process monitoring.”中的约束，从LSTM模型生成事件序列</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> process mining </tag>
            
            <tag> deep learning </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Long Short Term Memory Networks</title>
      <link href="/2021/07/19/Long%20Short%20Term%20Memory%20Networks/"/>
      <url>/2021/07/19/Long%20Short%20Term%20Memory%20Networks/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe><p><a href="https://zhuanlan.zhihu.com/p/32085405">人人都能看懂的LSTM - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/37644325">RNN、LSTM、GRU基础原理篇 - 知乎</a><br><a href="https://blog.csdn.net/matrix_space/article/details/53374040">机器学习：深入理解 LSTM 网络 (一)_Matrix-11-CSDN博客_lstm 机器学习</a></p><blockquote><p>中文分词、词性标注、命名实体识别、机器翻译、语音识别都属于序列挖掘的范畴。<font color="#DC143C">序列挖掘</font>的特点就是某一步的输出不仅依赖于这一步的输入，还依赖于其他步的输入或输出。在序列挖掘领域传统的机器学习方法有HMM（Hidden Markov Model，隐马尔可夫模型）和CRF（Conditional Random Field，条件随机场），近年来流行深度学习算法RNN（Recurrent Neural Networks，循环神经网络）。</p></blockquote><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p><img src="http://files.shanqianche.cn/2021719/1626698381786.png" alt="RNN网络架构图"></p><p>比如一个句子中有5个词，要给这5个词标注词性，那相应的RNN就是个5层的神经网络，每一层的输入是一个词，每一层的输出是这个词的词性。<br><img src="http://files.shanqianche.cn/2021719/1626698589144.png" alt="讲解"></p><h1 id="RNN的变体"><a href="#RNN的变体" class="headerlink" title="RNN的变体"></a>RNN的变体</h1><h2 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h2><p>双向RNN认为otot不仅依赖于序列之前的元素，也跟tt之后的元素有关，这在序列挖掘中也是很常见的事实。</p><p><img src="http://files.shanqianche.cn/2021719/1626698749683.png" alt=" Bidirectional RNNs网络结构"></p><h2 id="深层双向RNN"><a href="#深层双向RNN" class="headerlink" title="深层双向RNN"></a>深层双向RNN</h2><p>在双向RNN的基础上，每一步由原来的一个隐藏层变成了多个隐藏层。</p><p><img src="http://files.shanqianche.cn/2021719/1626698820535.png" alt="Deep Bidirectional RNNs网络结构"></p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>前文提到，由于<font color="#9932CC"><strong>梯度消失/梯度爆炸</strong></font>的问题传统RNN在实际中很难处理长期依赖，而LSTM（Long Short Term Memory）则绕开了这些问题依然可以从语料中学习到长期依赖关系。</p><p><img src="http://files.shanqianche.cn/2021719/1626699453120.png" alt="传统RNN每一步的隐藏单元只是执行一个简单的tanh或ReLU操作"></p><p><img src="http://files.shanqianche.cn/2021719/1626699501199.png" alt=" LSTM每个循环的模块内又有4层结构:3个sigmoid层，1个tanh层"></p><p><strong><font color="#D2691E">解释LSTM模块：</font></strong></p><p><img src="http://files.shanqianche.cn/2021719/1626699615537.png" alt="图标说明"></p><ul><li>粉色的圆圈表示一个二目运算。</li><li>两个箭头汇合成一个箭头表示2个向量首尾相连拼接在一起。</li><li>一个箭头分叉成2个箭头表示一个数据被复制成2份，分发到不同的地方去。</li></ul><p> LSTM的关键是细胞状态C，一条水平线贯穿于图形的上方，这条线上只有些少量的线性操作，信息在上面流传很容易保持。</p><p><img src="http://files.shanqianche.cn/2021719/1626699717681.png" alt="忘记层"></p><ol><li>忘记层，决定细胞状态中<strong>丢弃什么信息</strong>。把ht−1和xt拼接起来，传给一个sigmoid函数，该函数输出0到1之间的值，这个值乘到细胞状态Ct−1上去。<font color="#FF8C00">sigmoid函数的输出值直接决定了状态信息保留多少</font>。比如当我们要预测下一个词是什么时，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。</li></ol><p><img src="http://files.shanqianche.cn/2021719/1626700419154.png" alt="更新细胞状态"><br>2. 上一步的细胞状态Ct−1已经被忘记了一部分，接下来本步应该把哪些信息新加到细胞状态中呢？这里又包含2层：一个tanh层用来产生更新值的候选项C~t，tanh的输出在[-1,1]上，<strong>说明细胞状态在某些维度上需要加强，在某些维度上需要减弱</strong>；还有一个sigmoid层（输入门层），它的输出值要乘到tanh层的输出上，起到一个<strong>缩放</strong>的作用，<em>极端情况下sigmoid输出0说明相应维度上的细胞状态不需要更新</em>。在那个预测下一个词的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。</p><p><img src="http://files.shanqianche.cn/2021719/1626700649763.png" alt="生成新的细胞状态"><br>3. 现在可以让旧的细胞状态Ct−1与ft（f是forget忘记门的意思）相乘来丢弃一部分信息，然后再加个需要更新的部分it∗C~t（i是input输入门的意思），这就生成了<strong>新的细胞状态Ct</strong></p><p><img src="http://files.shanqianche.cn/2021719/1626700735024.png" alt="循环模块的输出"><br>4. 最后该决定输出什么了。输出值跟细胞状态有关，把Ct输给一个tanh函数得到输出值的候选项。<strong>候选项中的哪些部分最终会被输出由一个sigmoid层来决定</strong>。在那个预测下一个词的例子中，如果细胞状态告诉我们当前代词是第三人称，那我们就可以预测下一词可能是一个第三人称的动词。</p><h1 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h1><p>GRU（Gated Recurrent Unit）是LSTM最流行的一个变体，比LSTM模型要简单。没有了存储单元</p><p><img src="http://files.shanqianche.cn/2021719/1626700963311.png" alt="GRU"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RNN 结构的一个吸引人之处在于其可以利用之前的输入信息。但是一个关键的需要解决的问题是当前的信息与之前的信息的关联度有长有短。<br>LSTM的内部结构。通过门控状态来控制传输状态，<strong>记住需要长时间记忆的，忘记不重要的信息</strong>；而不像普通的RNN那样只能够“呆萌”地仅有一种记忆叠加方式。对很多需要“长期记忆”的任务来说，尤其好用。、<br>但也因为引入了很多内容，导致参数变多，也使得训练难度加大了很多。因此很多时候我们往往会使用效果和LSTM相当但参数更少的GRU来构建大训练量的模型。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于LSTM神经网络的业务过程预测监控</title>
      <link href="/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/"/>
      <url>/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=VAPwMDAm550&list=RDVAPwMDAm550&start_radio=1" title="我還年輕 我還年輕"><img src="https://res.cloudinary.com/marcomontalbano/image/upload/v1626681958/video_to_markdown/images/youtube--VAPwMDAm550-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="我還年輕 我還年輕"></a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文研究了长-短期记忆（LSTM）神经网络作为一种预测模型。并证明LSTMs在预测运行案例的下一个事件及其时间戳方面优于现有的技术。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作者提到他的目的是提出一个可以适用的框架。本文的研究点：</p><ol><li>LSTMs能否被用于广泛的流程预测，以及如何应用？</li><li>如何保障LSTM在不同数据中的准确度始终如一？</li></ol><p>在不同预测内容中，作者适用了4个日志数据集进行验证比较。</p><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><p>主要讲的是目前对于三种预测的技术，包括了，时间相关预测、事件结果的预测、正在执行事件的预测</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li>数据集A</li><li>数据集A中所有序列 $A^{*}$</li><li>一个长度为n的序列 σ =&lt;  $a_{1}$ ,  $a_{2}$ ,  $a_{3}$ , …… ,  $a_{n}$  &gt;,空序列为&lt;&gt;</li><li>$σ_ { 1 } \cdot σ _ { 2 }$ 表示序列 $σ_{1}$ 与 $σ_{2}$ 的串联</li><li> $h d ^ { k } ( o ) = ( a _ { 1 } , a _ { 2 } , \cdots , a _ { k } )$ 为<strong>前缀长度</strong>为k（0&lt;k&lt;n） 的序列 σ的<strong>前缀</strong>。 $t l ^ { k } ( o ) = ( a _ { k + 1 } \cdots , a _ { n } )$ 是它的后缀。</li></ul><p>对于前缀后缀的一个<strong>栗子</strong>：<br>序列： $σ _ { 1 } = ( a , b , c , d , e )$<br>前缀长度为二的前缀： $h d ^ { 2 } ( σ _ { 1 } ) = ( a , b )$<br>后缀为： $t l ^ { 2 } ( σ _ { 1 } ) = ( c , d , e )$</p><ul><li> $\varepsilon$ 【伊普西隆】为所有事件集合，T为时域。</li><li> $\pi _{ \tau }\in \varepsilon  \rightarrow T$ 为事件分配事件戳</li><li> $\pi _{ A }\in \varepsilon  \rightarrow A$ 从事件集A种为一个流程分配活动<h2 id="RNN和LSTM"><a href="#RNN和LSTM" class="headerlink" title="RNN和LSTM"></a>RNN和LSTM</h2></li></ul><p><a href="https://blog.zuishuailcq.xyz/2021/07/19/Long%20Short%20Term%20Memory%20Networks/">Long Short Term Memory Networks | 吾辈之人，自当自强不息！</a></p><h1 id="下一个活动和时间戳预测"><a href="#下一个活动和时间戳预测" class="headerlink" title="下一个活动和时间戳预测"></a>下一个活动和时间戳预测</h1><p>介绍评估多种体系结构预测下一个事件和时间戳。</p><p><img src="http://files.shanqianche.cn/2021728/1627442124718.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627442195597.png" alt="事件预测算法"></p><p>输入一个事件的前缀，然后预测下一个事件。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p><strong><font color="#D2691E">知识补充</font></strong><br>one hot编码是将类别变量转换为机器学习算法易于利用的一种形式的过程。<br>假设“花”的特征可能的取值为daffodil（水仙）、lily（百合）、rose（玫瑰）。one hot编码将其转换为三个特征：is_daffodil、is_lily、is_rose，这些特征都是二进制的。<br><a href="https://zhuanlan.zhihu.com/p/37471802">什么是one hot编码？为什么要使用one hot编码？ - 知乎</a></p></blockquote><ol><li>首先为LSTM构建特征向量矩阵，作为输入。</li></ol><p>事件e=σ（i）的时间特征指的是在trace中的上一个时间和当前时间之间的时间。转换函数：<br><img src="http://files.shanqianche.cn/2021720/1626745464036.png" alt="enter description here"></p><p>三种时间特征：fvt1表示事件的当前时间特征【与上一个时间的时间间隔】，同时也添加了包函一天时间的特征fvt2和包含一周的时间特征fvt3.这样当事件在工作日或者工作周结束的时候预测下一个活动的事件中时间间隔则会更长。</p><ul><li>LSTM可以通过fvt1学到不同节点的事件宇时间差的依赖关系。</li><li>fvt2，fvt3的加入，是为处理有些有些事件超出了工作日的特殊情况，因为传统的日志处理中只记录工作日中的。</li></ul><ol start="2"><li>对时间步长k【第k个事件的时间】的输出 $o _ { a } ^ { k }$ 进行one-hot编码。</li></ol><p><font color="#6495ED">异常情况</font></p><ul><li>当在时间k为事件的结尾，既没有新的事件可以预测。 </li></ul><p><font color="#B22222"> <strong>解决</strong></font></p><ul><li>当在时间k结束时,给输出的one-hot编码向量增加额外标记值1 </li></ul><ol start="3"><li><p>设置第二个输出值 $o_{t}^{k}$ 为下一个时间间隔的 $fv_{t1}$ 值。当知道当前时间戳，就可以计算到下一个事件的时间戳。</p></li><li><p>使用Adam算法【梯度下降算法】进行神经网络权重优化</p></li></ol><p><strong><font color="#FF1493">如何优化：</font></strong></p><ul><li>最小化基础事件one-hot编码和被预测的下一个事件的one-hot编码的<font color="#0000FF">交叉熵</font>。</li><li>最小化事件和预测事件之间时间的<font color="#FF1493">平均误差</font>（MAE）</li></ul><h2 id="模型的构建"><a href="#模型的构建" class="headerlink" title="模型的构建"></a>模型的构建</h2><p><img src="http://files.shanqianche.cn/2021727/1627371341818.png" alt="单任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371437071.png" alt="共享多任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371484245.png" alt="n层共享，m层单任务混合神经网络结构"></p><ol><li>使用相同的数据特征，分别单独训练两个模型，一个是预测下一步事件，另一个是预测下一个时间戳，如图a</li><li>多任务学习可以在同一个神经网络结构学习到多个模型，例如图b，同一个LSTM神经网络结构学习输出两个模型。</li><li>混合模型</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用的循环神经网络依赖库Keras构建项目</li><li>硬件是NVidia Tesla k80 GPU，每次epoch时间为15-90s。其中预测时间时间戳是以毫秒为单位的。</li></ul><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><h3 id="评定标准"><a href="#评定标准" class="headerlink" title="评定标准"></a>评定标准</h3><p>本文使用的<font color="#FF8C00">MAE</font>（平均绝对误差）来作为实验结果比较的参考。在实验效果评价这块，作者通过修改 van der Aalst提出的论文中用于预测剩余时间的模型来作为baseline。</p><h3 id="实验准备-1"><a href="#实验准备-1" class="headerlink" title="实验准备"></a>实验准备</h3><p>使用两个数据集进行预测下一个活动和时间戳。其中2/3的数据用于训练模型，1/3的用于预测。</p><p><i class="fas fa-tags" ></i>这里数据中长度为2的序列进行 $2 \leq k \lt | o |$ 预测，长度小于2则不对其预测。</p><p><strong><font color="#00008B">数据集</font></strong></p><ol><li>帮助中心数据集</li></ol><p>来自于意大利软件公司的票务管理系统，主要包括9中事件，一种事务流程。其中流程总共有3804条，事件有13710个。<br>2. BPI12子数据集W</p><p>此事件日志源自Business Process Intelligence Challenge（BPI’12）2，包含来自大型金融机构金融产品应用程序的数据。此流程由三个子流程组成：一个子流程跟踪应用程序的状态，一个子流程跟踪与应用程序关联的工作项的状态，第三个子流程跟踪报价的状态。在预测未来事件及其时间戳的上下文中，我们对自动执行的事件不感兴趣。因此，我们将评估范围缩小到工作项子流程，<font color="#FF8C00">其中包含手动执行的事件</font>。此外，我们过滤日志以<strong>仅保留complete类型的事件</strong>。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p><img src="http://files.shanqianche.cn/2021727/1627377231055.png" alt="result，前缀为all表示所有前缀的平均值"><br>N表示神经元。MAE为当前配置不同前缀长度的性能。</p><p>表1显示了help desk和BPI’12w子流程日志上各种LSTM体系结构在MAE预测时间和预测下一事件准确性方面的性能。由于BPI12中的流程长度较长，所以前缀较长。</p><p>TODO 前缀不是很懂<br><font color="#7FFF00">分析：</font></p><ol><li>ALL LSTM体系结构在所有前缀上都优于baseline，同时分别比较LSTM模型和baseline模型，可以发现 <strong><font color="#FF00FF">短前缀的增益要比长前缀要好。</font></strong></li><li>数据集helpdesk的预测准确度最好为71%；BPI’12 W数据集预测的最佳精度为76%，高于Breuker等人报告的71.9%的精度和Evermann等人报告的62.3%的精度。</li><li>预测精度最高的模型都为混合模型，尝试将每层的神经元数量减少到75个，对于只有一个共享层的架构，将其增加到150个，但发现这会导致两个任务的性能下降。可能有75个神经元导致模型欠拟合，而150个神经元导致模型过拟合。我们还在单层架构上对传统RNN进行了实验，发现它们在时间和活动预测方面都比LSTM差得多。</li></ol><h1 id="后缀预测"><a href="#后缀预测" class="headerlink" title="后缀预测"></a>后缀预测</h1><blockquote><p><strong><font color="#ff7500">本章理解</font></strong><br>区别于上一节，上一章是单个时间步长预测下一步，而本章是预测一个运行案例的整个延续。</p></blockquote><p><img src="http://files.shanqianche.cn/2021728/1627454393652.png" alt="事件预测"></p><p><img src="http://files.shanqianche.cn/2021728/1627454420942.png" alt="时间预测"></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过迭代地预测下一个事件和时间戳，然后再次进行预测直至这个案例结束。这里用 $\perp$ 表示案例结尾。</p><p><strong><font color="#006400">迭代预测：</font></strong></p><p><img src="http://files.shanqianche.cn/2021728/1627455885003.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627456583245.png" alt="时间预测算法"></p><p><font color="#FF1493">当当前事件为END，则不进行预测；否则将预测的结果输入到预测模块迭代预测。</font></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>对于预测准确度的评价这里采用的是通过计算预测结果与实际结果的编辑距离来衡量。</p><blockquote><p>知识补充：<font color="#2e4e7e">Levenshtein distance</font><br><a href="https://www.cnblogs.com/ivanyb/archive/2011/11/25/2263356.html">字符串相似度算法（编辑距离算法 Levenshtein Distance） - ZYB - 博客园</a></p></blockquote><p><strong>问题：</strong><br>  当处理并发任务的时候，Levenshtein distance并不适用于计算。例如&lt;a,b&gt;为预测的下一个事件，但实际上为&lt;b,a&gt;，这种情况只是因为ab并发顺序导致的，<font color="#DC143C">实际上并无相关</font>。但是Levenshtein distance结果为2,因为将预测序列转换为实际序列需要一次删除和一次插入操作。</p><p><strong>解决</strong><br>Damerau-Levenstein距离是一种更好地反映预测质量的评估度量，它为Levenshtein距离使用的操作集添加了交换操作。Damerau-Levenshtein距离将分配1的转换成本⟨a、 b⟩ 进入⟨b、 a⟩. 为了获得可变长度记录道的可比较结果，我们通过实际案例后缀长度和预测后缀长度的最大值对Damerau-Levenshtein距离进行归一化，归一化的Damerau-Levenshtein距离减1以获得Damerau-Levenshtein相似性（DLS）。</p><p><strong>模型</strong><br>采用的是双层架构，每层100个神经元的LSTM。</p><p><strong>数据集</strong><br>这是荷兰某市政当局环境许可程序的日志每宗个案涉及一份许可证申请。<br>该日志包含937个案例和381种事件类型的38944个事件。几乎每一种情况都遵循一个独特的路径，这使得后缀预测更具挑战性。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://files.shanqianche.cn/2021728/1627479266512.png" alt="基于Damerau-Levenshtein相似性的后缀预测结果"><br>Polato为baseline，no duplicates表示去掉案例中的重复事件，但是保留一个【案例结尾即使为重复事件也不去掉】。</p><p>观察可以发现所有数据集中的LSTM预测结果都要好于baseline。在BPI12数据集种很多案例中的事件会重复的出现，这就会导致预测的后缀长于真实案例，因此删除了BPI12中重复的事件并重新进行评估。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>利用LSTM神经网络预测运行案例的下一个活动及其时间戳的技术。表明，这种技术在现实数据集上优于现有的基线。此外，我们发现通过单一模型（多任务学习）预测下一个活动及其时间戳比使用单独的模型进行预测具有更高的准确性。</li><li>提出了一个运行种的案例整个延续的预测和预测剩余的周期时间的解决方案。</li><li>发现了LSTM模型的局限性，**<font color="#9932CC">即在一个案例种某些事件多次重复出现时，导致后缀过长，性能就会很低</font>**。</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数之交叉熵(一般用于分类问题)</title>
      <link href="/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/"/>
      <url>/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=i73Lh3h0DpQ" title="ONE HOUR"><img src="https://res.cloudinary.com/marcomontalbano/image/upload/v1626618085/video_to_markdown/images/youtube--i73Lh3h0DpQ-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="ONE HOUR"></a></p><p><a href="https://blog.csdn.net/u014453898/article/details/81559462">损失函数之交叉熵(一般用于分类问题)_ZJE-CSDN博客</a></p><h2 id="信息量、信息熵、相对熵"><a href="#信息量、信息熵、相对熵" class="headerlink" title="信息量、信息熵、相对熵"></a>信息量、信息熵、相对熵</h2><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p><font color="#FF8C00">一件事发生的概率越大，其蕴含的信息量就越少，反之，若发生的几率越小，则蕴含的信息量就越大</font>。</p><p>例如，“太阳从东方升起”：这件事发生概率极大，大家都习以为常，所以不觉得有什么不妥的地方，因此蕴含信息量很小。但“国足踢入世界杯”：这就蕴含的信息量很大了，因为这件事的发生概率很小。</p><p><img src="http://files.shanqianche.cn/2021718/1626617713541.png" alt="信息量"></p><p>若某事x的发生概率为P(x)，则信息量的计算公式为：<br>$I ( x ) = - \log ( P ( x ) )$</p><p>上式的log的底为2，当然也可以是e、10。在神经网络中，log的底一般是e。当log的底大于1，log的图形就像下图红色线。因为P(x)的取值范围为0<del>1，可以看到，log的图像，在0</del>1的时候是负数，且P(x)越接近0，log越接近负无穷，P(x)越接近1，log越接近0，所以信息量的公式会在log前面加个负号，让log的取值范围为0~∞。当P(x)接近0，log接近无穷，P(x)接近1，log接近0，这符合信息量的概率越小，信息量越大的定义。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵可以表达<strong>数据的信息量大小</strong>。<br>信息熵也被称为熵，用来表示所有信息量的<strong>期望</strong>。<br>期望是试验中每次可能结果的概率乘以其结果的总和。<br>信息熵的公式如下：<br>$H ( X ) = - \sum _ { i = 1 } ^ { n } P ( x _ { i } ) \log ( P ( x _ { i } )  )$ $( X = x _ { 1 } , x _ { 2 } , x _ { 3 } , x _ { n - 1 } , x _ { n } )$</p><p>使用明天的天气概率来计算其信息熵：</p><p><img src="http://files.shanqianche.cn/2021718/1626618468307.png" alt="天气"><br>$H ( X ) = - ( 0.5 * \log ( 0.5 ) + 0.2 * \log ( 0.2 ) + 0.3 * \log ( 0.3 ) )$</p><h3 id="KL散度（相对熵）—–用于衡量两个概率分布的差异"><a href="#KL散度（相对熵）—–用于衡量两个概率分布的差异" class="headerlink" title="KL散度（相对熵）—–用于衡量两个概率分布的差异"></a>KL散度（相对熵）—–用于衡量两个概率分布的差异</h3><p><strong><font color="#8A2BE2">如何理解 “衡量两个概率分布的差异”？</font></strong></p><p>例如在机器学习中，常常用P(x)表示样本的真实分布，用Q(x)表示模型预测的分布，比如在一个三分类任务中（例如，猫狗马分类器），[x1，x2，x3]分别表示猫，狗，马的概率，输入一张猫的图片，其真实分布为P(x)=[1，0，0]，预测分布为Q(x)=[0.7，0.2，0，1]，那么P(x)和Q(x)就是两个不同的概率分布，可以用KL散度来计算他们的差异。<br>公式为：<br><img src="http://files.shanqianche.cn/2021718/1626618687852.png" alt="enter description here"><br>KL散度越小，表示P(x)和Q(x)越接近，所以可以通过反复训练，来使Q(x)逼近P(x)，但KL散度有个特点，就是不对称，就是用P来你和Q和用Q来你和P的KL散度(相对熵)是不一样的，但是P和Q的距离是不变的。</p><p><strong>那KL散度(相对熵)和交叉熵有什么联系呢</strong>？</p><p>我们通过对相对熵公式进行变形：<br><img src="http://files.shanqianche.cn/2021718/1626618747252.png" alt="enter description here"><br>H(X)为之前的信息熵，后面那一坨其实就是交叉熵了，所以可以看到：**<font color="#FF00FF">KL散度 = 交叉熵 - 信息熵</font>**</p><p>所以交叉熵的公式如下：<br><img src="http://files.shanqianche.cn/2021718/1626618800801.png" alt="enter description here"><br>从信息熵的公式，我们知道，对于同一个数据集，其信息熵是不变的，所以信息熵可以看作一个常数，因此<font color="#9400D3">当KL散度最小时，也即是当交叉熵最小时</font>。在多分类任务中，KL散度(相对熵)和交叉熵是等价的。</p><h2 id="交叉熵的原理"><a href="#交叉熵的原理" class="headerlink" title="交叉熵的原理"></a>交叉熵的原理</h2><p>交叉熵是<font color="#057748">用来衡量两个 概率分布 的距离</font>(也可以叫差别)。[概率分布：即[0.1，0.5，0.2，0.1，0.1]，每个类别的概率都在0~1，且加起来为1]。</p><p>若有两个概率分布p(x)和q(x)，通过q来表示p的交叉熵为：(<strong>注意</strong>，p和q呼唤位置后，交叉熵是不同的)<br>$H ( p , q ) = - \sum p ( x ) \log q ( x )$<br>只要把p作为正确结果(如[0，0，0，1，0，0])，把q作为预测结果(如[0.1，0.1，0.4，0.1，0.2，0.1])，就可以得到两个概率分布的交叉熵了，<strong>交叉熵值越低，表示两个概率分布越靠近</strong>。</p><p><strong>交叉熵计算实例：</strong><br>假设有一个三分类问题，某个样例的正确答案是(1，0，0)，某个模型经过softmax回归之后的预测答案是(0.5，0.4，0.1)，那么他们的交叉熵为：<br><img src="http://files.shanqianche.cn/2021718/1626619013263.png" alt="enter description here"><br>如果另一个模型的预测概率分布为(0.8，0.1，0.1)，则这个预测与真实的交叉熵为：<br><img src="http://files.shanqianche.cn/2021718/1626619026409.png" alt="enter description here"><br>由于0.1小于0.3，所以第二个预测结果要由于第一个。</p><h2 id="使用交叉熵的背景"><a href="#使用交叉熵的背景" class="headerlink" title="使用交叉熵的背景"></a>使用交叉熵的背景</h2><p>通过神经网络解决分类问题时，一般会设置k个输出点，k代表类别的个数，如下图<br><img src="http://files.shanqianche.cn/2021718/1626619104894.png" alt="enter description here"><br>每个输出结点，都会输出该结点对应类别的得分，如[cat，dog，car，pedestrian] 为[44，10，22，5]</p><p>但是输出结点输出的是得分，而不是概率分布，那么就没有办法用交叉熵来衡量预测结果和真确结果了，那怎么办呢，**<font color="#FF00FF">解决方法是在输出结果后接一层 softmax，softmax的作用就是把输出得分换算为概率分布</font>**。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于注意力机制的神经网络业务过程预测分析</title>
      <link href="/2021/07/17/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
      <url>/2021/07/17/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>提出了一种具有注意力机制的神经网络，它是使用公开的事件日志（如BPI Challenge 2013）进行训练。<br>同时使用n-gram模型对比结果和LSTM（长-短期记忆结构的神经网络）对比训练时间。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>提到使用以前较小的数据进行与之前的研究进行对比，同时也使用到了较大过程的日志进行评估。<br>本文的亮点，作者首次提出结合基于自我关注的transformer模型【NLP中常用】进行流程预测。</p><blockquote><p>Transformer：<br><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/171875438">李宏毅-Attention，Self-Attention，Transformer - 知乎</a><br>Attention is All You Need<br><a href="https://finance.sina.com.cn/tech/2021-01-26/doc-ikftpnny1935086.shtml">堪比当年的LSTM，Transformer引燃机器学习圈：它是万能的|LSTM|机器学习_新浪科技_新浪网</a></p></blockquote><blockquote><p>残差网络<br>残差网络是为了解决深度神经网络（DNN）隐藏层过多时的网络退化问题而提出。退化（degradation）问题是指：当网络隐藏层变多时，网络的准确度达到饱和然后急剧退化，而且这个退化不是由于过拟合引起的。<br><a href="https://www.jiqizhixin.com/graph/technologies/738e788b-0e3b-4a8f-bd04-e407c7137694">深度残差网络 | 机器之心</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><p>Attention</p></li><li><p>self-attention</p></li></ol><p><a href="https://blog.csdn.net/At_a_lost/article/details/108469516">Attention机制与Self-Attention机制的区别_At_a_lost的博客-CSDN博客_attention和self attention的区别</a></p><ol start="2"><li><p>Transformer<br>Transformer模型并没有捕捉顺序序列的能力，也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，Transformer只是一个功能更强大的词袋模型而已。<br>为了解决这个问题，论文中在编码词向量时引入了位置编码（Position Embedding）的特征。—自己设计编码规则</p></li><li><p>前馈神经网络也经常称为多层感知器（Multi-Layer Perceptron，MLP）</p></li></ol><h3 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h3><p><strong><font color="#FF8C00">简述日志结构</font></strong></p><p><img src="http://files.shanqianche.cn/2021717/1626528110183.png" alt="流程结构--UML"></p><p>一个事件日志由多个案例组成，但一个案例总是分配给一个事件日志。案件与事件的关系也是如此；事件的典型属性是<strong>活动、持续时间、优先级或成本</strong>。</p><p>事件日志与事件案例：一对多<br>事件案例与事件：一对多</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p><strong>这块需要提前学习Transformer</strong></p><ol><li>通常，序列中的每个位置可以关注序列中的任何其他位置。作者提到为了不让Softmax函数计算时不考虑位置特征，将当前事件之后的位置的值设置为无穷大【忽略位置特征】</li></ol><ul><li>我的理解是位置特征无法通过分类来实现，这也是Transformer无法捕获序列顺序的原因</li></ul><ol start="2"><li>这里为了梯度的稳定，Transformer使用了score归一化，即除以 $\sqrt{d_{k}}$</li></ol><blockquote><p>**<font color="#7FFF00">知识补充</font>**：softmax<br><a href="https://zhuanlan.zhihu.com/p/105722023">一文详解Softmax函数 - 知乎</a><br>多分类、求大</p></blockquote><p><img src="http://files.shanqianche.cn/2021717/1626531018697.png" alt="Attention函数"></p><p>$W _ { i } ^ { Q } , W _ { i } ^ { K } , W _ { i } ^ { V } \in R^{d_{model}*d_{k}}$ ， $W^{O}\in R^{hd_{k}*d_{model}}$ 【 $d_{model}$ 表示嵌入的长度（可以理解为词嵌入）】</p><p><img src="http://files.shanqianche.cn/2021717/1626531384298.png" alt="self-attention函数"></p><p><img src="http://files.shanqianche.cn/2021717/1626531047214.png" alt="相当于h 个不同的self-attention的集成，全连接层"></p><p>通过学习线性变换将Q向量、K向量和V向量投影到h个不同的子空间中，在每个子空间上<strong>并行</strong>计算Attention值。结果被连接并投射到特征空间，使得模型能够联合处理来自不同位置的不同表示子空间的特征。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol><li>2016年之前主要是使用MMs（生成模型）和聚类算法（KNN或k-means）相结合；剩下的就是一些类似MMs，例如，基于贝叶斯概念的概率有限自动机（概率模型），它使用期望的极大似然估计。 数据来源2012，2013公开的BPI比赛。</li><li>2016至今，几乎都是长短期记忆结构（LSTM）然后与其它模型相结合的方法来预测，比如结合词嵌入的神经网络，使用一个热编码转换事件特征，并将其与生成的时间特征连接到单个特征向量。数据来源2012，2013公开的BPI比赛</li><li>另一种方法将事件预测视为经典的多类分类问题，并使用堆叠的自动编码器提取特征，然后使用深度前馈网络对特征进行分类。然而，这种方法只适用于简单的数据集，因为不同表示的数量随着唯一事件类的数量呈多项式增长。</li></ol><blockquote><p><font color="#FF8C00">知识补充</font> 独热编码<br><a href="https://www.cnblogs.com/zongfa/p/9305657.html">数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码 - 理想几岁 - 博客园</a></p></blockquote><blockquote><p><font color="#9400D3">知识补充</font> 多项式增长<br>也就是对于变量n，5n^2+2n+1这种就叫做多项式。</p></blockquote><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><strong>本实验数据集：</strong></p><ol><li>BPI Challenge 2013</li><li>一家德国软件公司提供的额外数据集。后一个数据集的事件日志包括律师、会计师和审计员使用一种特殊软件工具进行财务核算、管理付款交易和编制年度财务报表的情况。</li></ol><p>数据集由大约2.08亿个事件组成，由会话id标识，该会话id指示它们所属的情况、事件类型和时间戳。每个用户交互（通常是点击按钮）都被视为一个事件，一个案例从应用程序启动一直持续到关闭。</p><p>难点：<br>作者通过流程挖掘，许多独特的事件类增加了预测的难度。在<strong>较小的数据集中</strong>，大多数情况下都非常短。大约四分之一的病例由五个或更少的事件组成，只有百分之一的流程长度为500或更多。<br>同时数据集中大部分数据为重复的，数据类型不均匀，最常见的五个事件类型几乎占了<strong>整个数据集</strong>的一半。</p><h2 id="建模方法"><a href="#建模方法" class="headerlink" title="建模方法"></a>建模方法</h2><p>模型是在tensorflow上实现的，使用tf.data-API作为输入管道，tf.keras-API构建我们的模型。【不懂，反正tensorflow上的组件哇】</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ol><li>整理事件类型，并用整数标记</li><li>将一个流程的所有事件放到一个张量（tensor，多维数组，能够创造更高维度的矩阵、向量。）</li><li>为每个流程添加一个结束标记，并且通过左移一个位置来生成训练标签【没懂为啥要左移生成标签，但是目的是为了生成训练标签，感觉是<strong>通过监控位置标签判断是否为训练数据集</strong>】</li><li>在上一部分中提到数据集长短不一，作者提出通过按照长度将流程分到不同区域中。这里为了确保每个区域中的流程相似，就没有设置固定的长度，而是通过制定上限来控制长度。</li></ol><p><img src="http://files.shanqianche.cn/2021717/1626535517054.png" alt="上限控制"></p><p>$l_{1}&lt;9$ </p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="http://files.shanqianche.cn/2021717/1626535685586.png" alt="a为模型，b为attention模块"></p><p>N表示Transformer的数量、 $d_{model}$ 表示嵌入长度、h表示Attention的数量， $d_{l}$ 表示Q，K，V的向量维度。<br>M表示词汇的数量，这里可以理解为事件的数量，n为单个流程的长度，bsz表示流程的数量，单次样本数量。<br>Pos.Encoding  位置编码标记</p><blockquote><p><strong><font color="#DC143C">知识补充</font></strong><br><a href="https://blog.csdn.net/program_developer/article/details/78597738">神经网络中Epoch、Iteration、Batchsize相关理解和说明_Microstrong-CSDN博客_epoch</a><br><strong>epoch</strong>：中文翻译为时期。<br>一个时期=所有训练样本的一个正向传递和一个反向传递。<br>举个例子，训练集有1000个样本，batchsize=10，那么：<br>训练完整个样本集需要：<br>100次iteration，1次epoch。</p></blockquote><blockquote><p><strong>理解辅助：</strong><br>这块主要和Transformer论文中的Shared-Weight Embeddings and Softmax这一部分一样<br>与其他序列转导模型类似，使用可学习的 Embeddings 将 input tokens and output tokens 转换为维度  的向量【序列转序列转为d（model）维度的向量】。通过线性变换和 softmax 函数将解码器的输出向量转换为预测的 token 概率。在 Transformer 模型中，两个嵌入层和 pre-softmax 线性变换之间共享相同的权重矩阵，在 Embeddings 层中，将权重乘以 . 这些都是当前主流的操作。</p></blockquote><ol><li>通过被一个正态分布初始权值的可训练查找矩阵构成的<strong>嵌入层</strong>将输入映射到一个 $d_{model}$ 维度的特征空间【①使用embedding将输入转化为 $d_{model}$ 维度的向量】，同时pre-softmax函数在transformer中使用相同的查找矩阵。</li><li>由于Transformer不对顺序有预测效果，所以将位置编码加入到嵌入向量中【与第一个方法类似结合sin，cos】</li><li>通过交叉熵和标签滑动来进行拟合结果和消除过拟合</li><li>最后作者提到注意计算结果在内部缓存并复用的问题，主要在担心内存溢出，但是实验缓冲所需的空间可忽略不计。</li></ol><blockquote><p><strong><font color="#0000FF">知识补充</font></strong><br>label smoothing(标签平滑)：正则化策略，为了防止过拟合，加入噪声<br><a href="https://zhuanlan.zhihu.com/p/116466239">label smoothing(标签平滑)学习笔记 - 知乎</a><br>交叉熵即预测值与真实值之间的差值，越少越精准。<br><a href="https://blog.zuishuailcq.xyz/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/">损失函数之交叉熵(一般用于分类问题) | 吾辈之人，自当自强不息！</a></p></blockquote><blockquote><p><strong><font color="#00CED1">知识补充：</font></strong> 模型理解<br><a href="https://zhuanlan.zhihu.com/p/60821628">碎碎念：Transformer的细枝末节 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/106867810">Transformer理论源码细节详解 - 知乎</a><br><a href="https://www.codenong.com/cs106837783/">Transformer论文详解，论文完整翻译（七） | 码农家园</a><br><a href="https://congchan.github.io/NLP-attention-03-self-attention/">Transformer &amp; Self-Attention (多头) 自注意力编码 | Fly Me to the Moon</a></p></blockquote><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><p>作者使用了前面提到的BPI2013和DATSET，每个数据集分为三个部分：培训，验证和测试。对于BPI2013的数据集，作者选的的训练、验证、测试集之间比例80%，10%，10%。DATSET则是96%，2%，2%。<br>BPI2013用了30000个训练模型，DATSET使用了一百万个，一个epoch为1000个。</p><ol><li>BPI2013</li></ol><p><img src="http://files.shanqianche.cn/2021718/1626620621539.png" alt="BPI2013结果"><br>展示了四种超参数的配置 $d_{model}$ 为嵌入长度，h为Attention数量， $d_{ff}$ 规定了点式前馈神经网络的内部第一层输出节点， 为前反馈网络中的参数。</p><p>分析，在最小超参数的配置中，当结合四层Transformer后精确度达到最高。同时随着配置的增加，训练的效果却下降了，这里可能是设置超参数过大，欠拟合。</p><p><img src="http://files.shanqianche.cn/2021718/1626622123211.png" alt="近几年比较"><br>【4】”Comprehensible predictive models for business processes” 2016<br>【11】“Predicting process behaviour using deep learning”2016<br>【13】“A multi-stage deep learning approach for business process event prediction”2017</p><p>实验表明，我们的注意力竞争方法通常适用于过程事件预测的任务，并且可以与现有技术相当执行。</p><ol start="2"><li>DATSET</li></ol><p>由于DATSET的数据集较大，这里直接使用较大的超参数，同时结合4和6层的transformer</p><p><img src="http://files.shanqianche.cn/2021718/1626622668082.png" alt="超参数"></p><p><img src="http://files.shanqianche.cn/2021718/1626622687231.png" alt="DATSET"></p><pre><code>    训练的时候将超过500的流程筛选出来，这些只占了数据集1%</code></pre><p>分析，最高为0.6218。超参数较小的模型显着更糟糕，这表明它们无法完全模拟数据的复杂性。但是没有以前的数据进行对比，作者使用LSTM基本模型使用相同的超参数【256，N=4】进行对比。</p><p><img src="http://files.shanqianche.cn/2021718/1626622951569.png" alt="LSTM VS  Model"></p><p>证明了所提出的基于关注力的模型比基于LSTM的模型更好。此外，根据LSTM训练时间是我们的两倍。 <strong>TODO</strong> <font color="#FF00FF">这显示了注意机制对于长跟踪长度的优势，它能够一次处理整个跟踪，而不是一次处理一个元素。</font></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文，作者提出了基于注意力机制的业务流程预测模型，通过数据集验证，不仅在较小的数据集上（BPI2013）可以接近现有技术的精确度，同时在预测复杂的的数据集也可以达到良好的效果，同时训练时间更少。</p><p>提到对于复杂的模型处理的新的思路，<strong>对于流程轨迹进行分割，对于重复的事件进行预处理，缩短流程提升预测精度</strong>或者是<strong>仅部分学习预测</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意力机制</title>
      <link href="/2021/07/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/07/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/105335191">注意力机制到底是什么——基于常识的基本结构介绍 - 知乎</a><br><a href="https://www.zhihu.com/question/304499365">(96 封私信 / 80 条消息) 「注意力机制」是什么意思？ - 知乎</a><br><a href="https://my.oschina.net/u/876354/blog/3061863">大话注意力机制（Attention Mechanism） - 雪饼的个人空间 - OSCHINA - 中文开源技术交流社区</a><br><a href="https://zhuanlan.zhihu.com/p/148737297">attention机制中的query,key,value的概念解释 - 知乎</a></p><h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>注意力机制(Attention Mechanism)是人们在机器学习模型中嵌入的一种特殊结构，用来自动学习和计算输入数据对输出数据的<font color="#1E90FF"><strong>贡献</strong></font>大小。</p><blockquote><p>目前，注意力机制已经成为深度学习领域，尤其是自然语言处理领域，应用最广泛的“组件”之一。这两年曝光度极高的BERT、GPT、Transformer等等模型或结构，都采用了注意力机制。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>来自于认知工程领域提出的，类似人对于信息采集的机制—特征工程。</p><h3 id="人身上的注意力机制"><a href="#人身上的注意力机制" class="headerlink" title="人身上的注意力机制"></a>人身上的注意力机制</h3><p>去超市购物，和朋友去购物，作为提东西的工具人，不仅要体力跟的上，那么我们还需要的是跟的上朋友的步伐，人山人海中要跟上步伐确实比较困难，当我们用眼睛去一个一个寻找，把路人的信息特征衣服，脸，发色，发型~都传入到脑海中一个一个比对寻找朋友的时候，这时候不仅效率极其低而且大脑表示也遭不住，那么我们只需要记到部分明显特征发型身高等，然后扩大视野，这样效率会明显提高。<br>像这种情形，**<font color="#9932CC">有选择的处理信号</font>**，包括人类很多生物在处理外界信号时的策略，这种处理机制就是注意力机制。</p><h3 id="特征工程——模型外部的注意力机制"><a href="#特征工程——模型外部的注意力机制" class="headerlink" title="特征工程——模型外部的注意力机制"></a>特征工程——模型外部的注意力机制</h3><p>严格来说，「注意力机制」更像是一种方法论。没有严格的数学定义，而是根据具体任务目标，对关注的方向和加权模型进行调整。<br>简单的理解就是，在神经网络的隐藏层，增加「注意力机制」的加权。<br>使不符合注意力模型的内容弱化或者遗忘。</p><p><img src="http://files.shanqianche.cn/2021717/1626502007361.png" alt="特征工程"></p><h3 id="“key-query-value”理论"><a href="#“key-query-value”理论" class="headerlink" title="“key-query-value”理论"></a>“key-query-value”理论</h3><p><img src="http://files.shanqianche.cn/2021717/1626502458858.png" alt="Attention机制"></p><p>将Source中的构成元素想象成是由一系列的&lt;Key,Value&gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：<br>$Attention( Q u e r y , Source ) = \sum _ { i = 1 } ^ { L _ { x } }Similarity(Query,Key_{i})*Value_{i}$</p><blockquote><p><strong><font color="#7FFF00">个人理解</font></strong><br>可以把attention机制看作一种软寻址：Source可以看作存储器内存储的内容，元素由地址Key和值Value组成，当前有个Key=Query的查询，目的是取出存储器中对应的Value值，即Attention数值。通过Query和存储器内元素Key的地址进行相似性比较来寻址，之所以说是软寻址，指的不像一般寻址只从存储内容里面找出一条内容，而是可能从每个Key地址都会取出内容，**<font color="#7FFF00">取出内容的重要性根据Query和Key的相似性来决定</font>**，之后对Value进行加权求和，这样就可以取出最终的Value值，也即Attention值。</p></blockquote><p><strong><font color="#008B8B">Attention机制的具体计算过程：</font></strong></p><p><img src="http://files.shanqianche.cn/2021717/1626508762885.png" alt="计算过程"></p><ol><li>根据Query和Key计算两者的相似性或者相关性【学习】</li><li>对第一阶段的原始分值进行归一化处理【获取权重系数】</li><li>根据权重系数对Value进行加权求和</li></ol><blockquote><p><strong><font color="#00008B">知识补充</font></strong><br>点乘又叫向量的内积、数量积，是一个向量和它在另一个向量上的投影的长度的乘积；是标量。 <strong>点乘反映着两个向量的“相似度”</strong>，两个向量越“相似”，它们的点乘越大。<br>向量叉乘求的是<strong>垂直</strong>于这两个向量<br>Cosine相似性，求余弦<br>多层感知器（Multilayer Perceptron,缩写MLP）一种通用的函数近似方法，可以被用来拟合复杂的函数，或解决分类问题</p></blockquote><p>第一阶段中根据Query和Key求相似度目前常见的方法包括：求两者的向量点积、求两者的向量 Cosine相似性或者通过再引入额外的<br>神经网络来求值如下：<br>点积：<br>$Similarity(Query,Key_{i})=Query*Key_{i}$</p><p>Cosine相似性：<br>$Similarity(Query,Key_{i})=\frac { Query<em>Key_{i} } { ||Query||</em>||Key_{i}||}$</p><p>MLP网络：<br>$Similarity(Query,Key_{i})=MLP（Query*Key_{i}$</p><p>第二阶段引入类似SoftMax的计算方式对第一阶段的相似度得分进行数值转换，一方面可以进行归一化，将原始计算分值整理成所有元素权重之和为1的概率分布；另一方面也可以通过SoftMax的内在机制更加突出重要元素的权重。<br>$a_{i}=Softmax(Sim_{i})= \frac{e^{Sim_{i}}}{ \textstyle \sum_{j=1}^{L_{x}}e^{Sim_{j}} }$</p><p>最后一阶段是加权求和求Attention数值：<br>$Attention(Query,Source)={\textstyle \sum_{i=1}^{L_{x}}a_{i}\cdot Value_{i}}$</p><h2 id="深度学习领域的注意力机制"><a href="#深度学习领域的注意力机制" class="headerlink" title="深度学习领域的注意力机制"></a>深度学习领域的注意力机制</h2><h3 id="注意力机制的思想和基本框架"><a href="#注意力机制的思想和基本框架" class="headerlink" title="注意力机制的思想和基本框架"></a>注意力机制的思想和基本框架</h3><blockquote><p>一些学者尝试让<font color="#9400D3">模型自己学习如何分配自己的注意力</font>，即为输入信号加权。<em>他们用注意力机制的直接目的，就是为输入的各个维度打分，然后按照得分对特征加权，以突出重要特征对下游模型或模块的影响。这也是注意力机制的基本思想。</em></p></blockquote><p><strong>一般会采用”key-query-value”理论来描述注意力机制的机理。</strong></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/2021/07/13/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/13/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/steven-yang/p/6481772.html">强化学习读书笔记 - 00 - 术语和数学符号 - SNYang - 博客园</a><br><a href="https://www.cnblogs.com/wacc/p/5391209.html">强化学习笔记1 - Hiroki - 博客园</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>监督学习在机器学习中取得了重大的成功，然而在<strong>顺序决策制定</strong>和<strong>控制问题</strong>中，比如无人直升机、无人汽车等，难以给出显式的监督信息，因此这类问题中<strong>监督模型无法学习</strong>。<br>强化学习就是为了解决这类问题而产生的。在强化学习框架中，学习算法被称为一个agent，假设这个agent处于一个环境中，两者之间存在交互。<font color="#9400D3">agent通过与环境交互不断增强对环境的适应力，故得名强化学习。</font></p><p><img src="http://files.shanqianche.cn/2021713/1626145210759.png" alt="强化学习"></p><p>在每个时间步 $t$ ，agent：</p><ul><li>接受状态 $s _ { t }$</li><li>接受标量回报 $r _ { t }$</li><li>执行行动 $a _ { t }$</li></ul><p>环境：</p><ul><li>接受动作 $a _ { t }$</li><li>产生状态 $s _ { t }$</li><li>产生标量回报 $r _ { t }$</li></ul><h2 id="MDP-马尔科夫决策过程"><a href="#MDP-马尔科夫决策过程" class="headerlink" title="MDP(马尔科夫决策过程)"></a>MDP(马尔科夫决策过程)</h2><p>通常我们都是从MDP（马尔科夫决策过程）来了解强化学习的。MDP问题中，我们有一个五元组： $( S , A , P , \gamma , P )$</p><ul><li>$S$ :状态集，由agent所有可能的状态组成</li><li>$A$ :动作集，由agent所有可能的行动构成</li><li>$P ( s , a , s ^ { \prime } )$ :转移概率分布，表示状态s下执行动作a后下个时刻状态的概率分布</li><li>$\gamma$ :折扣因子，0≤ $\gamma$ ≤1，表示未来回报相对于当前回报的重要程度。如果 $\gamma$ =0，表示只重视当前立即回报； $\gamma$ =1表示将未来回报视为与当前回报同等重要。【<font color="#FF8C00">这块不懂，可以看后面下围棋的栗子</font>】</li><li>$R ( s , a , s ^ { \prime } )$ :标量立即回报函数。执行动作a，导致状态s转移到s′产生的回报。可以是关于状态-动作的函数 $S \times A \rightarrow R$ ，也可以是只关于状态的函数 $S \rightarrow R$ 。记t时刻的回报为 $r _ { t }$ ，为了后续表述方便，假设我们感兴趣的问题中回报函数只取决于状态，而状态-动作函数可以很容易地推广，这里暂不涉及。</li></ul><p><strong><font color="#8B008B">注：</font></strong> 这里阐述的MDP称为discounted MDP，即<font color="#00008B">带折扣因子的MDP</font>。有些MDP也可以定义为四元组： $( S , A , P , R )$ ，这是<em>因为这类MDP中使用的值函数不考虑折扣因子</em>。</p><blockquote><p>**<font color="#9932CC">马尔可夫性质</font>*<em>：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布<font color="#006400">仅依赖于当前状态</font>；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是<font color="#1E90FF">条件独立</font>的，那么此随机过程即具有马尔可夫性质。<br>例如：</em>明天的天气（是否下大雨）仅与今天的天气（是否刮大风）有关，而与前天及以前的天气无关*。</p></blockquote><p>MDP过程具有马尔科夫性质，即给定当前状态，未来的状态与过去的状态无关。但与马尔科夫链不同的是，MDP还考虑了<strong>动作</strong>，也就是说MDP中状态的转移不仅和状态有关，还依赖于agent采取的动作。</p><p>我们可以通过下面表格了解各种马尔科夫模型的区别：</p><table><thead><tr><th></th><th>不考虑动作</th><th>考虑动作</th></tr></thead><tbody><tr><td>状态可观测</td><td>马尔科夫链（MC）</td><td>马尔科夫决策过程（MDP）</td></tr><tr><td>状态不完全可观测</td><td>隐马尔科夫模型（HMM）</td><td>不完全可观察马尔可夫决策过程（POMDP）</td></tr></tbody></table><p><strong><font color="#FF8C00">MDP的运行过程：</font></strong><br><img src="http://files.shanqianche.cn/2021713/1626158954807.png" alt="MDP"></p><p>我们从初始状态 $s _ { 0 }$ 出发，执行某个动作 $a _ { 0 }$ ，根据转移概率分布确定下一个状态 $s _ { 1 }$ ∼ $P _ { s0a0 }$ ，接着执行动作 $a _ { 1 }$ ，再根据 $P _ { s1a1 }$ 确定 $s _ { 2 }$ …。</p><p>一个discounted MDP中，我们的目标最大化一个<font color="#1E90FF">累积未来折扣回报</font>:<br>$R _ { t } = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } r _ { t + k + 1 }$</p><p>具体地，我们希望学得一个<strong>策略</strong>（policy），通过执行这个策略使上式最大化。策略一般可以表示为一个函数，它以<font color="#9932CC">状态</font>为输入，输出<font color="#9932CC">对应的动作</font>。策略函数可以是确定的 $\pi ( s ) = a$ ，也可以是不确定的  $\pi ( s , a ) = p ( a | s )$ （这时策略函数是一个<em>条件概率分布</em>，表示给定状态s下执行下一个动作a的概率）。当agent执行一个策略时，每个状态下agent都执行策略指定的动作。</p><p>强化学习通常具有<strong>延迟回报</strong>的特点，以下围棋为例，只有在最终决定胜负的那个时刻才有回报（赢棋为1，输棋为-1），而之前的时刻立即回报均为0。这种情况下， $R _ { t }$ 等于1或-1，这将导致我们很难衡量策略的优劣，因为即使赢了一盘棋，未必能说明策略中每一步都是好棋；同样输了一盘棋也未必能说明每一步都是坏棋。因此我们需要一个目标函数来刻画策略的长期效用。<br>为此，我们可以为策略定义一个<strong>值函数</strong>（value function）来综合评估某个策略的好坏。这个函数既可以是只关于状态的值函数 $V ^ { \pi } ( s )$ ，也可以状态-动作值函数 $Q ^ { \pi } ( s , a )$ 。<font color="#2F4F4F">状态值函数评估agent处于某个状态下的长期收益</font>， 动作值函数评估agent在某个状态下执行某个动作的长期收益。</p><p>本文后续都将以 <strong><font color="#FF8C00">状态值函</font></strong> 数为例，进行阐述。一般常用的有三种形式：</p><ol><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \sum _ { k = 0 } ^ { \infty } r _ { t + k + 1 } | s _ { t } = s ]$</li><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \lim _ { k \rightarrow \infty } \frac { 1 } { k } \sum _ { i = 0 } ^ { k } T _ { t + i + 1 } | s _ { t } = s ]$</li><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } r _ { t + k + 1 } | s _ { t } = s ]$</li></ol><p>其中 $E _ { \pi } [ \cdot | s _ { t } = s ]$ 表示从状态s开始，通过执行策略 $π$  得到的累积回报的期望。有些情况下，agent和环境的交互是无止境的，比如一些控制问题，这样的问题称为 <strong><font color="#9400D3">continuing task</font></strong> 。还有一种情况是我们可以把交互过程打散成一个个 **<font color="#9400D3">片段式任务</font>**（episodic task），每个片段有一个起始态和一个终止态（或称为吸收态，absorbing state），比如下棋。当每个episode结束时，我们对整个过程重启随机设置一个起始态或者从某个随机起始分布采样决定一个起始态。<br>上面三种值函数中，我们一般常用第三种形式，我把它叫做 **<font color="#9400D3">折扣值函数</font>**（discounted value function）。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> deep learning </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN（K近邻法 K Nearest Neighbors）</title>
      <link href="/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/"/>
      <url>/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/25994179">一文搞懂k近邻（k-NN）算法（一） - 知乎</a></p><p><a href="https://blog.csdn.net/qq_20412595/article/details/82013677">机器学习算法（2）之K近邻算法_不曾走远的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/pxhdky/article/details/85080980">【机器学习】K近邻法（KNN）与kd树原理详解_齐在的专栏-CSDN博客</a></p><p>TODO 序列KNN</p><h2 id="KNN概述"><a href="#KNN概述" class="headerlink" title="KNN概述"></a>KNN概述</h2><ul><li>常用有监督学习方法</li><li>常用分类方法</li><li>同时也是回归方法</li><li>是懒惰学习</li></ul><blockquote><p><font color="#ff7500">扩展学习</font><br>懒惰学习是一种训练集处理方法，其会<font color="#012C54">在收到测试样本的同时进行训练</font>，与之相对的是急切学习，其会<font color="#8A2BE2">在训练阶段开始对样本进行学习</font>处理。</p></blockquote><p><font color="#FF8C00">基本思路：</font><br>如果一个待分类样本在特征空间中的k个最相似(即特征空间中K近邻)的样本中的大多数属于某一个类别，则该样本也属于这个类别，即近朱者赤，近墨者黑。</p><h2 id="KNN算法介绍"><a href="#KNN算法介绍" class="headerlink" title="KNN算法介绍"></a>KNN算法介绍</h2><h3 id="KNN模型"><a href="#KNN模型" class="headerlink" title="KNN模型"></a>KNN模型</h3><p><strong>kNN使用的模型实际上对应于对特征空间的划分。</strong></p><p><font color="#006400">由三个及基本要素组成：</font></p><ul><li>距离度量</li><li>k值的选择</li><li>决策规划</li></ul><ol><li>距离度量</li></ol><p>KNN中使用的距离度量可以是欧式距离、曼哈顿距离、切比雪夫距离或者一般的闵可夫斯基距离。</p><blockquote><p><font color="#9932CC">知识补充</font><br>设特征空间 $X$ 是 $n$ 维实数向量空间<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>R</mi><mi>n</mi></msup></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>j</mi></msub></math>∈ $X$ ，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mo>(</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow></msubsup><mo>)</mo><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msubsup><msup><mo>)</mo><mi>T</mi></msup></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mo>(</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow></msubsup><mo>)</mo><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msubsup><msup><mo>)</mo><mi>T</mi></msup></math></p><ol><li><p>闵可夫斯基距离（Minkowski distance,<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离）<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>j</mi></msub></math>的<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离定义为：<br><img src="http://files.shanqianche.cn/202175/1625491452207.png"><br>其中，p ≥ 1 。 </p></li><li><p>曼哈顿距离（Manhattan distance）<br>当p = 1 时，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了曼哈顿距离：<br><img src="http://files.shanqianche.cn/202175/1625491491032.png"></p></li><li><p>欧式距离（Euclidean distance）<br>当p = 2时，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了欧式距离：<br><img src="http://files.shanqianche.cn/202175/1625491674920.png"></p></li><li><p>切比雪夫距离（Chebyshev distance）<br>当<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo>=</mo><mo>&#x221E;</mo><mo>,</mo><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了切比雪夫距离，它是各个坐标距离的最大值：<br><img src="http://files.shanqianche.cn/202175/1625491693716.png"></p></li></ol></blockquote><ol start="2"><li>k值选择（借鉴李航–统计学习方法）</li></ol><p>如果k值较小，则训练误差减少，只有与输入实例相似的训练实例才会对于预测结果起作用,“学习”<font color="#D2691E">近似误差会减小</font>，但泛化误差提高了，预测结果会对近邻实例点非常敏感。k值较小意味着模型变得复杂，容易发生<font color="#0000FF">过拟合</font>。</p><p>如果k值较大，可以减少泛化误差，其优点是可以<font color="#D2691E">减少学习的估计误差</font>，但训练误差会增加，这时与输入实例相差较远的训练实例也会对预测结果起作用。k值较大意味着模型变得简单，容易发生<font color="#0000FF">欠拟合</font>。</p><p>通常情况下，我们需要对 k 经过多种尝试，来决定到底使用多大的 k 来作为最终参数。k通常会在3～10直接取值，或者是k等于训练数据的<font color="#DC143C">平方根</font>。比如15个数据，可能会取k=4。<br>第二种方法，选择能使测试集达到最优的k kk，即能够使得如MAPE等衡量预测准确度的统计量达到最小；<br>第三种方法，同时训练多个函数不同参数k kk的模型，然后取所有模型的预测值的平均值作为最终的预测值。</p><p>当k = 1时，k近邻算法就是最近邻算法。k值一般<font color="#FF1493">采用交叉验证法选取最优值</font>。</p><ol start="3"><li>决策规划</li></ol><p>通常，在分类任务中使用投票法计算最终预测结果，在回归任务中使用平均法，还可基于距离远近进行加权平均或加权投票。</p><h3 id="KNN算法描述"><a href="#KNN算法描述" class="headerlink" title="KNN算法描述"></a>KNN算法描述</h3><p>下面以<font color="#008B8B">分类</font>任务为例，介绍KNN算法，回归任务与此类似，区别不大。</p><p>输入：训练数据集<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><mo>{</mo><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo><msubsup><mo>}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup></math>    ，其中，<img src="http://files.shanqianche.cn/202175/1625492364666.png"> 是实例的类别。<br>过程：</p><ul><li>根据给定的距离度量，在训练集D中找出与x最邻近的k个点，涵盖着k 个点的领域记为<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>x</mi><mo>)</mo></math>；</li><li>在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>x</mi><mo>)</mo></math>中根据分类决策规则决定x的类别y： <img src="http://files.shanqianche.cn/202175/1625492543638.png" alt="所属类别"><br>输出：测试样本x xx所属的类别y yy。</li></ul><h2 id="KNN算法实现"><a href="#KNN算法实现" class="headerlink" title="KNN算法实现"></a>KNN算法实现</h2><h3 id="KNN算法蛮力实现"><a href="#KNN算法蛮力实现" class="headerlink" title="KNN算法蛮力实现"></a>KNN算法蛮力实现</h3><p> 首先我们看看最想当然的方式。</p><pre><code> 既然我们要找到k个最近的邻居来做预测，那么我们只需要计算预测样本和所有训练集中的样本的距离，然后计算出最小的k个距离即可，接着多数表决，很容易做出预测。这个方法的确简单直接，在样本量少，样本特征少的时候有效。但是在实际运用中很多时候用不上，为什么呢？因为我们经常碰到样本的特征数有上千以上，样本量有几十万以上，如果我们这要去预测少量的测试集样本，算法的时间效率很成问题。因此，这个方法我们一般称之为蛮力实现。&lt;font color=&quot;#1E90FF&quot;&gt;比较适合于少量样本的简单模型的时候用&lt;/font&gt;。</code></pre><h3 id="KD树实现原理"><a href="#KD树实现原理" class="headerlink" title="KD树实现原理"></a>KD树实现原理</h3><pre><code>KD树算法没有一开始就尝试对测试样本分类，而是先对训练集建模，建立的模型就是KD树，建好了模型再对测试集做预测。所谓的KD树就是K个特征维度的树，注意这里的K和KNN中的K的意思不同。KNN中的K代表特征输出类别，KD树中的K代表样本特征的维数。为了防止混淆，后面我们称特征维数为n。</code></pre><p>KD树算法包括三步，第一步是建树，第二部是搜索最近邻，最后一步是预测。</p><h4 id="KD树的建立"><a href="#KD树的建立" class="headerlink" title="KD树的建立"></a>KD树的建立</h4><p>我们首先来看建树的方法。KD树建树采用的是从m个样本的n维特征中，分别计算n个特征的取值的方差，用<font color="#DC143C">方差最大</font>的第k维特征<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>k</mi></msub></math>来作为<font color="#B22222">根节点</font>。对于这个特征，我们选择特征<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>k</mi></msub></math>的取值的中位数<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>对应的样本作为划分点，对于所有第k维特征的取值小于<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>的样本，我们划入左子树，对于第k维特征的取值大于等于<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>的样本，我们划入右子树，对于左子树和右子树，我们采用和刚才同样的办法来找方差最大的特征来做<font color="#B22222">根节点，递归</font>的生成KD树。</p><p><img src="http://files.shanqianche.cn/202175/1625494718364.png" alt="构建KD树"></p><p>比如我们有二维样本6个，{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}，构建kd树的具体步骤为：</p><ol><li>找到划分的特征。6个数据点在x，y维度上的数据方差分别为6.97，5.37，所以在x轴上方差更大，用第1维特征建树。</li><li>确定划分点（7,2）。根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以划分点的数据是（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：划分点维度的直线x=7；（很显然，中位数为6 ，这里选择（5,4）或者(7,2)都是可以的。这种情况任选一个即可）</li><li>确定左子空间和右子空间。 分割超平面x=7将整个空间分为两部分：x&lt;=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}。</li><li>用同样的办法划分左子树的节点{(2,3),(5,4),(4,7)}和右子树的节点{(9,6)，(8,1)}。最终得到KD树。</li><li>后续步骤反复上面的，<font color="#8FBC8F">直到两个子区域没有实例存在时停止（这意味着最后所有训练实例都对应一个叶结点或内部结点），从而形成kd树的区域划分</font>。</li></ol><p><img src="http://files.shanqianche.cn/202175/1625495422262.png" alt="KD树"></p><p><font color="#DC143C">标准kNN算法的切分特征选择是按顺序的，后来对kd树的一个重大改进是选择方差最大的特征，方差越大，不同实例点区分越明显，更方便进行划分。</font></p><h4 id="KD树搜索最近邻"><a href="#KD树搜索最近邻" class="headerlink" title="KD树搜索最近邻"></a>KD树搜索最近邻</h4><p>当我们生成KD树以后，就可以去预测测试集里面的样本目标点了。对于一个目标点，我们<font color="#9932CC">首先在KD树里面找到包含目标点的叶子节点</font>。<font color="#0000FF">以目标点为圆心，以目标点到叶子节点样本实例的距离为半径，得到一个超球体</font>，<font color="#B22222">最近邻的点一定在这个超球体内部</font>。然后返回叶子节点的父节点，检查另一个子节点包含的超矩形体是否和超球体相交，如果相交就到这个子节点寻找是否有更加近的近邻,有的话就更新最近邻。如果不相交那就简单了，我们直接返回父节点的父节点，在另一个子树继续搜索最近邻。当回溯到根节点时，算法结束，此时保存的最近邻节点就是最终的最近邻。</p><p><img src="http://files.shanqianche.cn/202175/1625496230689.png" alt="目标点为（2，4.5）"></p><p>从上面的描述可以看出，KD树划分后可以大大减少无效的最近邻搜索，很多<font color="#8A2BE2">样本点由于所在的超矩形体和超球体不相交，根本不需要计算距离。大大节省了计算时间。</font></p><p>先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但 （4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点； 以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。</p><h3 id="球树实现原理"><a href="#球树实现原理" class="headerlink" title="球树实现原理"></a>球树实现原理</h3><p>KD树算法虽然提高了KNN搜索的效率，但是在某些时候效率并不高，比如当处理不均匀分布的数据集时,不管是近似方形，还是矩形，甚至正方形，都不是最好的使用形状，因为他们都有角。一个例子如下图：<br><img src="http://files.shanqianche.cn/202175/1625496491462.png" alt="enter description here"></p><p>　　如果黑色的实例点离目标点星点再远一点，那么虚线圆会如红线所示那样扩大，导致与左上方矩形的右下角相交，既然相 交了，那么就要检查这个左上方矩形，而实际上，最近的点离星点的距离很近，检查左上方矩形区域已是多余。于此我们看见，KD树把二维平面划分成一个一个矩形，但矩形区域的角却是个难以处理的问题。</p><p>　　为了优化超矩形体导致的搜索效率的问题，有人引入了球树，这种结构可以优化上面的这种问题。</p><p><strong><font color="#7FFF00">球树的建立</font></strong></p><p><img src="http://files.shanqianche.cn/202175/1625496601030.png" alt="球树"></p><ol><li>先构建一个超球体，这个超球体是可以包含所有样本的最小球体。</li><li>从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这样我们得到了两个子超球体，和KD树里面的左右子树对应。（PS:<font color="#B22222">这里选择两个点后，就以这两个点来聚类，所以先确定的是以这两个点为中心来计算其他点到该中心的距离。当所有点都确定自己的中心后，再重新计算一次该超球体的半径和球心</font>。）</li><li>对于这两个子超球体，递归执行步骤2，最终得到了一个球树。</li></ol><p>　　可以看出KD树和球树类似，主要区别在于球树得到的是节点样本组成的最小超球体，而KD得到的是节点样本组成的超矩形体，这个超球体要与对应的KD树的超矩形体小，这样在做最近邻搜索的时候，可以避免一些无谓的搜索。</p><h2 id="KNN优缺点"><a href="#KNN优缺点" class="headerlink" title="KNN优缺点"></a>KNN优缺点</h2><p>优点：</p><ol><li>结构简单；</li><li>无数据输入假定，准确度高，对异常点不敏感。</li><li> 训练时间复杂度比支持向量机之类的算法低，仅为O(n)</li><li> 由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合</li></ol><p>缺点：</p><ol><li>计算复杂度高、空间复杂度高；</li><li>样本不平衡时，对稀有类别预测准确度低；</li><li>使用懒惰学习，预测速度慢。</li><li>KD树，球树之类的模型建立需要大量的内存</li><li>相比决策树模型，KNN模型可解释性不强<h2 id="什么情况下选择KNN"><a href="#什么情况下选择KNN" class="headerlink" title="什么情况下选择KNN"></a>什么情况下选择KNN</h2></li></ol><p><img src="http://files.shanqianche.cn/202177/1625667539256.png" alt="choose"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://www.cnblogs.com/ybjourney/p/4702562.html">机器学习（一）——K-近邻（KNN）算法 - Yabea - 博客园</a></p><h2 id="序列KNN"><a href="#序列KNN" class="headerlink" title="序列KNN"></a>序列KNN</h2><p><a href="https://antkillerfarm.github.io/ml/2017/10/19/Machine_Learning_28.html">机器学习（二十八）——KNN, AutoML, 数据不平衡问题</a></p><p><a href="https://blog.csdn.net/qq_41196612/article/details/107265167">R语言实战——基于KNN聚类的时间序列分析预测_三只佩奇不结义的博客-CSDN博客_r语言knn回归及预测</a></p><p><a href="https://www.coder.work/article/383913">python - 如何使用 KNN/K-means 对数据帧中的时间序列进行聚类 - IT工具网</a></p><p><a href="https://github.com/iwuqing/Time-Series-Classification-based-on-KNN">iwuqing/Time-Series-Classification-based-on-KNN: 基于KNN聚类算法结合Dynamic Time Warping（动态时间调整）的时间序列分类</a></p><p><a href="https://github.com/vvanggeng/TSC-KNN">vvanggeng/TSC-KNN: 基于KNN和DTW的时间序列分类</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> deep learning </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markov Model（马尔可夫模型）</title>
      <link href="/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/"/>
      <url>/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/mantch/p/11203748.html">一次性弄懂马尔可夫模型、隐马尔可夫模型、马尔可夫网络和条件随机场！(词性标注代码实现) - mantch - 博客园</a></p><h2 id="马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别"><a href="#马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别" class="headerlink" title="马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别"></a>马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别</h2><p>共分六点说明这些概念【<font color="#DC143C">这6点是依次递进的，不要跳跃着看</font>】：</p><ol><li>将随机变量作为结点，若两个随机变量相关或者不独立，则将二者连接一条边；若给定若干随机变量，则形成一个有向图，即构成一个<strong>网络</strong>。</li><li>如果该网络是有向无环图，则这个网络称为<strong>贝叶斯网络</strong>。</li><li>如果这个图退化成线性链的方式，则得到<strong>马尔可夫模型</strong>；因为每个结点都是随机变量，将其看成各个时刻(或空间)的相关变化，以随机过程的视角，则可以看成是<strong>马尔可夫过程</strong>。</li><li>若上述网络是无向的，则是无向图模型，又称<strong>马尔可夫随机场</strong>或者<strong>马尔可夫网络</strong>。</li><li>如果在给定某些条件的前提下，研究这个马尔可夫随机场，则得到<strong>条件随机场</strong>。</li><li>如果使用条件随机场解决标注问题，并且进一步将条件随机场中的网络拓扑变成线性的，则得到<strong>线性链条件随机场</strong>。</li></ol><h2 id="马尔可夫模型"><a href="#马尔可夫模型" class="headerlink" title="马尔可夫模型"></a>马尔可夫模型</h2><h3 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p>马尔可夫过程（Markov process）是一类<font color="#00FFFF">随机</font>过程。它的原始模型是马尔可夫链。<br>该过程具有如下特性：在已知目前状态（现在）的条件下，它未来的演变（将来）<font color="#0000FF">不依赖</font>于它以往的演变 (过去 )。</p><p>每个状态的转移只依赖于之前的n个状态，这个过程被称为1个n阶的模型，其中n是影响转移状态的数目。最简单的马尔可夫过程就是一阶过程，<font color="#006400">每一个状态的转移只依赖于其之前的那一个状态</font>，这个也叫作<strong>马尔可夫性质</strong>。</p><p>假设这个模型的每个状态都只依赖于之前的状态，这个假设被称为<font color="#1E90FF">马尔科夫假设</font>，这个假设可以大大的简化这个问题。显然，这个假设可能是一个非常糟糕的假设，导致很多重要的信息都丢失了。<br><img src="http://files.shanqianche.cn/202176/1625557564343.png"></p><p>假设天气服从<strong>马尔可夫链</strong>：</p><p><img src="http://files.shanqianche.cn/202176/1625557700847.png" alt="天气"></p><p>从上面这幅图可以看出：</p><ul><li>假如今天是晴天，明天变成阴天的概率是0.1</li><li>假如今天是晴天，明天任然是晴天的概率是0.9，和上一条概率之和为1，这也符合真实生活的情况。</li></ul><p><img src="http://files.shanqianche.cn/202178/1625728052403.png" alt="表格"></p><p>由上表我们可以得到马尔可夫链的<strong>状态转移矩阵</strong>：<br><img src="http://files.shanqianche.cn/202176/1625557951076.png" alt="状态转移矩阵"></p><p>因此，一阶马尔可夫过程定义了以下三个部分：</p><ul><li>状态：晴天和阴天</li><li>初始向量：定义系统在时间为0的时候的状态的概率</li><li>状态转移矩阵：每种天气转换的概率</li></ul><p>马尔可夫模型（Markov Model）是一种<font color="#DC143C">统计模型</font>，广泛应用在语音识别，词性自动标注，音字转换，概率文法等各个自然语言处理等应用领域。经过长期发展，尤其是在语音识别中的成功应用，使它成为一种通用的统计工具。到目前为止，它一直被认为是实现快速精确的语音识别系统的最成功的方法。</p><h2 id="隐马尔可夫模型（HMM）"><a href="#隐马尔可夫模型（HMM）" class="headerlink" title="隐马尔可夫模型（HMM）"></a>隐马尔可夫模型（HMM）</h2><blockquote><p> 在某些情况下马尔科夫过程不足以描述我们希望发现的模式。回到之前那个天气的例子，一个隐居的人可能不能直观的观察到天气的情况，但是有一些海藻。民间的传说告诉我们海藻的状态在某种概率上是和天气的情况相关的。在这种情况下我们有两个状态集合，一个可以观察到的状态集合（海藻的状态）和一个隐藏的状态（天气的状况）。我们希望能找到一个算法可以根据海藻的状况和马尔科夫假设来预测天气的状况。</p></blockquote><p>而这个算法就叫做**隐马尔可夫模型(HMM)**。</p><p><img src="http://files.shanqianche.cn/202176/1625559690747.png" alt="HMM"></p><p>隐马尔可夫模型 (Hidden Markov Model) 是一种<strong>统计模型</strong>，用来描述一个含有隐含未知参数的马尔可夫过程。<strong>它是结构最简单的动态贝叶斯网，这是一种著名的有向图模型，</strong> 主要用于<font color="#FF00FF">时序</font>数据建模，在语音识别、自然语言处理等领域有广泛应用。</p><h3 id="隐马尔可夫三大问题"><a href="#隐马尔可夫三大问题" class="headerlink" title="隐马尔可夫三大问题"></a>隐马尔可夫三大问题</h3><p><font color="#9400D3">注意</font></p><ol><li>给定模型，如何有效计算产生观测序列的概率？换言之，如何评估模型与观测序列之间的<font color="#FF1493">匹配程度</font>？</li><li>给定模型和观测序列，如何找到与此观测序列最匹配的状态序列？换言之，如何根据观测序列推断出隐藏的<font color="#B22222">模型状态</font>？</li><li>给定观测序列，如何调整模型参数使得该序列出现的概率最大？换言之，如何训练模型使其能最好地<font color="#B22222">描述</font>观测数据？</li></ol><p>前两个问题是模式识别的问题：1) 根据隐马尔科夫模型得到一个可观察状态序列的概率(<strong>评价</strong>)；2) 找到一个隐藏状态的序列使得这个序列产生一个可观察状态序列的概率最大(<strong>解码</strong>)。第三个问题就是根据一个可以观察到的状态序列集产生一个隐马尔科夫模型（<strong>学习</strong>）。</p><p>对应的三大问题解法：</p><ol><li>向前算法(Forward Algorithm)、向后算法(Backward Algorithm)</li><li>维特比算法(Viterbi Algorithm)</li><li>鲍姆-韦尔奇算法(Baum-Welch Algorithm) (约等于EM算法)</li></ol><blockquote><p>小明现在有三天的假期，他为了打发时间，可以在每一天中选择三件事情来做，这三件事情分别是散步、购物、打扫卫生(<strong>对应着可观测序列</strong>)，可是在生活中我们所做的决定一般都受到天气的影响，可能晴天的时候想要去购物或者散步，可能下雨天的时候不想出门，留在家里打扫卫生。而天气(晴天、下雨天)就属于<strong>隐藏状态</strong>，用一幅概率图来表示这一马尔可夫过程：</p></blockquote><p><img src="http://files.shanqianche.cn/202176/1625563725550.png" alt="场景"></p><p>那么，我们提出三个问题，分别对应马尔可夫的<font color="#B22222">三大</font>问题：</p><ol><li>已知整个模型，我观测到连续三天做的事情是：散步，购物，收拾。那么，根据模型，计算产生这些行为的概率是多少。</li><li>同样知晓这个模型，同样是这三件事，我想猜，这三天的天气是怎么样的。</li><li>最复杂的，我只知道这三天做了这三件事儿，而其他什么信息都没有。我得建立一个模型，晴雨转换概率，第一天天气情况的概率分布，根据天气情况选择做某事的概率分布。</li></ol><h3 id="第一个问题解法"><a href="#第一个问题解法" class="headerlink" title="第一个问题解法"></a>第一个问题解法</h3><ol><li><strong>遍历算法</strong></li></ol><p>假设第一天(T=1 时刻)是晴天，想要购物，那么就把图上的对应概率相乘就能够得到了。<br>第二天(T=2 时刻)要做的事情，在第一天的概率基础上乘上第二天的概率，依次类推，最终得到这三天(T=3 时刻)所要做的事情的概率值，这就是遍历算法，简单而又粗暴。但问题是<font color="#2F4F4F">用遍历算法的复杂度会随着观测序列和隐藏状态的增加而成指数级增长。</font></p><p><font color="#B22222">复杂度为</font>：<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>T</mi><msup><mi>N</mi><mi>T</mi></msup></math></p><p><font color="#8A2BE2">理解：</font>每次计算行为发生概率都从最开始遍历计算</p><ol start="2"><li><p><strong>前向算法</strong></p><ol><li>假设第一天要购物，那么就计算出第一天购物的概率(包括晴天和雨天)；假设第一天要散步，那么也计算出来，依次枚举。</li><li>假设前两天是购物和散步，也同样计算出这一种的概率；假设前两天是散步和打扫卫生，同样计算，枚举出前两天行为的概率。</li><li>第三步就是计算出前三天行为的概率。</li></ol></li></ol><p>第二步中要求的概率可以在第一步的基础上进行，同样的，第三步也会<font color="#0000FF">依赖</font>于第二步的计算结果。那么这样做就能够<strong>节省很多计算环节，类似于动态规划</strong>。</p><p><font color="#B22222">复杂度为</font>：<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>N</mi><mn>2</mn></msup><mi>T</mi></math></p><ol start="3"><li>后向算法</li></ol><p>跟前向算法相反，我们知道总的概率肯定是1，那么B_t=1，也就是最后一个时刻的概率合为1，先计算前三天的各种可能的概率，在计算前两天、前一天的数据，<font color="#696969">跟前向算法相反</font>的计算路径。</p><h3 id="第二个问题解法"><a href="#第二个问题解法" class="headerlink" title="第二个问题解法"></a>第二个问题解法</h3><ol><li>维特比算法（Viterbi）</li></ol><blockquote><p>维特比算法是一个特殊但应用最广的<strong>动态规划算法</strong>。利用动态规划，可以解决任何一个图中的<strong>最短</strong>路径问题。而维特比算法是针对一个特殊的图—篱笆网络（Lattice）的有向图最短路径问题而提出的。它之所以重要，是因为凡是使用<font color="#057748">隐含马尔可夫模型</font>描述的问题都可以用它来解码，包括今天的数字通信、语音识别、机器翻译、拼音转汉字、分词等。</p></blockquote><p>维特比算法一般用于模式识别，通过观测数据来<font color="#FF1493">反推出隐藏状态</font>。</p><p>因为是要根据观测数据来反推，所以这里要进行一个假设，<strong>假设这三天所做的行为分别是：散步、购物、打扫卫生</strong>，那么我们要求的是这三天的天气(路径)分别是什么。</p><ol><li>初始计算第一天下雨和第一天晴天去散步的概率值：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>表示第一天下雨的概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>R</mi></msub></math>表示中间的状态(下雨)概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mi>R</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>表示下雨并且散步的概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mrow><mi>R</mi><mo>-</mo><mi>R</mi></mrow></msub></math>表示下雨天到下雨天的概率</li></ol><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>=<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>R</mi></msub><mo>*</mo><msub><mi>b</mi><mi>R</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>=0.6 * 0.1 = 0.06</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>S</mi><mo>)</mo></math>=<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>S</mi></msub><mo>*</mo><msub><mi>b</mi><mi>S</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>=0.4 * 0.6 = 0.24</p><p><font color="#006400">初始路径</font>为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3D5;</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>=Rainy<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3D5;</mi><mn>1</mn></msub><mo>(</mo><mi>S</mi><mo>)</mo></math>=Sunny</p><ol start="2"><li>计算第二天下雨和第二天晴天去购物的概率值:</li></ol><p><img src="http://files.shanqianche.cn/202177/1625641072263.png" alt="行为概率"></p><p><font color="#00FFFF">对应路径为：</font></p><p><img src="http://files.shanqianche.cn/202177/1625642052293.png" alt="对应路径"></p><ol start="3"><li>计算第三天下雨和第三天晴天去打扫卫生的概率值：</li></ol><p><img src="http://files.shanqianche.cn/202177/1625642832307.png" alt="第三天概率"></p><p><font color="#228B22">对应路径为：</font></p><p><img src="http://files.shanqianche.cn/202177/1625642928241.png" alt="行为路径"></p><ol start="4"><li><p>比较每一步中△的概率大小，选取最大值并找到对应的路径，依次类推就能找到最有可能的隐藏状态路径。</p><ol><li>第一天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mi>S</mi></math>，对应路径为Sunny，</li><li>第二天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>2</mn></msub><mi>S</mi></math>，对应路径为Sunny，</li><li>第三天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>3</mn></msub><mi>S</mi></math>，对应路径为Rainy。</li></ol></li><li><p>合起来的路径就是Sunny-&gt;Sunny-&gt;Rainy，这就是我们所求。</p></li></ol><h3 id="第三个问题解法"><a href="#第三个问题解法" class="headerlink" title="第三个问题解法"></a>第三个问题解法</h3><p>鲍姆-韦尔奇算法(Baum-Welch Algorithm) (约等于<strong>EM</strong>算法)</p><p>如果训练数据只有观测序列而没有状态序列，即{<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>O</mi><mn>1</mn></msub><mo>,</mo><msub><mi>O</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>O</mi><mi>S</mi></msub></math>}此时HMM的学习就得使用EM算法了，这是<font color="#FF1493">非监督</font>学习。</p><p>通常，如果给定数据和已经模型，那么求模型参数我们会用<font color="#8A2BE2">极大似然估计法</font>，但是<font color="#8B008B">如果变量中含有隐变量，无法用极大似然求解</font>（对数式子里面有求和，难以求出解析解），此时就可以使用EM算法。考虑HMM，观测序列 O是显变量，而状态变量I  则是隐变量，所以HMM实际上是<font color="#556B2F">含有隐变量的概率模型</font></p><p><img src="http://files.shanqianche.cn/202177/1625646003916.png" alt="HMM的概率模型 | λ为模型参数"></p><blockquote><p><font color="#00FFFF">知识补充</font><br>极大似然估计<br>利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！<br>换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“<font color="#FF8C00">模型已定，参数未知</font>”。</p></blockquote><p>可以使用EM算法来求得模型参数。</p><p>关于EM算法流程，有多个版本，但是仔细学习可以发现是大同小异的，以下使用《统计学习方法》上介绍的EM算法流程。</p><p><a href="https://blog.csdn.net/qq_37334135/article/details/86302735">HMM学习笔记（二）：监督学习方法与Baum-Welch算法_成都往右的博客-CSDN博客</a></p><h2 id="马尔可夫网络"><a href="#马尔可夫网络" class="headerlink" title="马尔可夫网络"></a>马尔可夫网络</h2><h3 id="因子图"><a href="#因子图" class="headerlink" title="因子图"></a>因子图</h3><p>WiKIpedia：将一个具有多变量的全局函数因子分解，得到几个局部函数的乘积，以此为基础得到的一个双向图叫做<font color="#00CED1">因子图</font>（Factor Graph）。</p><p>通俗来讲，所谓因子图就是对函数进行因子分解得到的一种<strong>概率图</strong>。一般内含两种节点：变量节点和函数节点。我们知道，一<font color="#FF1493">个全局函数通过因式分解能够分解为多个局部函数的乘积</font>，这些局部函数和对应的变量关系就体现在因子图上。</p><p><img src="http://files.shanqianche.cn/202177/1625649785149.png" alt="栗子"></p><p>其中fA,fB,fC,fD,fE为各函数，表示变量之间的关系，可以是条件概率也可以是其他关系。其对应的因子图为：</p><p><img src="http://files.shanqianche.cn/202177/1625659847778.png" alt="变量-函数之间因子图"></p><p><img src="http://files.shanqianche.cn/202177/1625659895044.png" alt="变量-函数之间因子图"></p><h3 id="马尔可夫网络-1"><a href="#马尔可夫网络-1" class="headerlink" title="马尔可夫网络"></a>马尔可夫网络</h3><blockquote><p>我们已经知道，<strong>有向</strong>图模型，又称作<font color="#bf242a">贝叶斯网络</font>，但在有些情况下，强制对某些结点之间的边增加方向是不合适的。<strong>使用没有方向的无向边，形成了无向图模型</strong>（Undirected Graphical Model,UGM）, 又被称为<strong>马尔可夫随机场或者马尔可夫网络</strong>（Markov Random Field, MRF or Markov network）。</p></blockquote><p><img src="http://files.shanqianche.cn/202177/1625660204643.png" alt="MRF"></p><p>设X=(X1,X2…Xn)和Y=(Y1,Y2…Ym)都是<font color="#006400">联合随机变量</font>，若随机变量Y构成一个无向图 G=(V,E)表示的马尔可夫随机场（MRF），则条件概率分布P(Y|X)称为<strong>条件随机场</strong>（Conditional Random Field, 简称CRF，后续新的博客中可能会阐述CRF）。如下图所示，便是一个线性链条件随机场的无向图模型：</p><p><img src="http://files.shanqianche.cn/202177/1625664493380.png" alt="CRF"></p><p>在概率图中，求某个变量的边缘分布是常见的问题。这问题有很多求解方法，其中之一就是<font color="#A52A2A">把贝叶斯网络或马尔可夫随机场转换成因子图，然后用sum-product算法求解</font>。换言之，基于因子图可以用<strong>sum-product 算法</strong>高效的求各个变量的边缘分布。</p><p>详细的sum-product算法过程，请查看博文：<a href="https://blog.csdn.net/v_july_v/article/details/40984699">从贝叶斯方法谈到贝叶斯网络_结构之法 算法之道-CSDN博客_贝叶斯</a></p><h2 id="条件随机场-CRF"><a href="#条件随机场-CRF" class="headerlink" title="条件随机场(CRF)"></a>条件随机场(CRF)</h2><p><strong>一个通俗的例子</strong></p><p>假设你有许多小明同学一天内不同时段的照片，从小明提裤子起床到脱裤子睡觉各个时间段都有（小明是照片控！）。现在的任务是对这些照片进行分类。比如有的照片是吃饭，那就给它打上吃饭的标签；有的照片是跑步时拍的，那就打上跑步的标签；有的照片是开会时拍的，那就打上开会的标签。问题来了，你准备怎么干？</p><p>一个简单直观的办法就是，不管这些照片之间的时间顺序，想办法训练出一个多元分类器。就是用一些打好标签的照片作为训练数据，训练出一个模型，直接根据照片的特征来分类。例如，如果照片是早上6:00拍的，且画面是黑暗的，那就给它打上睡觉的标签;如果照片上有车，那就给它打上开车的标签。</p><p>乍一看可以！但实际上，由于我们忽略了这些照片之间的时间顺序这一重要信息，我们的分类器会有缺陷的。举个例子，假如有一张小明闭着嘴的照片，怎么分类？显然难以直接判断，需要参考闭嘴之前的照片，如果之前的照片显示小明在吃饭，那这个闭嘴的照片很可能是小明在咀嚼食物准备下咽，可以给它打上吃饭的标签；如果之前的照片显示小明在唱歌，那这个闭嘴的照片很可能是小明唱歌瞬间的抓拍，可以给它打上唱歌的标签。</p><p>所以，为了让我们的分类器能够有更好的表现，<strong>在为一张照片分类时，我们必须将与它相邻的照片的标签信息考虑进来</strong>。这——就是条件随机场(CRF)大显身手的地方！这就有点类似于词性标注了，只不过把照片换成了句子而已，本质上是一样的。</p><p>如同马尔可夫随机场，条件随机场为具有<strong>无向</strong>的图模型，图中的顶点代表随机变量，顶点间的连线代表随机变量间的相依关系，在条件随机场中，随机变量Y 的分布为条件机率，给定的观察值则为随机变量 X。下图就是一个线性连条件随机场。</p><p><img src="http://files.shanqianche.cn/202177/1625665022911.png" alt="线性连条件随机场"></p><p>条件概率分布P(Y|X)称为条件随机场。</p><h2 id="EM算法、HMM、CRF的比较"><a href="#EM算法、HMM、CRF的比较" class="headerlink" title="EM算法、HMM、CRF的比较"></a>EM算法、HMM、CRF的比较</h2><ol><li><strong>EM算法</strong>是<font color="#8FBC8F">用于含有隐变量模型</font>的极大似然估计或者极大后验估计，有两步组成：E步，求期望（expectation）；M步，求极大（maxmization）。本质上EM算法还是一个迭代算法，通过不断用上一代参数对隐变量的估计来对当前变量进行计算，直到收敛。注意：EM算法是对初值敏感的，而且EM是不断求解下界的极大化逼近求解对数似然函数的极大化的算法，也就是说<font color="#B22222">EM算法不能保证找到全局最优值</font>。对于EM的导出方法也应该掌握。</li><li><strong>隐马尔可夫模型</strong>是<font color="#8FBC8F">用于标注问题的生成模型</font>。有几个参数（π，A，B）：初始状态概率向量π，状态转移矩阵A，观测概率矩阵B。称为马尔科夫模型的三要素。马尔科夫三个基本问题：<br>  <strong>概率计算问题</strong>：给定模型和观测序列，计算模型下观测序列输出的概率。–》前向后向算法<br> <strong>学习问题</strong>：已知观测序列，估计模型参数，即用极大似然估计来估计参数。–》Baum-Welch(也就是EM算法)和极大似然估计。<br> <strong>预测问题</strong>：已知模型和观测序列，求解对应的状态序列。–》近似算法（贪心算法）和维比特算法（动态规划求最优路径）</li><li><strong>条件随机场CRF</strong>，给定一组输入随机变量的条件下另一组输出随机变量的条件概率分布密度。条件随机场假设输出变量构成马尔科夫随机场，而我们平时看到的大多是线性链条随机场，也就是由输入对输出进行预测的判别模型。求解方法为<font color="#B22222">极大似然估计或正则化的极大似然估计。</font></li><li>之所以总把HMM和CRF进行比较，主要是因为CRF和HMM都利用了图的知识，但是CRF利用的是马尔可夫随机场（无向图），而HMM的基础是贝叶斯网络（有向图）。而且CRF也有概率计算问题、学习问题和预测问题。大致计算方法和HMM类似，只不过不需要EM算法进行学习问题。</li><li>HMM和CRF对比：其根本还是在于基本的理念不同，一个是生成模型，一个是判别模型，这也就导致了求解方式的不同。</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> deep learning </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于业务流程事件和结果预测的混合模型</title>
      <link href="/2021/07/05/%E7%94%A8%E4%BA%8E%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%93%E6%9E%9C%E9%A2%84%E6%B5%8B%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/07/05/%E7%94%A8%E4%BA%8E%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%93%E6%9E%9C%E9%A2%84%E6%B5%8B%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>对于多样性流程进行异常预测</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>序列k近邻法（KNN）</li><li>基于序列比对的马尔科夫模型扩展法</li></ol><p><font color="#1E90FF">思路：</font><br>利用数据的时间分类特征，利用高阶马尔可夫模型预测过程的下一步，并利用序列对比技术预测过程的结果。通过考虑基于k个最近邻的相似过程序列的子集，增加了数据的多样性方面。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>已经证明，通过一组实验，序列k最近邻提法比原始提供更好的结果;我们的扩展马尔可夫模型优于随机猜测、马尔可夫模型和隐马尔可夫模型。</p><blockquote><p><font color="#2e4e7e">知识补充</font><br><a href="https://blog.zuishuailcq.xyz/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/">KNN（K近邻法 K Nearest Neighbors） | 吾辈之人，自当自强不息！</a><br><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="阐述"><a href="#阐述" class="headerlink" title="阐述"></a>阐述</h2><p>在进行流程预测的前，我们需要从日志中挖掘流程。通过分析数据，可以得知数据为带有<strong>时间序列</strong>的数据。1999年已经有人证明MMs适用于研究用户网上浏览行为。同时事件序列也可用于训练已经<strong>编码后续事件之间的转换概率</strong>的马尔可夫模型，<br>类似其它机器学习模型，越是高阶的模型越是拟合数据，预测结果也更加准确。</p><blockquote><p><font color="#FF1493">知识补充</font><br>在马尔可夫链的每一步，系统根据概率分布，可以从一个状态变到另一个状态,也可以保持当前状态。状态的改变叫做过渡，与不同的状态改变相关的概率叫做<strong>过渡概率</strong><br><font color="#006400">TODO </font>默认预测的提出没有仔细研究<br>当给定数据集很少时，导致无法机器学习和准确预测，所以为了解决这个问题，提出了几个为了解决特征和默认事件之间的非线性依赖关系的模型，通过补充特征默认值来补充数据，进行预测。<strong>默认预测</strong></p></blockquote><p>但是当数据多样化同时不聚集的时候，会导致高阶模型弱覆盖，对于未被覆盖的序列，就需要默认预测。但是默认预测会降低模型的准确度。<br><em>在马尔可夫模型中</em>，为了平衡覆盖与准确性，一般解决思想是合并多个不同阶的MMs的转换状态，然后在预测的时候遵循“冗余”状态。例如可选择马尔可夫模型（selective Markov model）</p><blockquote><p>TODO<br>遵循“冗余”状态的实际意义是什么？它的实际表现是什么<br>an extension of All Kth order Markov models (Deshpande &amp; Karypis, 2004)</p></blockquote><blockquote><p><font color="#2F4F4F">知识补充</font><br>个人理解<strong>弱覆盖</strong>是由于特征广而弱，无法高效学习，导致有一些特征被丢弃没有学习到。</p></blockquote><p>第二部部分讲述的是采用kNN算法来预测过程结果，即通过比对给定领域内的序列，找到最相似的序列。06年有研究者发表“预测使用电信公司的数据流失”，用欧几里德距离来计算给定序列与样本之间的距离。</p><blockquote><p>TODO 生物顺序结合没懂</p></blockquote><p>在本文中作者将KNN与生物学的序列对齐组合形成顺序kNN。</p><blockquote><p><font color="#bf242a">知识补充</font><br><strong>编辑距离</strong>是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。</p></blockquote><h3 id="creation"><a href="#creation" class="headerlink" title="creation"></a>creation</h3><blockquote><p>TODO 不理解下面的匹配机制</p></blockquote><p>首先是为了解决高阶MMs弱覆盖，提出了MMs和序列对准融合的技术。当预测模型无法找到预测实例对应的序列时，<strong>应用匹配过程</strong>以便从与给定序列中最相似的转换矩阵中提取那些序列（图案）。</p><p>其次是提出一种预测结果的序列kNN方法，即通过比对序列局部结果，然后比对相似程度，获得预测结果</p><h2 id="序列比对"><a href="#序列比对" class="headerlink" title="序列比对"></a>序列比对</h2><p><font color="#FF1493">为了确定序列相似性</font><br>序列比对主要类似于生物学中的新的DNA序列与DNA数据库进行比较。将DNA序列的事务与蛋白质数据库进行比较，以验证它们之间的关系是否可能发生在发生概率之间。</p><blockquote><p>序列比对<br>包括全局比对和局部比对<br>全局比对是提供了全局优化解决方案，遍历所有查询序列的整个长度。<br>局部比对旨在从两个查询序列中找到最相似的段</p></blockquote><p>我们在MMs中并不是使用当前的序列比对算法，而是使用序列比对的思想；同时作者提出<strong>局部序列比对与kNNs的结合</strong>使用方法：【替换矩阵】</p><blockquote><p><font color="#006400">知识补充</font><br>在序列比对算法中的<strong>替换矩阵</strong>又称为打分矩阵，其数学本质是统计权重。<br><a href="https://zhuanlan.zhihu.com/p/150582377">替换矩阵（计分矩阵）| 原理和作用 - 知乎</a><br>在序列比对中，我们一般需要给出一个定量的数值来描述两者的一致性和相似性。在此过程中，替换矩阵用来评价碱基或残基之间的相似性，在长期实践中，人们发现一些特定的碱基替换或者残基替换的频率是要高于另一些替换的，因此人们可以通过统计方法或者基于进化的突变模型来给每一种替换定义不同的分值，来体现出不同碱基或残基之间发生替换的可能性。其可以分成核酸序列替换矩阵和蛋白质序列替换矩阵。</p></blockquote><p> <strong><font color="#9932CC">替换矩阵：</font></strong><br> <em>生物学中用于描述单位时间内，一个氨基酸转换为另一个氨基酸的速率</em>。本文中替换矩阵作为单位矩阵，主对角线的元素是1，其他元素都是0。为了呈现突变，使用了更复杂形式的替代矩阵。上边<font color="#1E90FF">知识补充</font>中提到不同的矩阵不同值可以更好表现序列单元之间转换的可能性与频率。<font color="#FF00FF">我的理解是序列对比的权重表</font>。</p><p> <strong><font color="#9932CC">打分矩阵</font></strong><br> 即模型打分矩阵函数：</p><p> <img src="http://files.shanqianche.cn/2021710/1625901529848.png" alt="初始化"></p><p> <img src="http://files.shanqianche.cn/2021710/1625901755301.png" alt="计算公式"><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>j</mi></msub><mo>)</mo></math>是替换矩阵中Xi与Yj的替换分数。<br><font color="#483D8B">TODO</font> 公式中有个别参数读不懂</p><p><img src="http://files.shanqianche.cn/2021710/1625902300497.png" alt="栗子"></p><p><strong><font color="#FF8C00">案例：</font></strong><br>序列ABCDE与序列EBCAD对应的打分矩阵，根据分数高低来寻找最佳片段，然后沿着对角线从最高点到左上角，直至分数为0，来确定匹配序列，如图栗子中为BC。</p><h2 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h2><p><strong><font color="#9932CC">前提：</font></strong><br>本模型目的是在流程实例中预测<math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>s</mi><mrow><mi>i</mi></mrow><mrow><mo>(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>下一事件<math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>。其中<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></math>业务流程中的事件的预测是基于<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>=</mo><mo>{</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub><mo>&#x22EF;</mo><msub><mi>S</mi><mi>N</mi></msub><mo>}</mo></math></p><p>其中一个业务流程实例（Sj）是按时间顺序排列的离散事件(或任务)的组合Sj=<img src="http://files.shanqianche.cn/2021710/1625906179169.png" alt="enter description here">，而单个事件是来自于事件类型的有限集合<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi><mo>=</mo><mo>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>e</mi><mi>L</mi></msub><mo>}</mo></math></p><p><img src="http://files.shanqianche.cn/2021710/1625907751234.png" alt="predict model"></p><h3 id="MMs"><a href="#MMs" class="headerlink" title="MMs"></a>MMs</h3><p><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p><p>同时文中为了保障预测模型准确性，提出构建 <strong><font color="#006400">动态MMs</font></strong> ，通过存储单个事件在数据集中的次数、紧跟事件发生的下一个事件在数据集中的次数（事件A的下一个事件为B，这里指B的次数）和转换矩阵。还可以通过将折扣因子与事件数量结合，这样就可以在加入新数据时更新折扣因子来提供更多权重。</p><blockquote><p><strong><font color="#9400D3">知识补充</font></strong> 折扣因子<br><a href="https://www.zhihu.com/question/61389929">(95 封私信 / 79 条消息) 马尔可夫决策过程中为什么需要discount factor ，也就是问为啥时间近的状态影响越大？ - 知乎</a><br><a href="https://www.jianshu.com/p/678f57342d0b">#David Silver Reinforcement Learning # 笔记2-MDP - 简书</a><br><a href="https://www.cnblogs.com/wacc/p/5391209.html">强化学习笔记1 - Hiroki - 博客园</a></p></blockquote><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><p><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><blockquote><p>主要是平衡准确性和覆盖</p></blockquote><p>结合高阶MMs与序列比对技术（Waterman 1994），以保持高阶马尔可夫模型的高精度，同时弥补缺乏覆盖面积【个人感觉是通过通过增加区别序列对比消除过拟合】，提出了MSA（Markov sequence alignment 马尔可夫序列比对）【一种基于相似序列可能产生相同结果的假设，<font color="#E9967A">指处理没有遇到过的新的序列，然后在转换矩阵中找最类似的</font>】</p><p>通过构建矩阵比较两个序列的重量，最小则最为接近。<br>规则：<br>节点事件相同，则重量为0<br>如果事件不同则为1或者 $δ$</p><p><img src="http://files.shanqianche.cn/2021713/1626182437859.png" alt="栗子"></p><ol><li>从两个序列中删除的第一事件A和E导致重量为1</li><li>两个序列中的第二个事件是B并且具有重量0</li><li>第四个事件A从EBCAD中删除，以便将两个D事件匹配在两个序列中的第四和第五位置，重量加 $δ$</li><li>最后，我们从ABCDE序列中删除最后一个事件E，增加重量 $δ$</li><li>匹配两个序列的总重量是 $w = 1 + 0 + 0 + δ + δ = 1 + 2δ$</li></ol><p><font color="#8B0000">以下示例将说明我们的方法</font>，通过一个三阶MMs的转换矩阵和序列BCC。此序列尚未发生在矩阵之前并未存储在矩阵中。<font color="#FF8C00">目的是从矩阵找到最相似的序列，并使用它们的预测来为给定序列BCC生成预测。</font></p><p><img src="http://files.shanqianche.cn/2021713/1626183826410.png" alt="替换矩阵"></p><ol><li>我们首先将BCC与ABC相匹配</li></ol><p><img src="http://files.shanqianche.cn/2021713/1626183855711.png" alt="BCC to ABC"></p><p>weight： $w=δ+0+δ=2δ$</p><ol start="2"><li>类似地，匹配CBC和BCC的得到的重量</li></ol><p>weight: $w=2δ$</p><ol start="3"><li>BAA和BCC</li></ol><p>weight: $w=2$</p><p>这一块理解的是当无法通过删除操作达到序列匹配的时候则加重为1，否则通过删除和插入惩罚达 $δ$ 到序列匹配，文中提到的是0.4。<br>通过比重，ABC与CBC一样小，所以<font color="#9400D3">ABC与CBC都和BCC最相似</font>，但是它们的预测载体分别是（0.1,0.2,0.7）和（0.1,0.5,0.4），基于这些向量，就是预测{B，C}的下一步。<br>这两个事件的发生的权重和频率是相等的;因此，由于两个序列中较高的转换概率分别是 $m _ { 13 }=0.7$ 和  $m _ { 22 }=0.5$ ，因此给定的序列预测的下一步是具有更高的转移概率C。</p><p><img src="http://files.shanqianche.cn/2021713/1626185939137.png" alt="算法一"></p><ol><li>比对序列，识别通过删除/插入符号匹配两个序列的最佳编辑过程</li></ol><p><img src="http://files.shanqianche.cn/2021713/1626185957405.png" alt="算法二"><br>2. 计算匹配两个序列的分数</p><p><font color="#D2691E">算法1和2说明了通过删除和插入惩罚来匹配两个序列的过程</font></p><h3 id="KNN结合序列比对"><a href="#KNN结合序列比对" class="headerlink" title="KNN结合序列比对"></a>KNN结合序列比对</h3><p>KNN基本上是一种非参数方法;因此，其中一个优点是不需要训练模型。序列KNN的核心思想是**<font color="#FF1493">找到类似的序列</font>** ，期望这些序列具有共同的行为和结果。<br>业务流程的比对需要加入时间特征，这里采用生物学的序列对准技术结合KNN，通过与序列对准组合，kNN允许我们顺序地比较符号序列，提出了K最近序列比对（KnsSA）。</p><p>首先根据给的N个序列，构建了距离矩阵 $( d _ { i j } ) N * N$ ，然后使用距离矩阵的元素对序列进行排序。通过使用局部对齐匹配每对序列来获得距离矩阵的元素</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h3 id="过程分析和数据预处理"><a href="#过程分析和数据预处理" class="headerlink" title="过程分析和数据预处理"></a>过程分析和数据预处理</h3><pre><code>确定了MSA（Markov sequence alignment 马尔可夫序列比对）和KnsSA（KNN序列比对）</code></pre><blockquote><p><font color="#00CED1">非对应知识补充</font>：MSA<br><a href="https://blog.csdn.net/weixin_39569389/article/details/111647915">序列两两比对算法_多重序列比对(MSA)分析工具怎么选，看这一篇就够了_weixin_39569389的博客-CSDN博客</a><br><a href="https://www.jianshu.com/p/31fb919f1c91">【陪你学·生信】九、多序列比对-Multiple Sequence Alignment（MSA） - 简书</a></p></blockquote><blockquote><p><font color="#B8860B">非对应知识补充</font>：MSA<br><a href="https://zhuanlan.zhihu.com/p/92254686">替代梯度下降——基于极大值原理的深度学习训练算法 - 知乎</a><br>MSA可以替代梯度下降函数<br>优一：MSA的每次迭代的收敛速度确实比梯度下降方法快一些<br>优二：梯度下降法的一大问题就是如果参数初始化得不好，那么就有可能会遇到一些局部平坦的区域，导致收敛速度变慢，而MSA方法则不会受到这个问题的影响<br>缺点：每轮迭代的时间会比梯度下降慢得多，这是可以理解的，毕竟MSA的每轮迭代都需要去找到一个最大值，而梯度下降只需要计算一次梯度就行了。这就导致了<strong>虽然MSA每次迭代收敛地更快，但是从时间上来看却反而更慢了</strong><br><img src="http://files.shanqianche.cn/2021714/1626226968387.png" alt="总结"></p></blockquote><p>第一个数据集（DS1）由电信线路故障修复记录为9个月。第二（DS2）涵盖1个月的时间，并表示固定宽带断层的过程。第三数据集DS3来自不同的故障修复过程。数据集DS1和DS2用于我们扩展马尔可夫模型的实验中。数据集DS3和DS4用于KNSSA实验。</p><p>数据复杂且长短不一。【文中没有提到整理数据方式，只是进行可视化】</p><p><img src="http://files.shanqianche.cn/2021713/1626187757351.png" alt="通过工具Aperture挖掘10%的DS1的数据形成的可视化"></p><h3 id="扩展马尔可夫模型实验"><a href="#扩展马尔可夫模型实验" class="headerlink" title="扩展马尔可夫模型实验"></a>扩展马尔可夫模型实验</h3><blockquote><p>扩展马尔可夫模型实验</p></blockquote><ol><li>RM - 随机模型</li></ol><p>为了找到当前之后的下一个任务，我们随机从潜在的下一个任务中选择。例如，从历史数据得知事件a来自于序列A属于集合{C，D，E}的任务，我们随机选择从该设置的值作为预测的下一步。【不通，反正就是一个baseline，在有限的范围内进行下一步】</p><ol start="2"><li>高阶MMs</li></ol><p>从一阶到kth阶生成许多不同的秩马尔可夫模型。给定序列，我们从最高阶MMs开始。如果在转换矩阵中找不到给定序列，我们通过删除序列中的第一个事件来创建新的较短序列。然后，我们将使用下一个下阶MMs继续过程，直到我们在转换矩阵中找到一个匹配项，或者在尝试第一阶Markov模型之后，需要默认预测。【只通过降阶来预测 <strong><font color="#FF8C00">所有</font></strong> 序列】</p><ol start="3"><li>HMM</li></ol><p>我们测试了几个具有不同长度的多个序列HMM，用于输入序列和不同数量的隐藏状态，并选择了最佳状态。</p><p>**<font color="#9932CC">结果分析对比</font>**：<br>90%用于训练，10%做预测。使用十折交叉验证预测结果</p><blockquote><p><font color="#006400">知识补充</font>交叉验证<br><a href="https://zhuanlan.zhihu.com/p/267910629">8. Sklearn — 交叉验证(Cross-Validation) - 知乎</a></p></blockquote><p>首先是构建一阶到七阶MSAs，然后通过通过MSAs选取数据集的最适合 $l$ ,其中DS1取值为5，DS2取值3。</p><blockquote><p>$l$ 表示序列选取长度</p></blockquote><p>下图一，二别说明了DS1和DS2这两个数据集的MSAa准确性。结果表明，通过引入<font color="#FF00FF">默认预测</font>改进模块，MSA优于其他可比模型，尤其是当马尔可夫模型的阶数增加时。这是因为 <strong><font color="#D2691E">序列之间比较的相关性与其长度成正比。</font></strong></p><blockquote><p>数字表示阶层<br>蓝色表示原生MMs的预测准确度，红加蓝表示加上默认预测模块改进后的预测精确度。</p></blockquote><p><img src="http://files.shanqianche.cn/2021714/1626252630431.png" alt="图一，使用数据集DS1在MMs中应用默认预测模块前后的正确预测百分比"></p><p><img src="http://files.shanqianche.cn/2021714/1626253369803.png" alt="图二，使用数据集DS2在MMs中应用默认预测模块前后的正确预测百分比"></p><p><font color="#9932CC">分析：</font><br>二阶MSAs在一系列不同阶MSAs中表现最好，就DS1而言，正确预测27%；三阶MSAs在DS2中表现最好，可以达到70%的准确率。同时可以分析得到在五阶MSAs预测时，默认预测模块的作用明显增加。</p><p><img src="http://files.shanqianche.cn/2021715/1626314785957.png" alt="四种模型预测比较，第一个为全阶MMs"></p><p>这里选择的是五阶段MSA和全五阶MMs，因为全阶段MMs在高阶时是具有优势的，这里为了验证默认预测的作用所以使用五阶。该图显示了两个数据集下所有模型的性能。可以看出，RM表现最差，DS2的成功率只有10%左右。当应用于更大的数据集DS1时，结果下降到接近2%（MSAs是其14倍）。同时可以发现选择正确的下一个任务的概率随着集合大小的增加而降低。结果突出了处理复杂数据集的难度。当数据不是太多样化(即DS2)时，MSA(五阶)获得最高数量的正确预测，结果为63%。与其他基准相比，MSA结果优于达到57%的五阶马尔可夫模型、达到60%的全Kth (K=5)马尔可夫模型和达到43%的隐马尔可夫模型。</p><h3 id="连续KNN实验"><a href="#连续KNN实验" class="headerlink" title="连续KNN实验"></a>连续KNN实验</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这块作者提出的预测流程结果，所以需要给数据做标记，用于区分输出结果是成功还是失败。但是不同数据集输出的结果判断标注不同，<font color="#FF8C00">同一个数据集中不同流程的结果判断标注也不同</font>，这就无法统一对预测结果进行判定。</p><p><font color="#9932CC">为了寻找到不同业务流程相统一的结果判断标准，这里采用的是通过设置时间阈值来衡量流程结果的成功与否。</font></p><pre><code>然而，在DS4的情况下，实际交付日期和向客户承诺的交付日期之间的差被用作确定成功和失败的标准。特别是，如果实际交付日期在约定日期之前，则该流程实例被归类为成功，否则被归类为失败。</code></pre><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><blockquote><p><font color="#7FFF00">通过另外两种baseline来评估KnsSA</font></p></blockquote><ol><li>RM – random model(随机模型)：为了找到过程的结果，我们随机生成一个介于0和1之间的数字；如果生成的数字大于0.5，则结果为成功(1)，反之亦然；如果生成的数字小于0.5，则结果为失败(0)</li><li>Original KNN： 我们选择K个最近的序列是因为它们有共同的独特任务。例如，给定两个序列A、B、D和A、A、C，第一个序列中有一个A、一个B和一个D；第二个中有两个As和一个C。每个独特的任务可以被视为一个类别。每个类别的距离计算为相应任务出现次数的差值。为了获得任意两个给定序列之间的总距离，对所有类别进行求和。例如，前面给出的两个序列由四个类别A、B、C和D组成。类别A的距离分别为dA= 1，类别B、C和D的距离分别为dB=1、dC=1和dD= 1。这两个序列的总距离为d=dA+dB+dC+dD=4【每个流程中每个事件进行求总距离】</li></ol><p>该模型是局部序列比对技术与KNN的结合模型，所以选择KNN的k值，结合实验中标签是0和1，这里作者k值选择为<font color="#FF8C00">奇</font>数；同时考虑数据集的多样性，k值应该<font color="#FF8C00">较小</font>。</p><blockquote><p>**<font color="#B8860B">知识补充</font>**： k值为什么选择奇数<br><img src="http://files.shanqianche.cn/2021715/1626333046633.png" alt="k值为什么选择奇数"></p></blockquote><p><img src="http://files.shanqianche.cn/2021715/1626333229424.png" alt="Local KnsSA模型对DS3，DS4预测结果"></p><p><img src="http://files.shanqianche.cn/2021715/1626333425840.png" alt="Local KnsSA，KNN，RM对于数据集预测结果"></p><p><strong>结果表明</strong>，该模型优于原始KNN和随机猜测的基准模型。这也意味着数据的时间特性对于预测过程结果很重要。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文的设计构思，首先通过MMs和HMM生成数据集的替换矩阵，然后作者提出一种序列比对的马尔可夫扩展模型（MSAs）。为了验证该模型的有效性，与MMs和HMMs进行对比，发现其准确率由于其它至少10%。<br>同时表明了高阶马尔可夫模型预测准确率高于一阶【图五】。从五阶以后加入缺省默认预测模块后可以大幅度提高预测准确度。<br>第二个贡献是提出新的序列比对KNN（KnsSA）。该方法优于基准模型，证明了数据的序列特征在预测过程结果中的重要作用。相将相似序列进行分类，然后进行下一步处理。</p><h2 id="下一步构思"><a href="#下一步构思" class="headerlink" title="下一步构思"></a>下一步构思</h2><p>未来的研究将着眼于使用序列比对和K均值聚类将数据聚类成K个组，然后用合适的方法处理每个组</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> machine learning </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习与循环神经网络在预测下一个过程事件问题上的初步应用</title>
      <link href="/2021/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9C%A8%E9%A2%84%E6%B5%8B%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%E4%B8%8A%E7%9A%84%E5%88%9D%E6%AD%A5%E5%BA%94%E7%94%A8/"/>
      <url>/2021/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9C%A8%E9%A2%84%E6%B5%8B%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%E4%B8%8A%E7%9A%84%E5%88%9D%E6%AD%A5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><font color="#DC143C">TITLE</font>: A Deep Learning Approach for Predicting Process Behaviour at Runtime</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>描述深度学习与循环神经网络在预测下一个过程事件问题上的初步应用</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要介绍了流程预测与自然语言的处理有很多地方类似，同时也有不同之处。</p><p><font color="#FF1493">流程预测与自然语言不同：</font></p><ul><li>过程预测（事件类型数量）中词汇量的大小远小于自然语言词汇的大小</li><li>轨迹的长度远远超过自然语言中的典型句子长度</li><li>通过内部过程逻辑确定或约束过程事件序列，通常通过基于案例数据确定的决策规则确定。然而，以语法和形态规则的形式，自然语言也受到限制</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p><strong><font color="#B22222">这块主要讲了一下业务流程预测相关的研究</font></strong></p><h3 id="预测完成一个案件的剩余时间"><a href="#预测完成一个案件的剩余时间" class="headerlink" title="预测完成一个案件的剩余时间"></a>预测完成一个案件的剩余时间</h3><ol><li>使用事件频率、事件时间和案例数据的增强回归</li></ol><p><img src="http://files.shanqianche.cn/2021626/1624673781121.png" alt="When will this case finally be finished?"><br>2. 将隐马尔可夫模型应用于事件序列和执行时间[基于一个带注释的转换系统]</p><p><img src="http://files.shanqianche.cn/2021626/1624674466379.png" alt="A test-bed for the evaluation of bussiness process prediction techniques"><br>3. 使用聚类树和有限状态机(FSM)来预测运行过程案例的剩余时间</p><p><img src="http://files.shanqianche.cn/2021626/1624674870904.png" alt="Context-aware predictions on bussiness processes: An ensemble-based solution"></p><p><img src="http://files.shanqianche.cn/2021626/1624674967541.png" alt="Discovering context-aware models for predicting business process performances"><br>4. 将复杂的事件处理（CEP）应用于事件序列，并培训以预测其未来行为</p><p><img src="http://files.shanqianche.cn/2021626/1624675079138.png" alt="Facilitating predictive event-driven process analytics"><br>5. 使用随机petri网模拟</p><p><img src="http://files.shanqianche.cn/2021626/1624675153578.png" alt="Prediction of remaining service execution time using stochastic petri nets with arbitrary firing delays"></p><p><img src="http://files.shanqianche.cn/2021626/1624675288618.png" alt="Prediction of bussiness process durations using non-markovian stochastic petri nets"><br>6. 基于案例数据聚类和回归的预测技术</p><p><img src="http://files.shanqianche.cn/2021626/1624675498447.png" alt="A data-driven prediction framework for analyzing and monitoring business process performances"><br>7. 对部分和全部案例采用聚类方法</p><p><img src="http://files.shanqianche.cn/2021626/1624675713998.png" alt="Process remaining time prediction using query catalogs"><br>8. 提出了两种基于带注释的转换系统的方法，以及支持向量回归和朴素贝叶斯分类器</p><p><img src="http://files.shanqianche.cn/2021626/1624675768877.png" alt="Data-aware remaining time prediction of business process instances"></p><p><img src="http://files.shanqianche.cn/2021626/1624675838918.png" alt="Time and activity sequence prediction of business process instances"></p><h3 id="流程预测结果评估【二元评估】"><a href="#流程预测结果评估【二元评估】" class="headerlink" title="流程预测结果评估【二元评估】"></a>流程预测结果评估【二元评估】</h3><ol><li>在时间、资源和案例数据上使用决策树</li></ol><p><img src="http://files.shanqianche.cn/2021626/1624676985594.png" alt="Predictive business operations management"></p><p><img src="http://files.shanqianche.cn/2021626/1624677076066.png" alt="Business process intelligence"></p><p><img src="http://files.shanqianche.cn/2021626/1624677129344.png" alt="Improving bussiness "><br>2. 使用支持向量机</p><p><img src="http://files.shanqianche.cn/2021626/1624686889124.png" alt="Periodic berformance prediction for real-time business process monitoring"><br>3. 基于聚类和局部离群点检测</p><p><img src="http://files.shanqianche.cn/2021626/1624687171172.png" alt="Real-time business process monitoring method for prediction of abnormal termination using knni-based LOF prediction"><br>4. 使用决策树来预测违反线性时序逻辑限制</p><p><img src="http://files.shanqianche.cn/2021626/1624687372135.png" alt="Predictive monitoring of business processes"><br><img src="http://files.shanqianche.cn/2021626/1624687442053.png" alt="Predictive monitoring of business processes"><br>5. 使用随机森林</p><p><img src="http://files.shanqianche.cn/2021626/1624687491226.png" alt="Complex symbolic sequence encodings for predictive monitoring of business processes"><br>6. 采用神经网络、约束满足和服务质量聚合</p><p><img src="http://files.shanqianche.cn/2021626/1624687569443.png" alt="Comparing and combining predictive business process monitoring techniques"><br>7. 聚类和回归</p><p><img src="http://files.shanqianche.cn/2021626/1624687617567.png" alt="A prediction framework for proactive monitoring aggregate process-performance indicators"></p><h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><h2 id="Process-Prediction-using-RNN"><a href="#Process-Prediction-using-RNN" class="headerlink" title="Process Prediction using RNN"></a>Process Prediction using RNN</h2><h2 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><h3 id="阅读paper36【P10】"><a href="#阅读paper36【P10】" class="headerlink" title="阅读paper36【P10】"></a>阅读paper36【P10】</h3><p><img src="http://files.shanqianche.cn/2021627/1624759564094.png" alt="paper36"></p><h3 id="递归神经网络与循环神经网络"><a href="#递归神经网络与循环神经网络" class="headerlink" title="递归神经网络与循环神经网络"></a>递归神经网络与循环神经网络</h3><p><font color="#0000FF">Recursive Neural Network || Recurrent Neural Network</font></p><h3 id="Hidden-Markov-Models-HHM"><a href="#Hidden-Markov-Models-HHM" class="headerlink" title="Hidden Markov Models(HHM)"></a>Hidden Markov Models(HHM)</h3><h3 id="LSTM与RNN"><a href="#LSTM与RNN" class="headerlink" title="LSTM与RNN"></a>LSTM与RNN</h3>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> machine learning </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤立森林（Isolation Forest）</title>
      <link href="/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/"/>
      <url>/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><img src="http://files.shanqianche.cn/2021531/1622426214147.png" alt="数据蛋糕"></p><p>假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。</p><p>之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。</p><blockquote><p><font color="#8B008B">满足的条件</font></p><ul><li>数据本身不可再分割</li><li>二叉树达到限定的最大深度</li></ul></blockquote><p>直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间里了。</p><p><font color="#6495ED">异常检测原理的理解：</font>由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>孤立森林算法主要针对的是<strong>连续型结构化</strong>数据中的异常点。</p><p><font color="#FF1493">理论前提</font></p><ul><li>异常数据占总样本量的比例很小</li><li>异常点的特征值与正常点的差异很大</li></ul><p><img src="http://files.shanqianche.cn/2021531/1622426925434.png" alt="数据"></p><p>上图中，中心的白色空心点为正常点，即处于高密度群体中。四周的黑色实心点为异常点，散落在高密度区域以外的空间。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>孤立森林算法是基于 <strong>Ensemble</strong> 的异常检测方法，因此具有<font color="#7FFF00">线性的时间复杂度</font>。且精准度较高，在处理大数据时速度快，所以目前在工业界的应用范围比较广。常见的场景包括：网络安全中的攻击检测、金融交易欺诈检测、疾病侦测、噪声数据过滤（数据清洗）等。</p><blockquote><p><font color="#006400">知识补充</font>集成学习算法 (Ensemble Learning)<br>统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器<font color="#8FBC8F">组合</font>，从而实现一个预测效果更好的<font color="#8A2BE2">集成分类器</font>。</p></blockquote><blockquote><p><font color="#FF00FF">知识补充：</font><br><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">算法的性能指标 | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="孤立森林的创新点"><a href="#孤立森林的创新点" class="headerlink" title="孤立森林的创新点"></a>孤立森林的创新点</h2><ol><li><font color="#D2691E">Partial models</font>：在训练过程中，每棵孤立树都是随机选取部分样本</li><li><font color="#D2691E">No distance or density measures</font>：不同于 KMeans、DBSCAN 等算法，孤立森林不需要计算有关距离、密度的指标，可大幅度提升速度，减小系统开销</li><li><font color="#D2691E"> Linear time complexity</font>：因为基于 ensemble，所以有线性时间复杂度。通常树的数量越多，算法越稳定</li><li><font color="#D2691E">Handle extremely large data size</font>：由于每棵树都是独立生成的，因此可部署在大规模分布式系统上来加速运算</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟合</title>
      <link href="/2021/05/31/%E6%8B%9F%E5%90%88/"/>
      <url>/2021/05/31/%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/72038532#:~:text=%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%88%96%E6%9C%BA%E5%99%A8,%E7%A7%B0%E4%B8%BA%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E3%80%82">欠拟合、过拟合及如何防止过拟合 - 知乎</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为泛化误差。度量泛化能力的好坏，最直观的表现就是模型的过拟合（overfitting）和欠拟合（underfitting）。过拟合和欠拟合是用于描述模型在训练过程中的两种状态。一般来说，训练过程会是如下所示的一个曲线图。</p><p><img src="http://files.shanqianche.cn/2021531/1622461280602.png" alt="训练过程"></p><p>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络过度拟合了训练集，对训练集以外的数据却不有效。</p><p><img src="http://files.shanqianche.cn/2021531/1622461630220.png" alt="拟合"></p><h2 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h2><p><font color="#9932CC">欠拟合</font>是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p><p><img src="http://files.shanqianche.cn/2021531/1622461604985.png" alt="欠拟合"></p><p><strong>如何解决欠拟合？</strong></p><p>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<font color="#7FFF00">增加网络复杂度</font>或者在模型中<font color="#7FFF00">增加特征</font>，这些都是很好解决欠拟合的方法。</p><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p><font color="#9932CC">过拟合</font>是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<font color="#ff7500">模型在训练集上表现很好，但在测试集上却表现很差。</font>模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。</p><p><img src="http://files.shanqianche.cn/2021531/1622461615228.png" alt="过拟合"></p><p><font color="#FF1493">出现原因</font></p><ol><li><strong>训练数据集样本单一，样本不足。</strong> 如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。</li><li><strong>训练数据中噪声干扰过大。</strong> 噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。</li><li><strong>模型过于复杂</strong>。模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li></ol><p><strong><font color="#FF8C00">如何防止过拟合</font></strong><br>要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。</p><blockquote><p>正则化是指修改学习算法，使其降低泛化误差而非训练误差。</p></blockquote><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><blockquote><p>常用的正则化方法根据具体的使用<font color="#D2691E">策略</font>不同可分为：<br>（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；<br>（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和Dropout；<br>（3）不直接提供约束的隐式正则化方法，如数据增强等。</p></blockquote><ol><li> 获取和使用更多的数据（数据集增强）——解决过拟合的<font color="#DC143C">根本性</font>方法</li></ol><p>让机器学习或深度学习模型泛化能力更好的办法就是使用更多的数据进行训练。但是，在实践中，我们拥有的数据量是有限的。解决这个问题的一种方法就是<font color="#7FFF00">创建“假数据”并添加到训练集中——数据集增强</font>。通过增加训练集的额外副本来增加训练集的大小，进而改进模型的泛化能力。</p><ol start="2"><li>采用合适的模型（控制模型的复杂度）</li></ol><p>过于复杂的模型会带来过拟合问题。对于模型的设计，目前公认的一个深度学习规律”deeper is better”。国内外各种大牛通过实验和竞赛发现，对于CNN来说，层数越多效果越好，但是也更容易产生过拟合，并且计算所耗费的时间也越长。</p><p>根据<font color="#E9967A">奥卡姆剃刀</font>法则：在同样能够解释已知观测现象的假设中，我们应该挑选“最简单”的那一个。对于模型的设计而言，我们应该选择简单、合适的模型解决复杂的问题。</p><ol start="3"><li>降低特征的数量</li></ol><p>对于一些特征工程而言，可以降低特征的数量——<font color="#006400">删除冗余特征</font>，人工选择保留哪些特征。这种方法也可以解决过拟合问题。</p><ol start="4"><li>L1 / L2 正则化</li></ol><p><a href="https://www.cnblogs.com/zingp/p/10375691.html#_label0">深入理解L1、L2正则化 - ZingpLiu - 博客园</a></p><ul><li>L1正则化</li></ul><p>L1正则化可以使得参数稀疏化，即得到的参数是一个稀疏矩阵，可以用于特征选择。</p><pre><code>    稀疏性，说白了就是模型的很多参数是0。通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，很多参数是0，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，即使去掉对模型也没有什么影响，此时我们就可以只</code></pre><p>在原始的损失函数后面加上一个L1正则化项，即<strong>全部权重 $w$ 的绝对值的和，再乘以λ/n</strong>。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><munder><mo>&#x2211;</mo><mi>i</mi></munder><mfenced close="|" open="|"><msub><mi>w</mi><mi>i</mi></msub></mfenced></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math></p><p>其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math> 只是简单地取 $w1$ 各个元素地正负号。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>=</mo><mfenced close="" open="{"><mtable columnalign="left"><mtr><mtd><mn>1</mn><mo>,</mo><mi>w</mi><mo>&gt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn><mo>,</mo><mi>w</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo>-</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr></mtable></mfenced></math></p><p>梯度下降时权重 $w$ 更新变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><msup><mi>w</mi><mo>‘</mo></msup><mo>=</mo><mi>w</mi><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math></p><p>当 $w=0$ 时，|w|是不可导的。所以我们仅仅能依照原始的未经正则化的方法去更新 $w$  。<br>当 $w&gt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变小。<br>当 $w&lt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变大。换句换说，L1正则化使得权重 $w$ 往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p><p>这也就是<font color="#6495ED">L1正则化会产生更稀疏（sparse）的解</font>的原因。此处稀疏性指的是最优值中的一些参数为0。<font color="#1E90FF">L1正则化的稀疏性质已经被广泛地应用于特征选择</font>机制，从可用的特征子集中选择出有意义的特征。</p><ul><li>L2 正则化</li></ul><p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合。</p><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是抗扰动能力强。</p><p>L2正则化通常被称为<strong>权重衰减</strong>（weight decay），就是在原始的损失函数后面再加上一个L2正则化项，即<strong>全部权重</strong> $w$  的平方和，再乘以λ/2n。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>&#xB7;</mo><mo>&#x2211;</mo><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mi>w</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac></math></p><p>能够发现L2正则化项对偏置 b 的更新没有影响，可是对于权重 $w$  的更新有影响：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mi>w</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfenced><mrow><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></mrow></mfenced><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math><br>这里的<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B7;</mi></math>、 $n$ 、<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3BB;</mi></math>都是大于0的， 所以 <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></math>小于1。因此在梯度下降过程中，权重 $w$ 将逐渐减小，趋向于0但不等于0。这也就是<strong>权重衰减</strong>（weight decay）的由来。</p><p>L2正则化起到使得权重参数 $w$ 变小的效果，为什么能防止过拟合呢？因为更小的权重参数  意味着模型的复杂度更低，对训练数据的拟合刚刚好，不会过分拟合训练数据，从而提高模型的泛化能力。</p><ol start="5"><li>Dropout</li></ol><p>  Dropout是在训练网络时用的一种技巧（trike），相当于在隐藏单元增加了噪声。<strong>Dropout 指的是在训练过程中每次按一定的概率（比如50%）随机地“删除”一部分隐藏单元（神经元）</strong>。所谓的“删除”不是真正意义上的删除，其实就是将该部分神经元的激活函数设为0（激活函数的输出为0），让这些神经元不计算而已。</p><p>  <img src="http://files.shanqianche.cn/2021531/1622466578527.png" alt="Dropout"></p><p><font color="#006400">  <strong>Dropout为什么有助于防止过拟合呢？</strong></font></p><p>（a）在训练过程中会产生不同的训练模型，不同的训练模型也会产生不同的的计算结果。随着训练的不断进行，计算结果会在一个范围内波动，但是均值却不会有很大变化，因此可以把最终的训练结果看作是不同模型的平均输出。<br>（b）它消除或者减弱了神经元节点间的联合，降低了网络对单个神经元的依赖，从而增强了泛化能力。</p><blockquote><p><font color="#00008B">理解</font><br>通过加入噪声，在训练模型时，扩展模型的接受范围，避免过拟合</p></blockquote><ol start="6"><li>Early stopping（提前终止）</li></ol><p>对模型进行训练的过程即是对模型的参数进行学习更新的过程，这个参数学习的过程往往会用到一些迭代方法，如梯度下降（Gradient descent）。Early stopping是一种迭代次数截断的方法来防止过拟合的方法，<font color="#7FFF00">即在模型对训练数据集迭代收敛之前停止迭代来防止过拟合</font>。</p><p>为了获得性能良好的神经网络，训练过程中可能会经过很多次epoch（遍历整个数据集的次数，一次为一个epoch）。如果epoch数量太少，网络有可能发生欠拟合；如果epoch数量太多，则有可能发生过拟合。Early stopping旨在解决epoch数量需要手动设置的问题。具体做法：每个epoch（或每N个epoch）结束后，在验证集上获取测试结果，随着epoch的增加，如果在验证集上发现测试误差上升，则停止训练，将停止之后的权重作为网络的最终参数。</p><p><font color="#E9967A">为什么能防止过拟合？</font></p><p>当还未在神经网络运行太多迭代过程的时候，w参数[误差]接近于0，因为随机初始化w值的时候，它的值是较小的随机值。当你开始迭代过程，w的值会变得越来越大。到后面时，w的值已经变得十分大了。所以early stopping要做的就是在中间点停止迭代过程。我们将会得到一个中等大小的w参数，会得到与L2正则化相似的结果，选择了w参数较小的神经网络。</p><p><font color="#A52A2A">Early Stopping缺点</font><br><strong>没有采取不同的方式来解决优化损失函数和过拟合这两个问题</strong>，而是用一种方法同时解决两个问题 ，结果就是要考虑的东西变得更复杂。之所以不能独立地处理，因为如果你停止了优化损失函数，你可能会发现损失函数的值不够小，同时你又不希望过拟合。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分类之类别不平衡</title>
      <link href="/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/"/>
      <url>/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/massquantity/p/8550875.html">机器学习之类别不平衡问题 (1) —— 各种评估指标 - massquantity - 博客园</a><br><a href="https://www.zhihu.com/question/269698662">欠采样（undersampling）和过采样（oversampling）会对模型带来怎样的影响？</a><br><a href="https://www.cnblogs.com/inchbyinch/p/12642760.html">详解类别不平衡问题 - 天地辽阔 - 博客园</a></p><h2 id="类别不平衡-class-imbalance"><a href="#类别不平衡-class-imbalance" class="headerlink" title="类别不平衡(class-imbalance)"></a>类别不平衡(class-imbalance)</h2><blockquote><p><font color="#D2691E"> 惯例</font><br>在二分类问题中，一般将数目少的类别视为正例，数目多的类别视为负例</p></blockquote><p><font color="#228B22">也叫数据倾斜，数据不平衡指分类任务中不同类别的训练样例数目差别很大的情况。</font></p><h2 id="各种评估指标"><a href="#各种评估指标" class="headerlink" title="各种评估指标"></a>各种评估指标</h2><p><a href="https://www.cnblogs.com/massquantity/p/8550875.html">机器学习之类别不平衡问题 (1) —— 各种评估指标 - massquantity - 博客园</a></p><p><img src="http://files.shanqianche.cn/202167/1623024781731.png" alt="混淆矩阵图"></p><ul><li>True Positive(真正例，TP)：实例为正例，预测为正例</li><li>False Negative (假负例，FN)：实际为正例，预测为负例。</li><li>True Negative (真负例，TN)：实际为负例，预测为负例。</li><li>False Positive (假正例，FP)：实际为负例，预测为正例。</li></ul><ol><li>Precision (查准率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> ，Precision衡量的是<font color="#7FFF00">所有被预测为正例的样本中有多少是真正例</font>。<font color="#A52A2A">但Precision并没有表现有多少正例是被错判为了负例(即FN)</font>，举个极端的例子，分类器只将一个样本判为正例，其他所有都判为负例，这种情况下Precision为100%，但其实遗漏了很多正例，所以Precision常和下面的Recall (TPR) 相结合。</li><li>True Positive Rate (TPR，真正例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math> ，又称__Recall__(查全率,召回率)，Sensitivity(灵敏性)。Recall (TPR)衡量的是所有的正例中有多少是被<font color="#008B8B">正确分类</font>了，也可以看作是为了<font color="#057748">避免假负例(FN)的发生</font>，<font color="#0000FF">即将真正例分类到真正中而不是通过假负来判断的</font>，因为TPR高意味着FN低。Recall的问题和Precision正相反，没有表现出有多少负例被错判为正例(即FP)，若将所有样本全划为正例，则Recall为100%，但这样也没多大用。</li><li>True Negative Rate (TNR，真负例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> ，又称Specificity(特异性)。Specificity衡量的是<font color="#006400">所有的负例中有多少是被正确分类</font>了，由于<font color="#1E90FF">类别不平衡问题中通常关注正例能否正确被识别，Specificity高则FP低，意味着很少将正例错判为负例，即该分类器对正例的判别具有“特异性”，在预测为正例的样本中很少有负例混入</font>。</li><li>False Positive Rate (FPR，假正例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> = 1− $TNR$ , 由混淆矩阵可以看出该指标的<font color="#D2691E">着眼点</font>在于负例，意为有多少负例被错判成了正例。在ROC曲线中分别以TPR和FPR作为纵、横轴作图，显示出一种正例与负例之间的“<font color="#9400D3">博弈</font>”，在下篇文章中详解。</li></ol><p>F1 score = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>2</mn><mrow><mfrac><mn>1</mn><mtext>&#xA0;recall&#xA0;</mtext></mfrac><mo>+</mo><mfrac><mn>1</mn><mtext>&#xA0;precision&#xA0;</mtext></mfrac></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo>&#xD7;</mo><mtext>&#xA0;precision&#xA0;</mtext><mo>&#xD7;</mo><mtext>&#xA0;recall&#xA0;</mtext></mrow><mrow><mtext>&#xA0;precision&#xA0;</mtext><mo>+</mo><mtext>&#xA0;recall&#xA0;</mtext></mrow></mfrac></math></p><p>F1分数（F1-Score），又称为平衡F分数（BalancedScore），是一个综合指标,它被定义为精确率和召回率的调和平均数 (harmonic mean),数值上一般接近于二者中的<font color="#1E90FF">较小值</font>，因此如果F1 score比较高的话，意味着Precision和Recall都较高。</p><blockquote><p><font color="#7FFF00"> 知识补充</font><br>调和平均数（harmonic mean）又称倒数平均数，是总体各统计变量倒数的算术平均数的倒数。调和平均数是平均数的一种。<br>算数平均数中，重要性取决于绝对值大的一方（强），而在调和平均数中，<font color="#057748">重要性</font>取决于<font color="#8B0000">绝对值小的一方</font>（弱）。</p></blockquote><p>FP和FN还有个还有个与之相关的概念，那就是统计假设检验中的<font color="#483D8B">第一类错误</font> (Type I error)和<font color="#483D8B">第二类错误 (Type II error)</font> 。由于我们比较关心正例，所以将负例视为零假设，正例视为备选假设，则第一类错误为错误地拒绝零假设 (负例)，选择备选假设，则为FP；第二类错误为错误地接受零假设，则为FN。</p><blockquote><p><font color="#006400">知识补充</font><br>零假设的内容一般是希望证明其错误的假设。</p></blockquote><hr><p>上面介绍的这些指标都没有考虑检索结果的先后顺序，而像搜索问题中我们通常希望第一个结果是与查询最相关的，第二个则是次相关的，以此类推，因而有时候不仅要预测准确，<font color="#6495ED">对于相关性的顺序也非常看重</font>。所以最后介绍两个广泛应用的<font color="#9400D3">排序指标</font>。</p><p>Mean Average Precision (MAP，平均准确率均值)，对于<font color="#B8860B">单个</font>信息需求，返回结果中在每篇相关文档上 Precision 的平均值被称为 Average Precision (AP)，然后对<font color="#D2691E">所有</font>查询取平均得到 MAP。<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>AP</mi><mo>=</mo><mfrac><mrow><msubsup><mo>&#x2211;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>&#xD7;</mo><mo>rel</mo><mo>(</mo><mi>k</mi><mo>)</mo></mrow><mi>M</mi></mfrac></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>MAP</mi><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mfrac><msub><mi>AP</mi><mi>q</mi></msub><mi>Q</mi></mfrac></math><br>其中 P(k) 为前 k 个结果的 Precision，又可写为P@k。 rel(k) 表示第 k 个结果是否为相关文档，相关为1不相关为0，M 表示所有相关文档的数量，n 表示所有文档数量。如果只关心<font color="#00008B">前 K 个查询的情况</font>，则是下式：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>AP</mi><mo>@</mo><mi>K</mi><mo>=</mo><mfrac><mrow><msubsup><mo>&#x2211;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><mi>P</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>&#xD7;</mo><mo>rel</mo><mo>(</mo><mi>k</mi><mo>)</mo></mrow><msub><mi>M</mi><mi>K</mi></msub></mfrac></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>MAP</mi><mo>@</mo><mi>K</mi><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mfrac><mrow><msub><mi>AP</mi><mi>q</mi></msub><mo>@</mo><mi>K</mi></mrow><mi>Q</mi></mfrac></math><br>这里的 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>M</mi><mi>K</mi></msub></math> 为前 K 个结果中相关文档的数量。</p><p>对于单个信息需求来说，Average Precision 是<font color="#bf242a"> PR 曲线</font>下面积的近似值，因此 MAP 可粗略地认为是某个查询集合对应的多条 PR 曲线下面积的平均值。</p><p><strong>Normalized Discounted Cumulative Gain</strong> (NDCG，归一化折扣累计增益) 。如果说 <font color="#0000FF">MAP 是基于 0/1 二值描述相关性</font>，那么 <font color="#9932CC">NDCG 则是可将相关性分为多个等级的指标</font>。<br>对于信息检索和推荐之类的问题，每一个返回的结果都被赋予一个相关性分数 rel，则 NDCG 中的 CG 表示前 k 个结果的分数之和，即累计增益 ：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>CG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>rel</mi><mi>i</mi></msub></math></p><p>CG 没有考虑推荐的次序，所以在此基础上引入对结果顺序的考虑，即<font color="#DC143C">相关性高的结果</font>若排在后面则会受更多的惩罚，于是就有了 DCG (discounted CG)，折扣累积增益。公式如下：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>DCG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mfrac><mrow><msup><mn>2</mn><msub><mi>rel</mi><mi>i</mi></msub></msup><mo>-</mo><mn>1</mn></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></math></p><p>i 表示一个结果在结果集中的顺序，如果该结果 rel 很高，但排在后面，意味着分母 log2(i+1) 会变大，则相应的总体 DCG 会变小 (注意这里的 log 是以 2 为底的)。</p><p>对于不同的查询，往往会返回不同的结果集，而不同结果集之间因为大小不同难以直接用 DCG 进行比较，所以需要进行<font color="#006400">归一化</font>，这其实和机器学习中不同特征因量纲不同要进行归一化差不多意思。这个归一化后的指标就是 NDCG ：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>NDCG</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>DCG</mi><mi>k</mi></msub><msub><mi>IDCG</mi><mi>k</mi></msub></mfrac></math><br>其中 IDCG 表示 Ideal DCG， 指<font color="#006400">某个查询所能返回的最好结果集</font>，IDCG 的值也是结果集中最大的。将所有结果按相关性大小排序，计算出的 DCG 即为前 k 个结果的 IDCG：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>IDCG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>|</mo><mi>R</mi><mi>E</mi><mi>L</mi><mo>|</mo></mrow></munderover><mfrac><mrow><msup><mn>2</mn><msub><mi>rel</mi><mi>i</mi></msub></msup><mo>-</mo><mn>1</mn></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></math><br>其中 |REL| 表示按相关性顺序排列的结果集。因此 DCG 的值介于 (0, IDCG] ，故 NDCG 的值介于(0,1]，这样就起到了归一化的效果。不同查询或用户的 NDCG 平均起来可以用以评估一个搜索引擎或推荐系统的整体效果。</p><p>NDCG 的缺点是<font color="#483D8B">需要预先指定每一个返回结果的相关性</font>，这个超参数需要人为指定。</p><h2 id="常用的评估方法"><a href="#常用的评估方法" class="headerlink" title="常用的评估方法"></a>常用的评估方法</h2><h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ROC曲线常用于二分类问题中的模型比较，主要表现为一种<font color="#0000FF">真正例率 (TPR) </font>和<font color="#0000FF">假正例率 (FPR) </font>的权衡。</p><p><strong><font color="#ff7500">概述：</font></strong> 是在不同的分类阈值 (threshold) 设定下分别以TPR和FPR为纵、横轴作图。由ROC曲线的两个指标，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math> 可以看出，当一个样本被分类器判为正例，若其本身是正例，则TPR增加；若其本身是负例，则FPR增加，因此ROC曲线可以看作是随着阈值的不断移动，所有样本中正例与负例之间的“对抗”。曲线越靠近左上角，意味着<font color="#FF1493">越多的正例优先于负例，模型的整体表现也就越好</font>。</p><p><img src="http://files.shanqianche.cn/202167/1623072321656.png" alt="ROC曲线"></p><p> <strong><font color="#008B8B">AUC (Area Under the Curve)</font></strong></p><p> <img src="http://files.shanqianche.cn/202167/1623073223653.png" alt="ROC space"></p><p>先看一下ROC曲线中的随机线，图中[0,0]到[1,1]的虚线即为随机线，该线上所有的点都<font color="#00FFFF">表示该阈值下TPR=FPR</font><br>根据定义，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac></math>，表示所有正例中被预测为正例的概率；<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac></math>，表示所有负例中被被预测为正例的概率。<font color="#B8860B">若二者相等，意味着无论一个样本本身是正例还是负例，分类器预测其为正例的概率是一样的，这等同于随机猜测</font>（注意这里的“随机”不是像抛硬币那样50%正面50%反面的那种随机）。</p><p>上图中B点就是一个随机点，无论是样本数量和类别如何变化，始终将75%的样本分为正例。</p><p><font color="#B8860B">ROC曲线围成的面积 (即AUC)可以解读为</font>：从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。可以看到位于随机线上方的点(如图中的A点)被认为好于随机猜测。在这样的点上TPR总大于FPR，意为正例被判为正例的概率大于负例被判为正例的概率。<br>从另一个角度看，由于画ROC曲线时都是先将所有样本按分类器的<font color="#1E90FF">预测概率</font>排序，<font color="#B22222">所以AUC反映的是分类器对样本的排序能力</font>，依照上面的例子就是A排在B前面的概率。<font color="#008B8B">AUC越大，自然排序能力越好</font>，即分类器将越多的正例排在负例之前。</p><p><font color="#8B0000">ROC曲线的绘制方法</font>：假设有P个正例，N个反例，首先拿到分类器对于每个样本预测为正例的概率，根据概率对所有样本进行<font color="#006400">逆序排列</font>，然后将<font color="#0000FF">分类阈值设为最大</font>，即把所有样本均预测为反例，此时图上的点为 (0,0)。然后将分类阈值依次设为每个样本的预测概率，即依次将每个样本划分为正例，如果该样本为真正例，则TP+1，即<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>+</mo><mfrac><mn>1</mn><mi>P</mi></mfrac></math>; 如果该样本为负例，则FP+1，即<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>+</mo><mfrac><mn>1</mn><mi>N</mi></mfrac></math>。最后的到所有样本点的TPR和FPR值，用线段相连。</p><blockquote><p><a href="https://github.com/massquantity/Class-Imbalance/tree/master/">massquantity/Class-Imbalance: 《机器学习之类别不平衡问题》文章代码</a></p></blockquote><h4 id="ROC的优点"><a href="#ROC的优点" class="headerlink" title="ROC的优点"></a>ROC的优点</h4><p><img src="http://files.shanqianche.cn/202168/1623131643148.png" alt="混淆矩阵图"></p><ol><li><p>兼顾正例和负例的权衡。因为TPR聚焦于正例，FPR聚焦于与负例，使其成为一个比较均衡的评估方法。</p></li><li><p>ROC曲线选用的两个指标，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math>，都不依赖于具体的类别分布。</p><p> 注意TPR用到的TP和FN同属<font color="#FF1493">P</font>列，FPR用到的FP和TN同属<font color="#1E90FF">N</font>列，<font color="#7FFF00">所以即使P或N的整体数量发生了改变，也不会影响到另一列</font>。也就是说，即使正例与负例的比例发生了很大变化，ROC曲线也不会产生大的变化，而像Precision使用的TP和FP就分属两列，则易受类别分布改变的影响。</p></li></ol><p><a href="https://ccrma.stanford.edu/workshops/mir2009/references/ROCintro.pdf">参考文献</a>中举了个例子，负例增加了10倍，ROC曲线没有改变，而PR曲线则变了很多。作者认为这是ROC曲线的优点，即具有<font color="#0000FF">鲁棒性</font>，在类别分布发生明显改变的情况下依然能客观地识别出较好的分类器。</p><blockquote><p><font color="#006400">代码验证</font><br><a href="https://www.cnblogs.com/massquantity/p/8592091.html">相关资料</a></p></blockquote><h4 id="ROC的缺点"><a href="#ROC的缺点" class="headerlink" title="ROC的缺点"></a>ROC的缺点</h4><ol><li>上文提到ROC曲线的优点是不会随着类别分布的改变而改变，但这在某种程度上也是其缺点。因为负例N增加了很多，而曲线却没变，这等于产生了大量FP。像信息检索中如果主要关心正例的预测准确性的话，这就不可接受了。</li><li>在类别不平衡的背景下，负例的数目众多致使FPR的增长不明显，导致ROC曲线呈现一个过分乐观的效果估计。ROC曲线的横轴采用FPR，根据<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>FPR</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math>，当负例N的数量远超正例P时，FP的大幅增长只能换来FPR的微小改变。<font color="#B22222">结果是虽然大量负例被错判成正例，在ROC曲线上却无法直观地看出来。</font>（当然也可以只分析ROC曲线左边一小段）<br>举个例子，假设一个数据集有正例20，负例10000，开始时有20个负例被错判，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mn>20</mn><mrow><mn>20</mn><mo>+</mo><mn>9980</mn></mrow></mfrac><mo>=</mo><mn>0</mn><mo>.</mo><mn>002</mn></math>，接着又有20个负例错判，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><msub><mi>R</mi><mn>2</mn></msub><mo>=</mo><mfrac><mn>40</mn><mrow><mn>40</mn><mo>+</mo><mn>9960</mn></mrow></mfrac><mo>=</mo><mn>0</mn><mo>.</mo><mn>004</mn></math>，在ROC曲线上这个变化是很细微的。而与此同时Precision则从原来的0.5下降到了0.33，在PR曲线上将会是一个大幅下降。</li></ol><h3 id="PR-Precision-Recall-曲线"><a href="#PR-Precision-Recall-曲线" class="headerlink" title="PR(Precision Recall)曲线"></a>PR(Precision Recall)曲线</h3><p>PR曲线展示的是Precision vs Recall的曲线，PR曲线与ROC曲线的相同点是都采用了TPR (Recall)，都可以用AUC来衡量分类器的效果。不同点是ROC曲线使用了FPR，而PR曲线使用了Precision，因此<font color="#8A2BE2">PR曲线的两个指标都聚焦于正例</font>。<font color="#8A2BE2">类别不平衡问题中由于主要关心正例</font>，所以在此情况下PR曲线被广泛认为<font color="#FF8C00">优于</font>ROC曲线。</p><p>PR曲线的绘制与ROC曲线类似，PR曲线的AUC面积计算公式为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><munder><mo>&#x2211;</mo><mi>n</mi></munder><mo>(</mo><msub><mi>R</mi><mi>n</mi></msub><mo>-</mo><msub><mi>R</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>)</mo><msub><mi>P</mi><mi>n</mi></msub></math></p><blockquote><p><a href="https://github.com/massquantity/Class-Imbalance/tree/master/">massquantity/Class-Imbalance: 《机器学习之类别不平衡问题》文章代码</a></p></blockquote><p><strong><font color="#FF00FF">使用场景</font></strong></p><ol><li>ROC曲线由于<font color="#1E90FF">兼顾</font>正例与负例，所以适用于评估分类器的<font color="#B22222">整体性</font>能，相比而言PR曲线完全聚焦于<font color="#FF00FF">正例</font>。</li><li>如果有多份数据且存在不同的类别分布，比如信用卡欺诈问题中每个月正例和负例的比例可能都不相同，这时候如果只想单纯地比较分类器的性能且剔除类别分布改变的影响，则ROC曲线比较适合，因为<font color="#1E90FF">类别分布改变</font>可能使得PR曲线发生变化时好时坏，这种时候难以进行模型比较；反之，如果想<font color="#FF00FF">测试不同类别分布下对分类器的性能</font>的影响，则PR曲线比较适合。</li><li>如果想要评估在相同的类别分布下正例的预测情况，则宜选PR曲线。</li><li>类别不平衡问题中，ROC曲线通常会给出一个乐观的效果估计，所以大部分时候还是PR曲线更好。</li><li>最后可以根据具体的应用，在曲线上找到最优的点，得到相对应的precision，recall，f1 score等指标，去调整模型的阈值，从而得到一个符合具体应用的模型。</li></ol><h2 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h2><blockquote><p><font color="#FF1493">前提：</font>章节二三主要谈的是类别不平衡的评估指标，因此我们可以选择选择具体的类别不平衡问题的方法。</p></blockquote><p>采样方法大致可分为<font color="#00CED1">过采样 (oversampling)</font> 和<font color="#2F4F4F">欠采样 (undersampling) </font>，虽然过采样和降采样主题思想简单，但这些年来研究出了很多变种，本篇挑一些来具体阐述。见下思维导图：</p><p><img src="http://files.shanqianche.cn/202168/1623137294136.png" alt="采样方法"></p><h3 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h3><ol><li>随机过采样</li></ol><p>随机过采样顾名思义就是从样本少的类别中随机抽样，再将抽样得来的样本添加到数据集中。然而这种方法如今已经不大使用了，因为重复采样往往会导致<font color="#1E90FF">严重的过拟合</font>，因而现在的主流过采样方法是通过某种方式人工合成一些少数类样本，从而达到类别平衡的目的，而这其中的鼻祖就是SMOTE。</p><ol start="2"><li>SMOTE</li></ol><p>SMOTE (synthetic minority oversampling technique) 的思想概括起来就是在<font color="#00FFFF">少数类</font>样本之间进行插值来产生额外的样本。具体地，对于一个少数类样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">X</mi><mi>i</mi></msub></math>使用K近邻法(k值需要提前指定)，求出离<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">X</mi><mi>i</mi></msub></math>距离最近的k个少数类样本，其中距离定义为样本之间n维特征空间的欧氏距离。然后从k个近邻点中随机选取一个，使用下列公式生成新样本：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mtext>new&#xA0;</mtext></msub><mo>=</mo><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub><mo>+</mo><mfenced><mrow><msub><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>i</mi></msub><mo>-</mo><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></mrow></mfenced><mo>&#xD7;</mo><mi>&#x3B4;</mi></math><br>其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">X</mi><mo>^</mo></mover></math> 为选出的k近邻点，δ∈[0,1]是一个随机数。下图就是一个SMOTE生成样本的例子，使用的是3-近邻，可以看出SMOTE生成的样本一般就在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>和<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>i</mi></msub></math>相连的直线上：</p><p><img src="http://files.shanqianche.cn/202169/1623220386942.png" alt="SMOTE生成的样本"></p><p>SMOTE会随机选取少数类样本用以合成新样本，而不考虑周边样本的情况，这样容易带来两个<font color="#FF1493">问题</font>：</p><ol><li>如果选取的少数类样本周围也都是少数类样本，则新合成的样本不会提供太多有用信息。这就像支持向量机中远离margin的点对决策边界影响不大。</li><li>如果选取的少数类样本周围都是多数类样本，这类的样本可能是噪音，则新合成的样本会与周围的多数类样本产生大部分重叠，致使分类困难。</li></ol><p>总的来说我们希望新合成的少数类样本能处于两个类别的边界附近，这样往往能提供足够的信息用以分类。而这就是下面的 <strong>Border-line SMOTE</strong> 算法要做的事情。</p><blockquote><p><font color="#bf242a">知识补充</font><a href="https://blog.csdn.net/lemonaha/article/details/53410465#31-k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95">k近邻法–统计学习方法总结_lemonaha的博客-CSDN博客</a><br> k近邻法（k-nearest neighbor,<font color="#0000FF"> k-NN</font>）是一种基本分类与回归方法。这里只讨论分类问题中的k近邻法。k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k近邻法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方法进行预测。因此，k近邻法不具有显式的学习过程。k近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。**<font color="#1E90FF">k值的选择、距离度量及分类决策规则是k近邻法的三个基本要素</font>**。</p></blockquote><ol start="3"><li>Border-line SMOTE</li></ol><p>这个算法会先将所有的少数类样本分成三类，如下图所示：</p><ul><li>“noise” ： 所有的k近邻个样本都属于多数类</li><li>“danger” ： 超过一半的k近邻样本属于<font color="#0000FF">多</font>数类</li><li>“safe”： 超过一半的k近邻样本属于<font color="#0000FF">少</font>数类</li></ul><p><img src="http://files.shanqianche.cn/202169/1623220611894.png" alt="Border-line SMOTE"></p><p>  <font color="#ff7500">Border-line SMOTE</font>算法只会从处于”<em>danger</em>“状态的样本中随机选择，然后用SMOTE算法产生新的样本。处于”danger“状态的样本代表靠近”边界“附近的少数类样本，而处于边界附近的样本往往更<font color="#B8860B">容易被误分类</font>。因而 Border-line SMOTE 只对那些靠近”边界“的少数类样本进行人工合成样本，而 SMOTE 则对所有少数类样本一视同仁。</p><p>Border-line SMOTE 分为两种: Borderline-1 SMOTE 和 Borderline-2 SMOTE。 Borderline-1 SMOTE 在合成样本时,是式中的<math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover></math>是一个<font color="#1E90FF">少数类样本</font>，而 Borderline-2 SMOTE 中的<math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover></math>则是k近邻中的<font color="#FF1493">任意</font>一个样本。</p><ol start="4"><li>ADASYN</li></ol><p><font color="#8B008B">ADASYN</font>名为自适应合成抽样(adaptive synthetic sampling)，其最大的特点是<font color="#006400">采用某种机制自动决定每个少数类样本需要产生多少合成样本</font>，而不是像SMOTE那样对每个少数类样本合成同数量的样本。具体流程如下：</p><ol><li><p>首先计算需要合成的样本总量：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi><mo>=</mo><mfenced><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>j</mi></mrow></msub><mo>-</mo><msub><mi>S</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfenced><mo>&#xD7;</mo><mi>&#x3B2;</mi></math><br>其中<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>j</mi></mrow></msub></math>为多数类样本数量，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mi>min</mi></msub></math>为少数类样本数量，β∈[0,1]为系数。G即为总共想要<font color="#8A2BE2">合成的少数类样本数量</font>，如果β=1则是合成后各类别数目相等。</p></li><li><p>对于每个少类别样本xi，找出其K近邻个点，并计算：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x393;</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>&#x394;</mi><mi>i</mi></msub><mo>/</mo><mi>K</mi></mrow><mi>Z</mi></mfrac></math><br>其中Δi为K近邻个点中多数类样本的数量，Z为规范化因子以确保 Γ 构成一个分布。这样若一个少数类样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>的周围多数类样本越多，则其 Γi 也就越高。</p></li><li><p>最后对每个少类别样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>计算需要合成的样本数量<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">g</mi><mi>i</mi></msub></math>，再用SMOTE算法合成新样本：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><msub><mi>&#x393;</mi><mi>i</mi></msub><mo>&#xD7;</mo><mi>G</mi></math><br>可以看到ADASYN利用分布Γ来自动决定每个少数类样本所需要合成的样本数量，这等于是给每个少数类样本施加了一个权重，周围的多数类样本越多则权重越高。ADASYN的缺点是<font color="#A52A2A">易受离群点的影响</font>，如果一个少数类样本的K近邻都是多数类样本，则其权重会变得相当大，进而会在其周围生成较多的样本。</p></li></ol><p>下面利用sklearn中的 <em>make_classification</em> 构造了一个不平衡数据集，各类别比例为{0:54, 1:946}。原始数据，SMOTE，Borderline-1 SMOTE，Borderline-2 SMOTE和ADASYN的比较见下图，<font color="#0000FF">左侧为过采样后的决策边界</font>，<font color="#8B008B">右侧为过采样后的样本分布情况</font>，<font color="#B8860B">可以看到过采样后原来少数类的决策边界都扩大了，导致更多的多数类样本被划为少数类了</font>：</p><blockquote><p><font color="#0000FF">知识补充</font><br>决策边界顾名思义就是需要分类的数据中，区分不同类别的边界。</p></blockquote><pre><code>    原始数据</code></pre><p><img src="http://files.shanqianche.cn/202169/1623222264899.png" alt="原始数据"><br>        SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222317451.png" alt="SMOTE过采样"><br>        Borderline-1 SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222382482.png" alt="Borderline-1 SMOTE"><br>        Borderline-2 SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222404250.png" alt="Borderline-2 SMOTE"><br>        ADASYN<br><img src="http://files.shanqianche.cn/202169/1623222425227.png" alt="ADASYN"></p><p>从上图我们也可以比较几种过采样方法各自的特点。用 <code>SMOTE</code> 合成的样本分布比较平均，而<code>Border-line SMOTE</code>合成的样本则集中在类别边界处。<code>ADASYN</code>的特性是一个少数类样本周围多数类样本越多，则算法会为其生成越多的样本，从图中也可以看到生成的样本大都来自于原来与多数类比较靠近的那些少数类样本。</p><h3 id="欠采样"><a href="#欠采样" class="headerlink" title="欠采样"></a>欠采样</h3><ol><li><p>随机欠采样</p><p> 随机欠采样的思想同样比较简单，就是从多数类样本中随机选取一些剔除掉。这种方法的缺点是<font color="#0000FF">被剔除的样本可能包含着一些重要信息</font>，致使学习出来的模型效果不好。</p></li><li><p>EasyEnsemble 和 BalanceCascade<br>  EasyEnsemble和BalanceCascade采用集成学习机制来<font color="#8A2BE2">处理传统随机欠采样中的信息丢失</font>问题。</p></li></ol><ul><li>EasyEnsemble将多数类样本随机<font color="#00FFFF">划分成n个子集</font>，每个子集的数量等于少数类样本的数量，这相当于欠采样。接着将每个子集与少数类样本结合起来分别训练一个模型，最后将n个模型集成，这样虽然每个子集的样本少于总体样本，但集成后总信息量并不减少。</li><li>如果说EasyEnsemble是基于无监督的方式从多数类样本中生成子集进行欠采样，那么BalanceCascade则是采用了<font color="#7FFFD4">有监督</font>结合Boosting的方式。在第n轮训练中，将从多数类样本中抽样得来的子集与少数类样本结合起来训练一个基学习器H，训练完后多数类中能被H正确分类的样本会被剔除。在接下来的第n+1轮中，从被剔除后的多数类样本中产生子集用于与少数类样本结合起来训练，最后将不同的基学习器集成起来。BalanceCascade的有监督表现在每一轮的基学习器起到了在多数类中选择样本的作用，而其Boosting<font color="#bf242a">特点则体现在每一轮丢弃被正确分类的样本，进而后续基学习器会更注重那些之前分类错误的样本。</font></li></ul><blockquote><p><font color="#0000FF">知识补充</font>基学习器<br><a href="https://www.biaodianfu.com/boosting.html">机器学习算法之Boosting – 标点符</a><br>同质集成中的个体学习器又称为基学习器（base learner），相应的学习算法也被称为基学习算法（base learning algorithm）。</p></blockquote><ol start="3"><li>NearMiss</li></ol><p><font color="#725e82"><strong>NearMiss</strong></font>本质上是一种<font color="#BDB76B">原型选择</font>(prototype selection)方法，即从多数类样本中选取最具代表性的样本用于训练，主要是为了缓解随机欠采样中的信息丢失问题。NearMiss采用一些<font color="#A52A2A">启发式的规则</font>来选择样本，根据规则的不同可分为3类：</p><ul><li>NearMiss-1：选择到最近的K个少数类样本平均距离最近的多数类样本</li><li>NearMiss-2：选择到最远的K个少数类样本平均距离最近的多数类样本</li><li>NearMiss-3：对于每个少数类样本选择K个最近的多数类样本，目的是保证每个少数类样本都被多数类样本包围</li></ul><p>NearMiss-1和NearMiss-2的计算<font color="#0000FF">开销很大</font>，因为需要计算每个多类别样本的K近邻点。另外，NearMiss-1易受离群点的影响，如下面第二幅图中合理的情况是处于边界附近的多数类样本会被选中，然而由于右下方一些少数类离群点的存在，其附近的多数类样本就被选择了。相比之下NearMiss-2和NearMiss-3不易产生这方面的问题。</p><p><img src="http://files.shanqianche.cn/202169/1623224933174.png" alt="图一Oniginal data"></p><p><img src="http://files.shanqianche.cn/202169/1623225034300.png" alt="图二Resampling using Nearmiss-1"></p><p><img src="http://files.shanqianche.cn/202169/1623225086130.png" alt="图三Resampling using Nearmiss-2"></p><p><img src="http://files.shanqianche.cn/202169/1623225124104.png" alt="图四Resampling using Nearmiss-3"></p><ol start="4"><li>数据清洗方法 (data cleaning tichniques)</li></ol><p>这类方法主要<font color="#8A2BE2">通过某种规则来清洗重叠的数据</font>，从而达到欠采样的目的，而这些规则往往也是启发性的，下面进行简要阐述：</p><ul><li><p><font color="#ff7500">Tomek Link</font>：Tomek Link表示<font color="#7FFFD4">不同类别</font>之间距离最近的一对样本，即<font color="#bf242a">这两个样本互为最近邻且分属不同类别</font>。这样如果两个样本形成了一个Tomek Link，则要么其中一个是噪音，要么两个样本都在边界附近。这样通过移除Tomek Link就能“清洗掉”类间重叠样本，使得互为最近邻的样本皆属于同一类别，从而能更好地进行分类。</p><pre><code>  下图一上为原始数据，图二上为SMOTE后的数据，图三虚线标识出Tomek Link，图四为移除Tomek Link后的数据集，可以看到不同类别之间样本重叠减少了很多。</code></pre></li></ul><p><img src="http://files.shanqianche.cn/202169/1623226151018.png" alt="图一"></p><p><img src="http://files.shanqianche.cn/202169/1623226162443.png" alt="图二"></p><p><img src="http://files.shanqianche.cn/202169/1623226175192.png" alt="图三"></p><p><img src="http://files.shanqianche.cn/202169/1623226186988.png" alt="图四"></p><ul><li><font color="#ff7500"> Edited Nearest Neighbours(ENN)</font>：对于属于多数类的一个样本，如果其K个近邻点有超过一半都不属于多数类，则这个样本会被剔除。这个方法的另一个变种是所有的K个近邻点都不属于多数类，则这个样本会被剔除。、</li></ul><p>最后，数据清洗技术<font color="#0000FF">最大的缺点</font>是无法控制欠采样的数量。由于都在某种程度上采用了K近邻法，而事实上大部分多数类样本周围也都是多数类，因而能剔除的多数类样本比较有限。</p><h3 id="过采样和欠采样结合"><a href="#过采样和欠采样结合" class="headerlink" title="过采样和欠采样结合"></a>过采样和欠采样结合</h3><p>上文中提到SMOTE算法的缺点是生成的少数类样本容易与周围的多数类样本产生重叠难以分类，而数据清洗技术恰好可以处理掉重叠样本，所以可以将二者结合起来形成一个pipeline，先过采样再进行数据清洗。主要的方法是 <code>SMOTE + ENN</code> 和 <code>SMOTE + Tomek</code> ，其中 <code>SMOTE + ENN</code> 通常能清除更多的重叠样本，如下图：</p><p><img src="http://files.shanqianche.cn/202169/1623227628385.png" alt="Resampling using Original"></p><p><img src="http://files.shanqianche.cn/202169/1623227661187.png" alt="Resampling using SMOTE"></p><p><img src="http://files.shanqianche.cn/202169/1623227708226.png" alt="Resampling using SMOTE + ENN"></p><p><img src="http://files.shanqianche.cn/202169/1623227766137.png" alt="Resampling using SMOTE + TOMEK"></p><hr><p><strong><font color="#DC143C">★ 采样方法的效果</font></strong></p><p><a href="https://www.cnblogs.com/massquantity/p/9382710.html">机器学习之类别不平衡问题 (3) —— 采样方法 - massquantity - 博客园</a></p><h2 id="省心的方法"><a href="#省心的方法" class="headerlink" title="省心的方法"></a>省心的方法</h2><h3 id="主动收集数据"><a href="#主动收集数据" class="headerlink" title="主动收集数据"></a>主动收集数据</h3><p>针对少量样本数据，可以尽可能去扩大这些少量样本的数据集，或者尽可能去增加他们特有的特征来丰富数据的多样性（尽量转化成情况1）。譬如，如果是一个情感分析项目，在分析数据比例时发现负样本（消极情感）的样本数量较少，那么我们可以尽可能在网站中搜集更多的负样本数量，或者花钱去买，毕竟数据少了会带来很多潜在的问题。</p><h3 id="将任务转换成异常检测问题、"><a href="#将任务转换成异常检测问题、" class="headerlink" title="将任务转换成异常检测问题、"></a>将任务转换成异常检测问题、</h3><p>如果少数类样本太少，少数类的结构可能并不能被少数类样本的分布很好地表示，那么用平衡数据或调整算法的方法不一定有效。如果这些少数类样本在特征空间中再分布的比较散，情况会更加糟糕。这时候不如将其转换为无监督的异常检测算法，不用过多的去考虑将数据转换为平衡问题来解决。</p><h3 id="调整权重"><a href="#调整权重" class="headerlink" title="调整权重"></a>调整权重</h3><p>可以简单的设置损失函数的权重，让模型增加对多数类的惩罚，更多的关注少数类。在python的scikit-learn中我们可以使用class_weight参数来设置权重。</p><p>另外，调整权重方法也适合于这种情况：不同类型的错误所造成的后果不同。例如在医疗诊断中，错误地把健康人诊断为患者可能会带来进一步检查的麻烦，但是错误地把患者诊断为健康人，则可能会丧失了拯救生命的最佳时机；再如，门禁系统错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故；在信用卡盗用检查中，将正常使用误认为是盗用，可能会使用户体验不佳，但是将盗用误认为是正常使用，会使用户承受巨大的损失。为了权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”（unequal cost）。</p><h3 id="阈值调整（threshold-moving）"><a href="#阈值调整（threshold-moving）" class="headerlink" title="阈值调整（threshold moving）"></a>阈值调整（threshold moving）</h3><p>直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将原本默认为0.5的阈值调整到 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>|</mo><mi>P</mi><mo>|</mo></mrow><mrow><mo>(</mo><mo>|</mo><mi>P</mi><mo>|</mo><mo>+</mo><mo>|</mo><mi>N</mi><mo>|</mo><mo>)</mo></mrow></mfrac></math>即可。（大部分是负样本，因此分类器倾向于给出较低的分数）</p><h2 id="类别不平横影响模型的输出"><a href="#类别不平横影响模型的输出" class="headerlink" title="类别不平横影响模型的输出"></a>类别不平横影响模型的输出</h2><p>许多模型的输出是基于阈值的，大部分模型的默认阈值为输出值的中位数。比如逻辑回归的输出范围为[0,1]，当某个样本的输出大于0.5就会被划分为正例，反之为反例。在数据的类别不平衡时，采用默认的分类阈值可能会导致输出全部为反例，产生虚假的高准确度，导致分类失败。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernal</title>
      <link href="/2021/05/30/kernal/"/>
      <url>/2021/05/30/kernal/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><font color="#6495ED">核方法</font>是一类把低维空间的非线性可分问题，转化为高维空间的线性可分问题的方法。</p><blockquote><p><font color="#A9A9A9">理论基础:</font>核方法的理论基础是Cover’s theorem，指的是<font color="#FF8C00">对于非线性可分的训练集，可以大概率通过将其非线性映射到一个高维空间来转化成线性可分的训练集。</font></p></blockquote><p><font color="#9400D3">核函数</font>是映射关系 的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数。</p><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>是输入空间（即 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>  是 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="normal">&#x211D;</mi><mi>n</mi></msup></math> 的子集或离散集合 ），又设<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math>  为特征空间（<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 是希尔伯特空间），如果存在一个从 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math> 到 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 的映射</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>:</mo><mi mathvariant="script">X</mi><mo>&#x2192;</mo><mi mathvariant="script">H</mi></math></p><p>使得对所有 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>,</mo><mi>z</mi><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math>,函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo></math>满足条件</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo><mo>=</mo><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math></p><p>则称 $K$ 为核函数。其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math> 为映射函数， <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mo>&#xB7;</mo><mo>,</mo><mo>&#xB7;</mo><mo>&#x27E9;</mo></math>为内积。</p><p>即核函数输入两个向量，它返回的值<font color="#FF1493">等于</font>这两个向量分别作 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 映射然后点积【内积】的结果。</p><p><font color="#008B8B">核技巧</font>是一种利用核函数直接计算 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math> ，以避开分别计算<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>  和<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>  ，从而加速核方法计算的技巧。</p><blockquote><p><font color="#FF1493">注意</font><br>得益于<font color="#FF8C00">SVM对偶问题</font>的表现形式，核技巧可以应用于SVM。<br><font color="#7FFF00">TODO  </font>没有了解<br>核函数的选择是SVM的<font color="#B8860B">最大变数</font>，如果核函数选择不适，那么  将不能将输入空间映射到线性可分的特征空间。</p></blockquote><h2 id="判断核函数"><a href="#判断核函数" class="headerlink" title="判断核函数"></a>判断核函数</h2><p><font color="#bf242a">不知道 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 的情况下，如何判断某个 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是不是核函数？</font></p><p><strong>答案:</strong> 是 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是核函数当且仅当对任意数据 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></math> ，核矩阵(kernal matrix,gram matrix)总是半正定的</p><blockquote><p><font color="#368AF8">知识补充：</font><strong>实对称矩阵</strong><br>如果有n阶矩阵A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（aij=aji），(i,j为元素的脚标），则称A为实对称矩阵。</p></blockquote><blockquote><p><font color="#6495ED"><a href="https://zhuanlan.zhihu.com/p/44860862">知识补充</a>：</font><font color="#8B0000">「正定矩阵」(positive definite)</font>和<font color="#8B0000">「半正定矩阵」(positive semi-definite)</font><br><strong>正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">非零向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><strong>半正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><font color="#FF00FF">半正定矩阵包括了正定矩阵，核矩阵与协方差矩阵都要半正定</font></p></blockquote><p><img src="http://files.shanqianche.cn/2021530/1622369097125.png" alt="核矩阵"></p><h2 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h2><p><img src="http://files.shanqianche.cn/2021530/1622366953315.png" alt="常用核函数"></p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>举一个<a href="https://zhuanlan.zhihu.com/p/95362628">栗子</a><br>下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。</p><p><img src="http://files.shanqianche.cn/2021530/1622369536767.png" alt="二维"></p><p>我们现在考虑核函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mfenced><mo>=</mo><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><msup><mo>&gt;</mo><mn>2</mn></msup></math>，即“内积平方”。<br>这里面<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mn>1</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>是二维空间中的两个点。</p><p>这个核函数对应着一个二维空间到三维空间的映射，它的表达式是：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mfenced><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msqrt><mn>2</mn></msqrt><mi>x</mi><mi>y</mi><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mfenced></math><br>可以验证，<br><img src="http://files.shanqianche.cn/2021530/1622369667776.png" alt="核函数"></p><p>在P这个映射下，原来二维空间中的图在三维空间中的像是这个样子：</p><p><img src="http://files.shanqianche.cn/2021530/1622369693244.png" alt="三维"></p><p><font color="#D2691E">注意</font>到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。</p><p>而三维中的这个判决边界，再映射回二维空间中是这样的：</p><p><img src="http://files.shanqianche.cn/2021530/1622369730773.png" alt="再二维"></p><p>这是一条双曲线，它不是线性的。</p><p><font color="#A52A2A">通过高维映射使得特征线性可分，换种思路就是当两个特征值无法将数据分开时，就将两个特征值进行点交，形成第三个特征，这个时候就有三个特征值，然后构成三位空间，进行分类</font></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> data mining </tag>
            
            <tag> kernal method </tag>
            
            <tag> kernal trick </tag>
            
            <tag> kernal function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差矩阵</title>
      <link href="/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="方差和协方差的定义"><a href="#方差和协方差的定义" class="headerlink" title="方差和协方差的定义"></a>方差和协方差的定义</h2><p><font color="#184471"><strong>方差</strong>：</font>用来度量单个随机变量的离散程度</p><p>$$\sigma_{x}^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$$</p><p><font color="#D3B2F7">为什么样本方差的分母是n-1？</font></p><pre><code>最简单的原因，是因为因为均值已经用了n个数的平均来做估计在求方差时，只有(n-1)个数和均值信息是不相关的。而你的第ｎ个数已经可以由前(n-1)个数和均值　来唯一确定，实际上没有信息量。所以在计算方差时，只除以(n-1)。</code></pre><p><font color="#0C5F6C"><strong>协方差</strong>：</font>一般用来刻画两个随机变量的相似程度</p><p>$$\sigma(x, y)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)$$</p><p>在公式中，符号 $\bar{x}, \bar{y}$ 分别表示两个随机变量所对应的观测样本均值，据此，我们发现：方差 $\sigma_{x}^{2}$ 可视作随机变量 x 关于其自身的协方差 $\sigma(x, x)$ .</p><h2 id="从方差-协方差到协方差矩阵"><a href="#从方差-协方差到协方差矩阵" class="headerlink" title="从方差/协方差到协方差矩阵"></a>从方差/协方差到协方差矩阵</h2><p>根据方差的定义，给定 $d$ 个随机变量 $x_{k},k=1,2,\ldots,d$ ，则这些随机变量的方差为<br>$$\sigma\left(x_{k},x_{k}\right)=\frac{1}{n-1}\sum_{i=1}^{n}\left(x_{k i}-\bar{x}_{k}\right)^{2},k=1,2,\ldots,d$$</p><p> $x_{k i}$ 表示随机变量 $x_{k}$ 中的第 $i$ 个观测样本，$n$  表示样本量，每个随机变量所对应的观测样本数量均为 $n$ 。<br> 对于这些随机变量，我们还可以根据协方差的定义，求出<strong>两两之间的协方差</strong>，即<br> <img src="http://files.shanqianche.cn/2021527/1622097407978.png"></p><p> 因此，协方差矩阵为 $$\Sigma=\left[\begin{array}{ccc}\sigma\left(x_{1}, x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{1},x_{d}\right)\\vdots&amp;\ddots&amp;\vdots\\sigma\left(x_{d},x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{d},x_{d}\right)\end{array}\right]\in\mathbb{R}^{d\times d}$$<br>其中，对角线上的元素为各个随机变量的方差，非对角线上的元素为两两随机变量之间的协方差，根据协方差的定义，我们可以认定：矩阵 $\Sigma$ 为<font color="#AB8E35">对称矩阵</font>(symmetric matrix)，其大小为 $d$ x $d$ 。</p><h2 id="多元正态分布与线性变换"><a href="#多元正态分布与线性变换" class="headerlink" title="多元正态分布与线性变换"></a>多元正态分布与线性变换</h2><blockquote><p><font color="#EFED2E">多元正态分布</font>—n维的多元正态分布，也称为多元高斯分布</p></blockquote><p><img src="http://files.shanqianche.cn/2021526/1622033779880.png" alt="多元正态分布图"></p><p>假设一个向量 $x$ 服从均值向量为 $\boldsymbol{\mu}$ 、协方差矩阵为 $\Sigma$ 的多元正态分布(multi-variate Gaussian distribution)【第二章】，则 $$p(\boldsymbol{x})=|2 \pi \Sigma|^{-1 / 2} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \Sigma^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)$$</p><blockquote><p><font color="#DE8937">联立理解：</font>多元正态分布<br><img src="http://files.shanqianche.cn/2021526/1622035698486.png" alt="多元正态分布"></p></blockquote><p>令该分布的均值向量为 $\boldsymbol{\mu}=\mathbf{0}$ ，由于指数项外面的系数 $|2 \pi \Sigma|^{-1 / 2}$ 通常作为常数，故可将多元正态分布简化为 $$p(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \Sigma^{-1} \boldsymbol{x}\right)$$<br>再令 $\boldsymbol{x}=(y, z)^{T}$ ，包含两个随机变量 $y$ 和 $z$ ，则协方差矩阵可写成如下形式： $$ \Sigma=\left[\begin{array}{ll}\sigma(y, y) &amp; \sigma(y, z) \ \sigma(z, y) &amp; \sigma(z, z)\end{array}\right] \in \mathbb{R}^{2 \times 2} $$<br>用<font color="#006EFF">单位矩阵</font>(identity matrix) $I$ 作为<font color="#183D66">协方差矩阵</font>，随机变量 $y$ 和 $z$ 的方差均为1，则生成如干个随机数如图所示。 </p><p><img src="http://files.shanqianche.cn/2021526/1622038800402.png" alt="图1二元正态分布"></p><blockquote><p><font color="#DE8937">知识补充：</font>单位矩阵<br> 单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。<strong>任何矩阵与单位矩阵相乘都等于本身</strong><br><img src="http://files.shanqianche.cn/2021526/1622039427482.png" alt="单位矩阵"></p></blockquote><p>在生成的若干个随机数中，每个点的似然为 $$ \mathcal{L}(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \boldsymbol{x}\right) $$</p><blockquote><p><font color="">知识补充：</font>线性变换<br><a href="https://www.bilibili.com/video/av6043439">视频教学</a><br>线性性质一：直线在变换后仍然保持为直线，不能弯曲；线性性质二：原点是固定不变的</p></blockquote><p>对图[二元正态分布]中的所有点考虑一个线性变换(linear transformation)：$\boldsymbol{t}=A \boldsymbol{x}$  ，我们能够得到图</p><p><img src="http://files.shanqianche.cn/2021526/1622039676816.png" alt="图2 经过线性变换的二元正态分布，先将图1的纵坐标压缩0.5倍，再将所有点逆时针旋转30°得到"></p><p>在线性变换中，矩阵 $A$ 被称为<strong>变换矩阵</strong>(transformation matrix)，为了将图1中的点经过线性变换得到我们想要的图2，其实我们需要构造两个矩阵：</p><ul><li><strong>尺度矩阵</strong>(scaling matrix)： $$S=\left[\begin{array}{cc}s_{y}&amp;0\0&amp;s_{z}\end{array}\right]$$</li><li><strong>旋转矩阵</strong>(rotation matrix)： $$R=\left[\begin{array}{cc}\cos(\theta)&amp;-\sin(\theta)\\sin(\theta)&amp;\cos(\theta)\end{array}\right]$$<br>其中， $\theta$ 为顺时针旋转的度数。</li></ul><blockquote><p><font color="#8591A6">补充知识：</font>变换矩阵、尺度矩阵和旋转矩阵三者的关系式<br>$A=R S$</p></blockquote><p>在这个例子中，尺度矩阵为 $S=\left[\begin{array}{l l}1&amp;0\0&amp;\frac{1}{2}\end{array}\right]$ ，旋转矩阵为 $R=\left[\begin{array}{c c}\cos\left(-\frac{\pi}{6}\right)&amp;-\sin\left(-\frac{\pi}{6}\right)\\sin\left(-\frac{\pi}{6}\right)&amp;\cos\left(-\frac{\pi}{6}\right)\end{array}\right]=\left[\begin{array}{c c}\frac{\sqrt{3}}{2}&amp;\frac{1}{2}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{2}\end{array}\right]$ ，故变换矩阵为 $A=R S=\left[\begin{array}{cc}\frac{\sqrt{3}}{2}&amp;\frac{1}{4}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{4}\end{array}\right]$</p><p>另外，需要考虑的是，经过了线性变换，$t$  的分布是什么样子呢？</p><p>将 $\boldsymbol{x}=A^{-1} \boldsymbol{t}$ 带入前面给出的似然 $\mathcal{L}(\boldsymbol{x})$ ，有 $\mathcal{L}(\boldsymbol{t}) \propto \exp \left(-\frac{1}{2}\left(A^{-1} \boldsymbol{t}\right)^{T}\left(A^{-1} \boldsymbol{t}\right)\right)$<br>$=\exp \left(-\frac{1}{2} \boldsymbol{t}^{T}\left(A A^{T}\right)^{-1} \boldsymbol{t}\right)$</p><p>由此可以得到，多元正态分布的协方差矩阵为 $$\Sigma=A A^{T}=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{4} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{4}\end{array}\right]\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; -\frac{1}{2} \ \frac{1}{4} &amp; \frac{\sqrt{3}}{4}\end{array}\right]=\left[\begin{array}{cc}\frac{13}{16} &amp; -\frac{3 \sqrt{3}}{16} \ -\frac{3 \sqrt{3}}{16} &amp; \frac{7}{16}\end{array}\right]$$</p><h2 id="协方差矩阵的特征值分解"><a href="#协方差矩阵的特征值分解" class="headerlink" title="协方差矩阵的特征值分解"></a>协方差矩阵的特征值分解</h2><blockquote><p>回到我们已经学过的线性代数内容，对于任意对称矩阵 $\Sigma$ ，存在一个特征值分解(eigenvalue decomposition, EVD)： $$\Sigma=U \Lambda U^{T}$$ 其中, $U$ 的每一列都是相互正交的特征向量，且是单位向量，满足 $U^{T}U=I$ ， $\Lambda$ 对角线上的元素是从大到小排列的特征值，非对角线上的元素均为0。</p></blockquote><p>当然，这条公式在这里也可以很容易地写成如下形式： $$\Sigma=\left(U \Lambda^{1 / 2}\right)\left(U \Lambda^{1 / 2}\right)^{T}=A A^{T}$$<br>其中，$A=U \Lambda^{1 / 2}$  ，因此，通俗地说，<font color="#226771">任意一个协方差矩阵都可以视为线性变换的结果。</font><br>在上面的例子中，<strong>特征向量构成的矩阵</strong>为 $$U=R=\left[\begin{array}{cc}\cos (\theta) &amp; -\sin (\theta) \ \sin (\theta) &amp; \cos (\theta)\end{array}\right]=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{2} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{2}\end{array}\right]$$<br><strong>特征值构成的矩阵</strong>为<br>$$\Lambda=S S^{T}=\left[\begin{array}{cc}s_{y}^{2} &amp; 0 \ 0 &amp; s_{z}^{2}\end{array}\right]=\left[\begin{array}{ll}1 &amp; 0 \ 0 &amp; \frac{1}{4}\end{array}\right]$$<br>到这里，我们发现：多元正态分布的概率密度是由<font color="#BD5A5D">协方差矩阵的特征向量控制旋转(rotation)</font>，<font color="">特征值控制尺度(scale)</font>，除了协方差矩阵，<font color="#810006">均值向量会控制概率密度的位置</font>，在图1和图2中，均值向量为 $0$ ，因此，概率密度的中心位于坐标原点。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖掘业务流程，结合机器学习进行业务预测分析</title>
      <link href="/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基于机器学习的流程异常预测行为"><a href="#基于机器学习的流程异常预测行为" class="headerlink" title="基于机器学习的流程异常预测行为"></a>基于机器学习的流程异常预测行为</h2><p><img src="./attachments/%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B5%81%E7%A8%8B%E5%BC%82%E5%B8%B8%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95_%E9%AD%8F%E6%87%BF.pdf" alt="基于机器学习的流程异常预测方法_魏懿"></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><p>通过挖掘流程执行的<font color="#D2691E">日志记录</font> 和<font color="#6495ED">活动执行时间信息 </font>，基于机器学习方法的异常检测方法，实现实时预测业务流程中的超 期 异 常 和 流 程 行 为 异 常。</p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>异常(预期的，完全意外的)</p></blockquote><ol><li>流程超期、资源不可用、活动执行失败等和完全意外的异常</li></ol><blockquote><p>现有的流程异常检测方法</p></blockquote><ul><li>主动 的 设 置 时 间 检 查点、动态检查，或 被动地基于异常发生后捕捉异常、处理异常的机制<ol><li>主动设置时间检查点的方法有两个弊端，第一个设置点的位置无法精确判断，第二个是系统状态是动态的，受生产环境等诸多条件影响，所以主动i设置会造成很多新的问题</li><li>被动处理超期异常的方法，失去了对业务流程管理的主动性，从而将导致工作流期望的目标延迟或付出更大的开销。【即失去对于流程预测的主动性】</li></ol></li></ul><h3 id="目前国内外研究动态"><a href="#目前国内外研究动态" class="headerlink" title="目前国内外研究动态"></a>目前国内外研究动态</h3><h4 id="基于时间边界的时间异常检测"><a href="#基于时间边界的时间异常检测" class="headerlink" title="基于时间边界的时间异常检测"></a>基于时间边界的时间异常检测</h4><ol><li>基于时间边界的时间异常检测–Eder</li></ol><p><font size=1>the fifth and sixth document of this paper </font></p><pre><code>首先要明确每个任务节点执行时间的上下边界， 基于这两个时限， 计算起始节点到当前节点的最佳（ 最短） 执行时间和最坏（ 最长） 执行时间。当流程执行时， 如果当前时间在区间内， 则判断为没有时间异常</code></pre><ol start="2"><li>基于关键路径</li></ol><p><font size=1>the seventh document of this paper </font></p><pre><code>在工作流执行前，会根据模型先找出关键路径， 并在流程执行时检查最佳完成时间与最终时限， 如果最佳完成时间大于最终时限， 则预测为异常</code></pre><h4 id="时间统计模型建立"><a href="#时间统计模型建立" class="headerlink" title="时间统计模型建立"></a>时间统计模型建立</h4><ol><li>执行时间建模方法</li></ol><p><font size=1>the eighth document of this paper </font></p><pre><code>该方法利用历史日志生成涵盖所有活动持续时间直方图来表示当前节点和末端节点之间的剩余执行时间的概率，用于捕获有关工作流执行的时间信息，定义计算工作流执行时间的必要操作</code></pre><ol start="2"><li>综合时间模型和流程步骤分析</li></ol><p><font size=1>the ninth document of this paper </font></p><pre><code>综合运用时间统计模型和通过多个步骤分析方法生成运行时间概率分布、计算异常概率、与阈值比较的方法，提出一种基于运行的异常预测算法来预测工作流中的时间异常，该算法分为即设计时段和运行时段两个阶段，在设计时段，生成该模型所有可能产生的运行轨迹，并计算它们的预计执行时间的概率分布；在运行时段，通过分析计算流程超时的可能性与预设的阈值做比较来判断是否预测为异常    </code></pre><ol start="3"><li>结合积极语义模型</li></ol><p><font size=1>the tenth document of this paper </font></p><pre><code>采用积极语义模型来捕捉各种工作流情形下的 语 义 特 征，并 且 检 测 和 处 理 异 常    </code></pre><ol start="4"><li>提出受启发与传染病模型的时间延迟传播模型</li></ol><p><font size=1>the eleventh document of this paper </font></p><pre><code>着眼于并行云工作流中的时间延迟，提出受启发与传染病模型的时间延迟传播模型，预测使云工作流中达到一定完成率的最大时间异常数目</code></pre><h3 id="离群点检测的算法"><a href="#离群点检测的算法" class="headerlink" title="离群点检测的算法"></a>离群点检测的算法</h3><p><a href="https://blog.zuishuailcq.xyz/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/">离群点检测 | 吾辈之人，自当自强不息！</a></p><p><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/">孤立森林（Isolation Forest） | 吾辈之人，自当自强不息！</a></p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><blockquote><p>提出一种基于活动执行时间和比例关系的方法，通过学习历史流程执行日志中活动时间信息，根据正在执行的待预测流程的日志及状态，预测其是否为异常流程以及异常的类型。并且，本文提出通过计算活动执行时间之间的比例关系作为流程特征加入机器学习算法，运用机器学习中监督学习的分类器以预测流程是否会发生超期异常（流程执行总时间超过预设最终期限），同时使用非监督学习的离群点检测算法根据历史数据中活动执行时间比例关系判定流程行为异常。结合两种算法的结果对流程异常预测做出进一步的分类和分析。</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>预处理历史和正在执行的流程数据，获得流程中活动执行时间序列以及计算活动执行时间<font color="#8B0000">比例关系</font></li><li>使用监督学习的分类器，预测并标记超期【流程执行<br>总时间超过预设最终期限】异常流程为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 用无监督学习检测离群点算法【 <font color="#9400D3">活动执行时间之间比例关系(单个活动占总体)</font>为特征值】，找出历史数据中的异常流程并标记为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 通过集成业务流程异常预测方法将待预测流程分为正常流程或者不同种类的异常流程</li></ol><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p><img src="http://files.shanqianche.cn/2021531/1622429405396.png" alt="集成业务流程异常预测方法结构图"></p><blockquote><p><font color="#8FBC8F">知识补充：</font>弱监督<br>不完全监督（Incomplete supervision）：训练数据中只有一部分数据被给了标签，有一些数据是没有标签的。<br>不确切监督（Inexact supervision）：训练数据只给出了粗粒度标签。可理解为只给了大类的标签，详细属性没有给标签<br>不精确监督（Inaccurate supervision）：给出的标签不总是正确的</p></blockquote><p><img src="http://files.shanqianche.cn/2021531/1622441386940.png" alt="预测结果异常分类韦恩图"></p><ol><li>第一类通过弱监督学习方法可以标记出大部分的异常流程，但是系统的运行情况很容易受环境资源影响，很多时候由于等待时间过长，被误标为异常流程，但是依旧属于正常流程</li><li>在实际业务流程中， 活动的执行时间之间并非独立分布， 而是具有隐含的相关关系， 由于多种因素的影响， 造成了活动时间相应的变化。比如工作负荷加倍使得某些活动花费了较长时间， 导致流程总时间较长， 有超期异常的风险。但是从活动执行时间比例关系来看， 流程时间可能被近乎等比例放大， 完全是合情合理的， 并不应该被记为最终期限异常的流程。在活动时间比例上， 正常执行的流程活动时间比例关系是相似的， 而行为异常的流程活动时间比例关系容易出现离群点。因此计算流程中活动时间的比例关系， 并将其作为特征加入算法是有必要的。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h4><blockquote><p><font color="#1E90FF">数据集</font><br>将历史业务流程日志及正在执行流程中的活动执行时间信息作为初始的数据集</p></blockquote><p><font color="#7FFF00">TODO</font><br> 通过目前较为成熟的流程挖掘算法和软件， 如ProM Tools、Disco， 流程模型模拟业务流程获取数据可以简化结构、 缩减活动数量。</p><p><font color="#ff7500">数据初始化：</font><br>待预测流程的活动数量：n<br>多条与待预测执行流程路径一致的历史流程数量：q<br>待预测流程执行时间集：T<br>其中一条流程的活动执行时间序列：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>(</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo><mo>)</mo></math><br>序列中单个活动的执行时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>t</mi><mi>i</mi></msub><mo>(</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo><mo>)</mo></math></p><p>待预测流程执行时间集：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br>序列k的流程时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo></math></p><h4 id="获得时间比例"><a href="#获得时间比例" class="headerlink" title="获得时间比例"></a>获得时间比例</h4><p><font color="#1E90FF">对长度为 $n$ 的活动执行时间序列<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub></math>，求出长度为 $n-1$ 的时间比例序<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub></math>，记比例数据集为 $R$ </font></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><mfrac><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mfrac><mo>,</mo><mfrac><msub><mi>t</mi><mn>2</mn></msub><msub><mi>t</mi><mn>3</mn></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mi>i</mi></msub><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>n</mi></msub></mfrac></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>]</mo></math></p><h4 id="对异常流程进行标记"><a href="#对异常流程进行标记" class="headerlink" title="对异常流程进行标记"></a>对异常流程进行标记</h4><ul><li>通过历史流程计算出流程执行时间分布，可以给不同活动设定阈值，来标记超期异常流程</li><li>可以用执行时间拟合建立高斯分布，利用模型参数设立阈值以标记异常（如临界点 $threshold$ <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mi>&#x3BC;</mi><mo>+</mo><mn>2</mn><mo>&#xB7;</mo><mi>&#x3C3;</mi></math>），标记出的异常数据集为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi><mi>c</mi><mi>v</mi></math>【time constrain violation 违规时间约束】</li></ul><h4 id="集成业务流程异常预测方法（EnsBPAP）"><a href="#集成业务流程异常预测方法（EnsBPAP）" class="headerlink" title="集成业务流程异常预测方法（EnsBPAP）"></a>集成业务流程异常预测方法（EnsBPAP）</h4><blockquote><p><font color="#9932CC">前提</font><br>将待预测流程的活动执行时间序列记为ｔ，将其时间比例序列记为ｒ， 同数据预处理中得到的历史流程的执行时间,比例数据集和标记出的异常数据集 $T$ , $R$ , $tcv$</p></blockquote><ol><li>将活动执行时间和比例的训练数据集和测试用例数据传入监督学习的分类算法中， 得到超期异常预测结果</li><li>将活动时间比例的训练集和测试用例传入无监督学习异常检测算法， 得到行为异常预测结果</li><li>用两个预测结果访问EnsBPAP分类结果矩阵， 并返回最终的分类结果</li></ol><p><font color="#0000FF">EnsBPAP(t,r,T,R,balance_data)伪代码</font></p><p><img src="http://files.shanqianche.cn/2021531/1622448127881.png" alt="输入输出"></p><p><img src="http://files.shanqianche.cn/2021531/1622448326369.png" alt="步骤函数"></p><ol><li>标记超期异常流程</li><li>标记行为异常【时间比例异常】</li><li>制定EnsBPAP模型【位运算】</li><li>将异常流程通过EnsBPAP模型，获得符合模型的综合分类结果</li></ol><blockquote><p>class： 预测测试过程的综合分类结果</p></blockquote><h4 id="超期异常预测"><a href="#超期异常预测" class="headerlink" title="超期异常预测"></a>超期异常预测</h4><p><font color="#7FFF00">分类器基本模型</font></p><ul><li>逻辑回归算法–监督学习</li></ul><p><font color="#DC143C">数据存在问题</font></p><ul><li>异常点在整个数据集中的数量远小于正常点的数量【样本不均衡问题】，会导致分类器倾向于把预测样本分为多数类。</li></ul><p><font color="#00FFFF">处理样本不平衡问题</font>—<a href="https://blog.zuishuailcq.xyz/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/">二分类之类别不平衡 | 吾辈之人，自当自强不息！</a></p><ul><li>使用过采样和欠采样结合的方法<font color="#0000FF">SMOTE + TOMEK algorithm</font></li></ul><ol><li>第１步， 将执行时间和比例数据Ｔ，Ｒ 合并成训练集Ｘ， 训练目标为tcv，ｔ，ｒ合并成测试样本ｘ； </li><li>第２步， 根据balance_data参数选择是否执行SMOTE＋Tomek算法均衡训练样本【balance_data平衡训练数据以进行时间约束违规预测】</li><li>第3步，对每个特征做归一化消除数据量级的影响【<font color="#FF00FF">归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响</font>。】</li><li>第4步，初始化算法模型，超参数空间，最佳参数</li><li>第5步，通过若干次迭代随机生成超参数、参考交叉验证法评估当前超参数下的性能、更新最佳超参</li><li>最后一步，使用最佳超参数拟合算法模型，预测测试样本模型类型，并返回</li></ol><p><img src="http://files.shanqianche.cn/2021611/1623397346285.png" alt="TimeConstraitsViolationPrediction(t,r,T,R,tcv,balance_data)"></p><h4 id="行为异常检测"><a href="#行为异常检测" class="headerlink" title="行为异常检测"></a>行为异常检测</h4><p><font color="#8B0000">目标</font></p><ul><li>通过活动执行时间比例找出离群点， 以鉴别待预测流程是否为行为异常的流程。</li></ul><p><font color="#8B008B">算法模型</font></p><ul><li>孤立森林</li></ul><ol><li>第１步， 初始化算法模型</li><li>第２步， 拟合历史数据得到孤立森林模型</li><li>第３步， 预测测试样本并返回</li></ol><p><img src="http://files.shanqianche.cn/2021611/1623397471182.png" alt="BehaviorAnimalyDetection(r,R)"></p><blockquote><p><font color="#006400">补充知识</font><br><a href="https://blog.csdn.net/huangfei711/article/details/78456165">如何通俗易懂地理解皮尔逊相关系数？_黄飞的博客专栏-CSDN博客_皮尔逊相关系数怎么看</a></p></blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>流程的预设期限<font color="#5F9EA0">如何</font> <font color="#696969">在哪</font> 还有 <font color="#BDB76B">设置的标准</font>没有提到</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离群点检测</title>
      <link href="/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>离群点检测</strong>（<font color=" #009688">异常检测</font>）是找出其行为不同于预期对象的过程，这种对象称为离群点或异常。</p><blockquote><p>离群点和噪声有区别，噪声是观测变量的随机误差和方差，而离群点的产生机制和其他数据的产生机制就有根本的区别,同一批数据产生方式可能不一样。</p></blockquote><p><strong>全局离群点</strong>：通过找到某种合适的偏离度量方式，将离群点检测划为不同的类别；全局离群点是情景离群点的特例，因为考虑整个数据集为一个情境。</p><p><strong>情境离群点</strong>：又称为条件离群点，即在特定条件下它可能是离群点，但是在其他条件下可能又是合理的点。比如夏天的28℃和冬天的28℃等。</p><p><strong>集体离群点</strong>：个体数据可能不是离群点，但是这些对象作为整体显著偏移整个数据集就成为了集体离群点。</p><p><img src="http://files.shanqianche.cn/2021525/1621947763766.png" alt="黑色对象形成集体离群点"></p><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h3><blockquote><p>有些模型的表现一直不错，建议优先考虑。对于大数据量和高纬度的数据集，Isolation Forest算法的表现比较好。小数据集上，简单算法KNN和MCD的表现不错。</p></blockquote><p> <font color="#F6C75A">聚类：</font>将物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。</p><p><font color="#D87E8D">簇：</font>把数据划分为不同类别，机器学习给这个类别定义一个新的名字—簇。</p><h2 id="离群点检测目前遇到的挑战"><a href="#离群点检测目前遇到的挑战" class="headerlink" title="离群点检测目前遇到的挑战"></a>离群点检测目前遇到的挑战</h2><ul><li>正常数据和离群点的有效建模本身就是个挑战,数据没有标签，无法分清正常数据还是异常数据；或者缺乏异常数据；</li><li>离群点检测高度依赖于应用类型使得不可能开发出通用的离群点检测方法，比如针对性的相似性、距离度量机制等；</li><li>数据质量实际上往往很差，噪声充斥在数据中，影响离群点和正常点之间的差别，缺失的数据也可能“掩盖”住离群点，影响检测到有效性；</li><li>检测离群点的方法需要可解释性；</li></ul><h2 id="离群点检测方法"><a href="#离群点检测方法" class="headerlink" title="离群点检测方法"></a>离群点检测方法</h2><h3 id="监督方法"><a href="#监督方法" class="headerlink" title="监督方法"></a>监督方法</h3><p> <strong>➀训练可识别离群点的分类器</strong></p><p><font color="#009688">困难：</font> 1 .两个类别（正常和离群）的数据量很不平衡，缺乏足够的离群点样本可能会限制所构建分类器的能力；<br>2. 许多应用中，捕获尽可能多的离群点（灵敏度和召回率）比把正常对象误当做离群点更重要。</p><blockquote><p>由于与其他样本相比离群点很稀少，所以离群点检测的监督方法必须注意如何训练和如何解释分类率。</p></blockquote><p><strong>➁One-class model，一分类模型</strong></p><pre><code>考虑到数据集严重不平衡的问题，构建一个仅描述正常类的分类器，不属于正常类的任何样本都被视为离群点。比如SVM决策边界以外的都可以视为离群点。</code></pre><h3 id="无监督方法"><a href="#无监督方法" class="headerlink" title="无监督方法"></a>无监督方法</h3><blockquote><p>正常对象在某种程度上是“聚类”的，正常对象之间具有高度的相似性，但是离群点将远离正常对象的组群。<font color="#72A1C3">但是遇到前文所述的集体离群点时，正常数据是发散的，而离群点反而是聚类的</font>,这种情形下更适合<font color="#A98A2F">监督方法</font>进行检测。无监督方法很容易误标记离群点导致许多真实的离群点逃脱检测。</p></blockquote><p><strong>对于传统的聚类方法，有以下几个问题：</strong></p><ul><li>不属于任何簇的对象可能是噪声，而不是离群点；</li><li>先找出簇再找出离群点的开销很大（离群点数量远少于正常对象）；</li></ul><h3 id="半监督方法"><a href="#半监督方法" class="headerlink" title="半监督方法"></a>半监督方法</h3><p>当有一些被标记的正常对象时，可以先使用它们，与邻近的无标记对象一起训练一个正常的对象模型，使用这个模型检测离群点；但是由于具有标记的数据只有少部分，意味着仅仅基于少量被标记的离群点而构建的离群点模型不大可能是有效的。</p><h3 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h3><blockquote><p>假定正常的数据对象由一个统计模型产生，不遵守该模型的数据是离群点。即正常对象出现在该随机模型的高概率区域中，而低概率区域中的对象是离群点</p></blockquote><h4 id="参数方法—壹"><a href="#参数方法—壹" class="headerlink" title="参数方法—壹"></a>参数方法—壹</h4><blockquote><p>基于正态分布的一元离群点检测（仅涉及一个属性或变量的数据）</p></blockquote><ol><li>假定数据由某个正态分布产生，由输入来学习正态分布的参数（μ ，σ）（最大似然估计），通过假设检验的方法，一般认定如果某点距离估计的分布均值超过3σ  ，就被认为是离群点。下面的文章中提到过利用盒图和四分位数据来划分离群点，其原理类似。</li><li>另一种离群点检测方法是Grubb检验（最大标准残差检验），对于数据集中的每个对象x，定义z分数(z-score)为：$z=\frac{|x-\bar{x}|}{s}$ , $\bar{x}$是输入数据的均值，s是标准差。<br>若 $z\geq\frac{N-1}{\sqrt{n}}\sqrt{\frac{t_{a/(2N),N-2}^{2}}{N-2+t_{a/(2N),N-2}^{2}}}$ ,x视为离群点。<br>其中 $t^{2}\alpha/(2N),N-2$ 是显著水平 $\alpha /(2N)$ 下的 $t-$ 分布的值，N是数据集中的对象数。</li></ol><h4 id="参数方法—贰"><a href="#参数方法—贰" class="headerlink" title="参数方法—贰"></a>参数方法—贰</h4><blockquote><p>多元离群点检测<br><font size=1>涉及两个或多个属性或变量的数据称为多元数据。核心思想是把多元离群点检测任务转换成一元离群点检测问题。</font></p></blockquote><ol><li><font color="#032953"><strong>马哈拉诺比斯距离检测多元离群点</strong></font></li></ol><p> 对一个多元数据集，设 $\bar{o}$ 为均值向量，对数据集中的对象 $O$ ，从  $O$ 到 $\bar{o}$ 的马哈拉诺比斯距离为： $$M D i s t(o, \bar{o})=(o-\bar{o})^{T} S^{-1}(o-\bar{o})$$ ,S是协方差矩阵。 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>是一元变量，于是可以对它进行Grubb检验，如果<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>设定为离群点的阈值，则 $o$ 是为离群点。</p><blockquote><p><font color="#DD7ADF">补充知识：</font><a href="https://blog.zuishuailcq.xyz/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">协方差矩阵 | 吾辈之人，自当自强不息！</a><br><font color="#2C7D82">协方差矩阵：</font>计算样本不同维度之间的协方差<br><font color="#348A8A">协方差：</font>一般用来刻画两个随机变量的相似程度</p></blockquote><blockquote><p><font color="#F27611">补充知识：</font><strong>欧氏距离</strong>—–又称欧几里得距离<br>m维空间中两个点之间的真实距离<br>例如二维空间的公式：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi><mo>=</mo><msqrt><msup><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mfenced><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup></msqrt></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi></math> 为点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>与点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced></math>之间的欧氏距离</p></blockquote><blockquote><p><font color="#4D74F2">补充知识：</font><strong>马哈拉诺比斯距离</strong><br>表示数据的协方差距离，它是一种有效的计算两个未知样本集的相似度的方法。<br><strong>思路</strong>：</p><ul><li>将变量按照主成分进行旋转，消除维度间的相关性</li><li>对向量和分布进行标准化，让各个维度同为标准正态分布</li></ul></blockquote><ol start="2"><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math><strong>统计量</strong>的多元离群点检测</li></ol><p>  正态分布的假定下，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量也可以用来捕获多元离群点，对象 $o$ ，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量是：<br>  <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msup><mfenced><mrow><msub><mi>o</mi><mi>i</mi></msub><mo>-</mo><msub><mi>E</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><msub><mi>E</mi><mi>i</mi></msub></mfrac></math></p><blockquote><p><font color="#6B6B6B">统计量：</font><br>是样本测量的一种<em>属性</em>。类似计算样本的平均值。</p></blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>O</mi><mi>i</mi></msub></math>是$o$在第 $i$ 维上的值，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>E</mi><mi>i</mi></msub></math>是所有对象在第 $i$ 维上的均值，而n是是维度。如果对象的 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C7;</mi><mn>2</mn></math>统计量很大，则对象是离群点。</p><ol start="3"><li>混合参数分布检测离群</li></ol><p>  当实际数据很复杂时，假定服从正态分布的话会不太合适，这种情况下假定数据是被混合参数分布产生的。</p><blockquote><p><font color="#1076FF">补充知识：</font><strong>混合分布</strong><br>在概率与统计中，如果我们有一个包含多个随机变量的随机变量集合，再基于该集合生成一个新的随机变量，则该随机变量的分布称为混合分布(mixture distribution)。<br><font color="red">TODO:</font>查阅了<a href="https://blog.csdn.net/tanghonghanhaoli/article/details/90543917">混合分布</a>的三个性质没有理解如何判定离群 </p></blockquote><h4 id="非参数方法—壹"><a href="#非参数方法—壹" class="headerlink" title="非参数方法—壹"></a>非参数方法—壹</h4><p><font color="#DD7ADF">构造直方图</font></p><p>为了构造一个好的直方图，用户必须指定直方图的类型和其他参数（箱数、等宽or等深）。最简单的方法是，如果该对象落入直方图的一个箱中，则该对象被看做正常的，否则被认为是离群点。也可以使用直方图赋予每个对象一个离群点得分，比如对象的离群点得分为该对象落入的箱的容积的倒数。</p><h4 id="非参数方法—贰"><a href="#非参数方法—贰" class="headerlink" title="非参数方法—贰"></a>非参数方法—贰</h4><p><font color="#DD7ADF"><a href="https://blog.csdn.net/pipisorry/article/details/53635895">核密度估计</a></font></p><blockquote><p> <font color="#B22222">补充知识：</font><br> <strong>向量的内积与外积</strong><br> 对于向量a和向量b：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>&#xB7;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mfenced></math><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow></mfenced></math><br> <font color="#00FFFF">内积</font><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#x2219;</mo><mi>b</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><msub><mi>a</mi><mi mathvariant="normal">n</mi></msub><msub><mi>b</mi><mi>n</mi></msub></math>，内积的几何意义是可以用来表征【信息在头脑中的呈现方式】或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影。<br><font color="#FF8C00">外积</font><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#xD7;</mo><mi>b</mi><mo>=</mo><mfenced close="|" open="|"><mtable columnalign="left"><mtr><mtd><mi>i</mi></mtd><mtd><mi>j</mi></mtd><mtd><mi>k</mi></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>1</mn></msub></mtd><mtd><msub><mi>y</mi><mn>1</mn></msub></mtd><mtd><msub><mi>z</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>2</mn></msub></mtd><mtd><msub><mi>y</mi><mn>2</mn></msub></mtd><mtd><msub><mi>z</mi><mn>2</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced><mrow><msub><mi>y</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>i</mi><mo>-</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>j</mi><mo>+</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mi>k</mi></math>，外积的结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。</p></blockquote><p>把每个观测对象看作一个周围区域中的高概率密度指示子，一个点上的概率密度依赖于该点到观测对象的距离，使用核函数对样本点对其邻域的影响建模。核函数K()满足以下两个条件：</p><ol><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mo>&#x222B;</mo><mrow><mo>-</mo><mo>&#x221E;</mo></mrow><mo>&#x221E;</mo></msubsup><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo><mi>d</mi><mi>u</mi><mo>=</mo><mn>1</mn></math></li><li>对于所有的 $u$ 值，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mo>-</mo><mi>u</mi><mo>)</mo><mo>=</mo><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo></math></li></ol><p> 一个频繁使用的核函数是标准高斯函数：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>2</mn><mi>&#x3C0;</mi></msqrt></mfrac><msup><mi>e</mi><mrow><mo>-</mo><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>h</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math></p><blockquote><p><font color="#3B4B6E">补充知识：</font>高斯函数<br>一维形式<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>a</mi><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mi>b</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>c</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math><br>a是曲线尖峰的高度，b是尖峰中心的坐标，c称为标准方差<br><img src="http://files.shanqianche.cn/2021530/1622339515069.png" alt="高斯函数"></p><p><font color="#DD7ADF">二维高斯核函数</font>常用于高斯模糊Gaussian Blur，在数学领域，主要是用于解决热力方程和扩散方程，以及定义Weiertrass Transform<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>exp</mi><mfenced><mrow><mo>-</mo><mfenced><mrow><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>x</mi><mn>2</mn></msubsup></mrow></mfrac><mo>+</mo><mfrac><msup><mfenced><mrow><mi>y</mi><mo>-</mo><msub><mi>y</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>y</mi><mn>2</mn></msubsup></mrow></mfrac></mrow></mfenced></mrow></mfenced></math><br>A是幅值，x。y。是中心点坐标，σx σy是方差，图示如下，A = 1, xo = 0, yo = 0, σx = σy = 1<br><img src="http://files.shanqianche.cn/2021530/1622340032183.png" alt="二维高斯函数"></p></blockquote><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></math> 是随机变量 $f$ 的独立同分布样本，那么概率密度函数的核函数近似为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mover><mi>f</mi><mo>^</mo></mover><mi>h</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mi>h</mi></mrow></mfrac><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced></math>,K()是核函数，h是带宽,充当光滑参数</p><p>对于对象 $o$ ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 给出该对象被随机过程中产生的估计概率。如果 <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 过小，$o$  可能是离群点。</p><h3 id="基于邻近性的方法"><a href="#基于邻近性的方法" class="headerlink" title="基于邻近性的方法"></a>基于邻近性的方法</h3><p>假定一个对象是离群点，如果在特征空间中的最近邻也远离它，即该对象与它的最近邻之间的邻近性显著地偏离数据集中其他对象与它们的近邻之间的邻近性。</p><p>基于邻近性的方法的有效性高度依赖与所使用的邻近性度量，主要有<strong>基于距离</strong>和<strong>基于密度</strong>的离群点检测方法。</p><p><font color="#7FFF00">通俗理解，</font>离群点与近邻点的近邻距离明显大于其它对象与其的近邻的距离。即离群点周边环境明显和其它对象不一样。</p><h4 id="基于距离的离群点检测"><a href="#基于距离的离群点检测" class="headerlink" title="基于距离的离群点检测"></a>基于距离的离群点检测</h4><p>对象给定半径的邻域，如果它的邻域内没有足够多的其他点，则该点被认为是离群点。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mfenced close="||" open="||"><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><mi>r</mi></mrow></mfenced></mfenced></mrow><mrow><mo>&#x2016;</mo><mi>D</mi><mo>&#x2016;</mo></mrow></mfrac><mo>&#x2264;</mo><mi>&#x3C0;</mi></math></p><p><font color="#228B22">r是距离阈值</font>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math>  是分数阈值，对象 $o$ 如果满足上面的式子则是一个  离群点。</p><h4 id="基于密度的离群点检测"><a href="#基于密度的离群点检测" class="headerlink" title="基于密度的离群点检测"></a>基于密度的离群点检测</h4><p>基于距离的检测方法从全局考虑数据集，所找到的离群点都是<strong>全局离群点</strong>，但实际上数据结构更复杂，对象<font color="#8FBC8F">可能</font>关于其局部邻域，而<font color="#8FBC8F">不是</font>整个数据分布而视为离群点。</p><p>基于密度的离群点检测方法基本假定为：<strong>非离群点对象周围的密度与其邻域周围的密度类似，而离群点对象周围的密度显著不同于其邻域周围的密度。</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><mi>D</mi><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></math></p><p>D为数据集，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是对象o第k个近邻的对象之间的距离，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是所有在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 之内的对象集。可以使用 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 中的对象到o的平均距离作为局部密度的度量，但是为了避免比如有非常近的近邻使得距离度量统计产生波动，需要加上光滑效果：<br>$reachdist$<math xmlns="http://www.w3.org/1998/Math/MathML"><mmultiscripts><mfenced><mrow><mi>o</mi><mo>&#x2190;</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mprescripts/><mi>k</mi><none/></mmultiscripts><mo>=</mo><mi>max</mi><mfenced close="}" open="{"><mrow><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced></mrow></mfenced></math><br>k是用户指定参数，控制光滑效果。对象o的局部密度为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>r</mi><msub><mi>d</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><msub><mtext>&#xA0;reachdist&#xA0;</mtext><mi>k</mi></msub><mfenced><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2190;</mo><mi>o</mi></mrow></mfenced></mrow></mfrac></math><br>o的局部离群点因子为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mi>O</mi><msub><mi>F</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><mfrac><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mfenced><msup><mi>o</mi><mo>‘</mo></msup></mfenced></mrow><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfrac></mrow><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></mfrac></math><br>局部离群点因子是o的可达密度与o的k-最近邻可达密度之比的平均值。对象o的局部可达密度越低，并且o的k-最近邻局部可达密度越高，LOF值越高。</p><p><font color="#B8860B">LOF 的思想：</font><br>通过比较每个点 p 和其邻域点的密度来判断该点是否为异常点，如果点 p 的密度越低，越可能被认定是异常点。至于这个密度，是通过点之间的距离来计算的，点之间距离越远，密度越低，距离越近，密度越高，而且这里的密度不是基于全局数据，而是基于局部数据。</p><h3 id="基于聚类的方法"><a href="#基于聚类的方法" class="headerlink" title="基于聚类的方法"></a>基于聚类的方法</h3><p>假定<font color="#556B2F">正常数据</font>对象属于大的、稠密的簇、而<font color="#556B2F">离群点</font>属于小或稀疏的簇，或者不属于任何簇。直截了当的采用聚类方法用于离群点检测开销会很大，不能很好地扩展到大数据集上。</p><ol><li>将离群点检测为不属于任何簇的对象</li><li>最近簇距离的离群点检测</li></ol><blockquote><p>假设o到最近的簇中心为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> ,则o与 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 之间的距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 与指派到 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 这个簇中的对象之间的平均距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></math> ，比率 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></mrow><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></mfrac></math> 度量 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> 与平均值的差异程度。</p></blockquote><ol start="3"><li>识别小簇或稀疏簇</li></ol><blockquote><p>先是找出数据集中的簇，并把它们按照大小降序排列，假定大部分数据点都不是离群点。它使用一个参数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>(</mo><mn>0</mn><mo>&#x2264;</mo><mi>&#x3B1;</mi><mo>&#x2264;</mo><mn>1</mn><mo>)</mo></math>  区别大小簇。任何至少包含数据集中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>%</mo></math> 数据点的簇都被视为大簇，其余为小簇。然后对每个数据点赋予基于簇的局部离群点因子(CBLOF)。对于属于大簇的点，它的CBLOF是簇的大小与该点与簇的相似性的乘积。对于小簇的点，其CBLOF用小簇的大小和该点与最近的大簇的相似性乘积计算。<br>CBLOF代表点属于簇的概率，值越大，点与簇越相似。远离任何大簇的小簇被看作离群点组成，并且具有最低CBLOF值的点怀疑为离群点。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LOF类的算法适用于局部区域空间问题，对于完整区域空间，KNN和Iforest更好。</li><li>KNN每次运行需要遍历所有数据，所以效率比较低，如果效率要求比较高，用聚类方法更好。</li><li>传统机器学习算法中Iforest、KNN和OCSVM表现较好，基于深度学习的算法准确率在论文中更好！</li><li>对于不同种类的数据，没有哪一种算法是最好的，HBOS算法在某些数据集上的表现非常好，且运算速度很快。</li><li>当数据特征数很多时，如400个特征，只有KNN表现还不错，Iforest表现也不好，因为特征选取的随机性，可能无法覆盖足够多的特征（不绝对）。</li><li>ABOD综合效果最差，尽量不要用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA+AI</title>
      <link href="/2021/05/17/RPA+AI/"/>
      <url>/2021/05/17/RPA+AI/</url>
      
        <content type="html"><![CDATA[<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://developer.aliyun.com/group/rpa?spm=a2c6h.12873639.0.0.65b05d65mS6OlC#/?_k=agnoe0">阿里云RPA社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/59034887?utm_oi=786717341600858112">阿里云RPA（机器人流程自动化）系列</a></p><p><a href="https://www.yuque.com/aliyun_rpa">阿里云RPA文档</a></p><p><a href="https://github.com/rpabotsworld/awesome-rpa">资源</a></p><h2 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="阿里云RPA系列"><a href="#阿里云RPA系列" class="headerlink" title="阿里云RPA系列"></a>阿里云RPA系列</h4><ol><li>文件信息的处理–提取和处理结构和半结构化数据</li><li>异常处理–宕机、流程回滚、中断后的流程接续等问题</li><li>业务流程从明确化变为高适配的—智能处理【制定与运行过程中】</li><li>各类场景–大量重复【基本配置通用性高】、可贴合各类场景【规则灵活，外附组件可灵活配置】</li></ol><h4 id="S公司智能财务机器人共享中心建设与实践"><a href="#S公司智能财务机器人共享中心建设与实践" class="headerlink" title="S公司智能财务机器人共享中心建设与实践"></a>S公司智能财务机器人共享中心建设与实践</h4><p><a href="https://m.hanspub.org/journal/paper/34237">URL</a></p><ol><li>分布式部署时，对于资源无法实时有效判断其是否有效可用</li><li>将robot集中到资源池中，供全公司使用，打破单元机器人的壁垒—无法有效的共享数据，但是安全受到了极大威胁</li></ol><h4 id="一种基于RPA机器人共享中心的自动审批的方法【专利】"><a href="#一种基于RPA机器人共享中心的自动审批的方法【专利】" class="headerlink" title="一种基于RPA机器人共享中心的自动审批的方法【专利】"></a>一种基于RPA机器人共享中心的自动审批的方法【专利】</h4><p><a href="http://www10.drugfuture.com/pdfview/generic/web/viewer.html?file=/cnpat/package/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B9%A6CN201911335237.4.pdf">PDF</a></p><ol><li>没有实际创新点，就是为用户提供了访问权限，根据用户自己提交的内容，进行过滤分类，然后由robot进行访问对应的资源进行处理，专利只是讲了研究内容，具体算法和实践没有提到，所以它所涉及到的对机器人共享中心进行分级调度没有表现出来。</li></ol><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><blockquote><p>阿里云版本迭代</p></blockquote><p><img src="http://files.shanqianche.cn/2021517/1621238642819.png" alt="阿里云版本迭代方案"></p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>流程处理未知问题的智能化</li><li>中间通信安全</li><li>重新定义RPA，目前RPA，只是一个外接的控制工具，而不能替代人工</li><li>==* #F44336==挖掘业务流程，结合机器学习进行业务预测</li><li></li></ol><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>无数据比对，无证明方式，用数据证明有效改进</li></ol><p><a href="https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html">https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html</a></p><p><a href="https://www.touqikan.com/jsjj/660421.html">https://www.touqikan.com/jsjj/660421.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> RPA </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TagUI源码阅读及分析</title>
      <link href="/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>idea：</p><ol><li>RPA进程与AI的融合，非BPA那种与业务进行结合</li></ol><h3 id="tagui运行背后的技术支持"><a href="#tagui运行背后的技术支持" class="headerlink" title="tagui运行背后的技术支持"></a>tagui运行背后的技术支持</h3><p><img src="http://files.shanqianche.cn/202156/1620314243708.png" alt="技术支持"></p><ol><li>Automation Flow:作为一种flow 编辑工具，集成在tagui中，允许TagUi可以通过本地文件，在线文件甚至url获取业务流程；</li></ol><ul><li>同时可以通过命令，图表，url，API，email等方式传入参数</li></ul><ol start="3"><li>Chrome Extension 可以通过类似录视频的方式记录用户行为并创建业务流程</li><li>R&amp;Python 提供机器学习模块</li><li>Sikuli 图像识别处理</li><li>CasperJS测试集成工具</li></ol><h3 id="关键技术组成"><a href="#关键技术组成" class="headerlink" title="关键技术组成"></a>关键技术组成</h3><ul><li>SikuliX 用于图像标记、追踪功能</li><li>phantomJs 是一种轻量级脚本语言（环境简单）</li><li>casperjs中基于PhantomJS和SlimerJS的导航脚本和测试工具，包函了对于一些对于网页的基本操作的工具</li><li>SlimerJS与phantomjs类似，互相补充</li></ul><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>end_process: 通过扫描进程，按顺序杀死进程比Ctrl+C更加安全可靠</li><li>erina:==与tagui——helper有关，暂时无法看懂 #009688==</li><li>sleep: 补充win10环境中对于进程延迟的控制</li><li>tagui：TagUI接受脚本和参数</li><li>tagui_chrome: 用于连接chrome，通过控制浏览器发送和接收数据</li><li>tagui_crontab: 运行tagui服务端tagui_service</li><li>tagui_footer: 输出当前网站的url和title</li><li>tagui_global: ==暂时不懂 #009688==</li><li>tagui_header: ==作为一个工具包 #009688==</li></ul><h3 id="功能实现详细阐述"><a href="#功能实现详细阐述" class="headerlink" title="功能实现详细阐述"></a>功能实现详细阐述</h3><ol><li>监控对应任务进程进行杀死【php,chrome,sikuli,python,r,tagui】</li><li>sss</li><li>在Windows环境中无法进程设置延时，所以通过ping.exe补充功能</li><li>tagui框架入口源码交易理解，不做详细分析</li><li>tagui_chrome主要是依赖Textalk实现与chrome并发通信,同时它集成了Sikuli，可以通过图像识别实现业务流程</li><li>通过监控服务端状态，运行或者重复运行tagui_service</li><li>利用casperJs抓取当前脚本的url和title</li><li>sss</li><li>sss</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><a href="https://zhuanlan.zhihu.com/p/366304958">https://zhuanlan.zhihu.com/p/366304958</a><br><a href="https://github.com/kensoh/TagUI/tree/before_aisg">https://github.com/kensoh/TagUI/tree/before_aisg</a></p><h4 id="shell语言规范"><a href="#shell语言规范" class="headerlink" title="shell语言规范"></a>shell语言规范</h4><p><a href="https://www.cnblogs.com/zrmw/p/9625727.html">https://www.cnblogs.com/zrmw/p/9625727.html</a></p><p><a href="https://blog.csdn.net/weixin_37766087/article/details/99974385">https://blog.csdn.net/weixin_37766087/article/details/99974385</a></p><h4 id="curl工具"><a href="#curl工具" class="headerlink" title="curl工具"></a>curl工具</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><a href="https://blog.csdn.net/shenhuan1104/article/details/75852822">https://blog.csdn.net/shenhuan1104/article/details/75852822</a></p><p>grep -iq 404 ，匹配到404，则返回1；反之</p><h4 id="业务流程模型（BPMN）"><a href="#业务流程模型（BPMN）" class="headerlink" title="业务流程模型（BPMN）"></a>业务流程模型（BPMN）</h4><h4 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h4><p>CasperJS + PhantomJS==》Puppeteer + Node.js引擎</p><p><a href="https://blog.csdn.net/qq_38941937/article/details/110296665">https://blog.csdn.net/qq_38941937/article/details/110296665</a></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>流式无并行</li></ol><h4 id="开题失败—题目比较无实际意义"><a href="#开题失败—题目比较无实际意义" class="headerlink" title="开题失败—题目比较无实际意义"></a>开题失败—题目比较无实际意义</h4><p><img src="./attachments/RPA%E5%8A%A8%E6%80%81%E6%84%9F%E7%9F%A5%E5%88%86%E9%85%8D%E4%B8%9A%E5%8A%A1%E8%B5%84%E6%BA%90%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> code </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA</title>
      <link href="/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/"/>
      <url>/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/</url>
      
        <content type="html"><![CDATA[<h2 id="RPA"><a href="#RPA" class="headerlink" title="RPA"></a>RPA</h2><h3 id="进化历史"><a href="#进化历史" class="headerlink" title="进化历史"></a>进化历史</h3><ol><li>上个世纪二十年代 亨利·福特，改革了工业生产方式，开启了工业时代，提出了对于处理重复工作的需求</li><li>1990-2000，计算机被广泛使用，用于处理办公，提出批处理脚本和触发器</li><li>2000-2015，VBA宏编程（EXCEL宏）和BPA</li><li>2015-2018，RPA模型创建成功，并投入使用</li><li>2019~，RPA+AI，即RPA4.0被推出，被大企业认可</li></ol><p>1.2. 反应了为了解决重复工作，提出了批处理事务<br>脚本自动化：在RPA技术出现之前，脚本自动化是企业自动化可选的比较靠谱自动化落地技术。用于解决最基础的几步任务自动化，技术的缺点是没有容错、任务管理、弱鸡的基于GUI的能力。商业上的优势是，几乎可以免费使用。<br>3. VBA编程语言的创建是为了解决办公中常遇到的重复性问题【简单化】、BPA（业务流程自动化）通过深度关注业务流程，集成所有相关应用程序来实现功能，业务的实现与程序耦合太重【复杂化】</p><p>目前给出三个区别：<br><strong>集成</strong>：BPA相较于RPA对于一个业务流程提出了更加全面、更加精确的解决方法，但是BPA是一种侵入性很强的整合形式。它用自己的软件对现有的系统进行大修，并实现自己的系统。RPA不会破坏现有的业务流程。【存在优缺点】<br><strong>工作流</strong>：RPA机器人访问桌面现有的用户界面并执行人工任务，但是目前大多数机器人无法进行决策。BPA中使用的工作流程更加复杂，使用单一的处理模型来创建集成多种系统的工作流程。这些系统彼此交换和提取信息，以实现任务自动化，这需要API和数据库访问。这需要对编码和开发的大量IT支持。【应用场景的不同，无优缺点之分】<br><strong>定价</strong>：BPA定价取决于公司的规模。还有其涉及到的业务的规模。UiPath(RPA龙头企业)更加使用RPA类型来定价。【站在技术方面，RPA更加灵活，也更加适用】<br>4. 通过集成现有的业务不紧破坏了已有业务，同时过度的耦合、高昂的成本和无法普遍推广，这些条件都指定了传统化业务自动化流程只能为大公司所用。<br>这个时候屏幕抓取技术的诞生就突破了传统BPA的过度耦合的问题，它不需要过度依赖以前的业务来获取和处理数据，同时自动化与管理工具（管理系统的版本，安装，卸载等）使得RPA更易于推广，最后一个就是AI的加入，它是解放人类双手的核心，它可以根据人类先前的判断来执行任务。<br>5. RPA4.0的提出 我们不仅要看到AI为RPA提供的红利，同时也要看到RPA技术对于AI技术发展的重要意义，RPA为AI技术的发展提供了手和脚，RPA作为AI技术与现实生活的连接器，扩大了AI技术的使用范围</p><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>RPA的核心是通过自动化、智能化技术来“代替人”进行重复性、低价性、无需人工决策等固定性流程化操作，从而有效的提高工作效率，减少错误。</p><p>The main difference between software<br>robots and applications is the identity access<br>management (IAM) domain —  RPA instances<br>behave like an individual user. </p><h3 id="RPA进化四个阶段"><a href="#RPA进化四个阶段" class="headerlink" title="RPA进化四个阶段"></a>RPA进化四个阶段</h3><p><img src="http://files.shanqianche.cn/2021413/1618314304547.png" alt="四个阶段"></p><p>1：辅助性RPA（Assisted RPA）<br>　　在RPA 1.0阶段，作为“虚拟助手”出现的RPA，几乎涵盖了机器人自动化的主要功能，以及现有桌面自动化软件的全部操作。部署在员工PC机上，以提高工作效率。缺点则是难以实现端到端的自动化，成规模地应用还很难。<br>　　2：非辅助性RPA（Unassisted RPA）<br>　　在RPA 2.0阶段，被称为“虚拟劳动力”的RPA，主要目标即实现端到端的自动化，以及虚拟员工分级。主要部署在VMS虚拟机上，能够编排工作内容，集中化管理机器人、分析机器人的表现等。缺点则是对于RPA软件机器人的工作仍然需要人工的控制和管理。<br>　　3：自主性RPA（Autonomous RPA）<br>　　在RPA 3.0阶段，其主要目标是实现端到端的自动化和成规模多功能虚拟劳动力。通常部署在云服务器和SaaS上，特点是实现自动分级、动态负载平衡、情景感知、高级分析和工作流。缺点则是处理非结构化数据仍较为困难。<br>　　4：认知性RPA（Cognitive RPA）<br>　　RPA 4.0将是未来RPA发展的方向。开始运用人工智能、机器学习以及自然语言处理等技术，以实现非结构化数据的处理、预测规范分析、自动任务接受处理等功能。<br>　　目前，尽管大多数RPA软件产品，都还集中在2.0 - 3.0之间，但其发展已相当成熟，产品化程度亦是很高。一些行业巨头已经开始向RPA 4.0发起了探索。</p><h3 id="播放几个视频"><a href="#播放几个视频" class="headerlink" title="播放几个视频"></a>播放几个视频</h3><h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>轻量级IT，任何电子设备都可以被操控，<br>智能客服、智能家居，以及很多重复性较高、朝左流程固定的办公工作都可以被替代</p><h2 id="国内外现状"><a href="#国内外现状" class="headerlink" title="国内外现状"></a>国内外现状</h2><p>就国内外发展现状进行对比，全球五强RPA占有47%的市场，中国国产RPA目前智能更多被使用在能源、医疗、政务等一些领域。</p><h3 id="国内外"><a href="#国内外" class="headerlink" title="国内外"></a>国内外</h3><p><img src="http://files.shanqianche.cn/2021412/1618235359990.png" alt="国内外RPA"></p><p>国内主要厂商：来也科技、达观数据、云扩科技、艺赛旗、阿里云等<br>国外及世界领先的厂商：UiPath(免费社区版)、Blue Prism、Automation Anywhere</p><p>虽然国际RPA依旧扮演领导者和行业的规则的制定者，但是在各种新技术与RPA融合进程中，以及在生态建设成为RPA厂商主要竞争力的主流打法上，国产RPA并没有落后。甚至在一些方面，已经超越某些国外厂商。</p><p>可以通过近几年的融资金额和市场估值可以看出国产RPA也在蓬勃发展。</p><p><img src="http://files.shanqianche.cn/2021413/1618313802380.png" alt="2020年融资"></p><p><img src="http://files.shanqianche.cn/2021413/1618314424625.png" alt="近五年的投资事件"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><a href="https://zhuanlan.zhihu.com/p/275757075">https://zhuanlan.zhihu.com/p/275757075</a></p><h3 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h3><p><img src="http://files.shanqianche.cn/2021413/1618316991750.png" alt="UiPath服务器平台三层逻辑"></p><p>1）表示层<br>数据REST API端点<br>通知API<br>Web应用程序<br>2）Web服务层xiac<br>业务逻辑实现（下层为单个任务节点的实现提供服务，上层是bot根据任务队列，任务组成等多因素来控制任务执行）<br>3）持久层<br>弹性搜索<br>SQL服务器</p><p><img src="http://files.shanqianche.cn/2021413/1618317691754.png" alt="设计框架"></p><ol><li>开发人员在UiPath Studio中构建流程</li><li>使用Development Orchestrator和Quality Assurance Qrcheestrator对其进行测试；完成后，他们将工作流（未打包）签入uiatph中主UiProcess Library文件夹（在VCS上）</li><li>将工作流封装，并保存到QA，为本机专有使用</li><li>如果在测试期间发现任何问题，则重复上述步骤。</li><li>一旦所有的QA测试都通过了，包就被复制到生产环境（P包）</li><li>生产过程正在进行，由生产机器人运行</li></ol><ul><li><p>UiPath由studio（开发工具），Orchestrator（自动化云平台和监控平台），robot（运行已开发的机器人服务）组成</p></li><li><p>Robot分为Front Office Robot和Back Office Robot.缩写分别为FOR和BOR。 FOR需要手工启动。</p></li><li><p>BOR需要配合Orchestrator启动。</p></li><li><p>现在又分别叫Attended和Unattended：</p></li><li><p>Attended要有人照看，不能在电脑锁屏的状态下运行自动工作流</p></li><li><p>Unattended不用人工照看，可以在电脑锁屏的状态下运行自动工作流，由Orchestrator远程执行</p></li></ul><blockquote><p>Invokes Repository 调用（调用存储库）==公用部分，被多方调用 #00BCD4==<br>Reusable Code Library 可重用代码库</p></blockquote><p><img src="http://files.shanqianche.cn/2021413/1618320047098.png" alt="新版设计框架"></p><ul><li>提供免费社区版</li><li>产品线丰富，拓展了AI、process mining方面的能力</li><li>它提供了多种托管选项，例如云环境，虚拟机和终端服务</li><li>它支持各种Web和桌面应用程序</li><li>它支持自动登录功能来运行机器人</li><li>它包括可与 .Net，Java，Flash，PDF，Legacy，SAP配合使用的抓取解决方案，且准确性最高</li></ul><h3 id="阿里云RPA"><a href="#阿里云RPA" class="headerlink" title="阿里云RPA"></a>阿里云RPA</h3><p><img src="http://files.shanqianche.cn/2021413/1618321774264.png" alt="流程编辑器"></p><p><img src="http://files.shanqianche.cn/2021413/1618323038585.png" alt="整体结构"></p><p>阿里云RPA4.0采用主流C/S架构模式，前端客户端采用.net平台，基于Windows系统具有自主研发的SDK及各项功能，后端服务端采用Linux（CentOS）操作系统，提供各类后台服务和组件。</p><ul><li>对接阿里达摩院，NLP、OCR等人工智能能力深度整合，让机器人更智能</li><li>拥有丰富的SDK自动化模块，支持自定义SDK库</li><li>阿里云统一售后支持体系</li></ul><p><img src="http://files.shanqianche.cn/2021413/1618323129695.png" alt="场景"></p><h3 id="实在智能-章鱼数字员工"><a href="#实在智能-章鱼数字员工" class="headerlink" title="实在智能-章鱼数字员工"></a>实在智能-章鱼数字员工</h3><p>解决问题：<br>    - 用户可以根据自身需求指定AI套件<br>    - 通用AI能力精度不足</p><p><img src="http://files.shanqianche.cn/2021415/1618463061303.png" alt="AaaS架构"></p><ol><li>RPA与算法平台进行无缝衔接</li></ol><p><img src="http://files.shanqianche.cn/2021415/1618463296265.png" alt="与算法平台衔接"></p><p>【视频–实在智能】</p><ol start="2"><li>集群以及AI定制</li></ol><blockquote><p>不同的系统对于计算能力，内容，硬盘以及网络的要求是不同的，可以根据系统不同分集群部署，不如算法运行在GPU上，而小型数据中台选择数据库服务器集群等；同时用户可以根据自身要求，选择算法和算法服务集群。</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618463370738.png" alt="根据用户需求定制"></p><ol start="3"><li>算法开发训练</li></ol><blockquote><p>集成传统BPA的优势，为当前业务提供更加精确的算法</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618463186299.png" alt="算法开发训练"></p><p><strong>产品优势：</strong></p><blockquote><p>北斗****<br>1.传统的无锚点拾取，只能在简单场景<br>2.当页面中出现相同元素时通过附近元素进行判断并标识,选择不当容易导致流程失败<br>3.完全无感知的自动锚点选择，通过step-of-out图神经网络技术学习页面上的拓扑关系</p></blockquote><blockquote><p>神盾<br>通过监控流程，如果发生异常，则通过北斗自动修复元素来修正自动流程</p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjE2NjQ0Ng==&mid=2247484934&idx=1&sn=d7d105996c81ac9af8a5567a6db799aa&chksm=ea930fc7dde486d137d60d0a013db9d2f7390c0b3876da95a47ef8b0f17857fbab6fa40bd17b&scene=21#wechat_redirect">开源框架</a></p><blockquote><p>魔镜</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618464900207.png" alt="自动化开发"></p><p><img src="http://files.shanqianche.cn/2021415/1618464926504.png" alt="魔镜"></p><p>  目前各大公司对于RPA的使用多处于RPA2.0-RPA3.0之间，即需要RPA开发者介于，而魔镜这种通过视频与日志结合的开发模式将很大程度降低客户使用成本。</p><h3 id="框架总结"><a href="#框架总结" class="headerlink" title="框架总结"></a>框架总结</h3><p>RPA解决方案是依托于各类先进信息技术手段的虚拟劳动力，根据预先设定的程序操作指令对任务进行自动化处理，实现业务流程由机器人自动化处理。</p><p><strong>RPA能做的</strong></p><p><img src="http://files.shanqianche.cn/2021413/1618320374905.png" alt="可以满足我们的"></p><p><img src="http://files.shanqianche.cn/2021413/1618323364197.png" alt="新的行业标准"></p><ol><li>作为辅助甚至代替传统职工的工作软件，它需要员工的权限，但是却又脱离了系统的安全保障，这就造成了安全危机。<br>任子旭的对于网络安全和内部合规的提议：<br>对网络安全和内控合规的要求和约束时，主要是两个思路：<strong>遵从和自证清白</strong>。</li></ol><p><img src="http://files.shanqianche.cn/2021413/1618320690337.png" alt="保障安全"></p><ol start="2"><li>作为一个辅助软件，本身高效性的前提是与相对应的工作量对照的，这就需要在配置时根据公司业务量来取舍，防止资源被浪费</li><li>虚拟化和环境一致性。整个项目的交付过程中，并没有那么简单。我们要考虑空间环境、系统环境、程序适用、版本兼容等多个因素。</li></ol><p><img src="http://files.shanqianche.cn/2021413/1618320927712.png" alt="部署中的注意点"></p><h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>RPA到底可以发展到什么程度？</p><h3 id="可研究点"><a href="#可研究点" class="headerlink" title="可研究点"></a>可研究点</h3><h4 id="RPA-网络安全风险"><a href="#RPA-网络安全风险" class="headerlink" title="RPA 网络安全风险"></a>RPA 网络安全风险</h4><ol><li>滥用特权访问</li></ol><ul><li>攻击者可能能够危及机器人使用的管理员帐户。攻击者可以使用管理员帐户获得对敏感数据的访问权限</li><li>在离职之前，前员工可以编程机器人删除重要数据并中断业务流程</li></ul><ol start="2"><li>披露敏感数据</li></ol><ul><li>机器人开发人员可能会错误地编写BOT，以将高机密数据（例如信用卡信息）上传到公众通过Web访问的数据库。</li><li>机器人开发人员可以使用他或她的账户窃取业务其他服务信息</li></ul><ol start="3"><li>安全漏洞</li></ol><ul><li>虚拟机环境中可能存在安全漏洞，这是机器人运行的环境。</li><li>机器人开发人员编程机器人发送/接收敏感数据而不加密。此数据很脆弱，可以由攻击者利用</li></ul><ol start="4"><li>拒绝服务</li></ol><ul><li>一些不良的编程实践可以使机器人消耗所有虚拟机系统资源并导致虚拟机变得无响应，因此无法执行任何工作</li><li>虚拟机可能受到计划受到计划升级或网络维护的影响，可能导致中断损失。</li></ul><p><strong>应对策略</strong></p><ol><li>先进的职责分工，这就限制RPA用户只能执行分配给分配的任务，并且它们没有提升访问权限。同时也要限制代码开发人员与使用者的行为。</li></ol><p><img src="http://files.shanqianche.cn/2021414/1618390329616.png" alt="主要RPA角色"></p><ol start="2"><li>数字身份认证和凭证的发放与验证，大部分黑客攻击都是在凭据被损害后发起的。为了避免这种情况，就需要设置机器人为最小的特权角色，那么机器人只能执行它的设计，并且其用户角色不能用于执行其他功能</li><li>数据加密，保证数据在传输过程前被加密，以及作业完成后删除。</li><li>监视日志并在内部控件损坏时执行审计，机器人活动可用于监测异常行为并进行审计，以防问题存在问题。</li><li>在发布生产代码之前，需要先扫描代码的漏洞，可以通过一些工具实现，Dynamic Application Security Testing (DAST) 【动态应用安全测试】and Fortify. </li></ol><h4 id="业务流程转型，RPA部署的效率、评估和解决方案"><a href="#业务流程转型，RPA部署的效率、评估和解决方案" class="headerlink" title="业务流程转型，RPA部署的效率、评估和解决方案"></a>业务流程转型，RPA部署的效率、评估和解决方案</h4><h4 id="对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等"><a href="#对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等" class="headerlink" title="对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等"></a>对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等</h4><h4 id="分区平台的共享服务必然会被需求较小的公司需求"><a href="#分区平台的共享服务必然会被需求较小的公司需求" class="headerlink" title="分区平台的共享服务必然会被需求较小的公司需求"></a>分区平台的共享服务必然会被需求较小的公司需求</h4><h4 id="跨平台的应用操作能力"><a href="#跨平台的应用操作能力" class="headerlink" title="跨平台的应用操作能力"></a>跨平台的应用操作能力</h4><h4 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h4><h4 id="RPA开发运维"><a href="#RPA开发运维" class="headerlink" title="RPA开发运维"></a>RPA开发运维</h4><p>从软件供应商转变为服务供应商<br>在共享服务中，自动化会变得极其慢，集群</p><h3 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h3><p>UiPath、tensorFlow</p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个RPA框架通读</title>
      <link href="/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/"/>
      <url>/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Robot-Framework"><a href="#Robot-Framework" class="headerlink" title="Robot Framework"></a>Robot Framework</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>接受测试驱动开发（ATDD），行为驱动开发（BDD）和机器人流程自动化（RPA）</li><li><a href="https://robotframework.org/#examples">社区</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Robot Framework的环境搭建</p></blockquote><ol><li>安装wxpython需要安装wheel，不然无法打包安装======</li><li>需要安装与chrome版本匹配的driver到目录中</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li>通过代码来进行生产</li></ol><ul><li>项目组成</li></ul><p><img src="http://files.shanqianche.cn/202136/1615015210514.png" alt="项目组成"></p><blockquote><p>项目见压缩文件—项目一，下面是robot的代码结构组成</p></blockquote><p><a href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst#executing-this-guide">参考文档</a></p><p>robot核心结构是由三部分组成的，一个是keywords的依赖，第二个是关键字，最后则是执行动作</p><p><img src="http://files.shanqianche.cn/202136/1615015362634.png" alt="robot结构"></p><p><img src="http://files.shanqianche.cn/202136/1615015469911.png" alt="关键字组成"></p><p><img src="http://files.shanqianche.cn/202136/1615015588995.png" alt="动作"></p><p>运行效果，打包视频-robot1【视频总一个robot执行了两动作，所以结果都是两个】</p><p><img src="./videos/robot1.mkv" alt="robot1"></p><ol start="2"><li>通过较为成熟的工具–robocorp Lab</li></ol><p>==此工具可以实现的，robot framework都可以实验 #009688==</p><ul><li>结构组成</li></ul><p><img src="http://files.shanqianche.cn/202136/1615016378239.png" alt="项目结构"></p><p><img src="http://files.shanqianche.cn/202136/1615016399861.png" alt="robot结构"></p><ul><li>较为简单的栗子，自动打开浏览器然后访问url</li></ul><p><img src="./videos/robocorp1.mkv" alt="robocorp1"></p><ul><li>另一个栗子，登录功能的测试</li></ul><p><img src="./videos/robocorp2.mkv" alt="robocorp2"></p><blockquote><p>总结：和邹瑞进行过交流确实这个框架确实可以提升测试效率，由于执行动作可以通过传参来改变动作执行对象，所以可重复度明显提升，目前没有感觉到人工智能的应用点，下步继续了解。</p></blockquote><h2 id="TagUI"><a href="#TagUI" class="headerlink" title="TagUI"></a>TagUI</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><pre><code>    就是传统的，较为灵活但是复用性低；这个框架可以控制鼠标模拟动作    </code></pre><p><img src="http://files.shanqianche.cn/202136/1615018851173.png" alt="代码结构"></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol><li><p>访问网站并截图</p><p> <img src="http://files.shanqianche.cn/202136/1615019129522.png" alt="源码"></p></li></ol><p><img src="./videos/tagui_1.mkv" alt="tagui_1"></p><p>==tagui在模拟人的行为上确实比robot framework #00BCD4==</p><ol start="2"><li>访问github上项目并下载等待完成</li></ol><p><img src="./videos/tagui_2.mkv" alt="tagui_2"></p><ol start="3"><li>可以通过表格来设置参数，高重复性</li></ol><p>  <img src="./videos/tagui_3.mkv" alt="tagui_3"></p><pre><code>      还有一些官方也提到可以获取数控中数据来进行测试，也可以通过中文命令来测试等</code></pre><h2 id="UI-Vision"><a href="#UI-Vision" class="headerlink" title="UI.Vision"></a>UI.Vision</h2><blockquote><p>有两个，一个是浏览器插件，另一个是桌面版。桌面版适用于手机上app的测试【没有进行实验】</p></blockquote><p><img src="./videos/2021-03-06_17-29-08.mkv" alt="2021-03-06 17-29-08"></p><p>总结：很傻瓜式，所有动作需要一模一样，否则无法找到指定的属性来换参，前面有一点不一样，后面将可能无法执行。</p><h2 id="open-RPA"><a href="#open-RPA" class="headerlink" title="open RPA"></a>open RPA</h2><p><a href="https://open-rpa.readthedocs.io/en/latest/">https://open-rpa.readthedocs.io/en/latest/</a></p><p><a href="https://docs.openiap.io/">https://docs.openiap.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block chain transaction privacy protection method and system</title>
      <link href="/2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/"/>
      <url>/2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/</url>
      
        <content type="html"><![CDATA[<p><a href="https://patents.google.com/patent/WO2019080933A1/zh">https://patents.google.com/patent/WO2019080933A1/zh</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>解决交易信息透明，造成隐私信息暴露</li><li>论文提出解决方案使用到了秘密共享方式，解决共谋问题</li><li>确保关键字安全性</li></ol><h4 id="预处理方法"><a href="#预处理方法" class="headerlink" title="预处理方法"></a>预处理方法</h4><ol><li>将层次属性加密与线性秘密共享相结合，提出了一种基于可搜索属性加密的区块链数据隐私保护控制方案，解决了传统区块链交易中的隐私暴露问题。</li><li>用户的访问控制由验证节点实现，避免了向区块链网络提交私钥和访问结构的安全风险。将私钥组件与区块链中用户节点的随机身份相关联可以解决共谋问题</li><li>授权用户可以通过可搜索的加密来快速搜索和监督交易信息。改进的算法确保了关键字的安全性。【算法应该看不懂】</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li><p>提出基于椭圆曲线加密算法m的更有效的盲签名混合方案—该方案简单易用，通常适用于各种数字货币，【但它是集中式货币方案】。</p><blockquote><p>传统公钥密码体制（密钥长度一般为512bit）随着计算机运算速度的提升，已经有被破解的趋势了，同时RSA运算效率较低。利用曲线上的有理点组成的Abel群《TODO》及其上离散对数问题求解的困难性构成一些公钥密码体制，即密钥的每个bit都具有最高的安全强度，椭圆曲线密码体制中160bit长的密钥所展示的安全强度相当于RSA的1024bit</p></blockquote></li><li><p>使用盲签名之类《TODO》的混合加密技术—区块链隐私保护机制【增加了技术成本，并且第三方实施令牌处理不可避免地增加了额外的服务开销】</p></li><li><p>提出了一种改进的基于环的秘密交易方案《TODO》</p><blockquote><p>在该方案中，大量的环签名被放置在可链接的自发匿名组签名的多层中，其解决方案可以保护身份隐私和交易隐私。尽管环签名提供了强大的匿名性，但它具有三个限制：产生交易数据较多，需要更多的记录的存储空间、签名的大小与参与者数量成正比，因此传统每个事务做了限制，每个事务有四个输出、隐藏的数量增加了检查的难度，即，它不仅验证交易期间是否生成了秘密加密货币，而且还确定了特定时刻的额外数量。</p></blockquote></li></ol><h3 id="初步知识"><a href="#初步知识" class="headerlink" title="初步知识"></a>初步知识</h3><h4 id="Bilinear-Mapping"><a href="#Bilinear-Mapping" class="headerlink" title="Bilinear Mapping"></a>Bilinear Mapping</h4><blockquote><p>双线性映射</p><blockquote><p>群</p><ol><li>封闭性——如果a和b都属于G，则a+b也属于G。</li><li>结合律——对于G中的任意元素a、b和c，都有（a+b）+c=a+（b+c）成立。</li><li>单位元——G中存在元素e，对于G中任意元素a，都有a+e=e+a=a成立。</li><li>逆元——对于G中任意元素a，G中都存在元素a’，使得a+a’=a’+a=e成立。G就叫作一个群，记为（G，+）</li><li>在群中定义求幂运算为重复使用群中的运算，如a^4 =a+a+a+a。规定a^0 =e为单位元。如果一个群的所有元素都是a的幂a^k，则称这个群是一个==循环群 #00BCD4==，这里的k是整数。a也被称为这个群的生成元。</li></ol></blockquote></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734193371.png" alt="双线性映射"></p><p>设G1、G2都是阶为p的循环群，p是素数。如果映射e: G1 × G1 → G2 满足以下性质：</p><ol><li>双线性性。<br>对于任意a，b∈Z<sub>p</sub>和R，S∈G1，有e(R<sup>a</sup>, S<sup>b</sup>) = e(R, S)<sup>ab<sup>；</li><li>非退化性。<br>存在R，S∈G<sub>1</sub>，使得e(R, S) ≠ 1<sub>G2</sub>。这里1<sub>G2</sub>代表G2群的单位元；</li><li>可计算性。<br>存在有效的算法对任意的R，S∈G<sub>1</sub>，计算e(R, S)的值。<br>那么称<strong>e</strong>是一个<strong>双线性映射</strong>。</li></ol><h4 id="Determining-the-Bilinear-Diffie–"><a href="#Determining-the-Bilinear-Diffie–" class="headerlink" title="Determining the Bilinear Diffie–"></a>Determining the Bilinear Diffie–</h4><p>ellman Assumption (DBDH)</p><blockquote><p>确定双线性参数生产区的假设（DBDH）</p></blockquote><p>选择一个G1的生成器，设a,b,c,r属于（1，q-1）中任意质数，当g^a,g^b,g^c,g^r属于G1，e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>属于G2,判断<strong>e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>是否相等</strong></p><p><strong>判断条件：</strong><br>对于任意多项式概率时间算法的对手A，解决决策双线性Diffie-Hellman（DBDH）假设[i]的优势定义为</p><p><img src="http://files.shanqianche.cn/20201223/1608734247064.png" alt="DBDH判断条件"></p><p>如果确定的值Adv<sup>DBDH</sup><sub> A</sub>可忽略不计，则将建立决策双线性Diffie-Hellman假设。</p><h4 id="Lsss-Linear-Secret-Sharing-Scheme"><a href="#Lsss-Linear-Secret-Sharing-Scheme" class="headerlink" title="Lsss Linear Secret Sharing Scheme"></a>Lsss Linear Secret Sharing Scheme</h4><blockquote><p>Lsss线性秘密共享方案【是对密钥的管理策略】</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/95362628">有趣的栗子</a></p><p>在信息系统中使用的秘密共享，可以防止系统密钥的遗失、损坏和来自地方的攻击，减小秘密保存者的责任。在(t,n)秘密共享体制中，秘密分发者将一个秘密信息分成n个秘密份额，分发给n 个人，当需要恢复秘密信息时，任意少于t个的秘密保存者都得不到该秘密的任何信息。<br>现目前进行秘密共享的主流方案有基于访问控制树和秘密共享矩阵的。基于访问控制树进行秘密分享时，通过门限控制进行合理的多项式构造，最终将秘密分享给树的每一个子节点。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><blockquote><p>基于可搜索属性加密的区块链数据隐私访问控制系统模型如图</p></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734364209.png" alt="基于可搜索属性加密的区块链数据隐私访问控制系统模型"></p><blockquote><p>包含的四个实体</p></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734388573.png" alt="四个实体"></p><ol><li>数据所有者：首先进行初始化，生成索引密钥和陷门密钥，提取交易的关键词，然后使用索引密钥对索引进行加密，形成索引密文；其次，对陷门密钥进行加密以形成陷门密钥密文并共享数据。最后，使用安全签名算法对交易进行签名并加密，同时，数据所有者将索引关键字附加到交易密文的密文文件中。最重要的是，数据所有者可以是区块链上进行比特币交易的用户或矿工。</li><li>用户：注册系统生成与真实身份相对应的身份标识符RID和与用户属性相对应的私钥。另外，用户解密陷门密文并使用 用户密钥以生成陷门，然后发送区块链以请求交易密文。</li><li>验证节点：验证用户身份和权限的正确性，并在属性集合中计算用户的属性和私钥参数以及权限参数，以分发陷密钥密文，并将用户密钥UK分发给合法用户。</li><li>矿工节点：矿工节点在此期间广播所有交易信息，每个节点执行验证并在验证后加入区块链。计算并匹配数据所有者发送的陷门和索引，然后在匹配成功后将交易密文发送到数据使用方。</li></ol><h4 id="威胁模式"><a href="#威胁模式" class="headerlink" title="威胁模式"></a>威胁模式</h4><p><strong>前提：</strong> 只有“验证节点”是完全可信的，私钥能正常生成和分发给用户。大多数矿工节点半诚实【不破坏协议，根据规则可以推测用户信息】。此外，用户可能会合谋解密他们无法访问的数据。</p><h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><p><strong>安全模型是指对手与挑战者之间的博弈。</strong></p><ol><li>IND-CPA security model【Indistinguishability under chosen-plaintext attack】</li></ol><blockquote><p>选择明文攻击。可理解为攻击者拥有加密机的使用权限，可以加密自己想加密的任何明文。攻击目的：由明文和对应的密文来分析和推断加密算法的信息，主要是加密密钥。</p></blockquote><ul><li>初始化：挑战者A使用初始化算法生成公共参数和主密钥【重复使用的密钥，对称密钥】，并将主密钥发送给对手C。—-<em>每次通信只使用一次的密钥称为会话密钥（session key）。相对于会话密钥，重复使用的密钥称为主密钥（master key）。</em></li><li>第一步：对手C重复尝试一组属性S1-Sq，但是没有属性满足访问</li><li>挑战：对手C选择两条消息M0; M1并将它们发送给挑战者A。挑战者A选择0或者1，和加密的访问结构的消息M，并将密文发送给对手C</li><li>第二步：</li></ul><ol start="2"><li>IND-CKA security model</li></ol><blockquote><p>关键字攻击</p></blockquote><h3 id="具体结构即功能实现"><a href="#具体结构即功能实现" class="headerlink" title="具体结构即功能实现"></a>具体结构即功能实现</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>用户向系统提交注册申请，获取真实身份信息对应的身份RID和用户属性集，数据所有者（交易用户）进行注册获取密钥和身份标识。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://blog.csdn.net/zhangwenjiezw886/article/details/51006774">双线性</a></p><ol><li>数据拥有者:：选择一个以质数为序的群G<sub>0</sub>,用元素g(单位元)生成群，在限制字段中选择N个元素(N为阶)，并使用系统属性形成系统属性集S，并根据属性之间的相关性来确定S中的属性。S被分为x个树，H<sub>i</sub>被设置为i个树的深度，H为树中最大深度；随机选择向量U=(U<sub>y</sub>)<sub>1=&lt;x=&lt;y</sub>和U’=(U’<sub>y’</sub>)<sub>1=&lt;x‘=&lt;y’</sub>，u<sub>y</sub>代表与y属性树相对应的public参数，数据所有者选择素数p的序列，并生成群G<sub>1</sub>,H<sub>1</sub>。数据拥有者选择两个随机数η(姨塔)，μ(谬)，然后计算生成公钥PK={g,g<sup>μ</sup>}和私钥SK=η代表陷门。</li><li>验证结点：Z<sup>*</sup><sub>p</sub>在有限域中用p-基元表达一组元素，从中选择两个大小不同的随机数α，β，验证结点通过计算PK={G<sub>0</sub>,g,g<sup>β</sup>,Y=e(g,g)<sup>α</sup>,U,U’}和MK={α，β}来定义一个双线性图e:G<sub>0</sub>xG<sub>0</sub>=G<sub>1</sub>。</li><li>交易生成和签名：交易用户A生成交易信息，通过钱包签名算法对自身身份进行加密，并使用钱包地址对应的私钥对其签名，然后发送给交易用户B。签名的算法如下()：</li></ol><p><img src="http://files.shanqianche.cn/20201223/1608734446144.png" alt="签名算法"></p><blockquote><p>Trans:交易信息、<br>δ A为用户自身加密后的信息即用于标识、<br>CT<sub>A</sub>（Ciphertext密文）私钥加密产生签名</p></blockquote><ol start="4"><li>产生索引：交易者从交易明文信息中提取关键字，并用索引密钥g<sup>μ</sup>和两个随机数字进行加密。</li><li>加密：Encrypt(M，TK，PK)[信息，非对称传输密钥，公钥]</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> graduate student </tag>
            
            <tag> block chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《囚徒》普希金</title>
      <link href="/2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/"/>
      <url>/2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/</url>
      
        <content type="html"><![CDATA[<p><strong>我坐在阴湿牢狱的铁栏后<br>一只在禁锢中成长的鹰雏<br>和我郁郁地做伴；<br>它扑着翅膀，<br>在铁窗下啄食着血腥的食物。<br>它啄食着，丢弃着，又望望窗外，<br>像是和我感到同样的烦恼。<br>它用眼神和叫声向我招呼，<br>像要说：“我们飞去吧，是时候了，<br>“我们原是自由的鸟儿，飞去吧——<br>飞到那乌云后面明媚的山峦，<br>飞到那里，到那蓝色的海角，<br>只有风在欢舞……还有我做伴……</strong></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详记HTTP向HTTPS进化</title>
      <link href="/2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/"/>
      <url>/2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>老师这个是我自己学习的，同时我也上传过这篇文章到我的博客，如果您想要验证，可以在<a href="https://blog.zuishuailcq.xyz/">博客</a>中搜索ssl就可以查到这篇文章了</p><h1 id="两者表面的区别"><a href="#两者表面的区别" class="headerlink" title="两者表面的区别"></a>两者表面的区别</h1><ol><li>HTTP（Hypertext Transfer Protocol）是超文本传输协议，<font color=#DE6B6E>信息是明文</font>，HTTPSHypertext Transfer Protocol Secure则是既有安全性的SSL加密传输协议。基本可以理解为在HTTP的传输基础上加入SSL层来加密信息。两者请求和响应都是已相同的方式进行工作。</li><li>HTTP采用80端口连接，HTTPS采用443端口连接qi</li><li>HTTP与HTTPS<font color=#FAE05C>连接方式不同</font></li><li>HTTPS在连接中需要CA证书认证身份，一般需要money购买</li><li>HTTP连接是<font color=#DE6B6E>无状态的</font>，可以短连接也可以长连接，更加灵活；HTTPS协议是由<font color=#DE6B6E>SSL+HTTP协议</font>构建的可加密传输，身份认证的网络协议，虽然建立连接变得复杂但是更加安全，需要多次握手，所以一般会加剧50%时间延迟，且会消耗 CPU 资源，对服务器资源消耗较大</li></ol><h1 id="HTTP和HTTPS建立连接方式"><a href="#HTTP和HTTPS建立连接方式" class="headerlink" title="HTTP和HTTPS建立连接方式"></a>HTTP和HTTPS建立连接方式</h1><h2 id="HTTP建立连接"><a href="#HTTP建立连接" class="headerlink" title="HTTP建立连接"></a>HTTP建立连接</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="https://merlynr.github.io/post-images/1592550376754.png"></p><p>==TCP三次握手(Three-way Handshake)==<br>TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。“即互联网中TCP/IP就可以满足信息通信，但是想要识别传输的信息是否有意义，我们就需要应用层协议”</p><blockquote><p>  TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。这个过程在TCP收发端开始通信时，被称为三次握手初始化。<br>     三次握手的目的是使收发端的数据发送和接收同步，协调可以收发的数据量，建立虚连接。双方的TCP协议软件在交换数据时必须首先建立会话连接，然后才能够以数据分组为单位进行通信。接收端TCP协议软件每收到一个数据分组，在检验传输无误后，就对发送端计算机发送确认信息(ACK，Acknowledgement)，通知该序号分组收到。<br>     数据传输过程中，发送端对已经发出的分组要有记录，并且设置等待确认的计时器，对超过规定时间未收到确认的分组按照丢失重传处理；接收端的TCP协议软件会自动检查是否所有的数据分组都已收到，如果发现哪个数据分组损坏，接收端会将它舍弃，并通知发送端重传；接收端的TCP协议软件还能对未按顺序到达的数据分组进行重新排序，解决乱序问题。<br>     收发端TCP协议软件进行带确认的数据传送过程如所示。在图中，发送端将序号为100的数据分组(SEQ=100)送出；接收端收到后，向发送端回应一个序号为200的分组(SEQ=200)，内容是对收到序号为100的数据分组的确认，确认信息是对收到的数据分组序号加1(ACK=101)；发送端得知序号100的分组收到后，发送下一个数据分组(序号为101， SEQ=101)，并且在该分组中带有对收到序号为200的回应分组的确认(仍然是对收到的分组序号加1，ACK=201)。<br>     最后，当接收端计算机的TCP协议软件确认收到的数据分组无误，就根据封装在分组头部的目的端口号，识别出目的应用程序，将分组中的数据取出并按照原来顺序组合好交付给相应程序。</p><blockquote><p><a href="https://blog.csdn.net/wwj_748/article/details/11855289">FROM:TCP协议的作用？-IT_xiao小巫</a> </p></blockquote></blockquote><ul><li>初始状态：A，B都属于初始状态都是关闭状态</li><li>状态变化：A主动打开连接，B被动打开连接并进入监听状态</li><li>第一次握手：A向B发送一个TCP包，其中包中SYN标志设置为1，表明A向B请求建立连接，并设置序号seq=x，其中x的值表示第一个数据字节序号为x（x不确定，即seq是个随机值）。<br><font color=#DE6B6E>注意：</font>SYN包就是SYN标设为1的TCP包，只有A收到B发来的SYN包，才可以建立连接，否则无法建立连接。因此，<font color=#FAE05C>如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。</font></li><li>状态变化：A进入SYN_SEND状态，等待B的确认</li><li>第二次握手：B如果同意建立连接，会向A发送一个对A发送的SYN包的确认（SYN/ACK）包， 确认号ack=x+1，初始序号seq=y（随机值）<br><font color=#DE6B6E>注意：</font>SYN/ACK包是仅SYN 和 ACK 标记为1的包。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>状态变化：B进入SYN-RCVD状态（同步收到）</li><li>第三次握手：A收到B的确认TCP报后，向B发送一个确认收到B发送的确认报，其中确认报确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）</li><li>状态变化：A接到B的确认报文进行检查后变为ESTABLISHED（已建立连接）</li><li>状态变化：当B收到A的确认报文进行检查后变为ESTABLISHED（已建立连接）<br><font color=#DE6B6E>注意：</font>A收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给B，B检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功。</li></ul><blockquote><blockquote><p><a href="https://blog.csdn.net/xingerr/article/details/72834303">FROM：TCP三次握手详解-Shirsen</a><br><a href="https://juejin.im/post/5b1d34eb6fb9a01e7d5c3e25">FROM：注意！是TCP不是HTTP的3次握手与4次挥手-鲍康霖</a></p></blockquote></blockquote><blockquote><p>三次握手的目的是连接服务器指定端口，建立 TCP连接，并同步连接双方的序列号和确认号，交换 TCP窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p></blockquote><h3 id="HTTPS通信中存在问题"><a href="#HTTPS通信中存在问题" class="headerlink" title="HTTPS通信中存在问题"></a>HTTPS通信中存在问题</h3><ol><li>容易被监听<br>http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的</li><li>被伪装<br>http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求<a href="http://www.taobao.com,你怎么知道返回的数据就是来自淘宝,中间人可能返回数据伪装成淘宝./">www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。</a></li><li>被篡改<br>hacker中间篡改数据后，接收方并不知道数据已经被更改</li></ol><h2 id="HTTPS连接方式"><a href="#HTTPS连接方式" class="headerlink" title="HTTPS连接方式"></a>HTTPS连接方式</h2><p>==https是http与ssl的结合体==</p><p><img src="https://merlynr.github.io/post-images/1592735988318.png"></p><h3>客户端与服务器获取验证的通信过程</h3><ul><li>客户端发送请求到服务器端</li><li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li><li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端</li><li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端</li><li>客户端使用共享密钥解密数据</li><li>SSL加密建立………</li></ul>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> front-end </tag>
            
            <tag> summarize </tag>
            
            <tag> Java </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
